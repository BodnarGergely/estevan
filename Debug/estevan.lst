
estevan.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00008000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000cfa0  08000188  08000188  00008188  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .init_array   00000004  0800d128  0800d128  00015128  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .fini_array   00000004  0800d12c  0800d12c  0001512c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .data         00000038  20000000  0800d130  00018000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00001468  20000038  0800d168  00018038  2**2
                  ALLOC
  6 ._user_heap_stack 00000400  200014a0  0800d168  000194a0  2**0
                  ALLOC
  7 .ARM.attributes 0000002f  00000000  00000000  00018038  2**0
                  CONTENTS, READONLY
  8 .debug_info   0000c4db  00000000  00000000  00018067  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00002162  00000000  00000000  00024542  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00005371  00000000  00000000  000266a4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 000002e8  00000000  00000000  0002ba18  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  0000f00e  00000000  00000000  0002bd00  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00006a05  00000000  00000000  0003ad0e  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0004e7ec  00000000  00000000  00041713  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .comment      00000030  00000000  00000000  0008feff  2**0
                  CONTENTS, READONLY
 16 .debug_frame  00002da0  00000000  00000000  0008ff30  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00000020  00000000  00000000  00092cd0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000188 <deregister_tm_clones>:
 8000188:	b508      	push	{r3, lr}
 800018a:	f240 0038 	movw	r0, #56	; 0x38
 800018e:	4b07      	ldr	r3, [pc, #28]	; (80001ac <deregister_tm_clones+0x24>)
 8000190:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000194:	1a1b      	subs	r3, r3, r0
 8000196:	2b06      	cmp	r3, #6
 8000198:	d800      	bhi.n	800019c <deregister_tm_clones+0x14>
 800019a:	bd08      	pop	{r3, pc}
 800019c:	f240 0300 	movw	r3, #0
 80001a0:	f2c0 0300 	movt	r3, #0
 80001a4:	2b00      	cmp	r3, #0
 80001a6:	d0f8      	beq.n	800019a <deregister_tm_clones+0x12>
 80001a8:	4798      	blx	r3
 80001aa:	e7f6      	b.n	800019a <deregister_tm_clones+0x12>
 80001ac:	2000003b 	.word	0x2000003b

080001b0 <register_tm_clones>:
 80001b0:	b508      	push	{r3, lr}
 80001b2:	f240 0038 	movw	r0, #56	; 0x38
 80001b6:	f240 0338 	movw	r3, #56	; 0x38
 80001ba:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80001be:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80001c2:	1a1b      	subs	r3, r3, r0
 80001c4:	109b      	asrs	r3, r3, #2
 80001c6:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
 80001ca:	1059      	asrs	r1, r3, #1
 80001cc:	d100      	bne.n	80001d0 <register_tm_clones+0x20>
 80001ce:	bd08      	pop	{r3, pc}
 80001d0:	f240 0200 	movw	r2, #0
 80001d4:	f2c0 0200 	movt	r2, #0
 80001d8:	2a00      	cmp	r2, #0
 80001da:	d0f8      	beq.n	80001ce <register_tm_clones+0x1e>
 80001dc:	4790      	blx	r2
 80001de:	e7f6      	b.n	80001ce <register_tm_clones+0x1e>

080001e0 <__do_global_dtors_aux>:
 80001e0:	b510      	push	{r4, lr}
 80001e2:	f240 0438 	movw	r4, #56	; 0x38
 80001e6:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80001ea:	7823      	ldrb	r3, [r4, #0]
 80001ec:	b973      	cbnz	r3, 800020c <__do_global_dtors_aux+0x2c>
 80001ee:	f7ff ffcb 	bl	8000188 <deregister_tm_clones>
 80001f2:	f240 0300 	movw	r3, #0
 80001f6:	f2c0 0300 	movt	r3, #0
 80001fa:	b12b      	cbz	r3, 8000208 <__do_global_dtors_aux+0x28>
 80001fc:	f24d 1010 	movw	r0, #53520	; 0xd110
 8000200:	f6c0 0000 	movt	r0, #2048	; 0x800
 8000204:	f3af 8000 	nop.w
 8000208:	2301      	movs	r3, #1
 800020a:	7023      	strb	r3, [r4, #0]
 800020c:	bd10      	pop	{r4, pc}
 800020e:	bf00      	nop

08000210 <frame_dummy>:
 8000210:	b508      	push	{r3, lr}
 8000212:	f240 0300 	movw	r3, #0
 8000216:	f2c0 0300 	movt	r3, #0
 800021a:	b14b      	cbz	r3, 8000230 <frame_dummy+0x20>
 800021c:	f24d 1010 	movw	r0, #53520	; 0xd110
 8000220:	f240 013c 	movw	r1, #60	; 0x3c
 8000224:	f6c0 0000 	movt	r0, #2048	; 0x800
 8000228:	f2c2 0100 	movt	r1, #8192	; 0x2000
 800022c:	f3af 8000 	nop.w
 8000230:	f240 0038 	movw	r0, #56	; 0x38
 8000234:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000238:	6803      	ldr	r3, [r0, #0]
 800023a:	b12b      	cbz	r3, 8000248 <frame_dummy+0x38>
 800023c:	f240 0300 	movw	r3, #0
 8000240:	f2c0 0300 	movt	r3, #0
 8000244:	b103      	cbz	r3, 8000248 <frame_dummy+0x38>
 8000246:	4798      	blx	r3
 8000248:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800024c:	f7ff bfb0 	b.w	80001b0 <register_tm_clones>

08000250 <Inputs_Init>:

#include "inputs.h"
#include "stm32f4xx.h"

void Inputs_Init()
{
 8000250:	b580      	push	{r7, lr}
 8000252:	b086      	sub	sp, #24
 8000254:	af00      	add	r7, sp, #0
    GPIO_InitTypeDef GPIO_InitStructure;
    EXTI_InitTypeDef  EXTI_InitStructure;
    NVIC_InitTypeDef NVIC_InitStructure;

    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
 8000256:	f04f 0008 	mov.w	r0, #8
 800025a:	f04f 0101 	mov.w	r1, #1
 800025e:	f007 ffa7 	bl	80081b0 <RCC_AHB1PeriphClockCmd>
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG,ENABLE);//Kulso megszakitas orajele
 8000262:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8000266:	f04f 0101 	mov.w	r1, #1
 800026a:	f008 f821 	bl	80082b0 <RCC_APB2PeriphClockCmd>


    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_6 | GPIO_Pin_7;
 800026e:	f04f 03cf 	mov.w	r3, #207	; 0xcf
 8000272:	613b      	str	r3, [r7, #16]
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8000274:	f04f 0300 	mov.w	r3, #0
 8000278:	753b      	strb	r3, [r7, #20]
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 800027a:	f04f 0300 	mov.w	r3, #0
 800027e:	757b      	strb	r3, [r7, #21]
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8000280:	f04f 0300 	mov.w	r3, #0
 8000284:	75bb      	strb	r3, [r7, #22]
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8000286:	f04f 0300 	mov.w	r3, #0
 800028a:	75fb      	strb	r3, [r7, #23]
    GPIO_Init(GPIOD, &GPIO_InitStructure);
 800028c:	f107 0310 	add.w	r3, r7, #16
 8000290:	4878      	ldr	r0, [pc, #480]	; (8000474 <Inputs_Init+0x224>)
 8000292:	4619      	mov	r1, r3
 8000294:	f007 f97a 	bl	800758c <GPIO_Init>



/*                              Megszakításvezérlõ egység konfigurálása                             */

    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_3); //Ezzel a beállítással 8 preemption és 2 sub priority érhetõ el
 8000298:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800029c:	f005 f990 	bl	80055c0 <NVIC_PriorityGroupConfig>

    // Az input 1 és 2 megszakítás vezérlõ (NVIC) konfigja.
    NVIC_InitStructure.NVIC_IRQChannel = EXTI9_5_IRQn;
 80002a0:	f04f 0317 	mov.w	r3, #23
 80002a4:	713b      	strb	r3, [r7, #4]
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 5;
 80002a6:	f04f 0305 	mov.w	r3, #5
 80002aa:	717b      	strb	r3, [r7, #5]
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
 80002ac:	f04f 0301 	mov.w	r3, #1
 80002b0:	71bb      	strb	r3, [r7, #6]
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 80002b2:	f04f 0301 	mov.w	r3, #1
 80002b6:	71fb      	strb	r3, [r7, #7]
    NVIC_Init(&NVIC_InitStructure);
 80002b8:	f107 0304 	add.w	r3, r7, #4
 80002bc:	4618      	mov	r0, r3
 80002be:	f005 f991 	bl	80055e4 <NVIC_Init>

    // Az input 3 megszakítás vezérlõ (NVIC) konfigja.
    NVIC_InitStructure.NVIC_IRQChannel = EXTI3_IRQn;
 80002c2:	f04f 0309 	mov.w	r3, #9
 80002c6:	713b      	strb	r3, [r7, #4]
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 5;
 80002c8:	f04f 0305 	mov.w	r3, #5
 80002cc:	717b      	strb	r3, [r7, #5]
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 80002ce:	f04f 0300 	mov.w	r3, #0
 80002d2:	71bb      	strb	r3, [r7, #6]
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 80002d4:	f04f 0301 	mov.w	r3, #1
 80002d8:	71fb      	strb	r3, [r7, #7]
    NVIC_Init(&NVIC_InitStructure);
 80002da:	f107 0304 	add.w	r3, r7, #4
 80002de:	4618      	mov	r0, r3
 80002e0:	f005 f980 	bl	80055e4 <NVIC_Init>

    // Az input 4 megszakítás vezérlõ (NVIC) konfigja.
    NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn;
 80002e4:	f04f 0308 	mov.w	r3, #8
 80002e8:	713b      	strb	r3, [r7, #4]
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 5;
 80002ea:	f04f 0305 	mov.w	r3, #5
 80002ee:	717b      	strb	r3, [r7, #5]
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 80002f0:	f04f 0300 	mov.w	r3, #0
 80002f4:	71bb      	strb	r3, [r7, #6]
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 80002f6:	f04f 0301 	mov.w	r3, #1
 80002fa:	71fb      	strb	r3, [r7, #7]
    NVIC_Init(&NVIC_InitStructure);
 80002fc:	f107 0304 	add.w	r3, r7, #4
 8000300:	4618      	mov	r0, r3
 8000302:	f005 f96f 	bl	80055e4 <NVIC_Init>

    // Az input 5 megszakítás vezérlõ (NVIC) konfigja.
    NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQn;
 8000306:	f04f 0307 	mov.w	r3, #7
 800030a:	713b      	strb	r3, [r7, #4]
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 5;
 800030c:	f04f 0305 	mov.w	r3, #5
 8000310:	717b      	strb	r3, [r7, #5]
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
 8000312:	f04f 0301 	mov.w	r3, #1
 8000316:	71bb      	strb	r3, [r7, #6]
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8000318:	f04f 0301 	mov.w	r3, #1
 800031c:	71fb      	strb	r3, [r7, #7]
    NVIC_Init(&NVIC_InitStructure);
 800031e:	f107 0304 	add.w	r3, r7, #4
 8000322:	4618      	mov	r0, r3
 8000324:	f005 f95e 	bl	80055e4 <NVIC_Init>

    // Az input 6 megszakítás vezérlõ (NVIC) konfigja.
    NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;
 8000328:	f04f 0306 	mov.w	r3, #6
 800032c:	713b      	strb	r3, [r7, #4]
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 5;
 800032e:	f04f 0305 	mov.w	r3, #5
 8000332:	717b      	strb	r3, [r7, #5]
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 8000334:	f04f 0300 	mov.w	r3, #0
 8000338:	71bb      	strb	r3, [r7, #6]
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 800033a:	f04f 0301 	mov.w	r3, #1
 800033e:	71fb      	strb	r3, [r7, #7]
    NVIC_Init(&NVIC_InitStructure);
 8000340:	f107 0304 	add.w	r3, r7, #4
 8000344:	4618      	mov	r0, r3
 8000346:	f005 f94d 	bl	80055e4 <NVIC_Init>


    /*                              Külsõ megszakítás vezérlõ modul konfigurálása                               */

    //Input 1 konfigurálása
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG,ENABLE);
 800034a:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800034e:	f04f 0101 	mov.w	r1, #1
 8000352:	f007 ffad 	bl	80082b0 <RCC_APB2PeriphClockCmd>
    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource6);
 8000356:	f04f 0003 	mov.w	r0, #3
 800035a:	f04f 0106 	mov.w	r1, #6
 800035e:	f009 fd3b 	bl	8009dd8 <SYSCFG_EXTILineConfig>

    EXTI_InitStructure.EXTI_Line = EXTI_Line6;
 8000362:	f04f 0340 	mov.w	r3, #64	; 0x40
 8000366:	60bb      	str	r3, [r7, #8]
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 8000368:	f04f 0301 	mov.w	r3, #1
 800036c:	73bb      	strb	r3, [r7, #14]
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 800036e:	f04f 0300 	mov.w	r3, #0
 8000372:	733b      	strb	r3, [r7, #12]
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;;
 8000374:	f04f 030c 	mov.w	r3, #12
 8000378:	737b      	strb	r3, [r7, #13]
    EXTI_Init(&EXTI_InitStructure);
 800037a:	f107 0308 	add.w	r3, r7, #8
 800037e:	4618      	mov	r0, r3
 8000380:	f006 fb60 	bl	8006a44 <EXTI_Init>

    //Input 2 konfigurálása

    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource7 );
 8000384:	f04f 0003 	mov.w	r0, #3
 8000388:	f04f 0107 	mov.w	r1, #7
 800038c:	f009 fd24 	bl	8009dd8 <SYSCFG_EXTILineConfig>

    EXTI_InitStructure.EXTI_Line = EXTI_Line7;
 8000390:	f04f 0380 	mov.w	r3, #128	; 0x80
 8000394:	60bb      	str	r3, [r7, #8]
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 8000396:	f04f 0301 	mov.w	r3, #1
 800039a:	73bb      	strb	r3, [r7, #14]
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 800039c:	f04f 0300 	mov.w	r3, #0
 80003a0:	733b      	strb	r3, [r7, #12]
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;;
 80003a2:	f04f 030c 	mov.w	r3, #12
 80003a6:	737b      	strb	r3, [r7, #13]
    EXTI_Init(&EXTI_InitStructure);
 80003a8:	f107 0308 	add.w	r3, r7, #8
 80003ac:	4618      	mov	r0, r3
 80003ae:	f006 fb49 	bl	8006a44 <EXTI_Init>

    //Input 3 konfigurálása

    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource3);
 80003b2:	f04f 0003 	mov.w	r0, #3
 80003b6:	f04f 0103 	mov.w	r1, #3
 80003ba:	f009 fd0d 	bl	8009dd8 <SYSCFG_EXTILineConfig>

    EXTI_InitStructure.EXTI_Line = EXTI_Line3;
 80003be:	f04f 0308 	mov.w	r3, #8
 80003c2:	60bb      	str	r3, [r7, #8]
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 80003c4:	f04f 0301 	mov.w	r3, #1
 80003c8:	73bb      	strb	r3, [r7, #14]
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 80003ca:	f04f 0300 	mov.w	r3, #0
 80003ce:	733b      	strb	r3, [r7, #12]
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
 80003d0:	f04f 030c 	mov.w	r3, #12
 80003d4:	737b      	strb	r3, [r7, #13]
    EXTI_Init(&EXTI_InitStructure);
 80003d6:	f107 0308 	add.w	r3, r7, #8
 80003da:	4618      	mov	r0, r3
 80003dc:	f006 fb32 	bl	8006a44 <EXTI_Init>

    //Input 4 konfigurálása

    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource2);
 80003e0:	f04f 0003 	mov.w	r0, #3
 80003e4:	f04f 0102 	mov.w	r1, #2
 80003e8:	f009 fcf6 	bl	8009dd8 <SYSCFG_EXTILineConfig>

    EXTI_InitStructure.EXTI_Line = EXTI_Line2;
 80003ec:	f04f 0304 	mov.w	r3, #4
 80003f0:	60bb      	str	r3, [r7, #8]
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 80003f2:	f04f 0301 	mov.w	r3, #1
 80003f6:	73bb      	strb	r3, [r7, #14]
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 80003f8:	f04f 0300 	mov.w	r3, #0
 80003fc:	733b      	strb	r3, [r7, #12]
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
 80003fe:	f04f 030c 	mov.w	r3, #12
 8000402:	737b      	strb	r3, [r7, #13]
    EXTI_Init(&EXTI_InitStructure);
 8000404:	f107 0308 	add.w	r3, r7, #8
 8000408:	4618      	mov	r0, r3
 800040a:	f006 fb1b 	bl	8006a44 <EXTI_Init>

    //Input 5 konfigurálása

    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource1);
 800040e:	f04f 0003 	mov.w	r0, #3
 8000412:	f04f 0101 	mov.w	r1, #1
 8000416:	f009 fcdf 	bl	8009dd8 <SYSCFG_EXTILineConfig>

    EXTI_InitStructure.EXTI_Line = EXTI_Line1;
 800041a:	f04f 0302 	mov.w	r3, #2
 800041e:	60bb      	str	r3, [r7, #8]
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 8000420:	f04f 0301 	mov.w	r3, #1
 8000424:	73bb      	strb	r3, [r7, #14]
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 8000426:	f04f 0300 	mov.w	r3, #0
 800042a:	733b      	strb	r3, [r7, #12]
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;;
 800042c:	f04f 030c 	mov.w	r3, #12
 8000430:	737b      	strb	r3, [r7, #13]
    EXTI_Init(&EXTI_InitStructure);
 8000432:	f107 0308 	add.w	r3, r7, #8
 8000436:	4618      	mov	r0, r3
 8000438:	f006 fb04 	bl	8006a44 <EXTI_Init>

    //Input 6 konfigurálása

    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource0);
 800043c:	f04f 0003 	mov.w	r0, #3
 8000440:	f04f 0100 	mov.w	r1, #0
 8000444:	f009 fcc8 	bl	8009dd8 <SYSCFG_EXTILineConfig>

    EXTI_InitStructure.EXTI_Line = EXTI_Line0;
 8000448:	f04f 0301 	mov.w	r3, #1
 800044c:	60bb      	str	r3, [r7, #8]
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 800044e:	f04f 0301 	mov.w	r3, #1
 8000452:	73bb      	strb	r3, [r7, #14]
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 8000454:	f04f 0300 	mov.w	r3, #0
 8000458:	733b      	strb	r3, [r7, #12]
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;;
 800045a:	f04f 030c 	mov.w	r3, #12
 800045e:	737b      	strb	r3, [r7, #13]
    EXTI_Init(&EXTI_InitStructure);
 8000460:	f107 0308 	add.w	r3, r7, #8
 8000464:	4618      	mov	r0, r3
 8000466:	f006 faed 	bl	8006a44 <EXTI_Init>
}
 800046a:	f107 0718 	add.w	r7, r7, #24
 800046e:	46bd      	mov	sp, r7
 8000470:	bd80      	pop	{r7, pc}
 8000472:	bf00      	nop
 8000474:	40020c00 	.word	0x40020c00

08000478 <__delay_cycles>:


#include "lcd.h"

void __delay_cycles(int a)
{
 8000478:	b480      	push	{r7}
 800047a:	b085      	sub	sp, #20
 800047c:	af00      	add	r7, sp, #0
 800047e:	6078      	str	r0, [r7, #4]
    int i = 0;
 8000480:	f04f 0300 	mov.w	r3, #0
 8000484:	60fb      	str	r3, [r7, #12]
    int f = 0;
 8000486:	f04f 0300 	mov.w	r3, #0
 800048a:	60bb      	str	r3, [r7, #8]
    while(f<a)
 800048c:	e00a      	b.n	80004a4 <__delay_cycles+0x2c>
    {
            while(i<60)
                {i++;}
 800048e:	68fb      	ldr	r3, [r7, #12]
 8000490:	f103 0301 	add.w	r3, r3, #1
 8000494:	60fb      	str	r3, [r7, #12]
{
    int i = 0;
    int f = 0;
    while(f<a)
    {
            while(i<60)
 8000496:	68fb      	ldr	r3, [r7, #12]
 8000498:	2b3b      	cmp	r3, #59	; 0x3b
 800049a:	ddf8      	ble.n	800048e <__delay_cycles+0x16>
                {i++;}
        f++;
 800049c:	68bb      	ldr	r3, [r7, #8]
 800049e:	f103 0301 	add.w	r3, r3, #1
 80004a2:	60bb      	str	r3, [r7, #8]

void __delay_cycles(int a)
{
    int i = 0;
    int f = 0;
    while(f<a)
 80004a4:	68ba      	ldr	r2, [r7, #8]
 80004a6:	687b      	ldr	r3, [r7, #4]
 80004a8:	429a      	cmp	r2, r3
 80004aa:	dbf4      	blt.n	8000496 <__delay_cycles+0x1e>
    {
            while(i<60)
                {i++;}
        f++;
    }
}
 80004ac:	f107 0714 	add.w	r7, r7, #20
 80004b0:	46bd      	mov	sp, r7
 80004b2:	bc80      	pop	{r7}
 80004b4:	4770      	bx	lr
 80004b6:	bf00      	nop

080004b8 <PulseLcm>:

void PulseLcm()
{
 80004b8:	b580      	push	{r7, lr}
 80004ba:	af00      	add	r7, sp, #0
    LCM_OUT &= ~LCM_PIN_EN;
 80004bc:	4b0f      	ldr	r3, [pc, #60]	; (80004fc <PulseLcm+0x44>)
 80004be:	4a0f      	ldr	r2, [pc, #60]	; (80004fc <PulseLcm+0x44>)
 80004c0:	6952      	ldr	r2, [r2, #20]
 80004c2:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80004c6:	615a      	str	r2, [r3, #20]
    __delay_cycles(400);
 80004c8:	f44f 70c8 	mov.w	r0, #400	; 0x190
 80004cc:	f7ff ffd4 	bl	8000478 <__delay_cycles>
    LCM_OUT |= LCM_PIN_EN;
 80004d0:	4b0a      	ldr	r3, [pc, #40]	; (80004fc <PulseLcm+0x44>)
 80004d2:	4a0a      	ldr	r2, [pc, #40]	; (80004fc <PulseLcm+0x44>)
 80004d4:	6952      	ldr	r2, [r2, #20]
 80004d6:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80004da:	615a      	str	r2, [r3, #20]
    __delay_cycles(400);
 80004dc:	f44f 70c8 	mov.w	r0, #400	; 0x190
 80004e0:	f7ff ffca 	bl	8000478 <__delay_cycles>
    LCM_OUT &= (~LCM_PIN_EN);
 80004e4:	4b05      	ldr	r3, [pc, #20]	; (80004fc <PulseLcm+0x44>)
 80004e6:	4a05      	ldr	r2, [pc, #20]	; (80004fc <PulseLcm+0x44>)
 80004e8:	6952      	ldr	r2, [r2, #20]
 80004ea:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80004ee:	615a      	str	r2, [r3, #20]
    __delay_cycles(400);
 80004f0:	f44f 70c8 	mov.w	r0, #400	; 0x190
 80004f4:	f7ff ffc0 	bl	8000478 <__delay_cycles>
}
 80004f8:	bd80      	pop	{r7, pc}
 80004fa:	bf00      	nop
 80004fc:	40021000 	.word	0x40021000

08000500 <SendByte>:

void SendByte(char ByteToSend, int IsData)
{
 8000500:	b580      	push	{r7, lr}
 8000502:	b082      	sub	sp, #8
 8000504:	af00      	add	r7, sp, #0
 8000506:	4603      	mov	r3, r0
 8000508:	6039      	str	r1, [r7, #0]
 800050a:	71fb      	strb	r3, [r7, #7]
    LCM_OUT &= (~LCM_PIN_MASK);
 800050c:	4b26      	ldr	r3, [pc, #152]	; (80005a8 <SendByte+0xa8>)
 800050e:	4a26      	ldr	r2, [pc, #152]	; (80005a8 <SendByte+0xa8>)
 8000510:	6952      	ldr	r2, [r2, #20]
 8000512:	f422 727e 	bic.w	r2, r2, #1016	; 0x3f8
 8000516:	615a      	str	r2, [r3, #20]
    LCM_OUT |= (ByteToSend & 0xF0);
 8000518:	4b23      	ldr	r3, [pc, #140]	; (80005a8 <SendByte+0xa8>)
 800051a:	4a23      	ldr	r2, [pc, #140]	; (80005a8 <SendByte+0xa8>)
 800051c:	6951      	ldr	r1, [r2, #20]
 800051e:	79fa      	ldrb	r2, [r7, #7]
 8000520:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8000524:	430a      	orrs	r2, r1
 8000526:	615a      	str	r2, [r3, #20]

    if (IsData == TRUE)
 8000528:	683b      	ldr	r3, [r7, #0]
 800052a:	2b01      	cmp	r3, #1
 800052c:	d106      	bne.n	800053c <SendByte+0x3c>
    {
        LCM_OUT |= LCM_PIN_RS;
 800052e:	4b1e      	ldr	r3, [pc, #120]	; (80005a8 <SendByte+0xa8>)
 8000530:	4a1d      	ldr	r2, [pc, #116]	; (80005a8 <SendByte+0xa8>)
 8000532:	6952      	ldr	r2, [r2, #20]
 8000534:	f042 0208 	orr.w	r2, r2, #8
 8000538:	615a      	str	r2, [r3, #20]
 800053a:	e005      	b.n	8000548 <SendByte+0x48>
    }
    else
    {
        LCM_OUT &= ~LCM_PIN_RS;
 800053c:	4b1a      	ldr	r3, [pc, #104]	; (80005a8 <SendByte+0xa8>)
 800053e:	4a1a      	ldr	r2, [pc, #104]	; (80005a8 <SendByte+0xa8>)
 8000540:	6952      	ldr	r2, [r2, #20]
 8000542:	f022 0208 	bic.w	r2, r2, #8
 8000546:	615a      	str	r2, [r3, #20]
    }
    PulseLcm();
 8000548:	f7ff ffb6 	bl	80004b8 <PulseLcm>
    __delay_cycles(400);
 800054c:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8000550:	f7ff ff92 	bl	8000478 <__delay_cycles>
    LCM_OUT &= (~LCM_PIN_MASK);
 8000554:	4b14      	ldr	r3, [pc, #80]	; (80005a8 <SendByte+0xa8>)
 8000556:	4a14      	ldr	r2, [pc, #80]	; (80005a8 <SendByte+0xa8>)
 8000558:	6952      	ldr	r2, [r2, #20]
 800055a:	f422 727e 	bic.w	r2, r2, #1016	; 0x3f8
 800055e:	615a      	str	r2, [r3, #20]
    LCM_OUT |= ((ByteToSend & 0x0F) << 4);
 8000560:	4b11      	ldr	r3, [pc, #68]	; (80005a8 <SendByte+0xa8>)
 8000562:	4a11      	ldr	r2, [pc, #68]	; (80005a8 <SendByte+0xa8>)
 8000564:	6951      	ldr	r1, [r2, #20]
 8000566:	79fa      	ldrb	r2, [r7, #7]
 8000568:	ea4f 1202 	mov.w	r2, r2, lsl #4
 800056c:	b2d2      	uxtb	r2, r2
 800056e:	430a      	orrs	r2, r1
 8000570:	615a      	str	r2, [r3, #20]

    if (IsData == TRUE)
 8000572:	683b      	ldr	r3, [r7, #0]
 8000574:	2b01      	cmp	r3, #1
 8000576:	d106      	bne.n	8000586 <SendByte+0x86>
    {
        LCM_OUT |= LCM_PIN_RS;
 8000578:	4b0b      	ldr	r3, [pc, #44]	; (80005a8 <SendByte+0xa8>)
 800057a:	4a0b      	ldr	r2, [pc, #44]	; (80005a8 <SendByte+0xa8>)
 800057c:	6952      	ldr	r2, [r2, #20]
 800057e:	f042 0208 	orr.w	r2, r2, #8
 8000582:	615a      	str	r2, [r3, #20]
 8000584:	e005      	b.n	8000592 <SendByte+0x92>
    }
    else
    {
        LCM_OUT &= ~LCM_PIN_RS;
 8000586:	4b08      	ldr	r3, [pc, #32]	; (80005a8 <SendByte+0xa8>)
 8000588:	4a07      	ldr	r2, [pc, #28]	; (80005a8 <SendByte+0xa8>)
 800058a:	6952      	ldr	r2, [r2, #20]
 800058c:	f022 0208 	bic.w	r2, r2, #8
 8000590:	615a      	str	r2, [r3, #20]
    }

    PulseLcm();
 8000592:	f7ff ff91 	bl	80004b8 <PulseLcm>
    __delay_cycles(400);
 8000596:	f44f 70c8 	mov.w	r0, #400	; 0x190
 800059a:	f7ff ff6d 	bl	8000478 <__delay_cycles>
}
 800059e:	f107 0708 	add.w	r7, r7, #8
 80005a2:	46bd      	mov	sp, r7
 80005a4:	bd80      	pop	{r7, pc}
 80005a6:	bf00      	nop
 80005a8:	40021000 	.word	0x40021000

080005ac <ReceiveStatus>:
void ReceiveStatus(char * ByteToReceive)
{
 80005ac:	b580      	push	{r7, lr}
 80005ae:	b082      	sub	sp, #8
 80005b0:	af00      	add	r7, sp, #0
 80005b2:	6078      	str	r0, [r7, #4]
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5| GPIO_Pin_6| GPIO_Pin_7;
 80005b4:	4b40      	ldr	r3, [pc, #256]	; (80006b8 <ReceiveStatus+0x10c>)
 80005b6:	f04f 02f0 	mov.w	r2, #240	; 0xf0
 80005ba:	601a      	str	r2, [r3, #0]
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 80005bc:	4b3e      	ldr	r3, [pc, #248]	; (80006b8 <ReceiveStatus+0x10c>)
 80005be:	f04f 0200 	mov.w	r2, #0
 80005c2:	711a      	strb	r2, [r3, #4]
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80005c4:	4b3c      	ldr	r3, [pc, #240]	; (80006b8 <ReceiveStatus+0x10c>)
 80005c6:	f04f 0200 	mov.w	r2, #0
 80005ca:	719a      	strb	r2, [r3, #6]
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 80005cc:	4b3a      	ldr	r3, [pc, #232]	; (80006b8 <ReceiveStatus+0x10c>)
 80005ce:	f04f 0203 	mov.w	r2, #3
 80005d2:	715a      	strb	r2, [r3, #5]
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 80005d4:	4b38      	ldr	r3, [pc, #224]	; (80006b8 <ReceiveStatus+0x10c>)
 80005d6:	f04f 0200 	mov.w	r2, #0
 80005da:	71da      	strb	r2, [r3, #7]
    GPIO_Init(GPIOB, &GPIO_InitStructure);
 80005dc:	4837      	ldr	r0, [pc, #220]	; (80006bc <ReceiveStatus+0x110>)
 80005de:	4936      	ldr	r1, [pc, #216]	; (80006b8 <ReceiveStatus+0x10c>)
 80005e0:	f006 ffd4 	bl	800758c <GPIO_Init>

    LCM_OUT &= (~(LCM_PIN_RS | LCM_PIN_EN | LCM_PIN_RW));
 80005e4:	4b36      	ldr	r3, [pc, #216]	; (80006c0 <ReceiveStatus+0x114>)
 80005e6:	4a36      	ldr	r2, [pc, #216]	; (80006c0 <ReceiveStatus+0x114>)
 80005e8:	6952      	ldr	r2, [r2, #20]
 80005ea:	f422 7242 	bic.w	r2, r2, #776	; 0x308
 80005ee:	615a      	str	r2, [r3, #20]
    LCM_OUT |= LCM_PIN_RW;
 80005f0:	4b33      	ldr	r3, [pc, #204]	; (80006c0 <ReceiveStatus+0x114>)
 80005f2:	4a33      	ldr	r2, [pc, #204]	; (80006c0 <ReceiveStatus+0x114>)
 80005f4:	6952      	ldr	r2, [r2, #20]
 80005f6:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80005fa:	615a      	str	r2, [r3, #20]
    LCM_OUT &= ~LCM_PIN_RS;
 80005fc:	4b30      	ldr	r3, [pc, #192]	; (80006c0 <ReceiveStatus+0x114>)
 80005fe:	4a30      	ldr	r2, [pc, #192]	; (80006c0 <ReceiveStatus+0x114>)
 8000600:	6952      	ldr	r2, [r2, #20]
 8000602:	f022 0208 	bic.w	r2, r2, #8
 8000606:	615a      	str	r2, [r3, #20]

     *ByteToReceive = 0;
 8000608:	687b      	ldr	r3, [r7, #4]
 800060a:	f04f 0200 	mov.w	r2, #0
 800060e:	701a      	strb	r2, [r3, #0]
    PulseLcm();
 8000610:	f7ff ff52 	bl	80004b8 <PulseLcm>
    *ByteToReceive |= (LCM_IN & 0xF0);
 8000614:	687b      	ldr	r3, [r7, #4]
 8000616:	781a      	ldrb	r2, [r3, #0]
 8000618:	4b29      	ldr	r3, [pc, #164]	; (80006c0 <ReceiveStatus+0x114>)
 800061a:	691b      	ldr	r3, [r3, #16]
 800061c:	b2db      	uxtb	r3, r3
 800061e:	f023 030f 	bic.w	r3, r3, #15
 8000622:	b2db      	uxtb	r3, r3
 8000624:	4313      	orrs	r3, r2
 8000626:	b2da      	uxtb	r2, r3
 8000628:	687b      	ldr	r3, [r7, #4]
 800062a:	701a      	strb	r2, [r3, #0]
    __delay_cycles(40000);
 800062c:	f649 4040 	movw	r0, #40000	; 0x9c40
 8000630:	f7ff ff22 	bl	8000478 <__delay_cycles>

    LCM_OUT &= (~(LCM_PIN_RS | LCM_PIN_EN | LCM_PIN_RW));
 8000634:	4b22      	ldr	r3, [pc, #136]	; (80006c0 <ReceiveStatus+0x114>)
 8000636:	4a22      	ldr	r2, [pc, #136]	; (80006c0 <ReceiveStatus+0x114>)
 8000638:	6952      	ldr	r2, [r2, #20]
 800063a:	f422 7242 	bic.w	r2, r2, #776	; 0x308
 800063e:	615a      	str	r2, [r3, #20]
    LCM_OUT |= LCM_PIN_RW;
 8000640:	4b1f      	ldr	r3, [pc, #124]	; (80006c0 <ReceiveStatus+0x114>)
 8000642:	4a1f      	ldr	r2, [pc, #124]	; (80006c0 <ReceiveStatus+0x114>)
 8000644:	6952      	ldr	r2, [r2, #20]
 8000646:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800064a:	615a      	str	r2, [r3, #20]
    LCM_OUT &= ~LCM_PIN_RS;
 800064c:	4b1c      	ldr	r3, [pc, #112]	; (80006c0 <ReceiveStatus+0x114>)
 800064e:	4a1c      	ldr	r2, [pc, #112]	; (80006c0 <ReceiveStatus+0x114>)
 8000650:	6952      	ldr	r2, [r2, #20]
 8000652:	f022 0208 	bic.w	r2, r2, #8
 8000656:	615a      	str	r2, [r3, #20]

    PulseLcm();
 8000658:	f7ff ff2e 	bl	80004b8 <PulseLcm>
    *ByteToReceive |= ((LCM_IN & 0xF0) >> 4);
 800065c:	687b      	ldr	r3, [r7, #4]
 800065e:	781a      	ldrb	r2, [r3, #0]
 8000660:	4b17      	ldr	r3, [pc, #92]	; (80006c0 <ReceiveStatus+0x114>)
 8000662:	691b      	ldr	r3, [r3, #16]
 8000664:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8000668:	ea4f 1313 	mov.w	r3, r3, lsr #4
 800066c:	b2db      	uxtb	r3, r3
 800066e:	4313      	orrs	r3, r2
 8000670:	b2da      	uxtb	r2, r3
 8000672:	687b      	ldr	r3, [r7, #4]
 8000674:	701a      	strb	r2, [r3, #0]
    __delay_cycles(40000);
 8000676:	f649 4040 	movw	r0, #40000	; 0x9c40
 800067a:	f7ff fefd 	bl	8000478 <__delay_cycles>

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5| GPIO_Pin_6| GPIO_Pin_7;
 800067e:	4b0e      	ldr	r3, [pc, #56]	; (80006b8 <ReceiveStatus+0x10c>)
 8000680:	f04f 02f0 	mov.w	r2, #240	; 0xf0
 8000684:	601a      	str	r2, [r3, #0]
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8000686:	4b0c      	ldr	r3, [pc, #48]	; (80006b8 <ReceiveStatus+0x10c>)
 8000688:	f04f 0201 	mov.w	r2, #1
 800068c:	711a      	strb	r2, [r3, #4]
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800068e:	4b0a      	ldr	r3, [pc, #40]	; (80006b8 <ReceiveStatus+0x10c>)
 8000690:	f04f 0200 	mov.w	r2, #0
 8000694:	719a      	strb	r2, [r3, #6]
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8000696:	4b08      	ldr	r3, [pc, #32]	; (80006b8 <ReceiveStatus+0x10c>)
 8000698:	f04f 0203 	mov.w	r2, #3
 800069c:	715a      	strb	r2, [r3, #5]
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 800069e:	4b06      	ldr	r3, [pc, #24]	; (80006b8 <ReceiveStatus+0x10c>)
 80006a0:	f04f 0200 	mov.w	r2, #0
 80006a4:	71da      	strb	r2, [r3, #7]
    GPIO_Init(GPIOB, &GPIO_InitStructure);
 80006a6:	4805      	ldr	r0, [pc, #20]	; (80006bc <ReceiveStatus+0x110>)
 80006a8:	4903      	ldr	r1, [pc, #12]	; (80006b8 <ReceiveStatus+0x10c>)
 80006aa:	f006 ff6f 	bl	800758c <GPIO_Init>
}
 80006ae:	f107 0708 	add.w	r7, r7, #8
 80006b2:	46bd      	mov	sp, r7
 80006b4:	bd80      	pop	{r7, pc}
 80006b6:	bf00      	nop
 80006b8:	20000cec 	.word	0x20000cec
 80006bc:	40020400 	.word	0x40020400
 80006c0:	40021000 	.word	0x40021000

080006c4 <Cursor>:



void Cursor(char Row, char Col)
{
 80006c4:	b580      	push	{r7, lr}
 80006c6:	b084      	sub	sp, #16
 80006c8:	af00      	add	r7, sp, #0
 80006ca:	4602      	mov	r2, r0
 80006cc:	460b      	mov	r3, r1
 80006ce:	71fa      	strb	r2, [r7, #7]
 80006d0:	71bb      	strb	r3, [r7, #6]
    char address;

    __delay_cycles(4000);
 80006d2:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 80006d6:	f7ff fecf 	bl	8000478 <__delay_cycles>

    if (Row == 0)
 80006da:	79fb      	ldrb	r3, [r7, #7]
 80006dc:	2b00      	cmp	r3, #0
 80006de:	d103      	bne.n	80006e8 <Cursor+0x24>
    {
        address = 0;
 80006e0:	f04f 0300 	mov.w	r3, #0
 80006e4:	73fb      	strb	r3, [r7, #15]
 80006e6:	e010      	b.n	800070a <Cursor+0x46>
    }
    else if(Row == 1 )
 80006e8:	79fb      	ldrb	r3, [r7, #7]
 80006ea:	2b01      	cmp	r3, #1
 80006ec:	d103      	bne.n	80006f6 <Cursor+0x32>
    {
        address = 0x40;
 80006ee:	f04f 0340 	mov.w	r3, #64	; 0x40
 80006f2:	73fb      	strb	r3, [r7, #15]
 80006f4:	e009      	b.n	800070a <Cursor+0x46>
    }
    else if(Row == 2 )
 80006f6:	79fb      	ldrb	r3, [r7, #7]
 80006f8:	2b02      	cmp	r3, #2
 80006fa:	d103      	bne.n	8000704 <Cursor+0x40>
    {
        address = 0x10;
 80006fc:	f04f 0310 	mov.w	r3, #16
 8000700:	73fb      	strb	r3, [r7, #15]
 8000702:	e002      	b.n	800070a <Cursor+0x46>
    }
    else
    {
        address = 0x50;
 8000704:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000708:	73fb      	strb	r3, [r7, #15]
    }

    address |= Col;
 800070a:	7bfa      	ldrb	r2, [r7, #15]
 800070c:	79bb      	ldrb	r3, [r7, #6]
 800070e:	4313      	orrs	r3, r2
 8000710:	73fb      	strb	r3, [r7, #15]
    SendByte(0x80 | address, FALSE);
 8000712:	7bfb      	ldrb	r3, [r7, #15]
 8000714:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8000718:	b2db      	uxtb	r3, r3
 800071a:	4618      	mov	r0, r3
 800071c:	f04f 0100 	mov.w	r1, #0
 8000720:	f7ff feee 	bl	8000500 <SendByte>

    __delay_cycles(4000);
 8000724:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 8000728:	f7ff fea6 	bl	8000478 <__delay_cycles>
}
 800072c:	f107 0710 	add.w	r7, r7, #16
 8000730:	46bd      	mov	sp, r7
 8000732:	bd80      	pop	{r7, pc}

08000734 <ClearLcmScreen>:


void ClearLcmScreen()
{
 8000734:	b580      	push	{r7, lr}
 8000736:	af00      	add	r7, sp, #0
    __delay_cycles(40000);
 8000738:	f649 4040 	movw	r0, #40000	; 0x9c40
 800073c:	f7ff fe9c 	bl	8000478 <__delay_cycles>
    SendByte(0x01, FALSE);
 8000740:	f04f 0001 	mov.w	r0, #1
 8000744:	f04f 0100 	mov.w	r1, #0
 8000748:	f7ff feda 	bl	8000500 <SendByte>
    __delay_cycles(40000);
 800074c:	f649 4040 	movw	r0, #40000	; 0x9c40
 8000750:	f7ff fe92 	bl	8000478 <__delay_cycles>
    SendByte(0x02, FALSE);
 8000754:	f04f 0002 	mov.w	r0, #2
 8000758:	f04f 0100 	mov.w	r1, #0
 800075c:	f7ff fed0 	bl	8000500 <SendByte>
    __delay_cycles(40000);
 8000760:	f649 4040 	movw	r0, #40000	; 0x9c40
 8000764:	f7ff fe88 	bl	8000478 <__delay_cycles>
}
 8000768:	bd80      	pop	{r7, pc}
 800076a:	bf00      	nop

0800076c <InitializeLcm>:

void InitializeLcm(void)
{
 800076c:	b580      	push	{r7, lr}
 800076e:	af00      	add	r7, sp, #0
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE, ENABLE);
 8000770:	f04f 0010 	mov.w	r0, #16
 8000774:	f04f 0101 	mov.w	r1, #1
 8000778:	f007 fd1a 	bl	80081b0 <RCC_AHB1PeriphClockCmd>
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9;
 800077c:	4b36      	ldr	r3, [pc, #216]	; (8000858 <InitializeLcm+0xec>)
 800077e:	f44f 727e 	mov.w	r2, #1016	; 0x3f8
 8000782:	601a      	str	r2, [r3, #0]
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8000784:	4b34      	ldr	r3, [pc, #208]	; (8000858 <InitializeLcm+0xec>)
 8000786:	f04f 0201 	mov.w	r2, #1
 800078a:	711a      	strb	r2, [r3, #4]
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800078c:	4b32      	ldr	r3, [pc, #200]	; (8000858 <InitializeLcm+0xec>)
 800078e:	f04f 0200 	mov.w	r2, #0
 8000792:	719a      	strb	r2, [r3, #6]
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8000794:	4b30      	ldr	r3, [pc, #192]	; (8000858 <InitializeLcm+0xec>)
 8000796:	f04f 0203 	mov.w	r2, #3
 800079a:	715a      	strb	r2, [r3, #5]
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 800079c:	4b2e      	ldr	r3, [pc, #184]	; (8000858 <InitializeLcm+0xec>)
 800079e:	f04f 0200 	mov.w	r2, #0
 80007a2:	71da      	strb	r2, [r3, #7]
    GPIO_Init(GPIOE, &GPIO_InitStructure);
 80007a4:	482d      	ldr	r0, [pc, #180]	; (800085c <InitializeLcm+0xf0>)
 80007a6:	492c      	ldr	r1, [pc, #176]	; (8000858 <InitializeLcm+0xec>)
 80007a8:	f006 fef0 	bl	800758c <GPIO_Init>

    LCM_OUT &= ~(LCM_PIN_MASK);
 80007ac:	4b2b      	ldr	r3, [pc, #172]	; (800085c <InitializeLcm+0xf0>)
 80007ae:	4a2b      	ldr	r2, [pc, #172]	; (800085c <InitializeLcm+0xf0>)
 80007b0:	6952      	ldr	r2, [r2, #20]
 80007b2:	f422 727e 	bic.w	r2, r2, #1016	; 0x3f8
 80007b6:	615a      	str	r2, [r3, #20]

    __delay_cycles(32000);
 80007b8:	f44f 40fa 	mov.w	r0, #32000	; 0x7d00
 80007bc:	f7ff fe5c 	bl	8000478 <__delay_cycles>
    __delay_cycles(32000);
 80007c0:	f44f 40fa 	mov.w	r0, #32000	; 0x7d00
 80007c4:	f7ff fe58 	bl	8000478 <__delay_cycles>
    __delay_cycles(32000);
 80007c8:	f44f 40fa 	mov.w	r0, #32000	; 0x7d00
 80007cc:	f7ff fe54 	bl	8000478 <__delay_cycles>

    LCM_OUT &= ~LCM_PIN_RS;
 80007d0:	4b22      	ldr	r3, [pc, #136]	; (800085c <InitializeLcm+0xf0>)
 80007d2:	4a22      	ldr	r2, [pc, #136]	; (800085c <InitializeLcm+0xf0>)
 80007d4:	6952      	ldr	r2, [r2, #20]
 80007d6:	f022 0208 	bic.w	r2, r2, #8
 80007da:	615a      	str	r2, [r3, #20]
    LCM_OUT &= ~LCM_PIN_EN;
 80007dc:	4b1f      	ldr	r3, [pc, #124]	; (800085c <InitializeLcm+0xf0>)
 80007de:	4a1f      	ldr	r2, [pc, #124]	; (800085c <InitializeLcm+0xf0>)
 80007e0:	6952      	ldr	r2, [r2, #20]
 80007e2:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80007e6:	615a      	str	r2, [r3, #20]

    LCM_OUT = 0x20;
 80007e8:	4b1c      	ldr	r3, [pc, #112]	; (800085c <InitializeLcm+0xf0>)
 80007ea:	f04f 0220 	mov.w	r2, #32
 80007ee:	615a      	str	r2, [r3, #20]
    PulseLcm();
 80007f0:	f7ff fe62 	bl	80004b8 <PulseLcm>
    __delay_cycles(32000);
 80007f4:	f44f 40fa 	mov.w	r0, #32000	; 0x7d00
 80007f8:	f7ff fe3e 	bl	8000478 <__delay_cycles>
    LCM_OUT = 0x20;
 80007fc:	4b17      	ldr	r3, [pc, #92]	; (800085c <InitializeLcm+0xf0>)
 80007fe:	f04f 0220 	mov.w	r2, #32
 8000802:	615a      	str	r2, [r3, #20]
    PulseLcm();
 8000804:	f7ff fe58 	bl	80004b8 <PulseLcm>
    __delay_cycles(32000);
 8000808:	f44f 40fa 	mov.w	r0, #32000	; 0x7d00
 800080c:	f7ff fe34 	bl	8000478 <__delay_cycles>
    LCM_OUT = 0x20;
 8000810:	4b12      	ldr	r3, [pc, #72]	; (800085c <InitializeLcm+0xf0>)
 8000812:	f04f 0220 	mov.w	r2, #32
 8000816:	615a      	str	r2, [r3, #20]
    PulseLcm();
 8000818:	f7ff fe4e 	bl	80004b8 <PulseLcm>
    __delay_cycles(32000);
 800081c:	f44f 40fa 	mov.w	r0, #32000	; 0x7d00
 8000820:	f7ff fe2a 	bl	8000478 <__delay_cycles>

    SendByte(0x28, FALSE);
 8000824:	f04f 0028 	mov.w	r0, #40	; 0x28
 8000828:	f04f 0100 	mov.w	r1, #0
 800082c:	f7ff fe68 	bl	8000500 <SendByte>
    SendByte(0x0E, FALSE);
 8000830:	f04f 000e 	mov.w	r0, #14
 8000834:	f04f 0100 	mov.w	r1, #0
 8000838:	f7ff fe62 	bl	8000500 <SendByte>
    SendByte(0x01, FALSE);
 800083c:	f04f 0001 	mov.w	r0, #1
 8000840:	f04f 0100 	mov.w	r1, #0
 8000844:	f7ff fe5c 	bl	8000500 <SendByte>
    SendByte(0x06, FALSE);
 8000848:	f04f 0006 	mov.w	r0, #6
 800084c:	f04f 0100 	mov.w	r1, #0
 8000850:	f7ff fe56 	bl	8000500 <SendByte>
}
 8000854:	bd80      	pop	{r7, pc}
 8000856:	bf00      	nop
 8000858:	20000cec 	.word	0x20000cec
 800085c:	40021000 	.word	0x40021000

08000860 <StrAlign>:
void StrAlign(char * Text, char * Temp, char Mode)
{
 8000860:	b480      	push	{r7}
 8000862:	b087      	sub	sp, #28
 8000864:	af00      	add	r7, sp, #0
 8000866:	60f8      	str	r0, [r7, #12]
 8000868:	60b9      	str	r1, [r7, #8]
 800086a:	4613      	mov	r3, r2
 800086c:	71fb      	strb	r3, [r7, #7]
    char i = 0, j = 0, k = 0;
 800086e:	f04f 0300 	mov.w	r3, #0
 8000872:	75fb      	strb	r3, [r7, #23]
 8000874:	f04f 0300 	mov.w	r3, #0
 8000878:	75bb      	strb	r3, [r7, #22]
 800087a:	f04f 0300 	mov.w	r3, #0
 800087e:	757b      	strb	r3, [r7, #21]
    switch(Mode)
 8000880:	79fb      	ldrb	r3, [r7, #7]
 8000882:	f103 33ff 	add.w	r3, r3, #4294967295
 8000886:	2b03      	cmp	r3, #3
 8000888:	f200 8124 	bhi.w	8000ad4 <StrAlign+0x274>
 800088c:	a201      	add	r2, pc, #4	; (adr r2, 8000894 <StrAlign+0x34>)
 800088e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000892:	bf00      	nop
 8000894:	080008a5 	.word	0x080008a5
 8000898:	080008fb 	.word	0x080008fb
 800089c:	08000981 	.word	0x08000981
 80008a0:	08000a3b 	.word	0x08000a3b
    {
    case 1:
        for(i=0; Text[i] != '\0'; i++)
 80008a4:	f04f 0300 	mov.w	r3, #0
 80008a8:	75fb      	strb	r3, [r7, #23]
 80008aa:	e00b      	b.n	80008c4 <StrAlign+0x64>
            Temp[i] = Text[i];
 80008ac:	7dfb      	ldrb	r3, [r7, #23]
 80008ae:	68ba      	ldr	r2, [r7, #8]
 80008b0:	18d3      	adds	r3, r2, r3
 80008b2:	7dfa      	ldrb	r2, [r7, #23]
 80008b4:	68f9      	ldr	r1, [r7, #12]
 80008b6:	188a      	adds	r2, r1, r2
 80008b8:	7812      	ldrb	r2, [r2, #0]
 80008ba:	701a      	strb	r2, [r3, #0]
{
    char i = 0, j = 0, k = 0;
    switch(Mode)
    {
    case 1:
        for(i=0; Text[i] != '\0'; i++)
 80008bc:	7dfb      	ldrb	r3, [r7, #23]
 80008be:	f103 0301 	add.w	r3, r3, #1
 80008c2:	75fb      	strb	r3, [r7, #23]
 80008c4:	7dfb      	ldrb	r3, [r7, #23]
 80008c6:	68fa      	ldr	r2, [r7, #12]
 80008c8:	18d3      	adds	r3, r2, r3
 80008ca:	781b      	ldrb	r3, [r3, #0]
 80008cc:	2b00      	cmp	r3, #0
 80008ce:	d1ed      	bne.n	80008ac <StrAlign+0x4c>
            Temp[i] = Text[i];

        for(i; i < 16; i++)
 80008d0:	e009      	b.n	80008e6 <StrAlign+0x86>
            Temp[i] = ' ';
 80008d2:	7dfb      	ldrb	r3, [r7, #23]
 80008d4:	68ba      	ldr	r2, [r7, #8]
 80008d6:	18d3      	adds	r3, r2, r3
 80008d8:	f04f 0220 	mov.w	r2, #32
 80008dc:	701a      	strb	r2, [r3, #0]
    {
    case 1:
        for(i=0; Text[i] != '\0'; i++)
            Temp[i] = Text[i];

        for(i; i < 16; i++)
 80008de:	7dfb      	ldrb	r3, [r7, #23]
 80008e0:	f103 0301 	add.w	r3, r3, #1
 80008e4:	75fb      	strb	r3, [r7, #23]
 80008e6:	7dfb      	ldrb	r3, [r7, #23]
 80008e8:	2b0f      	cmp	r3, #15
 80008ea:	d9f2      	bls.n	80008d2 <StrAlign+0x72>
            Temp[i] = ' ';
        Temp[16] = '\0';
 80008ec:	68bb      	ldr	r3, [r7, #8]
 80008ee:	f103 0310 	add.w	r3, r3, #16
 80008f2:	f04f 0200 	mov.w	r2, #0
 80008f6:	701a      	strb	r2, [r3, #0]
        break;
 80008f8:	e0ed      	b.n	8000ad6 <StrAlign+0x276>
    case 2:
        for(i=0; Text[i]!='\0'; i++);
 80008fa:	f04f 0300 	mov.w	r3, #0
 80008fe:	75fb      	strb	r3, [r7, #23]
 8000900:	e003      	b.n	800090a <StrAlign+0xaa>
 8000902:	7dfb      	ldrb	r3, [r7, #23]
 8000904:	f103 0301 	add.w	r3, r3, #1
 8000908:	75fb      	strb	r3, [r7, #23]
 800090a:	7dfb      	ldrb	r3, [r7, #23]
 800090c:	68fa      	ldr	r2, [r7, #12]
 800090e:	18d3      	adds	r3, r2, r3
 8000910:	781b      	ldrb	r3, [r3, #0]
 8000912:	2b00      	cmp	r3, #0
 8000914:	d1f5      	bne.n	8000902 <StrAlign+0xa2>
        for(j=0; j < (16-i); j++)
 8000916:	f04f 0300 	mov.w	r3, #0
 800091a:	75bb      	strb	r3, [r7, #22]
 800091c:	e009      	b.n	8000932 <StrAlign+0xd2>
            Temp[j] = ' ';
 800091e:	7dbb      	ldrb	r3, [r7, #22]
 8000920:	68ba      	ldr	r2, [r7, #8]
 8000922:	18d3      	adds	r3, r2, r3
 8000924:	f04f 0220 	mov.w	r2, #32
 8000928:	701a      	strb	r2, [r3, #0]
            Temp[i] = ' ';
        Temp[16] = '\0';
        break;
    case 2:
        for(i=0; Text[i]!='\0'; i++);
        for(j=0; j < (16-i); j++)
 800092a:	7dbb      	ldrb	r3, [r7, #22]
 800092c:	f103 0301 	add.w	r3, r3, #1
 8000930:	75bb      	strb	r3, [r7, #22]
 8000932:	7dba      	ldrb	r2, [r7, #22]
 8000934:	7dfb      	ldrb	r3, [r7, #23]
 8000936:	f1c3 0310 	rsb	r3, r3, #16
 800093a:	429a      	cmp	r2, r3
 800093c:	dbef      	blt.n	800091e <StrAlign+0xbe>
            Temp[j] = ' ';
        for(j=0; j<i; j++)
 800093e:	f04f 0300 	mov.w	r3, #0
 8000942:	75bb      	strb	r3, [r7, #22]
 8000944:	e011      	b.n	800096a <StrAlign+0x10a>
            Temp[(15-j)] = Text[(i-1-j)];
 8000946:	7dbb      	ldrb	r3, [r7, #22]
 8000948:	f1c3 030f 	rsb	r3, r3, #15
 800094c:	68ba      	ldr	r2, [r7, #8]
 800094e:	18d3      	adds	r3, r2, r3
 8000950:	7dfa      	ldrb	r2, [r7, #23]
 8000952:	f102 31ff 	add.w	r1, r2, #4294967295
 8000956:	7dba      	ldrb	r2, [r7, #22]
 8000958:	1a8a      	subs	r2, r1, r2
 800095a:	68f9      	ldr	r1, [r7, #12]
 800095c:	188a      	adds	r2, r1, r2
 800095e:	7812      	ldrb	r2, [r2, #0]
 8000960:	701a      	strb	r2, [r3, #0]
        break;
    case 2:
        for(i=0; Text[i]!='\0'; i++);
        for(j=0; j < (16-i); j++)
            Temp[j] = ' ';
        for(j=0; j<i; j++)
 8000962:	7dbb      	ldrb	r3, [r7, #22]
 8000964:	f103 0301 	add.w	r3, r3, #1
 8000968:	75bb      	strb	r3, [r7, #22]
 800096a:	7dba      	ldrb	r2, [r7, #22]
 800096c:	7dfb      	ldrb	r3, [r7, #23]
 800096e:	429a      	cmp	r2, r3
 8000970:	d3e9      	bcc.n	8000946 <StrAlign+0xe6>
            Temp[(15-j)] = Text[(i-1-j)];
        Temp[16] = '\0';
 8000972:	68bb      	ldr	r3, [r7, #8]
 8000974:	f103 0310 	add.w	r3, r3, #16
 8000978:	f04f 0200 	mov.w	r2, #0
 800097c:	701a      	strb	r2, [r3, #0]
        break;
 800097e:	e0aa      	b.n	8000ad6 <StrAlign+0x276>
    case 3:
        for(i=0; Text[i] != '\0'; i++);
 8000980:	f04f 0300 	mov.w	r3, #0
 8000984:	75fb      	strb	r3, [r7, #23]
 8000986:	e003      	b.n	8000990 <StrAlign+0x130>
 8000988:	7dfb      	ldrb	r3, [r7, #23]
 800098a:	f103 0301 	add.w	r3, r3, #1
 800098e:	75fb      	strb	r3, [r7, #23]
 8000990:	7dfb      	ldrb	r3, [r7, #23]
 8000992:	68fa      	ldr	r2, [r7, #12]
 8000994:	18d3      	adds	r3, r2, r3
 8000996:	781b      	ldrb	r3, [r3, #0]
 8000998:	2b00      	cmp	r3, #0
 800099a:	d1f5      	bne.n	8000988 <StrAlign+0x128>
        j = ((16-i) >> 1);
 800099c:	7dfb      	ldrb	r3, [r7, #23]
 800099e:	f1c3 0310 	rsb	r3, r3, #16
 80009a2:	ea4f 0363 	mov.w	r3, r3, asr #1
 80009a6:	75bb      	strb	r3, [r7, #22]
        for(k=0; k<i; k++)
 80009a8:	f04f 0300 	mov.w	r3, #0
 80009ac:	757b      	strb	r3, [r7, #21]
 80009ae:	e015      	b.n	80009dc <StrAlign+0x17c>
            Temp[j + i - 1 - k] = Text [i - 1 - k];
 80009b0:	7dba      	ldrb	r2, [r7, #22]
 80009b2:	7dfb      	ldrb	r3, [r7, #23]
 80009b4:	18d3      	adds	r3, r2, r3
 80009b6:	f103 32ff 	add.w	r2, r3, #4294967295
 80009ba:	7d7b      	ldrb	r3, [r7, #21]
 80009bc:	1ad3      	subs	r3, r2, r3
 80009be:	68ba      	ldr	r2, [r7, #8]
 80009c0:	18d3      	adds	r3, r2, r3
 80009c2:	7dfa      	ldrb	r2, [r7, #23]
 80009c4:	f102 31ff 	add.w	r1, r2, #4294967295
 80009c8:	7d7a      	ldrb	r2, [r7, #21]
 80009ca:	1a8a      	subs	r2, r1, r2
 80009cc:	68f9      	ldr	r1, [r7, #12]
 80009ce:	188a      	adds	r2, r1, r2
 80009d0:	7812      	ldrb	r2, [r2, #0]
 80009d2:	701a      	strb	r2, [r3, #0]
        Temp[16] = '\0';
        break;
    case 3:
        for(i=0; Text[i] != '\0'; i++);
        j = ((16-i) >> 1);
        for(k=0; k<i; k++)
 80009d4:	7d7b      	ldrb	r3, [r7, #21]
 80009d6:	f103 0301 	add.w	r3, r3, #1
 80009da:	757b      	strb	r3, [r7, #21]
 80009dc:	7d7a      	ldrb	r2, [r7, #21]
 80009de:	7dfb      	ldrb	r3, [r7, #23]
 80009e0:	429a      	cmp	r2, r3
 80009e2:	d3e5      	bcc.n	80009b0 <StrAlign+0x150>
            Temp[j + i - 1 - k] = Text [i - 1 - k];
        for(k=0; k<j; k++)
 80009e4:	f04f 0300 	mov.w	r3, #0
 80009e8:	757b      	strb	r3, [r7, #21]
 80009ea:	e009      	b.n	8000a00 <StrAlign+0x1a0>
            Temp[k] = ' ';
 80009ec:	7d7b      	ldrb	r3, [r7, #21]
 80009ee:	68ba      	ldr	r2, [r7, #8]
 80009f0:	18d3      	adds	r3, r2, r3
 80009f2:	f04f 0220 	mov.w	r2, #32
 80009f6:	701a      	strb	r2, [r3, #0]
    case 3:
        for(i=0; Text[i] != '\0'; i++);
        j = ((16-i) >> 1);
        for(k=0; k<i; k++)
            Temp[j + i - 1 - k] = Text [i - 1 - k];
        for(k=0; k<j; k++)
 80009f8:	7d7b      	ldrb	r3, [r7, #21]
 80009fa:	f103 0301 	add.w	r3, r3, #1
 80009fe:	757b      	strb	r3, [r7, #21]
 8000a00:	7d7a      	ldrb	r2, [r7, #21]
 8000a02:	7dbb      	ldrb	r3, [r7, #22]
 8000a04:	429a      	cmp	r2, r3
 8000a06:	d3f1      	bcc.n	80009ec <StrAlign+0x18c>
            Temp[k] = ' ';
        for(k = (i+j); k<16; k++)
 8000a08:	7dfa      	ldrb	r2, [r7, #23]
 8000a0a:	7dbb      	ldrb	r3, [r7, #22]
 8000a0c:	18d3      	adds	r3, r2, r3
 8000a0e:	757b      	strb	r3, [r7, #21]
 8000a10:	e009      	b.n	8000a26 <StrAlign+0x1c6>
            Temp[k] = ' ';
 8000a12:	7d7b      	ldrb	r3, [r7, #21]
 8000a14:	68ba      	ldr	r2, [r7, #8]
 8000a16:	18d3      	adds	r3, r2, r3
 8000a18:	f04f 0220 	mov.w	r2, #32
 8000a1c:	701a      	strb	r2, [r3, #0]
        j = ((16-i) >> 1);
        for(k=0; k<i; k++)
            Temp[j + i - 1 - k] = Text [i - 1 - k];
        for(k=0; k<j; k++)
            Temp[k] = ' ';
        for(k = (i+j); k<16; k++)
 8000a1e:	7d7b      	ldrb	r3, [r7, #21]
 8000a20:	f103 0301 	add.w	r3, r3, #1
 8000a24:	757b      	strb	r3, [r7, #21]
 8000a26:	7d7b      	ldrb	r3, [r7, #21]
 8000a28:	2b0f      	cmp	r3, #15
 8000a2a:	d9f2      	bls.n	8000a12 <StrAlign+0x1b2>
            Temp[k] = ' ';
        Temp[16] = '\0';
 8000a2c:	68bb      	ldr	r3, [r7, #8]
 8000a2e:	f103 0310 	add.w	r3, r3, #16
 8000a32:	f04f 0200 	mov.w	r2, #0
 8000a36:	701a      	strb	r2, [r3, #0]
        break;
 8000a38:	e04d      	b.n	8000ad6 <StrAlign+0x276>
    case 4:
        for(i=0; Text[i] != '\0'; i++);
 8000a3a:	f04f 0300 	mov.w	r3, #0
 8000a3e:	75fb      	strb	r3, [r7, #23]
 8000a40:	e003      	b.n	8000a4a <StrAlign+0x1ea>
 8000a42:	7dfb      	ldrb	r3, [r7, #23]
 8000a44:	f103 0301 	add.w	r3, r3, #1
 8000a48:	75fb      	strb	r3, [r7, #23]
 8000a4a:	7dfb      	ldrb	r3, [r7, #23]
 8000a4c:	68fa      	ldr	r2, [r7, #12]
 8000a4e:	18d3      	adds	r3, r2, r3
 8000a50:	781b      	ldrb	r3, [r3, #0]
 8000a52:	2b00      	cmp	r3, #0
 8000a54:	d1f5      	bne.n	8000a42 <StrAlign+0x1e2>
        for(k=0; k<i; k++)
 8000a56:	f04f 0300 	mov.w	r3, #0
 8000a5a:	757b      	strb	r3, [r7, #21]
 8000a5c:	e013      	b.n	8000a86 <StrAlign+0x226>
            Temp[2 + i - 1 - k] = Text [i - 1 - k];
 8000a5e:	7dfb      	ldrb	r3, [r7, #23]
 8000a60:	f103 0201 	add.w	r2, r3, #1
 8000a64:	7d7b      	ldrb	r3, [r7, #21]
 8000a66:	1ad3      	subs	r3, r2, r3
 8000a68:	68ba      	ldr	r2, [r7, #8]
 8000a6a:	18d3      	adds	r3, r2, r3
 8000a6c:	7dfa      	ldrb	r2, [r7, #23]
 8000a6e:	f102 31ff 	add.w	r1, r2, #4294967295
 8000a72:	7d7a      	ldrb	r2, [r7, #21]
 8000a74:	1a8a      	subs	r2, r1, r2
 8000a76:	68f9      	ldr	r1, [r7, #12]
 8000a78:	188a      	adds	r2, r1, r2
 8000a7a:	7812      	ldrb	r2, [r2, #0]
 8000a7c:	701a      	strb	r2, [r3, #0]
            Temp[k] = ' ';
        Temp[16] = '\0';
        break;
    case 4:
        for(i=0; Text[i] != '\0'; i++);
        for(k=0; k<i; k++)
 8000a7e:	7d7b      	ldrb	r3, [r7, #21]
 8000a80:	f103 0301 	add.w	r3, r3, #1
 8000a84:	757b      	strb	r3, [r7, #21]
 8000a86:	7d7a      	ldrb	r2, [r7, #21]
 8000a88:	7dfb      	ldrb	r3, [r7, #23]
 8000a8a:	429a      	cmp	r2, r3
 8000a8c:	d3e7      	bcc.n	8000a5e <StrAlign+0x1fe>
            Temp[2 + i - 1 - k] = Text [i - 1 - k];
        for(k = (i+2); k<16; k++)
 8000a8e:	7dfb      	ldrb	r3, [r7, #23]
 8000a90:	f103 0302 	add.w	r3, r3, #2
 8000a94:	757b      	strb	r3, [r7, #21]
 8000a96:	e009      	b.n	8000aac <StrAlign+0x24c>
            Temp[k] = ' ';
 8000a98:	7d7b      	ldrb	r3, [r7, #21]
 8000a9a:	68ba      	ldr	r2, [r7, #8]
 8000a9c:	18d3      	adds	r3, r2, r3
 8000a9e:	f04f 0220 	mov.w	r2, #32
 8000aa2:	701a      	strb	r2, [r3, #0]
        break;
    case 4:
        for(i=0; Text[i] != '\0'; i++);
        for(k=0; k<i; k++)
            Temp[2 + i - 1 - k] = Text [i - 1 - k];
        for(k = (i+2); k<16; k++)
 8000aa4:	7d7b      	ldrb	r3, [r7, #21]
 8000aa6:	f103 0301 	add.w	r3, r3, #1
 8000aaa:	757b      	strb	r3, [r7, #21]
 8000aac:	7d7b      	ldrb	r3, [r7, #21]
 8000aae:	2b0f      	cmp	r3, #15
 8000ab0:	d9f2      	bls.n	8000a98 <StrAlign+0x238>
            Temp[k] = ' ';
        Temp[0] = '-';
 8000ab2:	68bb      	ldr	r3, [r7, #8]
 8000ab4:	f04f 022d 	mov.w	r2, #45	; 0x2d
 8000ab8:	701a      	strb	r2, [r3, #0]
        Temp[1] = '>';
 8000aba:	68bb      	ldr	r3, [r7, #8]
 8000abc:	f103 0301 	add.w	r3, r3, #1
 8000ac0:	f04f 023e 	mov.w	r2, #62	; 0x3e
 8000ac4:	701a      	strb	r2, [r3, #0]
        Temp[16] = '\0';
 8000ac6:	68bb      	ldr	r3, [r7, #8]
 8000ac8:	f103 0310 	add.w	r3, r3, #16
 8000acc:	f04f 0200 	mov.w	r2, #0
 8000ad0:	701a      	strb	r2, [r3, #0]
        break;
 8000ad2:	e000      	b.n	8000ad6 <StrAlign+0x276>
    default:
        break;
 8000ad4:	bf00      	nop
    }
}
 8000ad6:	f107 071c 	add.w	r7, r7, #28
 8000ada:	46bd      	mov	sp, r7
 8000adc:	bc80      	pop	{r7}
 8000ade:	4770      	bx	lr

08000ae0 <PrintStr>:

void PrintStr(char * Text)
{
 8000ae0:	b580      	push	{r7, lr}
 8000ae2:	b084      	sub	sp, #16
 8000ae4:	af00      	add	r7, sp, #0
 8000ae6:	6078      	str	r0, [r7, #4]
    char *c;

    c = Text;
 8000ae8:	687b      	ldr	r3, [r7, #4]
 8000aea:	60fb      	str	r3, [r7, #12]

    while ((c != 0) && (*c != 0))
 8000aec:	e00a      	b.n	8000b04 <PrintStr+0x24>
    {
        SendByte(*c, TRUE);
 8000aee:	68fb      	ldr	r3, [r7, #12]
 8000af0:	781b      	ldrb	r3, [r3, #0]
 8000af2:	4618      	mov	r0, r3
 8000af4:	f04f 0101 	mov.w	r1, #1
 8000af8:	f7ff fd02 	bl	8000500 <SendByte>
        c++;
 8000afc:	68fb      	ldr	r3, [r7, #12]
 8000afe:	f103 0301 	add.w	r3, r3, #1
 8000b02:	60fb      	str	r3, [r7, #12]
{
    char *c;

    c = Text;

    while ((c != 0) && (*c != 0))
 8000b04:	68fb      	ldr	r3, [r7, #12]
 8000b06:	2b00      	cmp	r3, #0
 8000b08:	d003      	beq.n	8000b12 <PrintStr+0x32>
 8000b0a:	68fb      	ldr	r3, [r7, #12]
 8000b0c:	781b      	ldrb	r3, [r3, #0]
 8000b0e:	2b00      	cmp	r3, #0
 8000b10:	d1ed      	bne.n	8000aee <PrintStr+0xe>
    {
        SendByte(*c, TRUE);
        c++;
    }
    __delay_cycles(4000);
 8000b12:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 8000b16:	f7ff fcaf 	bl	8000478 <__delay_cycles>
}
 8000b1a:	f107 0710 	add.w	r7, r7, #16
 8000b1e:	46bd      	mov	sp, r7
 8000b20:	bd80      	pop	{r7, pc}
 8000b22:	bf00      	nop

08000b24 <dec2bcd>:

void dec2bcd(int value, char * temp) {
 8000b24:	b480      	push	{r7}
 8000b26:	b085      	sub	sp, #20
 8000b28:	af00      	add	r7, sp, #0
 8000b2a:	6078      	str	r0, [r7, #4]
 8000b2c:	6039      	str	r1, [r7, #0]
    char i=0, j=0, k=0;
 8000b2e:	f04f 0300 	mov.w	r3, #0
 8000b32:	73fb      	strb	r3, [r7, #15]
 8000b34:	f04f 0300 	mov.w	r3, #0
 8000b38:	73bb      	strb	r3, [r7, #14]
 8000b3a:	f04f 0300 	mov.w	r3, #0
 8000b3e:	737b      	strb	r3, [r7, #13]
    int divider = 1000000000;
 8000b40:	4b26      	ldr	r3, [pc, #152]	; (8000bdc <dec2bcd+0xb8>)
 8000b42:	60bb      	str	r3, [r7, #8]
       for(i = 10; i > 0; i--) {
 8000b44:	f04f 030a 	mov.w	r3, #10
 8000b48:	73fb      	strb	r3, [r7, #15]
 8000b4a:	e03f      	b.n	8000bcc <dec2bcd+0xa8>
               temp[(10-i)] = (char)(value/divider);
 8000b4c:	7bfb      	ldrb	r3, [r7, #15]
 8000b4e:	f1c3 030a 	rsb	r3, r3, #10
 8000b52:	683a      	ldr	r2, [r7, #0]
 8000b54:	18d3      	adds	r3, r2, r3
 8000b56:	6879      	ldr	r1, [r7, #4]
 8000b58:	68ba      	ldr	r2, [r7, #8]
 8000b5a:	fb91 f2f2 	sdiv	r2, r1, r2
 8000b5e:	b2d2      	uxtb	r2, r2
 8000b60:	701a      	strb	r2, [r3, #0]
               if(temp[(10-i)]==0 && j==0 && k!=9)
 8000b62:	7bfb      	ldrb	r3, [r7, #15]
 8000b64:	f1c3 030a 	rsb	r3, r3, #10
 8000b68:	683a      	ldr	r2, [r7, #0]
 8000b6a:	18d3      	adds	r3, r2, r3
 8000b6c:	781b      	ldrb	r3, [r3, #0]
 8000b6e:	2b00      	cmp	r3, #0
 8000b70:	d10a      	bne.n	8000b88 <dec2bcd+0x64>
 8000b72:	7bbb      	ldrb	r3, [r7, #14]
 8000b74:	2b00      	cmp	r3, #0
 8000b76:	d107      	bne.n	8000b88 <dec2bcd+0x64>
 8000b78:	7b7b      	ldrb	r3, [r7, #13]
 8000b7a:	2b09      	cmp	r3, #9
 8000b7c:	d004      	beq.n	8000b88 <dec2bcd+0x64>
               {k++;}
 8000b7e:	7b7b      	ldrb	r3, [r7, #13]
 8000b80:	f103 0301 	add.w	r3, r3, #1
 8000b84:	737b      	strb	r3, [r7, #13]
 8000b86:	e007      	b.n	8000b98 <dec2bcd+0x74>
               else{
               j++; k++;}
 8000b88:	7bbb      	ldrb	r3, [r7, #14]
 8000b8a:	f103 0301 	add.w	r3, r3, #1
 8000b8e:	73bb      	strb	r3, [r7, #14]
 8000b90:	7b7b      	ldrb	r3, [r7, #13]
 8000b92:	f103 0301 	add.w	r3, r3, #1
 8000b96:	737b      	strb	r3, [r7, #13]
               value -= temp[(10-i)]*divider;
 8000b98:	7bfb      	ldrb	r3, [r7, #15]
 8000b9a:	f1c3 030a 	rsb	r3, r3, #10
 8000b9e:	683a      	ldr	r2, [r7, #0]
 8000ba0:	18d3      	adds	r3, r2, r3
 8000ba2:	781b      	ldrb	r3, [r3, #0]
 8000ba4:	68ba      	ldr	r2, [r7, #8]
 8000ba6:	fb02 f303 	mul.w	r3, r2, r3
 8000baa:	687a      	ldr	r2, [r7, #4]
 8000bac:	1ad3      	subs	r3, r2, r3
 8000bae:	607b      	str	r3, [r7, #4]
               divider /= 10;
 8000bb0:	68bb      	ldr	r3, [r7, #8]
 8000bb2:	4a0b      	ldr	r2, [pc, #44]	; (8000be0 <dec2bcd+0xbc>)
 8000bb4:	fb82 1203 	smull	r1, r2, r2, r3
 8000bb8:	ea4f 02a2 	mov.w	r2, r2, asr #2
 8000bbc:	ea4f 73e3 	mov.w	r3, r3, asr #31
 8000bc0:	1ad3      	subs	r3, r2, r3
 8000bc2:	60bb      	str	r3, [r7, #8]
}

void dec2bcd(int value, char * temp) {
    char i=0, j=0, k=0;
    int divider = 1000000000;
       for(i = 10; i > 0; i--) {
 8000bc4:	7bfb      	ldrb	r3, [r7, #15]
 8000bc6:	f103 33ff 	add.w	r3, r3, #4294967295
 8000bca:	73fb      	strb	r3, [r7, #15]
 8000bcc:	7bfb      	ldrb	r3, [r7, #15]
 8000bce:	2b00      	cmp	r3, #0
 8000bd0:	d1bc      	bne.n	8000b4c <dec2bcd+0x28>
               else{
               j++; k++;}
               value -= temp[(10-i)]*divider;
               divider /= 10;
       }
}
 8000bd2:	f107 0714 	add.w	r7, r7, #20
 8000bd6:	46bd      	mov	sp, r7
 8000bd8:	bc80      	pop	{r7}
 8000bda:	4770      	bx	lr
 8000bdc:	3b9aca00 	.word	0x3b9aca00
 8000be0:	66666667 	.word	0x66666667

08000be4 <DisplayFill>:

MenuElement_Typedef display_fill_menu_temporary;
extern char temp [17];

void DisplayFill(MenuElement_Typedef menu_current, MenuElement_Typedef menu_first)
{
 8000be4:	b084      	sub	sp, #16
 8000be6:	b5b0      	push	{r4, r5, r7, lr}
 8000be8:	af00      	add	r7, sp, #0
 8000bea:	f107 0c10 	add.w	ip, r7, #16
 8000bee:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
    display_fill_menu_temporary = menu_first;
 8000bf2:	4b9a      	ldr	r3, [pc, #616]	; (8000e5c <DisplayFill+0x278>)
 8000bf4:	461c      	mov	r4, r3
 8000bf6:	f107 052c 	add.w	r5, r7, #44	; 0x2c
 8000bfa:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000bfc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000bfe:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8000c02:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    while(display_fill_menu_temporary.previous)
 8000c06:	e00a      	b.n	8000c1e <DisplayFill+0x3a>
        display_fill_menu_temporary = *display_fill_menu_temporary.previous;
 8000c08:	4b94      	ldr	r3, [pc, #592]	; (8000e5c <DisplayFill+0x278>)
 8000c0a:	691b      	ldr	r3, [r3, #16]
 8000c0c:	4a93      	ldr	r2, [pc, #588]	; (8000e5c <DisplayFill+0x278>)
 8000c0e:	4614      	mov	r4, r2
 8000c10:	461d      	mov	r5, r3
 8000c12:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000c14:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000c16:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8000c1a:	e884 0007 	stmia.w	r4, {r0, r1, r2}
extern char temp [17];

void DisplayFill(MenuElement_Typedef menu_current, MenuElement_Typedef menu_first)
{
    display_fill_menu_temporary = menu_first;
    while(display_fill_menu_temporary.previous)
 8000c1e:	4b8f      	ldr	r3, [pc, #572]	; (8000e5c <DisplayFill+0x278>)
 8000c20:	691b      	ldr	r3, [r3, #16]
 8000c22:	2b00      	cmp	r3, #0
 8000c24:	d1f0      	bne.n	8000c08 <DisplayFill+0x24>
        display_fill_menu_temporary = *display_fill_menu_temporary.previous;
    display_fill_menu_temporary = *display_fill_menu_temporary.up;
 8000c26:	4b8d      	ldr	r3, [pc, #564]	; (8000e5c <DisplayFill+0x278>)
 8000c28:	695b      	ldr	r3, [r3, #20]
 8000c2a:	4a8c      	ldr	r2, [pc, #560]	; (8000e5c <DisplayFill+0x278>)
 8000c2c:	4614      	mov	r4, r2
 8000c2e:	461d      	mov	r5, r3
 8000c30:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000c32:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000c34:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8000c38:	e884 0007 	stmia.w	r4, {r0, r1, r2}

    Cursor(0,0);
 8000c3c:	f04f 0000 	mov.w	r0, #0
 8000c40:	f04f 0100 	mov.w	r1, #0
 8000c44:	f7ff fd3e 	bl	80006c4 <Cursor>
    __delay_cycles(40000);
 8000c48:	f649 4040 	movw	r0, #40000	; 0x9c40
 8000c4c:	f7ff fc14 	bl	8000478 <__delay_cycles>
    StrAlign(display_fill_menu_temporary.nev, temp, ALIGN_CENTER);
 8000c50:	4b82      	ldr	r3, [pc, #520]	; (8000e5c <DisplayFill+0x278>)
 8000c52:	681b      	ldr	r3, [r3, #0]
 8000c54:	4618      	mov	r0, r3
 8000c56:	4982      	ldr	r1, [pc, #520]	; (8000e60 <DisplayFill+0x27c>)
 8000c58:	f04f 0203 	mov.w	r2, #3
 8000c5c:	f7ff fe00 	bl	8000860 <StrAlign>
    PrintStr(temp);
 8000c60:	487f      	ldr	r0, [pc, #508]	; (8000e60 <DisplayFill+0x27c>)
 8000c62:	f7ff ff3d 	bl	8000ae0 <PrintStr>
    __delay_cycles(4000);
 8000c66:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 8000c6a:	f7ff fc05 	bl	8000478 <__delay_cycles>

    Cursor(((menu_current.designator - menu_first.designator) + 1), 0);
 8000c6e:	7d3a      	ldrb	r2, [r7, #20]
 8000c70:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 8000c74:	1ad3      	subs	r3, r2, r3
 8000c76:	b2db      	uxtb	r3, r3
 8000c78:	f103 0301 	add.w	r3, r3, #1
 8000c7c:	b2db      	uxtb	r3, r3
 8000c7e:	4618      	mov	r0, r3
 8000c80:	f04f 0100 	mov.w	r1, #0
 8000c84:	f7ff fd1e 	bl	80006c4 <Cursor>
    __delay_cycles(40000);
 8000c88:	f649 4040 	movw	r0, #40000	; 0x9c40
 8000c8c:	f7ff fbf4 	bl	8000478 <__delay_cycles>
    StrAlign(menu_current.nev, temp, ALIGN_ARROW);
 8000c90:	693b      	ldr	r3, [r7, #16]
 8000c92:	4618      	mov	r0, r3
 8000c94:	4972      	ldr	r1, [pc, #456]	; (8000e60 <DisplayFill+0x27c>)
 8000c96:	f04f 0204 	mov.w	r2, #4
 8000c9a:	f7ff fde1 	bl	8000860 <StrAlign>
    PrintStr(temp);
 8000c9e:	4870      	ldr	r0, [pc, #448]	; (8000e60 <DisplayFill+0x27c>)
 8000ca0:	f7ff ff1e 	bl	8000ae0 <PrintStr>
    __delay_cycles(4000);
 8000ca4:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 8000ca8:	f7ff fbe6 	bl	8000478 <__delay_cycles>

    if((menu_current.designator - menu_first.designator))
 8000cac:	7d3a      	ldrb	r2, [r7, #20]
 8000cae:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 8000cb2:	429a      	cmp	r2, r3
 8000cb4:	d026      	beq.n	8000d04 <DisplayFill+0x120>
    {
        display_fill_menu_temporary = *(menu_current.previous);
 8000cb6:	6a3b      	ldr	r3, [r7, #32]
 8000cb8:	4a68      	ldr	r2, [pc, #416]	; (8000e5c <DisplayFill+0x278>)
 8000cba:	4614      	mov	r4, r2
 8000cbc:	461d      	mov	r5, r3
 8000cbe:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000cc0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000cc2:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8000cc6:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        Cursor(((menu_current.designator - menu_first.designator)), 0);
 8000cca:	7d3a      	ldrb	r2, [r7, #20]
 8000ccc:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 8000cd0:	1ad3      	subs	r3, r2, r3
 8000cd2:	b2db      	uxtb	r3, r3
 8000cd4:	4618      	mov	r0, r3
 8000cd6:	f04f 0100 	mov.w	r1, #0
 8000cda:	f7ff fcf3 	bl	80006c4 <Cursor>
        __delay_cycles(40000);
 8000cde:	f649 4040 	movw	r0, #40000	; 0x9c40
 8000ce2:	f7ff fbc9 	bl	8000478 <__delay_cycles>
        StrAlign(display_fill_menu_temporary.nev, temp, ALIGN_LEFT);
 8000ce6:	4b5d      	ldr	r3, [pc, #372]	; (8000e5c <DisplayFill+0x278>)
 8000ce8:	681b      	ldr	r3, [r3, #0]
 8000cea:	4618      	mov	r0, r3
 8000cec:	495c      	ldr	r1, [pc, #368]	; (8000e60 <DisplayFill+0x27c>)
 8000cee:	f04f 0201 	mov.w	r2, #1
 8000cf2:	f7ff fdb5 	bl	8000860 <StrAlign>
        PrintStr(temp);
 8000cf6:	485a      	ldr	r0, [pc, #360]	; (8000e60 <DisplayFill+0x27c>)
 8000cf8:	f7ff fef2 	bl	8000ae0 <PrintStr>
        __delay_cycles(4000);
 8000cfc:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 8000d00:	f7ff fbba 	bl	8000478 <__delay_cycles>
    }

    if((menu_current.designator - menu_first.designator) == 2)
 8000d04:	7d3b      	ldrb	r3, [r7, #20]
 8000d06:	461a      	mov	r2, r3
 8000d08:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 8000d0c:	1ad3      	subs	r3, r2, r3
 8000d0e:	2b02      	cmp	r3, #2
 8000d10:	d12d      	bne.n	8000d6e <DisplayFill+0x18a>
    {
        display_fill_menu_temporary = *(menu_current.previous);
 8000d12:	6a3b      	ldr	r3, [r7, #32]
 8000d14:	4a51      	ldr	r2, [pc, #324]	; (8000e5c <DisplayFill+0x278>)
 8000d16:	4614      	mov	r4, r2
 8000d18:	461d      	mov	r5, r3
 8000d1a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000d1c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000d1e:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8000d22:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        display_fill_menu_temporary = *(display_fill_menu_temporary.previous);
 8000d26:	4b4d      	ldr	r3, [pc, #308]	; (8000e5c <DisplayFill+0x278>)
 8000d28:	691b      	ldr	r3, [r3, #16]
 8000d2a:	4a4c      	ldr	r2, [pc, #304]	; (8000e5c <DisplayFill+0x278>)
 8000d2c:	4614      	mov	r4, r2
 8000d2e:	461d      	mov	r5, r3
 8000d30:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000d32:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000d34:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8000d38:	e884 0007 	stmia.w	r4, {r0, r1, r2}

        Cursor(1, 0);
 8000d3c:	f04f 0001 	mov.w	r0, #1
 8000d40:	f04f 0100 	mov.w	r1, #0
 8000d44:	f7ff fcbe 	bl	80006c4 <Cursor>
        __delay_cycles(40000);
 8000d48:	f649 4040 	movw	r0, #40000	; 0x9c40
 8000d4c:	f7ff fb94 	bl	8000478 <__delay_cycles>
        StrAlign(display_fill_menu_temporary.nev, temp, ALIGN_LEFT);
 8000d50:	4b42      	ldr	r3, [pc, #264]	; (8000e5c <DisplayFill+0x278>)
 8000d52:	681b      	ldr	r3, [r3, #0]
 8000d54:	4618      	mov	r0, r3
 8000d56:	4942      	ldr	r1, [pc, #264]	; (8000e60 <DisplayFill+0x27c>)
 8000d58:	f04f 0201 	mov.w	r2, #1
 8000d5c:	f7ff fd80 	bl	8000860 <StrAlign>
        PrintStr(temp);
 8000d60:	483f      	ldr	r0, [pc, #252]	; (8000e60 <DisplayFill+0x27c>)
 8000d62:	f7ff febd 	bl	8000ae0 <PrintStr>
        __delay_cycles(4000);
 8000d66:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 8000d6a:	f7ff fb85 	bl	8000478 <__delay_cycles>
    }

    if(((menu_current.designator - menu_first.designator) + 1) < 3)
 8000d6e:	7d3b      	ldrb	r3, [r7, #20]
 8000d70:	461a      	mov	r2, r3
 8000d72:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 8000d76:	1ad3      	subs	r3, r2, r3
 8000d78:	f103 0301 	add.w	r3, r3, #1
 8000d7c:	2b02      	cmp	r3, #2
 8000d7e:	dc29      	bgt.n	8000dd4 <DisplayFill+0x1f0>
    {
        display_fill_menu_temporary = *(menu_current.next);
 8000d80:	69fb      	ldr	r3, [r7, #28]
 8000d82:	4a36      	ldr	r2, [pc, #216]	; (8000e5c <DisplayFill+0x278>)
 8000d84:	4614      	mov	r4, r2
 8000d86:	461d      	mov	r5, r3
 8000d88:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000d8a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000d8c:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8000d90:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        Cursor(((menu_current.designator - menu_first.designator) + 2), 0);
 8000d94:	7d3a      	ldrb	r2, [r7, #20]
 8000d96:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 8000d9a:	1ad3      	subs	r3, r2, r3
 8000d9c:	b2db      	uxtb	r3, r3
 8000d9e:	f103 0302 	add.w	r3, r3, #2
 8000da2:	b2db      	uxtb	r3, r3
 8000da4:	4618      	mov	r0, r3
 8000da6:	f04f 0100 	mov.w	r1, #0
 8000daa:	f7ff fc8b 	bl	80006c4 <Cursor>
        __delay_cycles(40000);
 8000dae:	f649 4040 	movw	r0, #40000	; 0x9c40
 8000db2:	f7ff fb61 	bl	8000478 <__delay_cycles>
        StrAlign(display_fill_menu_temporary.nev, temp, ALIGN_LEFT);
 8000db6:	4b29      	ldr	r3, [pc, #164]	; (8000e5c <DisplayFill+0x278>)
 8000db8:	681b      	ldr	r3, [r3, #0]
 8000dba:	4618      	mov	r0, r3
 8000dbc:	4928      	ldr	r1, [pc, #160]	; (8000e60 <DisplayFill+0x27c>)
 8000dbe:	f04f 0201 	mov.w	r2, #1
 8000dc2:	f7ff fd4d 	bl	8000860 <StrAlign>
        PrintStr(temp);
 8000dc6:	4826      	ldr	r0, [pc, #152]	; (8000e60 <DisplayFill+0x27c>)
 8000dc8:	f7ff fe8a 	bl	8000ae0 <PrintStr>
        __delay_cycles(4000);
 8000dcc:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 8000dd0:	f7ff fb52 	bl	8000478 <__delay_cycles>
    }

    if((((menu_current.designator - menu_first.designator) + 2) < 3) && (menu_current.next) && ((*menu_current.next).next))
 8000dd4:	7d3b      	ldrb	r3, [r7, #20]
 8000dd6:	461a      	mov	r2, r3
 8000dd8:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 8000ddc:	1ad3      	subs	r3, r2, r3
 8000dde:	f103 0302 	add.w	r3, r3, #2
 8000de2:	2b02      	cmp	r3, #2
 8000de4:	dc34      	bgt.n	8000e50 <DisplayFill+0x26c>
 8000de6:	69fb      	ldr	r3, [r7, #28]
 8000de8:	2b00      	cmp	r3, #0
 8000dea:	d031      	beq.n	8000e50 <DisplayFill+0x26c>
 8000dec:	69fb      	ldr	r3, [r7, #28]
 8000dee:	68db      	ldr	r3, [r3, #12]
 8000df0:	2b00      	cmp	r3, #0
 8000df2:	d02d      	beq.n	8000e50 <DisplayFill+0x26c>
    {
        display_fill_menu_temporary = *(menu_current.next);
 8000df4:	69fb      	ldr	r3, [r7, #28]
 8000df6:	4a19      	ldr	r2, [pc, #100]	; (8000e5c <DisplayFill+0x278>)
 8000df8:	4614      	mov	r4, r2
 8000dfa:	461d      	mov	r5, r3
 8000dfc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000dfe:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000e00:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8000e04:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        display_fill_menu_temporary = *(display_fill_menu_temporary.next);
 8000e08:	4b14      	ldr	r3, [pc, #80]	; (8000e5c <DisplayFill+0x278>)
 8000e0a:	68db      	ldr	r3, [r3, #12]
 8000e0c:	4a13      	ldr	r2, [pc, #76]	; (8000e5c <DisplayFill+0x278>)
 8000e0e:	4614      	mov	r4, r2
 8000e10:	461d      	mov	r5, r3
 8000e12:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000e14:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000e16:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8000e1a:	e884 0007 	stmia.w	r4, {r0, r1, r2}

        Cursor(3, 0);
 8000e1e:	f04f 0003 	mov.w	r0, #3
 8000e22:	f04f 0100 	mov.w	r1, #0
 8000e26:	f7ff fc4d 	bl	80006c4 <Cursor>
        __delay_cycles(40000);
 8000e2a:	f649 4040 	movw	r0, #40000	; 0x9c40
 8000e2e:	f7ff fb23 	bl	8000478 <__delay_cycles>
        StrAlign(display_fill_menu_temporary.nev, temp, ALIGN_LEFT);
 8000e32:	4b0a      	ldr	r3, [pc, #40]	; (8000e5c <DisplayFill+0x278>)
 8000e34:	681b      	ldr	r3, [r3, #0]
 8000e36:	4618      	mov	r0, r3
 8000e38:	4909      	ldr	r1, [pc, #36]	; (8000e60 <DisplayFill+0x27c>)
 8000e3a:	f04f 0201 	mov.w	r2, #1
 8000e3e:	f7ff fd0f 	bl	8000860 <StrAlign>
        PrintStr(temp);
 8000e42:	4807      	ldr	r0, [pc, #28]	; (8000e60 <DisplayFill+0x27c>)
 8000e44:	f7ff fe4c 	bl	8000ae0 <PrintStr>
        __delay_cycles(4000);
 8000e48:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 8000e4c:	f7ff fb14 	bl	8000478 <__delay_cycles>
    }
}
 8000e50:	46bd      	mov	sp, r7
 8000e52:	e8bd 40b0 	ldmia.w	sp!, {r4, r5, r7, lr}
 8000e56:	b004      	add	sp, #16
 8000e58:	4770      	bx	lr
 8000e5a:	bf00      	nop
 8000e5c:	20000cd0 	.word	0x20000cd0
 8000e60:	20000fac 	.word	0x20000fac

08000e64 <OutputOn>:
char datechanger_date[9];
char watering_lenght[3];
int day_counter;

int OutputOn(char param)
{
 8000e64:	b580      	push	{r7, lr}
 8000e66:	b082      	sub	sp, #8
 8000e68:	af00      	add	r7, sp, #0
 8000e6a:	4603      	mov	r3, r0
 8000e6c:	71fb      	strb	r3, [r7, #7]
    Output_On(param);
 8000e6e:	79fb      	ldrb	r3, [r7, #7]
 8000e70:	4618      	mov	r0, r3
 8000e72:	f003 f8fd 	bl	8004070 <Output_On>

    return 0;
 8000e76:	f04f 0300 	mov.w	r3, #0
}
 8000e7a:	4618      	mov	r0, r3
 8000e7c:	f107 0708 	add.w	r7, r7, #8
 8000e80:	46bd      	mov	sp, r7
 8000e82:	bd80      	pop	{r7, pc}

08000e84 <OutputOff>:

int OutputOff(char param)
{
 8000e84:	b580      	push	{r7, lr}
 8000e86:	b082      	sub	sp, #8
 8000e88:	af00      	add	r7, sp, #0
 8000e8a:	4603      	mov	r3, r0
 8000e8c:	71fb      	strb	r3, [r7, #7]
    Output_Off(param);
 8000e8e:	79fb      	ldrb	r3, [r7, #7]
 8000e90:	4618      	mov	r0, r3
 8000e92:	f003 f953 	bl	800413c <Output_Off>

    return 0;
 8000e96:	f04f 0300 	mov.w	r3, #0
}
 8000e9a:	4618      	mov	r0, r3
 8000e9c:	f107 0708 	add.w	r7, r7, #8
 8000ea0:	46bd      	mov	sp, r7
 8000ea2:	bd80      	pop	{r7, pc}

08000ea4 <TimeCompare>:
 * */

char watering_temp[6][17];	//Az öntözési programok egyes paramétereit tárolom benne. Az öntözés kezdete: (8-12 bit, hossza: 14, 15.bit)

int TimeCompare(Watering_Typedef * watering_current)	//0-val tér vissza, ha éppen megy egy program, 1-el, ha nem.
{
 8000ea4:	b480      	push	{r7}
 8000ea6:	b085      	sub	sp, #20
 8000ea8:	af00      	add	r7, sp, #0
 8000eaa:	6078      	str	r0, [r7, #4]
    int temp1;
    int temp2;

    temp1 = ((watering_temp[(watering_current->designator - 1)][8] - ASCII_OFFSEET) * 36000 + (watering_temp[(watering_current->designator - 1)][9] - ASCII_OFFSEET) * 3600 + (watering_temp[(watering_current->designator - 1)][11] - ASCII_OFFSEET) * 600 + (watering_temp[(watering_current->designator - 1)][12] - ASCII_OFFSEET) * 60);
 8000eac:	687b      	ldr	r3, [r7, #4]
 8000eae:	791b      	ldrb	r3, [r3, #4]
 8000eb0:	f103 32ff 	add.w	r2, r3, #4294967295
 8000eb4:	496a      	ldr	r1, [pc, #424]	; (8001060 <TimeCompare+0x1bc>)
 8000eb6:	4613      	mov	r3, r2
 8000eb8:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8000ebc:	189b      	adds	r3, r3, r2
 8000ebe:	18cb      	adds	r3, r1, r3
 8000ec0:	f103 0308 	add.w	r3, r3, #8
 8000ec4:	781b      	ldrb	r3, [r3, #0]
 8000ec6:	f648 42a0 	movw	r2, #36000	; 0x8ca0
 8000eca:	fb02 f303 	mul.w	r3, r2, r3
 8000ece:	f5a3 12d2 	sub.w	r2, r3, #1720320	; 0x1a4000
 8000ed2:	f5a2 52f0 	sub.w	r2, r2, #7680	; 0x1e00
 8000ed6:	687b      	ldr	r3, [r7, #4]
 8000ed8:	791b      	ldrb	r3, [r3, #4]
 8000eda:	f103 31ff 	add.w	r1, r3, #4294967295
 8000ede:	4860      	ldr	r0, [pc, #384]	; (8001060 <TimeCompare+0x1bc>)
 8000ee0:	460b      	mov	r3, r1
 8000ee2:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8000ee6:	185b      	adds	r3, r3, r1
 8000ee8:	18c3      	adds	r3, r0, r3
 8000eea:	f103 0309 	add.w	r3, r3, #9
 8000eee:	781b      	ldrb	r3, [r3, #0]
 8000ef0:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 8000ef4:	fb01 f303 	mul.w	r3, r1, r3
 8000ef8:	f5a3 3328 	sub.w	r3, r3, #172032	; 0x2a000
 8000efc:	f5a3 7340 	sub.w	r3, r3, #768	; 0x300
 8000f00:	18d1      	adds	r1, r2, r3
 8000f02:	687b      	ldr	r3, [r7, #4]
 8000f04:	791b      	ldrb	r3, [r3, #4]
 8000f06:	f103 32ff 	add.w	r2, r3, #4294967295
 8000f0a:	4855      	ldr	r0, [pc, #340]	; (8001060 <TimeCompare+0x1bc>)
 8000f0c:	4613      	mov	r3, r2
 8000f0e:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8000f12:	189b      	adds	r3, r3, r2
 8000f14:	18c3      	adds	r3, r0, r3
 8000f16:	f103 030b 	add.w	r3, r3, #11
 8000f1a:	781b      	ldrb	r3, [r3, #0]
 8000f1c:	f44f 7216 	mov.w	r2, #600	; 0x258
 8000f20:	fb02 f303 	mul.w	r3, r2, r3
 8000f24:	f5a3 43e1 	sub.w	r3, r3, #28800	; 0x7080
 8000f28:	18c9      	adds	r1, r1, r3
 8000f2a:	687b      	ldr	r3, [r7, #4]
 8000f2c:	791b      	ldrb	r3, [r3, #4]
 8000f2e:	f103 32ff 	add.w	r2, r3, #4294967295
 8000f32:	484b      	ldr	r0, [pc, #300]	; (8001060 <TimeCompare+0x1bc>)
 8000f34:	4613      	mov	r3, r2
 8000f36:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8000f3a:	189b      	adds	r3, r3, r2
 8000f3c:	18c3      	adds	r3, r0, r3
 8000f3e:	f103 030c 	add.w	r3, r3, #12
 8000f42:	781b      	ldrb	r3, [r3, #0]
 8000f44:	461a      	mov	r2, r3
 8000f46:	4613      	mov	r3, r2
 8000f48:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8000f4c:	1a9b      	subs	r3, r3, r2
 8000f4e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000f52:	f5a3 6334 	sub.w	r3, r3, #2880	; 0xb40
 8000f56:	18cb      	adds	r3, r1, r3
 8000f58:	60fb      	str	r3, [r7, #12]
    temp2 = (((RTC->TR & TIME_HOUR_BCD_1) >> TIME_HOUR_BCD_1_OFFSET) * 36000 + ((RTC->TR & TIME_HOUR_BCD_2) >> TIME_HOUR_BCD_2_OFFSET) * 3600 + ((RTC->TR & TIME_MINUTE_BCD_1) >> TIME_MINUTE_BCD_1_OFFSET) * 600 + ((RTC->TR & TIME_MINUTE_BCD_2) >> TIME_MINUTE_BCD_2_OFFSET) * 60 + ((RTC->TR & TIME_SECOND_BCD_1) >> TIME_SECOND_BCD_1_OFFSET) * 10 + ((RTC->TR & TIME_SECOND_BCD_2) >> TIME_SECOND_BCD_2_OFFSET));
 8000f5a:	4b42      	ldr	r3, [pc, #264]	; (8001064 <TimeCompare+0x1c0>)
 8000f5c:	681b      	ldr	r3, [r3, #0]
 8000f5e:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 8000f62:	ea4f 5313 	mov.w	r3, r3, lsr #20
 8000f66:	f648 42a0 	movw	r2, #36000	; 0x8ca0
 8000f6a:	fb02 f203 	mul.w	r2, r2, r3
 8000f6e:	4b3d      	ldr	r3, [pc, #244]	; (8001064 <TimeCompare+0x1c0>)
 8000f70:	681b      	ldr	r3, [r3, #0]
 8000f72:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
 8000f76:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8000f7a:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 8000f7e:	fb01 f303 	mul.w	r3, r1, r3
 8000f82:	18d1      	adds	r1, r2, r3
 8000f84:	4b37      	ldr	r3, [pc, #220]	; (8001064 <TimeCompare+0x1c0>)
 8000f86:	681b      	ldr	r3, [r3, #0]
 8000f88:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 8000f8c:	ea4f 2213 	mov.w	r2, r3, lsr #8
 8000f90:	4613      	mov	r3, r2
 8000f92:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8000f96:	1a9b      	subs	r3, r3, r2
 8000f98:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000f9c:	461a      	mov	r2, r3
 8000f9e:	4b31      	ldr	r3, [pc, #196]	; (8001064 <TimeCompare+0x1c0>)
 8000fa0:	681b      	ldr	r3, [r3, #0]
 8000fa2:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
 8000fa6:	ea4f 3313 	mov.w	r3, r3, lsr #12
 8000faa:	f44f 7016 	mov.w	r0, #600	; 0x258
 8000fae:	fb00 f303 	mul.w	r3, r0, r3
 8000fb2:	18d3      	adds	r3, r2, r3
 8000fb4:	18c9      	adds	r1, r1, r3
 8000fb6:	4b2b      	ldr	r3, [pc, #172]	; (8001064 <TimeCompare+0x1c0>)
 8000fb8:	681b      	ldr	r3, [r3, #0]
 8000fba:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8000fbe:	ea4f 1213 	mov.w	r2, r3, lsr #4
 8000fc2:	4613      	mov	r3, r2
 8000fc4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000fc8:	189b      	adds	r3, r3, r2
 8000fca:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000fce:	18ca      	adds	r2, r1, r3
 8000fd0:	4b24      	ldr	r3, [pc, #144]	; (8001064 <TimeCompare+0x1c0>)
 8000fd2:	681b      	ldr	r3, [r3, #0]
 8000fd4:	f003 030f 	and.w	r3, r3, #15
 8000fd8:	18d3      	adds	r3, r2, r3
 8000fda:	60bb      	str	r3, [r7, #8]

    if((temp1 <= temp2) && ((temp1 + ((watering_temp[(watering_current->designator - 1)][14] - ASCII_OFFSEET) * 600) + ((watering_temp[(watering_current->designator - 1)][15] - ASCII_OFFSEET) * 60)) >= temp2))
 8000fdc:	68fa      	ldr	r2, [r7, #12]
 8000fde:	68bb      	ldr	r3, [r7, #8]
 8000fe0:	429a      	cmp	r2, r3
 8000fe2:	dc32      	bgt.n	800104a <TimeCompare+0x1a6>
 8000fe4:	687b      	ldr	r3, [r7, #4]
 8000fe6:	791b      	ldrb	r3, [r3, #4]
 8000fe8:	f103 32ff 	add.w	r2, r3, #4294967295
 8000fec:	491c      	ldr	r1, [pc, #112]	; (8001060 <TimeCompare+0x1bc>)
 8000fee:	4613      	mov	r3, r2
 8000ff0:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8000ff4:	189b      	adds	r3, r3, r2
 8000ff6:	18cb      	adds	r3, r1, r3
 8000ff8:	f103 030e 	add.w	r3, r3, #14
 8000ffc:	781b      	ldrb	r3, [r3, #0]
 8000ffe:	f44f 7216 	mov.w	r2, #600	; 0x258
 8001002:	fb02 f303 	mul.w	r3, r2, r3
 8001006:	f5a3 42e1 	sub.w	r2, r3, #28800	; 0x7080
 800100a:	68fb      	ldr	r3, [r7, #12]
 800100c:	18d1      	adds	r1, r2, r3
 800100e:	687b      	ldr	r3, [r7, #4]
 8001010:	791b      	ldrb	r3, [r3, #4]
 8001012:	f103 32ff 	add.w	r2, r3, #4294967295
 8001016:	4812      	ldr	r0, [pc, #72]	; (8001060 <TimeCompare+0x1bc>)
 8001018:	4613      	mov	r3, r2
 800101a:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800101e:	189b      	adds	r3, r3, r2
 8001020:	18c3      	adds	r3, r0, r3
 8001022:	f103 030f 	add.w	r3, r3, #15
 8001026:	781b      	ldrb	r3, [r3, #0]
 8001028:	461a      	mov	r2, r3
 800102a:	4613      	mov	r3, r2
 800102c:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001030:	1a9b      	subs	r3, r3, r2
 8001032:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001036:	f5a3 6334 	sub.w	r3, r3, #2880	; 0xb40
 800103a:	18ca      	adds	r2, r1, r3
 800103c:	68bb      	ldr	r3, [r7, #8]
 800103e:	429a      	cmp	r2, r3
 8001040:	db03      	blt.n	800104a <TimeCompare+0x1a6>
        temp1 = 0;
 8001042:	f04f 0300 	mov.w	r3, #0
 8001046:	60fb      	str	r3, [r7, #12]
 8001048:	e002      	b.n	8001050 <TimeCompare+0x1ac>
    else
    	temp1 = 1;
 800104a:	f04f 0301 	mov.w	r3, #1
 800104e:	60fb      	str	r3, [r7, #12]
    return temp1;
 8001050:	68fb      	ldr	r3, [r7, #12]
}
 8001052:	4618      	mov	r0, r3
 8001054:	f107 0714 	add.w	r7, r7, #20
 8001058:	46bd      	mov	sp, r7
 800105a:	bc80      	pop	{r7}
 800105c:	4770      	bx	lr
 800105e:	bf00      	nop
 8001060:	20000dac 	.word	0x20000dac
 8001064:	40002800 	.word	0x40002800

08001068 <TimeCompare2>:

int TimeCompare2(Watering_Typedef * watering_current, Watering_Typedef * watering_other)
{
 8001068:	b480      	push	{r7}
 800106a:	b087      	sub	sp, #28
 800106c:	af00      	add	r7, sp, #0
 800106e:	6078      	str	r0, [r7, #4]
 8001070:	6039      	str	r1, [r7, #0]
    int tempc1;
    int tempc2;
    int tempo1;
    int tempo2;

    tempc1 = ((datechanger_date[0] - ASCII_OFFSEET) * 36000 + (datechanger_date[1] - ASCII_OFFSEET) * 3600 + (datechanger_date[3] - ASCII_OFFSEET) * 600 + (datechanger_date[4] - ASCII_OFFSEET) * 60);
 8001072:	4b78      	ldr	r3, [pc, #480]	; (8001254 <TimeCompare2+0x1ec>)
 8001074:	781b      	ldrb	r3, [r3, #0]
 8001076:	f648 42a0 	movw	r2, #36000	; 0x8ca0
 800107a:	fb02 f303 	mul.w	r3, r2, r3
 800107e:	f5a3 12d2 	sub.w	r2, r3, #1720320	; 0x1a4000
 8001082:	f5a2 52f0 	sub.w	r2, r2, #7680	; 0x1e00
 8001086:	4b73      	ldr	r3, [pc, #460]	; (8001254 <TimeCompare2+0x1ec>)
 8001088:	785b      	ldrb	r3, [r3, #1]
 800108a:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 800108e:	fb01 f303 	mul.w	r3, r1, r3
 8001092:	f5a3 3328 	sub.w	r3, r3, #172032	; 0x2a000
 8001096:	f5a3 7340 	sub.w	r3, r3, #768	; 0x300
 800109a:	18d2      	adds	r2, r2, r3
 800109c:	4b6d      	ldr	r3, [pc, #436]	; (8001254 <TimeCompare2+0x1ec>)
 800109e:	78db      	ldrb	r3, [r3, #3]
 80010a0:	f44f 7116 	mov.w	r1, #600	; 0x258
 80010a4:	fb01 f303 	mul.w	r3, r1, r3
 80010a8:	f5a3 43e1 	sub.w	r3, r3, #28800	; 0x7080
 80010ac:	18d1      	adds	r1, r2, r3
 80010ae:	4b69      	ldr	r3, [pc, #420]	; (8001254 <TimeCompare2+0x1ec>)
 80010b0:	791b      	ldrb	r3, [r3, #4]
 80010b2:	461a      	mov	r2, r3
 80010b4:	4613      	mov	r3, r2
 80010b6:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80010ba:	1a9b      	subs	r3, r3, r2
 80010bc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80010c0:	f5a3 6334 	sub.w	r3, r3, #2880	; 0xb40
 80010c4:	18cb      	adds	r3, r1, r3
 80010c6:	617b      	str	r3, [r7, #20]
    tempo1 = ((watering_temp[(watering_other->designator - 1)][8] - ASCII_OFFSEET) * 36000 + (watering_temp[(watering_other->designator - 1)][9] - ASCII_OFFSEET) * 3600 + (watering_temp[(watering_other->designator - 1)][11] - ASCII_OFFSEET) * 600 + (watering_temp[(watering_other->designator - 1)][12] - ASCII_OFFSEET) * 60);
 80010c8:	683b      	ldr	r3, [r7, #0]
 80010ca:	791b      	ldrb	r3, [r3, #4]
 80010cc:	f103 32ff 	add.w	r2, r3, #4294967295
 80010d0:	4961      	ldr	r1, [pc, #388]	; (8001258 <TimeCompare2+0x1f0>)
 80010d2:	4613      	mov	r3, r2
 80010d4:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80010d8:	189b      	adds	r3, r3, r2
 80010da:	18cb      	adds	r3, r1, r3
 80010dc:	f103 0308 	add.w	r3, r3, #8
 80010e0:	781b      	ldrb	r3, [r3, #0]
 80010e2:	f648 42a0 	movw	r2, #36000	; 0x8ca0
 80010e6:	fb02 f303 	mul.w	r3, r2, r3
 80010ea:	f5a3 12d2 	sub.w	r2, r3, #1720320	; 0x1a4000
 80010ee:	f5a2 52f0 	sub.w	r2, r2, #7680	; 0x1e00
 80010f2:	683b      	ldr	r3, [r7, #0]
 80010f4:	791b      	ldrb	r3, [r3, #4]
 80010f6:	f103 31ff 	add.w	r1, r3, #4294967295
 80010fa:	4857      	ldr	r0, [pc, #348]	; (8001258 <TimeCompare2+0x1f0>)
 80010fc:	460b      	mov	r3, r1
 80010fe:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001102:	185b      	adds	r3, r3, r1
 8001104:	18c3      	adds	r3, r0, r3
 8001106:	f103 0309 	add.w	r3, r3, #9
 800110a:	781b      	ldrb	r3, [r3, #0]
 800110c:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 8001110:	fb01 f303 	mul.w	r3, r1, r3
 8001114:	f5a3 3328 	sub.w	r3, r3, #172032	; 0x2a000
 8001118:	f5a3 7340 	sub.w	r3, r3, #768	; 0x300
 800111c:	18d1      	adds	r1, r2, r3
 800111e:	683b      	ldr	r3, [r7, #0]
 8001120:	791b      	ldrb	r3, [r3, #4]
 8001122:	f103 32ff 	add.w	r2, r3, #4294967295
 8001126:	484c      	ldr	r0, [pc, #304]	; (8001258 <TimeCompare2+0x1f0>)
 8001128:	4613      	mov	r3, r2
 800112a:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800112e:	189b      	adds	r3, r3, r2
 8001130:	18c3      	adds	r3, r0, r3
 8001132:	f103 030b 	add.w	r3, r3, #11
 8001136:	781b      	ldrb	r3, [r3, #0]
 8001138:	f44f 7216 	mov.w	r2, #600	; 0x258
 800113c:	fb02 f303 	mul.w	r3, r2, r3
 8001140:	f5a3 43e1 	sub.w	r3, r3, #28800	; 0x7080
 8001144:	18c9      	adds	r1, r1, r3
 8001146:	683b      	ldr	r3, [r7, #0]
 8001148:	791b      	ldrb	r3, [r3, #4]
 800114a:	f103 32ff 	add.w	r2, r3, #4294967295
 800114e:	4842      	ldr	r0, [pc, #264]	; (8001258 <TimeCompare2+0x1f0>)
 8001150:	4613      	mov	r3, r2
 8001152:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001156:	189b      	adds	r3, r3, r2
 8001158:	18c3      	adds	r3, r0, r3
 800115a:	f103 030c 	add.w	r3, r3, #12
 800115e:	781b      	ldrb	r3, [r3, #0]
 8001160:	461a      	mov	r2, r3
 8001162:	4613      	mov	r3, r2
 8001164:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001168:	1a9b      	subs	r3, r3, r2
 800116a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800116e:	f5a3 6334 	sub.w	r3, r3, #2880	; 0xb40
 8001172:	18cb      	adds	r3, r1, r3
 8001174:	613b      	str	r3, [r7, #16]
    tempc2 = (tempc1 + ((watering_lenght[0] - ASCII_OFFSEET) * 600) + ((watering_lenght[1] - ASCII_OFFSEET) * 60));
 8001176:	4b39      	ldr	r3, [pc, #228]	; (800125c <TimeCompare2+0x1f4>)
 8001178:	781b      	ldrb	r3, [r3, #0]
 800117a:	f44f 7216 	mov.w	r2, #600	; 0x258
 800117e:	fb02 f303 	mul.w	r3, r2, r3
 8001182:	f5a3 42e1 	sub.w	r2, r3, #28800	; 0x7080
 8001186:	697b      	ldr	r3, [r7, #20]
 8001188:	18d1      	adds	r1, r2, r3
 800118a:	4b34      	ldr	r3, [pc, #208]	; (800125c <TimeCompare2+0x1f4>)
 800118c:	785b      	ldrb	r3, [r3, #1]
 800118e:	461a      	mov	r2, r3
 8001190:	4613      	mov	r3, r2
 8001192:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001196:	1a9b      	subs	r3, r3, r2
 8001198:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800119c:	f5a3 6334 	sub.w	r3, r3, #2880	; 0xb40
 80011a0:	18cb      	adds	r3, r1, r3
 80011a2:	60fb      	str	r3, [r7, #12]
    tempo2 = (tempo1 + ((watering_temp[(watering_other->designator - 1)][14] - ASCII_OFFSEET) * 600) + ((watering_temp[(watering_other->designator - 1)][15] - ASCII_OFFSEET) * 60));
 80011a4:	683b      	ldr	r3, [r7, #0]
 80011a6:	791b      	ldrb	r3, [r3, #4]
 80011a8:	f103 32ff 	add.w	r2, r3, #4294967295
 80011ac:	492a      	ldr	r1, [pc, #168]	; (8001258 <TimeCompare2+0x1f0>)
 80011ae:	4613      	mov	r3, r2
 80011b0:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80011b4:	189b      	adds	r3, r3, r2
 80011b6:	18cb      	adds	r3, r1, r3
 80011b8:	f103 030e 	add.w	r3, r3, #14
 80011bc:	781b      	ldrb	r3, [r3, #0]
 80011be:	f44f 7216 	mov.w	r2, #600	; 0x258
 80011c2:	fb02 f303 	mul.w	r3, r2, r3
 80011c6:	f5a3 42e1 	sub.w	r2, r3, #28800	; 0x7080
 80011ca:	693b      	ldr	r3, [r7, #16]
 80011cc:	18d1      	adds	r1, r2, r3
 80011ce:	683b      	ldr	r3, [r7, #0]
 80011d0:	791b      	ldrb	r3, [r3, #4]
 80011d2:	f103 32ff 	add.w	r2, r3, #4294967295
 80011d6:	4820      	ldr	r0, [pc, #128]	; (8001258 <TimeCompare2+0x1f0>)
 80011d8:	4613      	mov	r3, r2
 80011da:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80011de:	189b      	adds	r3, r3, r2
 80011e0:	18c3      	adds	r3, r0, r3
 80011e2:	f103 030f 	add.w	r3, r3, #15
 80011e6:	781b      	ldrb	r3, [r3, #0]
 80011e8:	461a      	mov	r2, r3
 80011ea:	4613      	mov	r3, r2
 80011ec:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80011f0:	1a9b      	subs	r3, r3, r2
 80011f2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80011f6:	f5a3 6334 	sub.w	r3, r3, #2880	; 0xb40
 80011fa:	18cb      	adds	r3, r1, r3
 80011fc:	60bb      	str	r3, [r7, #8]

    if((tempc1 <= tempo1 && tempo1 <= tempc2) || (tempc1 <= tempo2 && tempo2 <= tempc2) || (tempo1 <= tempc1 && tempc1 <= tempo2) || (tempo1 <= tempc2 && tempc2 <= tempo2))
 80011fe:	697a      	ldr	r2, [r7, #20]
 8001200:	693b      	ldr	r3, [r7, #16]
 8001202:	429a      	cmp	r2, r3
 8001204:	dc03      	bgt.n	800120e <TimeCompare2+0x1a6>
 8001206:	693a      	ldr	r2, [r7, #16]
 8001208:	68fb      	ldr	r3, [r7, #12]
 800120a:	429a      	cmp	r2, r3
 800120c:	dd17      	ble.n	800123e <TimeCompare2+0x1d6>
 800120e:	697a      	ldr	r2, [r7, #20]
 8001210:	68bb      	ldr	r3, [r7, #8]
 8001212:	429a      	cmp	r2, r3
 8001214:	dc03      	bgt.n	800121e <TimeCompare2+0x1b6>
 8001216:	68ba      	ldr	r2, [r7, #8]
 8001218:	68fb      	ldr	r3, [r7, #12]
 800121a:	429a      	cmp	r2, r3
 800121c:	dd0f      	ble.n	800123e <TimeCompare2+0x1d6>
 800121e:	693a      	ldr	r2, [r7, #16]
 8001220:	697b      	ldr	r3, [r7, #20]
 8001222:	429a      	cmp	r2, r3
 8001224:	dc03      	bgt.n	800122e <TimeCompare2+0x1c6>
 8001226:	697a      	ldr	r2, [r7, #20]
 8001228:	68bb      	ldr	r3, [r7, #8]
 800122a:	429a      	cmp	r2, r3
 800122c:	dd07      	ble.n	800123e <TimeCompare2+0x1d6>
 800122e:	693a      	ldr	r2, [r7, #16]
 8001230:	68fb      	ldr	r3, [r7, #12]
 8001232:	429a      	cmp	r2, r3
 8001234:	dc06      	bgt.n	8001244 <TimeCompare2+0x1dc>
 8001236:	68fa      	ldr	r2, [r7, #12]
 8001238:	68bb      	ldr	r3, [r7, #8]
 800123a:	429a      	cmp	r2, r3
 800123c:	dc02      	bgt.n	8001244 <TimeCompare2+0x1dc>
    	return 0;
 800123e:	f04f 0300 	mov.w	r3, #0
 8001242:	e001      	b.n	8001248 <TimeCompare2+0x1e0>
    else
    	return 1;
 8001244:	f04f 0301 	mov.w	r3, #1
}
 8001248:	4618      	mov	r0, r3
 800124a:	f107 071c 	add.w	r7, r7, #28
 800124e:	46bd      	mov	sp, r7
 8001250:	bc80      	pop	{r7}
 8001252:	4770      	bx	lr
 8001254:	200012fc 	.word	0x200012fc
 8001258:	20000dac 	.word	0x20000dac
 800125c:	20000e3c 	.word	0x20000e3c

08001260 <Watering_Next_Set>:
char datechanger_temp;

int alarm_temp;

void Watering_Next_Set()
{
 8001260:	b598      	push	{r3, r4, r7, lr}
 8001262:	af00      	add	r7, sp, #0
	watering_j = 0;
 8001264:	4b07      	ldr	r3, [pc, #28]	; (8001284 <Watering_Next_Set+0x24>)
 8001266:	f04f 0200 	mov.w	r2, #0
 800126a:	701a      	strb	r2, [r3, #0]
	watering_temporary2 = &watering[1];
 800126c:	4b06      	ldr	r3, [pc, #24]	; (8001288 <Watering_Next_Set+0x28>)
 800126e:	4a07      	ldr	r2, [pc, #28]	; (800128c <Watering_Next_Set+0x2c>)
 8001270:	601a      	str	r2, [r3, #0]
	alarm_temp = 0;
 8001272:	4b07      	ldr	r3, [pc, #28]	; (8001290 <Watering_Next_Set+0x30>)
 8001274:	f04f 0200 	mov.w	r2, #0
 8001278:	601a      	str	r2, [r3, #0]

    for(watering_i = 0; watering_i < 6; watering_i++)	//végigmegyek a hat öntözési lehetõség között. Megkeresem azt, amelyik idõpontja nagyobb a pillanatnyi idõnél, de a lehetõ legkevesebbel.
 800127a:	4b06      	ldr	r3, [pc, #24]	; (8001294 <Watering_Next_Set+0x34>)
 800127c:	f04f 0200 	mov.w	r2, #0
 8001280:	701a      	strb	r2, [r3, #0]
 8001282:	e1d3      	b.n	800162c <Watering_Next_Set+0x3cc>
 8001284:	20001334 	.word	0x20001334
 8001288:	200012f8 	.word	0x200012f8
 800128c:	2000115c 	.word	0x2000115c
 8001290:	20000e14 	.word	0x20000e14
 8001294:	20000fa8 	.word	0x20000fa8
    {
    	if((((watering_temp[(watering_temporary2->designator) - 1][6] - ASCII_OFFSEET) * 86400 + (watering_temp[(watering_temporary2->designator) - 1][8] - ASCII_OFFSEET) * 36000 + (watering_temp[(watering_temporary2->designator) - 1][9] - ASCII_OFFSEET) * 3600 + (watering_temp[(watering_temporary2->designator) - 1][11] - ASCII_OFFSEET) * 600 + (watering_temp[(watering_temporary2->designator) - 1][12] - ASCII_OFFSEET) * 60) > ((day_counter * 86400) + (((RTC->TR & TIME_HOUR_BCD_1) >> TIME_HOUR_BCD_1_OFFSET) * 36000) + (((RTC->TR & TIME_HOUR_BCD_2) >> TIME_HOUR_BCD_2_OFFSET) * 3600) + (((RTC->TR & TIME_MINUTE_BCD_1) >> TIME_MINUTE_BCD_1_OFFSET) * 600) + (((RTC->TR & TIME_MINUTE_BCD_2) >> TIME_MINUTE_BCD_2_OFFSET) * 60)) &&  ((watering_temp[(watering_temporary2->designator) - 1][8] != 'x'))))
 8001298:	4bc3      	ldr	r3, [pc, #780]	; (80015a8 <Watering_Next_Set+0x348>)
 800129a:	681b      	ldr	r3, [r3, #0]
 800129c:	791b      	ldrb	r3, [r3, #4]
 800129e:	f103 32ff 	add.w	r2, r3, #4294967295
 80012a2:	49c2      	ldr	r1, [pc, #776]	; (80015ac <Watering_Next_Set+0x34c>)
 80012a4:	4613      	mov	r3, r2
 80012a6:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80012aa:	189b      	adds	r3, r3, r2
 80012ac:	18cb      	adds	r3, r1, r3
 80012ae:	f103 0306 	add.w	r3, r3, #6
 80012b2:	781b      	ldrb	r3, [r3, #0]
 80012b4:	4abe      	ldr	r2, [pc, #760]	; (80015b0 <Watering_Next_Set+0x350>)
 80012b6:	fb02 f303 	mul.w	r3, r2, r3
 80012ba:	f5a3 127d 	sub.w	r2, r3, #4145152	; 0x3f4000
 80012be:	f5a2 6200 	sub.w	r2, r2, #2048	; 0x800
 80012c2:	4bb9      	ldr	r3, [pc, #740]	; (80015a8 <Watering_Next_Set+0x348>)
 80012c4:	681b      	ldr	r3, [r3, #0]
 80012c6:	791b      	ldrb	r3, [r3, #4]
 80012c8:	f103 31ff 	add.w	r1, r3, #4294967295
 80012cc:	48b7      	ldr	r0, [pc, #732]	; (80015ac <Watering_Next_Set+0x34c>)
 80012ce:	460b      	mov	r3, r1
 80012d0:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80012d4:	185b      	adds	r3, r3, r1
 80012d6:	18c3      	adds	r3, r0, r3
 80012d8:	f103 0308 	add.w	r3, r3, #8
 80012dc:	781b      	ldrb	r3, [r3, #0]
 80012de:	f648 41a0 	movw	r1, #36000	; 0x8ca0
 80012e2:	fb01 f303 	mul.w	r3, r1, r3
 80012e6:	f5a3 13d2 	sub.w	r3, r3, #1720320	; 0x1a4000
 80012ea:	f5a3 53f0 	sub.w	r3, r3, #7680	; 0x1e00
 80012ee:	18d1      	adds	r1, r2, r3
 80012f0:	4bad      	ldr	r3, [pc, #692]	; (80015a8 <Watering_Next_Set+0x348>)
 80012f2:	681b      	ldr	r3, [r3, #0]
 80012f4:	791b      	ldrb	r3, [r3, #4]
 80012f6:	f103 32ff 	add.w	r2, r3, #4294967295
 80012fa:	48ac      	ldr	r0, [pc, #688]	; (80015ac <Watering_Next_Set+0x34c>)
 80012fc:	4613      	mov	r3, r2
 80012fe:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001302:	189b      	adds	r3, r3, r2
 8001304:	18c3      	adds	r3, r0, r3
 8001306:	f103 0309 	add.w	r3, r3, #9
 800130a:	781b      	ldrb	r3, [r3, #0]
 800130c:	f44f 6261 	mov.w	r2, #3600	; 0xe10
 8001310:	fb02 f303 	mul.w	r3, r2, r3
 8001314:	f5a3 3328 	sub.w	r3, r3, #172032	; 0x2a000
 8001318:	f5a3 7340 	sub.w	r3, r3, #768	; 0x300
 800131c:	18c9      	adds	r1, r1, r3
 800131e:	4ba2      	ldr	r3, [pc, #648]	; (80015a8 <Watering_Next_Set+0x348>)
 8001320:	681b      	ldr	r3, [r3, #0]
 8001322:	791b      	ldrb	r3, [r3, #4]
 8001324:	f103 32ff 	add.w	r2, r3, #4294967295
 8001328:	48a0      	ldr	r0, [pc, #640]	; (80015ac <Watering_Next_Set+0x34c>)
 800132a:	4613      	mov	r3, r2
 800132c:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001330:	189b      	adds	r3, r3, r2
 8001332:	18c3      	adds	r3, r0, r3
 8001334:	f103 030b 	add.w	r3, r3, #11
 8001338:	781b      	ldrb	r3, [r3, #0]
 800133a:	f44f 7216 	mov.w	r2, #600	; 0x258
 800133e:	fb02 f303 	mul.w	r3, r2, r3
 8001342:	f5a3 43e1 	sub.w	r3, r3, #28800	; 0x7080
 8001346:	18c9      	adds	r1, r1, r3
 8001348:	4b97      	ldr	r3, [pc, #604]	; (80015a8 <Watering_Next_Set+0x348>)
 800134a:	681b      	ldr	r3, [r3, #0]
 800134c:	791b      	ldrb	r3, [r3, #4]
 800134e:	f103 32ff 	add.w	r2, r3, #4294967295
 8001352:	4896      	ldr	r0, [pc, #600]	; (80015ac <Watering_Next_Set+0x34c>)
 8001354:	4613      	mov	r3, r2
 8001356:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800135a:	189b      	adds	r3, r3, r2
 800135c:	18c3      	adds	r3, r0, r3
 800135e:	f103 030c 	add.w	r3, r3, #12
 8001362:	781b      	ldrb	r3, [r3, #0]
 8001364:	461a      	mov	r2, r3
 8001366:	4613      	mov	r3, r2
 8001368:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800136c:	1a9b      	subs	r3, r3, r2
 800136e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001372:	f5a3 6334 	sub.w	r3, r3, #2880	; 0xb40
 8001376:	18cb      	adds	r3, r1, r3
 8001378:	4619      	mov	r1, r3
 800137a:	4b8e      	ldr	r3, [pc, #568]	; (80015b4 <Watering_Next_Set+0x354>)
 800137c:	681b      	ldr	r3, [r3, #0]
 800137e:	4a8c      	ldr	r2, [pc, #560]	; (80015b0 <Watering_Next_Set+0x350>)
 8001380:	fb02 f303 	mul.w	r3, r2, r3
 8001384:	461a      	mov	r2, r3
 8001386:	4b8c      	ldr	r3, [pc, #560]	; (80015b8 <Watering_Next_Set+0x358>)
 8001388:	681b      	ldr	r3, [r3, #0]
 800138a:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 800138e:	ea4f 5313 	mov.w	r3, r3, lsr #20
 8001392:	f648 40a0 	movw	r0, #36000	; 0x8ca0
 8001396:	fb00 f303 	mul.w	r3, r0, r3
 800139a:	18d2      	adds	r2, r2, r3
 800139c:	4b86      	ldr	r3, [pc, #536]	; (80015b8 <Watering_Next_Set+0x358>)
 800139e:	681b      	ldr	r3, [r3, #0]
 80013a0:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
 80013a4:	ea4f 3313 	mov.w	r3, r3, lsr #12
 80013a8:	f44f 7016 	mov.w	r0, #600	; 0x258
 80013ac:	fb00 f003 	mul.w	r0, r0, r3
 80013b0:	4b81      	ldr	r3, [pc, #516]	; (80015b8 <Watering_Next_Set+0x358>)
 80013b2:	681b      	ldr	r3, [r3, #0]
 80013b4:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
 80013b8:	ea4f 4313 	mov.w	r3, r3, lsr #16
 80013bc:	f44f 6461 	mov.w	r4, #3600	; 0xe10
 80013c0:	fb04 f303 	mul.w	r3, r4, r3
 80013c4:	18c3      	adds	r3, r0, r3
 80013c6:	18d0      	adds	r0, r2, r3
 80013c8:	4b7b      	ldr	r3, [pc, #492]	; (80015b8 <Watering_Next_Set+0x358>)
 80013ca:	681b      	ldr	r3, [r3, #0]
 80013cc:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 80013d0:	ea4f 2213 	mov.w	r2, r3, lsr #8
 80013d4:	4613      	mov	r3, r2
 80013d6:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80013da:	1a9b      	subs	r3, r3, r2
 80013dc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80013e0:	18c3      	adds	r3, r0, r3
 80013e2:	4299      	cmp	r1, r3
 80013e4:	f240 8116 	bls.w	8001614 <Watering_Next_Set+0x3b4>
 80013e8:	4b6f      	ldr	r3, [pc, #444]	; (80015a8 <Watering_Next_Set+0x348>)
 80013ea:	681b      	ldr	r3, [r3, #0]
 80013ec:	791b      	ldrb	r3, [r3, #4]
 80013ee:	f103 32ff 	add.w	r2, r3, #4294967295
 80013f2:	496e      	ldr	r1, [pc, #440]	; (80015ac <Watering_Next_Set+0x34c>)
 80013f4:	4613      	mov	r3, r2
 80013f6:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80013fa:	189b      	adds	r3, r3, r2
 80013fc:	18cb      	adds	r3, r1, r3
 80013fe:	f103 0308 	add.w	r3, r3, #8
 8001402:	781b      	ldrb	r3, [r3, #0]
 8001404:	2b78      	cmp	r3, #120	; 0x78
 8001406:	f000 8105 	beq.w	8001614 <Watering_Next_Set+0x3b4>
    	{
    		watering_j = 1;
 800140a:	4b6c      	ldr	r3, [pc, #432]	; (80015bc <Watering_Next_Set+0x35c>)
 800140c:	f04f 0201 	mov.w	r2, #1
 8001410:	701a      	strb	r2, [r3, #0]

    		if(!alarm_temp || (alarm_temp > ((watering_temp[(watering_temporary2->designator) - 1][6] - ASCII_OFFSEET) * 86400 + (watering_temp[(watering_temporary2->designator) - 1][8] - ASCII_OFFSEET) * 36000 + (watering_temp[(watering_temporary2->designator) - 1][9] - ASCII_OFFSEET) * 3600 + (watering_temp[(watering_temporary2->designator) - 1][11] - ASCII_OFFSEET) * 600 + (watering_temp[(watering_temporary2->designator) - 1][12] - ASCII_OFFSEET) * 60)))
 8001412:	4b6b      	ldr	r3, [pc, #428]	; (80015c0 <Watering_Next_Set+0x360>)
 8001414:	681b      	ldr	r3, [r3, #0]
 8001416:	2b00      	cmp	r3, #0
 8001418:	d074      	beq.n	8001504 <Watering_Next_Set+0x2a4>
 800141a:	4b63      	ldr	r3, [pc, #396]	; (80015a8 <Watering_Next_Set+0x348>)
 800141c:	681b      	ldr	r3, [r3, #0]
 800141e:	791b      	ldrb	r3, [r3, #4]
 8001420:	f103 32ff 	add.w	r2, r3, #4294967295
 8001424:	4961      	ldr	r1, [pc, #388]	; (80015ac <Watering_Next_Set+0x34c>)
 8001426:	4613      	mov	r3, r2
 8001428:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800142c:	189b      	adds	r3, r3, r2
 800142e:	18cb      	adds	r3, r1, r3
 8001430:	f103 0306 	add.w	r3, r3, #6
 8001434:	781b      	ldrb	r3, [r3, #0]
 8001436:	4a5e      	ldr	r2, [pc, #376]	; (80015b0 <Watering_Next_Set+0x350>)
 8001438:	fb02 f303 	mul.w	r3, r2, r3
 800143c:	f5a3 127d 	sub.w	r2, r3, #4145152	; 0x3f4000
 8001440:	f5a2 6200 	sub.w	r2, r2, #2048	; 0x800
 8001444:	4b58      	ldr	r3, [pc, #352]	; (80015a8 <Watering_Next_Set+0x348>)
 8001446:	681b      	ldr	r3, [r3, #0]
 8001448:	791b      	ldrb	r3, [r3, #4]
 800144a:	f103 31ff 	add.w	r1, r3, #4294967295
 800144e:	4857      	ldr	r0, [pc, #348]	; (80015ac <Watering_Next_Set+0x34c>)
 8001450:	460b      	mov	r3, r1
 8001452:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001456:	185b      	adds	r3, r3, r1
 8001458:	18c3      	adds	r3, r0, r3
 800145a:	f103 0308 	add.w	r3, r3, #8
 800145e:	781b      	ldrb	r3, [r3, #0]
 8001460:	f648 41a0 	movw	r1, #36000	; 0x8ca0
 8001464:	fb01 f303 	mul.w	r3, r1, r3
 8001468:	f5a3 13d2 	sub.w	r3, r3, #1720320	; 0x1a4000
 800146c:	f5a3 53f0 	sub.w	r3, r3, #7680	; 0x1e00
 8001470:	18d1      	adds	r1, r2, r3
 8001472:	4b4d      	ldr	r3, [pc, #308]	; (80015a8 <Watering_Next_Set+0x348>)
 8001474:	681b      	ldr	r3, [r3, #0]
 8001476:	791b      	ldrb	r3, [r3, #4]
 8001478:	f103 32ff 	add.w	r2, r3, #4294967295
 800147c:	484b      	ldr	r0, [pc, #300]	; (80015ac <Watering_Next_Set+0x34c>)
 800147e:	4613      	mov	r3, r2
 8001480:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001484:	189b      	adds	r3, r3, r2
 8001486:	18c3      	adds	r3, r0, r3
 8001488:	f103 0309 	add.w	r3, r3, #9
 800148c:	781b      	ldrb	r3, [r3, #0]
 800148e:	f44f 6261 	mov.w	r2, #3600	; 0xe10
 8001492:	fb02 f303 	mul.w	r3, r2, r3
 8001496:	f5a3 3328 	sub.w	r3, r3, #172032	; 0x2a000
 800149a:	f5a3 7340 	sub.w	r3, r3, #768	; 0x300
 800149e:	18c9      	adds	r1, r1, r3
 80014a0:	4b41      	ldr	r3, [pc, #260]	; (80015a8 <Watering_Next_Set+0x348>)
 80014a2:	681b      	ldr	r3, [r3, #0]
 80014a4:	791b      	ldrb	r3, [r3, #4]
 80014a6:	f103 32ff 	add.w	r2, r3, #4294967295
 80014aa:	4840      	ldr	r0, [pc, #256]	; (80015ac <Watering_Next_Set+0x34c>)
 80014ac:	4613      	mov	r3, r2
 80014ae:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80014b2:	189b      	adds	r3, r3, r2
 80014b4:	18c3      	adds	r3, r0, r3
 80014b6:	f103 030b 	add.w	r3, r3, #11
 80014ba:	781b      	ldrb	r3, [r3, #0]
 80014bc:	f44f 7216 	mov.w	r2, #600	; 0x258
 80014c0:	fb02 f303 	mul.w	r3, r2, r3
 80014c4:	f5a3 43e1 	sub.w	r3, r3, #28800	; 0x7080
 80014c8:	18c9      	adds	r1, r1, r3
 80014ca:	4b37      	ldr	r3, [pc, #220]	; (80015a8 <Watering_Next_Set+0x348>)
 80014cc:	681b      	ldr	r3, [r3, #0]
 80014ce:	791b      	ldrb	r3, [r3, #4]
 80014d0:	f103 32ff 	add.w	r2, r3, #4294967295
 80014d4:	4835      	ldr	r0, [pc, #212]	; (80015ac <Watering_Next_Set+0x34c>)
 80014d6:	4613      	mov	r3, r2
 80014d8:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80014dc:	189b      	adds	r3, r3, r2
 80014de:	18c3      	adds	r3, r0, r3
 80014e0:	f103 030c 	add.w	r3, r3, #12
 80014e4:	781b      	ldrb	r3, [r3, #0]
 80014e6:	461a      	mov	r2, r3
 80014e8:	4613      	mov	r3, r2
 80014ea:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80014ee:	1a9b      	subs	r3, r3, r2
 80014f0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80014f4:	f5a3 6334 	sub.w	r3, r3, #2880	; 0xb40
 80014f8:	18ca      	adds	r2, r1, r3
 80014fa:	4b31      	ldr	r3, [pc, #196]	; (80015c0 <Watering_Next_Set+0x360>)
 80014fc:	681b      	ldr	r3, [r3, #0]
 80014fe:	429a      	cmp	r2, r3
 8001500:	f280 8088 	bge.w	8001614 <Watering_Next_Set+0x3b4>
    		{
    			alarm_temp = ((watering_temp[(watering_temporary2->designator) - 1][6] - ASCII_OFFSEET) * 86400 + (watering_temp[(watering_temporary2->designator) - 1][6] - ASCII_OFFSEET) * 86400 + (watering_temp[(watering_temporary2->designator) - 1][8] - ASCII_OFFSEET) * 36000 + (watering_temp[(watering_temporary2->designator) - 1][9] - ASCII_OFFSEET) * 3600 + (watering_temp[(watering_temporary2->designator) - 1][11] - ASCII_OFFSEET) * 600 + (watering_temp[(watering_temporary2->designator) - 1][12] - ASCII_OFFSEET) * 60);
 8001504:	4b28      	ldr	r3, [pc, #160]	; (80015a8 <Watering_Next_Set+0x348>)
 8001506:	681b      	ldr	r3, [r3, #0]
 8001508:	791b      	ldrb	r3, [r3, #4]
 800150a:	f103 32ff 	add.w	r2, r3, #4294967295
 800150e:	4927      	ldr	r1, [pc, #156]	; (80015ac <Watering_Next_Set+0x34c>)
 8001510:	4613      	mov	r3, r2
 8001512:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001516:	189b      	adds	r3, r3, r2
 8001518:	18cb      	adds	r3, r1, r3
 800151a:	f103 0306 	add.w	r3, r3, #6
 800151e:	781b      	ldrb	r3, [r3, #0]
 8001520:	4a28      	ldr	r2, [pc, #160]	; (80015c4 <Watering_Next_Set+0x364>)
 8001522:	fb02 f303 	mul.w	r3, r2, r3
 8001526:	f5a3 02fd 	sub.w	r2, r3, #8290304	; 0x7e8000
 800152a:	f5a2 5280 	sub.w	r2, r2, #4096	; 0x1000
 800152e:	4b1e      	ldr	r3, [pc, #120]	; (80015a8 <Watering_Next_Set+0x348>)
 8001530:	681b      	ldr	r3, [r3, #0]
 8001532:	791b      	ldrb	r3, [r3, #4]
 8001534:	f103 31ff 	add.w	r1, r3, #4294967295
 8001538:	481c      	ldr	r0, [pc, #112]	; (80015ac <Watering_Next_Set+0x34c>)
 800153a:	460b      	mov	r3, r1
 800153c:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001540:	185b      	adds	r3, r3, r1
 8001542:	18c3      	adds	r3, r0, r3
 8001544:	f103 0308 	add.w	r3, r3, #8
 8001548:	781b      	ldrb	r3, [r3, #0]
 800154a:	f648 41a0 	movw	r1, #36000	; 0x8ca0
 800154e:	fb01 f303 	mul.w	r3, r1, r3
 8001552:	f5a3 13d2 	sub.w	r3, r3, #1720320	; 0x1a4000
 8001556:	f5a3 53f0 	sub.w	r3, r3, #7680	; 0x1e00
 800155a:	18d1      	adds	r1, r2, r3
 800155c:	4b12      	ldr	r3, [pc, #72]	; (80015a8 <Watering_Next_Set+0x348>)
 800155e:	681b      	ldr	r3, [r3, #0]
 8001560:	791b      	ldrb	r3, [r3, #4]
 8001562:	f103 32ff 	add.w	r2, r3, #4294967295
 8001566:	4811      	ldr	r0, [pc, #68]	; (80015ac <Watering_Next_Set+0x34c>)
 8001568:	4613      	mov	r3, r2
 800156a:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800156e:	189b      	adds	r3, r3, r2
 8001570:	18c3      	adds	r3, r0, r3
 8001572:	f103 0309 	add.w	r3, r3, #9
 8001576:	781b      	ldrb	r3, [r3, #0]
 8001578:	f44f 6261 	mov.w	r2, #3600	; 0xe10
 800157c:	fb02 f303 	mul.w	r3, r2, r3
 8001580:	f5a3 3328 	sub.w	r3, r3, #172032	; 0x2a000
 8001584:	f5a3 7340 	sub.w	r3, r3, #768	; 0x300
 8001588:	18c9      	adds	r1, r1, r3
 800158a:	4b07      	ldr	r3, [pc, #28]	; (80015a8 <Watering_Next_Set+0x348>)
 800158c:	681b      	ldr	r3, [r3, #0]
 800158e:	791b      	ldrb	r3, [r3, #4]
 8001590:	f103 32ff 	add.w	r2, r3, #4294967295
 8001594:	4805      	ldr	r0, [pc, #20]	; (80015ac <Watering_Next_Set+0x34c>)
 8001596:	4613      	mov	r3, r2
 8001598:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800159c:	189b      	adds	r3, r3, r2
 800159e:	18c3      	adds	r3, r0, r3
 80015a0:	f103 030b 	add.w	r3, r3, #11
 80015a4:	e010      	b.n	80015c8 <Watering_Next_Set+0x368>
 80015a6:	bf00      	nop
 80015a8:	200012f8 	.word	0x200012f8
 80015ac:	20000dac 	.word	0x20000dac
 80015b0:	00015180 	.word	0x00015180
 80015b4:	20000e5c 	.word	0x20000e5c
 80015b8:	40002800 	.word	0x40002800
 80015bc:	20001334 	.word	0x20001334
 80015c0:	20000e14 	.word	0x20000e14
 80015c4:	0002a300 	.word	0x0002a300
 80015c8:	781b      	ldrb	r3, [r3, #0]
 80015ca:	f44f 7216 	mov.w	r2, #600	; 0x258
 80015ce:	fb02 f303 	mul.w	r3, r2, r3
 80015d2:	f5a3 43e1 	sub.w	r3, r3, #28800	; 0x7080
 80015d6:	18c9      	adds	r1, r1, r3
 80015d8:	4b1d      	ldr	r3, [pc, #116]	; (8001650 <Watering_Next_Set+0x3f0>)
 80015da:	681b      	ldr	r3, [r3, #0]
 80015dc:	791b      	ldrb	r3, [r3, #4]
 80015de:	f103 32ff 	add.w	r2, r3, #4294967295
 80015e2:	481c      	ldr	r0, [pc, #112]	; (8001654 <Watering_Next_Set+0x3f4>)
 80015e4:	4613      	mov	r3, r2
 80015e6:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80015ea:	189b      	adds	r3, r3, r2
 80015ec:	18c3      	adds	r3, r0, r3
 80015ee:	f103 030c 	add.w	r3, r3, #12
 80015f2:	781b      	ldrb	r3, [r3, #0]
 80015f4:	461a      	mov	r2, r3
 80015f6:	4613      	mov	r3, r2
 80015f8:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80015fc:	1a9b      	subs	r3, r3, r2
 80015fe:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001602:	f5a3 6334 	sub.w	r3, r3, #2880	; 0xb40
 8001606:	18ca      	adds	r2, r1, r3
 8001608:	4b13      	ldr	r3, [pc, #76]	; (8001658 <Watering_Next_Set+0x3f8>)
 800160a:	601a      	str	r2, [r3, #0]
    			watering_current = watering_temporary2;
 800160c:	4b10      	ldr	r3, [pc, #64]	; (8001650 <Watering_Next_Set+0x3f0>)
 800160e:	681a      	ldr	r2, [r3, #0]
 8001610:	4b12      	ldr	r3, [pc, #72]	; (800165c <Watering_Next_Set+0x3fc>)
 8001612:	601a      	str	r2, [r3, #0]
    		}
    	}
    	watering_temporary2 = watering_temporary2->next;
 8001614:	4b0e      	ldr	r3, [pc, #56]	; (8001650 <Watering_Next_Set+0x3f0>)
 8001616:	681b      	ldr	r3, [r3, #0]
 8001618:	68da      	ldr	r2, [r3, #12]
 800161a:	4b0d      	ldr	r3, [pc, #52]	; (8001650 <Watering_Next_Set+0x3f0>)
 800161c:	601a      	str	r2, [r3, #0]
{
	watering_j = 0;
	watering_temporary2 = &watering[1];
	alarm_temp = 0;

    for(watering_i = 0; watering_i < 6; watering_i++)	//végigmegyek a hat öntözési lehetõség között. Megkeresem azt, amelyik idõpontja nagyobb a pillanatnyi idõnél, de a lehetõ legkevesebbel.
 800161e:	4b10      	ldr	r3, [pc, #64]	; (8001660 <Watering_Next_Set+0x400>)
 8001620:	781b      	ldrb	r3, [r3, #0]
 8001622:	f103 0301 	add.w	r3, r3, #1
 8001626:	b2da      	uxtb	r2, r3
 8001628:	4b0d      	ldr	r3, [pc, #52]	; (8001660 <Watering_Next_Set+0x400>)
 800162a:	701a      	strb	r2, [r3, #0]
 800162c:	4b0c      	ldr	r3, [pc, #48]	; (8001660 <Watering_Next_Set+0x400>)
 800162e:	781b      	ldrb	r3, [r3, #0]
 8001630:	2b05      	cmp	r3, #5
 8001632:	f67f ae31 	bls.w	8001298 <Watering_Next_Set+0x38>
    		}
    	}
    	watering_temporary2 = watering_temporary2->next;
    }

	if(watering_j == 0)
 8001636:	4b0b      	ldr	r3, [pc, #44]	; (8001664 <Watering_Next_Set+0x404>)
 8001638:	781b      	ldrb	r3, [r3, #0]
 800163a:	2b00      	cmp	r3, #0
 800163c:	f040 81dc 	bne.w	80019f8 <Watering_Next_Set+0x798>
	{
		watering_temporary2 = &watering[1];
 8001640:	4b03      	ldr	r3, [pc, #12]	; (8001650 <Watering_Next_Set+0x3f0>)
 8001642:	4a09      	ldr	r2, [pc, #36]	; (8001668 <Watering_Next_Set+0x408>)
 8001644:	601a      	str	r2, [r3, #0]

		for(watering_i = 0; watering_i < 6; watering_i++)	//végigmegyek a hat öntözési lehetõség között. Megkeresem azt, amelyik idõpontja nagyobb a pillanatnyi idõnél, de a lehetõ legkevesebbel.
 8001646:	4b06      	ldr	r3, [pc, #24]	; (8001660 <Watering_Next_Set+0x400>)
 8001648:	f04f 0200 	mov.w	r2, #0
 800164c:	701a      	strb	r2, [r3, #0]
 800164e:	e1ce      	b.n	80019ee <Watering_Next_Set+0x78e>
 8001650:	200012f8 	.word	0x200012f8
 8001654:	20000dac 	.word	0x20000dac
 8001658:	20000e14 	.word	0x20000e14
 800165c:	20001314 	.word	0x20001314
 8001660:	20000fa8 	.word	0x20000fa8
 8001664:	20001334 	.word	0x20001334
 8001668:	2000115c 	.word	0x2000115c
		{
			if((((watering_temp[(watering_temporary2->designator) - 1][6] - ASCII_OFFSEET) * 86400 + (watering_temp[(watering_temporary2->designator) - 1][8] - ASCII_OFFSEET) * 36000 + (watering_temp[(watering_temporary2->designator) - 1][9] - ASCII_OFFSEET) * 3600 + (watering_temp[(watering_temporary2->designator) - 1][11] - ASCII_OFFSEET) * 600 + (watering_temp[(watering_temporary2->designator) - 1][12] - ASCII_OFFSEET) * 60) < ((day_counter * 86400) + (((RTC->TR & TIME_HOUR_BCD_1) >> TIME_HOUR_BCD_1_OFFSET) * 36000) + (((RTC->TR & TIME_HOUR_BCD_2) >> TIME_HOUR_BCD_2_OFFSET) * 3600) + (((RTC->TR & TIME_MINUTE_BCD_1) >> TIME_MINUTE_BCD_1_OFFSET) * 600) + (((RTC->TR & TIME_MINUTE_BCD_2) >> TIME_MINUTE_BCD_2_OFFSET) * 60)) &&  ((watering_temp[(watering_temporary2->designator) - 1][8] != 'x'))))
 800166c:	4bc4      	ldr	r3, [pc, #784]	; (8001980 <Watering_Next_Set+0x720>)
 800166e:	681b      	ldr	r3, [r3, #0]
 8001670:	791b      	ldrb	r3, [r3, #4]
 8001672:	f103 32ff 	add.w	r2, r3, #4294967295
 8001676:	49c3      	ldr	r1, [pc, #780]	; (8001984 <Watering_Next_Set+0x724>)
 8001678:	4613      	mov	r3, r2
 800167a:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800167e:	189b      	adds	r3, r3, r2
 8001680:	18cb      	adds	r3, r1, r3
 8001682:	f103 0306 	add.w	r3, r3, #6
 8001686:	781b      	ldrb	r3, [r3, #0]
 8001688:	4abf      	ldr	r2, [pc, #764]	; (8001988 <Watering_Next_Set+0x728>)
 800168a:	fb02 f303 	mul.w	r3, r2, r3
 800168e:	f5a3 127d 	sub.w	r2, r3, #4145152	; 0x3f4000
 8001692:	f5a2 6200 	sub.w	r2, r2, #2048	; 0x800
 8001696:	4bba      	ldr	r3, [pc, #744]	; (8001980 <Watering_Next_Set+0x720>)
 8001698:	681b      	ldr	r3, [r3, #0]
 800169a:	791b      	ldrb	r3, [r3, #4]
 800169c:	f103 31ff 	add.w	r1, r3, #4294967295
 80016a0:	48b8      	ldr	r0, [pc, #736]	; (8001984 <Watering_Next_Set+0x724>)
 80016a2:	460b      	mov	r3, r1
 80016a4:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80016a8:	185b      	adds	r3, r3, r1
 80016aa:	18c3      	adds	r3, r0, r3
 80016ac:	f103 0308 	add.w	r3, r3, #8
 80016b0:	781b      	ldrb	r3, [r3, #0]
 80016b2:	f648 41a0 	movw	r1, #36000	; 0x8ca0
 80016b6:	fb01 f303 	mul.w	r3, r1, r3
 80016ba:	f5a3 13d2 	sub.w	r3, r3, #1720320	; 0x1a4000
 80016be:	f5a3 53f0 	sub.w	r3, r3, #7680	; 0x1e00
 80016c2:	18d1      	adds	r1, r2, r3
 80016c4:	4bae      	ldr	r3, [pc, #696]	; (8001980 <Watering_Next_Set+0x720>)
 80016c6:	681b      	ldr	r3, [r3, #0]
 80016c8:	791b      	ldrb	r3, [r3, #4]
 80016ca:	f103 32ff 	add.w	r2, r3, #4294967295
 80016ce:	48ad      	ldr	r0, [pc, #692]	; (8001984 <Watering_Next_Set+0x724>)
 80016d0:	4613      	mov	r3, r2
 80016d2:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80016d6:	189b      	adds	r3, r3, r2
 80016d8:	18c3      	adds	r3, r0, r3
 80016da:	f103 0309 	add.w	r3, r3, #9
 80016de:	781b      	ldrb	r3, [r3, #0]
 80016e0:	f44f 6261 	mov.w	r2, #3600	; 0xe10
 80016e4:	fb02 f303 	mul.w	r3, r2, r3
 80016e8:	f5a3 3328 	sub.w	r3, r3, #172032	; 0x2a000
 80016ec:	f5a3 7340 	sub.w	r3, r3, #768	; 0x300
 80016f0:	18c9      	adds	r1, r1, r3
 80016f2:	4ba3      	ldr	r3, [pc, #652]	; (8001980 <Watering_Next_Set+0x720>)
 80016f4:	681b      	ldr	r3, [r3, #0]
 80016f6:	791b      	ldrb	r3, [r3, #4]
 80016f8:	f103 32ff 	add.w	r2, r3, #4294967295
 80016fc:	48a1      	ldr	r0, [pc, #644]	; (8001984 <Watering_Next_Set+0x724>)
 80016fe:	4613      	mov	r3, r2
 8001700:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001704:	189b      	adds	r3, r3, r2
 8001706:	18c3      	adds	r3, r0, r3
 8001708:	f103 030b 	add.w	r3, r3, #11
 800170c:	781b      	ldrb	r3, [r3, #0]
 800170e:	f44f 7216 	mov.w	r2, #600	; 0x258
 8001712:	fb02 f303 	mul.w	r3, r2, r3
 8001716:	f5a3 43e1 	sub.w	r3, r3, #28800	; 0x7080
 800171a:	18c9      	adds	r1, r1, r3
 800171c:	4b98      	ldr	r3, [pc, #608]	; (8001980 <Watering_Next_Set+0x720>)
 800171e:	681b      	ldr	r3, [r3, #0]
 8001720:	791b      	ldrb	r3, [r3, #4]
 8001722:	f103 32ff 	add.w	r2, r3, #4294967295
 8001726:	4897      	ldr	r0, [pc, #604]	; (8001984 <Watering_Next_Set+0x724>)
 8001728:	4613      	mov	r3, r2
 800172a:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800172e:	189b      	adds	r3, r3, r2
 8001730:	18c3      	adds	r3, r0, r3
 8001732:	f103 030c 	add.w	r3, r3, #12
 8001736:	781b      	ldrb	r3, [r3, #0]
 8001738:	461a      	mov	r2, r3
 800173a:	4613      	mov	r3, r2
 800173c:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001740:	1a9b      	subs	r3, r3, r2
 8001742:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001746:	f5a3 6334 	sub.w	r3, r3, #2880	; 0xb40
 800174a:	18cb      	adds	r3, r1, r3
 800174c:	4619      	mov	r1, r3
 800174e:	4b8f      	ldr	r3, [pc, #572]	; (800198c <Watering_Next_Set+0x72c>)
 8001750:	681b      	ldr	r3, [r3, #0]
 8001752:	4a8d      	ldr	r2, [pc, #564]	; (8001988 <Watering_Next_Set+0x728>)
 8001754:	fb02 f303 	mul.w	r3, r2, r3
 8001758:	461a      	mov	r2, r3
 800175a:	4b8d      	ldr	r3, [pc, #564]	; (8001990 <Watering_Next_Set+0x730>)
 800175c:	681b      	ldr	r3, [r3, #0]
 800175e:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 8001762:	ea4f 5313 	mov.w	r3, r3, lsr #20
 8001766:	f648 40a0 	movw	r0, #36000	; 0x8ca0
 800176a:	fb00 f303 	mul.w	r3, r0, r3
 800176e:	18d2      	adds	r2, r2, r3
 8001770:	4b87      	ldr	r3, [pc, #540]	; (8001990 <Watering_Next_Set+0x730>)
 8001772:	681b      	ldr	r3, [r3, #0]
 8001774:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
 8001778:	ea4f 3313 	mov.w	r3, r3, lsr #12
 800177c:	f44f 7016 	mov.w	r0, #600	; 0x258
 8001780:	fb00 f003 	mul.w	r0, r0, r3
 8001784:	4b82      	ldr	r3, [pc, #520]	; (8001990 <Watering_Next_Set+0x730>)
 8001786:	681b      	ldr	r3, [r3, #0]
 8001788:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
 800178c:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8001790:	f44f 6461 	mov.w	r4, #3600	; 0xe10
 8001794:	fb04 f303 	mul.w	r3, r4, r3
 8001798:	18c3      	adds	r3, r0, r3
 800179a:	18d0      	adds	r0, r2, r3
 800179c:	4b7c      	ldr	r3, [pc, #496]	; (8001990 <Watering_Next_Set+0x730>)
 800179e:	681b      	ldr	r3, [r3, #0]
 80017a0:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 80017a4:	ea4f 2213 	mov.w	r2, r3, lsr #8
 80017a8:	4613      	mov	r3, r2
 80017aa:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80017ae:	1a9b      	subs	r3, r3, r2
 80017b0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80017b4:	18c3      	adds	r3, r0, r3
 80017b6:	4299      	cmp	r1, r3
 80017b8:	f080 810d 	bcs.w	80019d6 <Watering_Next_Set+0x776>
 80017bc:	4b70      	ldr	r3, [pc, #448]	; (8001980 <Watering_Next_Set+0x720>)
 80017be:	681b      	ldr	r3, [r3, #0]
 80017c0:	791b      	ldrb	r3, [r3, #4]
 80017c2:	f103 32ff 	add.w	r2, r3, #4294967295
 80017c6:	496f      	ldr	r1, [pc, #444]	; (8001984 <Watering_Next_Set+0x724>)
 80017c8:	4613      	mov	r3, r2
 80017ca:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80017ce:	189b      	adds	r3, r3, r2
 80017d0:	18cb      	adds	r3, r1, r3
 80017d2:	f103 0308 	add.w	r3, r3, #8
 80017d6:	781b      	ldrb	r3, [r3, #0]
 80017d8:	2b78      	cmp	r3, #120	; 0x78
 80017da:	f000 80fc 	beq.w	80019d6 <Watering_Next_Set+0x776>
			{
				if(!alarm_temp || (alarm_temp > ((watering_temp[(watering_temporary2->designator) - 1][6] - ASCII_OFFSEET) * 86400 + (watering_temp[(watering_temporary2->designator) - 1][8] - ASCII_OFFSEET) * 36000 + (watering_temp[(watering_temporary2->designator) - 1][9] - ASCII_OFFSEET) * 3600 + (watering_temp[(watering_temporary2->designator) - 1][11] - ASCII_OFFSEET) * 600 + (watering_temp[(watering_temporary2->designator) - 1][12] - ASCII_OFFSEET) * 60)))
 80017de:	4b6d      	ldr	r3, [pc, #436]	; (8001994 <Watering_Next_Set+0x734>)
 80017e0:	681b      	ldr	r3, [r3, #0]
 80017e2:	2b00      	cmp	r3, #0
 80017e4:	d074      	beq.n	80018d0 <Watering_Next_Set+0x670>
 80017e6:	4b66      	ldr	r3, [pc, #408]	; (8001980 <Watering_Next_Set+0x720>)
 80017e8:	681b      	ldr	r3, [r3, #0]
 80017ea:	791b      	ldrb	r3, [r3, #4]
 80017ec:	f103 32ff 	add.w	r2, r3, #4294967295
 80017f0:	4964      	ldr	r1, [pc, #400]	; (8001984 <Watering_Next_Set+0x724>)
 80017f2:	4613      	mov	r3, r2
 80017f4:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80017f8:	189b      	adds	r3, r3, r2
 80017fa:	18cb      	adds	r3, r1, r3
 80017fc:	f103 0306 	add.w	r3, r3, #6
 8001800:	781b      	ldrb	r3, [r3, #0]
 8001802:	4a61      	ldr	r2, [pc, #388]	; (8001988 <Watering_Next_Set+0x728>)
 8001804:	fb02 f303 	mul.w	r3, r2, r3
 8001808:	f5a3 127d 	sub.w	r2, r3, #4145152	; 0x3f4000
 800180c:	f5a2 6200 	sub.w	r2, r2, #2048	; 0x800
 8001810:	4b5b      	ldr	r3, [pc, #364]	; (8001980 <Watering_Next_Set+0x720>)
 8001812:	681b      	ldr	r3, [r3, #0]
 8001814:	791b      	ldrb	r3, [r3, #4]
 8001816:	f103 31ff 	add.w	r1, r3, #4294967295
 800181a:	485a      	ldr	r0, [pc, #360]	; (8001984 <Watering_Next_Set+0x724>)
 800181c:	460b      	mov	r3, r1
 800181e:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001822:	185b      	adds	r3, r3, r1
 8001824:	18c3      	adds	r3, r0, r3
 8001826:	f103 0308 	add.w	r3, r3, #8
 800182a:	781b      	ldrb	r3, [r3, #0]
 800182c:	f648 41a0 	movw	r1, #36000	; 0x8ca0
 8001830:	fb01 f303 	mul.w	r3, r1, r3
 8001834:	f5a3 13d2 	sub.w	r3, r3, #1720320	; 0x1a4000
 8001838:	f5a3 53f0 	sub.w	r3, r3, #7680	; 0x1e00
 800183c:	18d1      	adds	r1, r2, r3
 800183e:	4b50      	ldr	r3, [pc, #320]	; (8001980 <Watering_Next_Set+0x720>)
 8001840:	681b      	ldr	r3, [r3, #0]
 8001842:	791b      	ldrb	r3, [r3, #4]
 8001844:	f103 32ff 	add.w	r2, r3, #4294967295
 8001848:	484e      	ldr	r0, [pc, #312]	; (8001984 <Watering_Next_Set+0x724>)
 800184a:	4613      	mov	r3, r2
 800184c:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001850:	189b      	adds	r3, r3, r2
 8001852:	18c3      	adds	r3, r0, r3
 8001854:	f103 0309 	add.w	r3, r3, #9
 8001858:	781b      	ldrb	r3, [r3, #0]
 800185a:	f44f 6261 	mov.w	r2, #3600	; 0xe10
 800185e:	fb02 f303 	mul.w	r3, r2, r3
 8001862:	f5a3 3328 	sub.w	r3, r3, #172032	; 0x2a000
 8001866:	f5a3 7340 	sub.w	r3, r3, #768	; 0x300
 800186a:	18c9      	adds	r1, r1, r3
 800186c:	4b44      	ldr	r3, [pc, #272]	; (8001980 <Watering_Next_Set+0x720>)
 800186e:	681b      	ldr	r3, [r3, #0]
 8001870:	791b      	ldrb	r3, [r3, #4]
 8001872:	f103 32ff 	add.w	r2, r3, #4294967295
 8001876:	4843      	ldr	r0, [pc, #268]	; (8001984 <Watering_Next_Set+0x724>)
 8001878:	4613      	mov	r3, r2
 800187a:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800187e:	189b      	adds	r3, r3, r2
 8001880:	18c3      	adds	r3, r0, r3
 8001882:	f103 030b 	add.w	r3, r3, #11
 8001886:	781b      	ldrb	r3, [r3, #0]
 8001888:	f44f 7216 	mov.w	r2, #600	; 0x258
 800188c:	fb02 f303 	mul.w	r3, r2, r3
 8001890:	f5a3 43e1 	sub.w	r3, r3, #28800	; 0x7080
 8001894:	18c9      	adds	r1, r1, r3
 8001896:	4b3a      	ldr	r3, [pc, #232]	; (8001980 <Watering_Next_Set+0x720>)
 8001898:	681b      	ldr	r3, [r3, #0]
 800189a:	791b      	ldrb	r3, [r3, #4]
 800189c:	f103 32ff 	add.w	r2, r3, #4294967295
 80018a0:	4838      	ldr	r0, [pc, #224]	; (8001984 <Watering_Next_Set+0x724>)
 80018a2:	4613      	mov	r3, r2
 80018a4:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80018a8:	189b      	adds	r3, r3, r2
 80018aa:	18c3      	adds	r3, r0, r3
 80018ac:	f103 030c 	add.w	r3, r3, #12
 80018b0:	781b      	ldrb	r3, [r3, #0]
 80018b2:	461a      	mov	r2, r3
 80018b4:	4613      	mov	r3, r2
 80018b6:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80018ba:	1a9b      	subs	r3, r3, r2
 80018bc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80018c0:	f5a3 6334 	sub.w	r3, r3, #2880	; 0xb40
 80018c4:	18ca      	adds	r2, r1, r3
 80018c6:	4b33      	ldr	r3, [pc, #204]	; (8001994 <Watering_Next_Set+0x734>)
 80018c8:	681b      	ldr	r3, [r3, #0]
 80018ca:	429a      	cmp	r2, r3
 80018cc:	f280 8083 	bge.w	80019d6 <Watering_Next_Set+0x776>
				{
					alarm_temp = ((watering_temp[(watering_temporary2->designator) - 1][6] - ASCII_OFFSEET) * 86400 + (watering_temp[(watering_temporary2->designator) - 1][8] - ASCII_OFFSEET) * 36000 + (watering_temp[(watering_temporary2->designator) - 1][9] - ASCII_OFFSEET) * 3600 + (watering_temp[(watering_temporary2->designator) - 1][11] - ASCII_OFFSEET) * 600 + (watering_temp[(watering_temporary2->designator) - 1][12] - ASCII_OFFSEET) * 60);
 80018d0:	4b2b      	ldr	r3, [pc, #172]	; (8001980 <Watering_Next_Set+0x720>)
 80018d2:	681b      	ldr	r3, [r3, #0]
 80018d4:	791b      	ldrb	r3, [r3, #4]
 80018d6:	f103 32ff 	add.w	r2, r3, #4294967295
 80018da:	492a      	ldr	r1, [pc, #168]	; (8001984 <Watering_Next_Set+0x724>)
 80018dc:	4613      	mov	r3, r2
 80018de:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80018e2:	189b      	adds	r3, r3, r2
 80018e4:	18cb      	adds	r3, r1, r3
 80018e6:	f103 0306 	add.w	r3, r3, #6
 80018ea:	781b      	ldrb	r3, [r3, #0]
 80018ec:	4a26      	ldr	r2, [pc, #152]	; (8001988 <Watering_Next_Set+0x728>)
 80018ee:	fb02 f303 	mul.w	r3, r2, r3
 80018f2:	f5a3 127d 	sub.w	r2, r3, #4145152	; 0x3f4000
 80018f6:	f5a2 6200 	sub.w	r2, r2, #2048	; 0x800
 80018fa:	4b21      	ldr	r3, [pc, #132]	; (8001980 <Watering_Next_Set+0x720>)
 80018fc:	681b      	ldr	r3, [r3, #0]
 80018fe:	791b      	ldrb	r3, [r3, #4]
 8001900:	f103 31ff 	add.w	r1, r3, #4294967295
 8001904:	481f      	ldr	r0, [pc, #124]	; (8001984 <Watering_Next_Set+0x724>)
 8001906:	460b      	mov	r3, r1
 8001908:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800190c:	185b      	adds	r3, r3, r1
 800190e:	18c3      	adds	r3, r0, r3
 8001910:	f103 0308 	add.w	r3, r3, #8
 8001914:	781b      	ldrb	r3, [r3, #0]
 8001916:	f648 41a0 	movw	r1, #36000	; 0x8ca0
 800191a:	fb01 f303 	mul.w	r3, r1, r3
 800191e:	f5a3 13d2 	sub.w	r3, r3, #1720320	; 0x1a4000
 8001922:	f5a3 53f0 	sub.w	r3, r3, #7680	; 0x1e00
 8001926:	18d1      	adds	r1, r2, r3
 8001928:	4b15      	ldr	r3, [pc, #84]	; (8001980 <Watering_Next_Set+0x720>)
 800192a:	681b      	ldr	r3, [r3, #0]
 800192c:	791b      	ldrb	r3, [r3, #4]
 800192e:	f103 32ff 	add.w	r2, r3, #4294967295
 8001932:	4814      	ldr	r0, [pc, #80]	; (8001984 <Watering_Next_Set+0x724>)
 8001934:	4613      	mov	r3, r2
 8001936:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800193a:	189b      	adds	r3, r3, r2
 800193c:	18c3      	adds	r3, r0, r3
 800193e:	f103 0309 	add.w	r3, r3, #9
 8001942:	781b      	ldrb	r3, [r3, #0]
 8001944:	f44f 6261 	mov.w	r2, #3600	; 0xe10
 8001948:	fb02 f303 	mul.w	r3, r2, r3
 800194c:	f5a3 3328 	sub.w	r3, r3, #172032	; 0x2a000
 8001950:	f5a3 7340 	sub.w	r3, r3, #768	; 0x300
 8001954:	18c9      	adds	r1, r1, r3
 8001956:	4b0a      	ldr	r3, [pc, #40]	; (8001980 <Watering_Next_Set+0x720>)
 8001958:	681b      	ldr	r3, [r3, #0]
 800195a:	791b      	ldrb	r3, [r3, #4]
 800195c:	f103 32ff 	add.w	r2, r3, #4294967295
 8001960:	4808      	ldr	r0, [pc, #32]	; (8001984 <Watering_Next_Set+0x724>)
 8001962:	4613      	mov	r3, r2
 8001964:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001968:	189b      	adds	r3, r3, r2
 800196a:	18c3      	adds	r3, r0, r3
 800196c:	f103 030b 	add.w	r3, r3, #11
 8001970:	781b      	ldrb	r3, [r3, #0]
 8001972:	f44f 7216 	mov.w	r2, #600	; 0x258
 8001976:	fb02 f303 	mul.w	r3, r2, r3
 800197a:	f5a3 43e1 	sub.w	r3, r3, #28800	; 0x7080
 800197e:	e00b      	b.n	8001998 <Watering_Next_Set+0x738>
 8001980:	200012f8 	.word	0x200012f8
 8001984:	20000dac 	.word	0x20000dac
 8001988:	00015180 	.word	0x00015180
 800198c:	20000e5c 	.word	0x20000e5c
 8001990:	40002800 	.word	0x40002800
 8001994:	20000e14 	.word	0x20000e14
 8001998:	18c9      	adds	r1, r1, r3
 800199a:	4bb5      	ldr	r3, [pc, #724]	; (8001c70 <Watering_Next_Set+0xa10>)
 800199c:	681b      	ldr	r3, [r3, #0]
 800199e:	791b      	ldrb	r3, [r3, #4]
 80019a0:	f103 32ff 	add.w	r2, r3, #4294967295
 80019a4:	48b3      	ldr	r0, [pc, #716]	; (8001c74 <Watering_Next_Set+0xa14>)
 80019a6:	4613      	mov	r3, r2
 80019a8:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80019ac:	189b      	adds	r3, r3, r2
 80019ae:	18c3      	adds	r3, r0, r3
 80019b0:	f103 030c 	add.w	r3, r3, #12
 80019b4:	781b      	ldrb	r3, [r3, #0]
 80019b6:	461a      	mov	r2, r3
 80019b8:	4613      	mov	r3, r2
 80019ba:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80019be:	1a9b      	subs	r3, r3, r2
 80019c0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80019c4:	f5a3 6334 	sub.w	r3, r3, #2880	; 0xb40
 80019c8:	18ca      	adds	r2, r1, r3
 80019ca:	4bab      	ldr	r3, [pc, #684]	; (8001c78 <Watering_Next_Set+0xa18>)
 80019cc:	601a      	str	r2, [r3, #0]
					watering_current = watering_temporary2;
 80019ce:	4ba8      	ldr	r3, [pc, #672]	; (8001c70 <Watering_Next_Set+0xa10>)
 80019d0:	681a      	ldr	r2, [r3, #0]
 80019d2:	4baa      	ldr	r3, [pc, #680]	; (8001c7c <Watering_Next_Set+0xa1c>)
 80019d4:	601a      	str	r2, [r3, #0]
				}
			}
			watering_temporary2 = watering_temporary2->next;
 80019d6:	4ba6      	ldr	r3, [pc, #664]	; (8001c70 <Watering_Next_Set+0xa10>)
 80019d8:	681b      	ldr	r3, [r3, #0]
 80019da:	68da      	ldr	r2, [r3, #12]
 80019dc:	4ba4      	ldr	r3, [pc, #656]	; (8001c70 <Watering_Next_Set+0xa10>)
 80019de:	601a      	str	r2, [r3, #0]

	if(watering_j == 0)
	{
		watering_temporary2 = &watering[1];

		for(watering_i = 0; watering_i < 6; watering_i++)	//végigmegyek a hat öntözési lehetõség között. Megkeresem azt, amelyik idõpontja nagyobb a pillanatnyi idõnél, de a lehetõ legkevesebbel.
 80019e0:	4ba7      	ldr	r3, [pc, #668]	; (8001c80 <Watering_Next_Set+0xa20>)
 80019e2:	781b      	ldrb	r3, [r3, #0]
 80019e4:	f103 0301 	add.w	r3, r3, #1
 80019e8:	b2da      	uxtb	r2, r3
 80019ea:	4ba5      	ldr	r3, [pc, #660]	; (8001c80 <Watering_Next_Set+0xa20>)
 80019ec:	701a      	strb	r2, [r3, #0]
 80019ee:	4ba4      	ldr	r3, [pc, #656]	; (8001c80 <Watering_Next_Set+0xa20>)
 80019f0:	781b      	ldrb	r3, [r3, #0]
 80019f2:	2b05      	cmp	r3, #5
 80019f4:	f67f ae3a 	bls.w	800166c <Watering_Next_Set+0x40c>
			}
			watering_temporary2 = watering_temporary2->next;
		}
	}

    RTC_AlarmCmd(RTC_Alarm_A, DISABLE);
 80019f8:	f44f 7080 	mov.w	r0, #256	; 0x100
 80019fc:	f04f 0100 	mov.w	r1, #0
 8001a00:	f007 fb98 	bl	8009134 <RTC_AlarmCmd>
    RTC_AlarmCmd(RTC_Alarm_B, DISABLE);
 8001a04:	f44f 7000 	mov.w	r0, #512	; 0x200
 8001a08:	f04f 0100 	mov.w	r1, #0
 8001a0c:	f007 fb92 	bl	8009134 <RTC_AlarmCmd>

    RTC_AlarmStructure.RTC_AlarmTime.RTC_H12     = RTC_H12_AM;
 8001a10:	4b9c      	ldr	r3, [pc, #624]	; (8001c84 <Watering_Next_Set+0xa24>)
 8001a12:	f04f 0200 	mov.w	r2, #0
 8001a16:	70da      	strb	r2, [r3, #3]
    RTC_AlarmStructure.RTC_AlarmTime.RTC_Hours   = ((watering_temp[(watering_current->designator) - 1][8] - ASCII_OFFSEET) << 4 | (watering_temp[(watering_current->designator) - 1][9] - ASCII_OFFSEET));
 8001a18:	4b98      	ldr	r3, [pc, #608]	; (8001c7c <Watering_Next_Set+0xa1c>)
 8001a1a:	681b      	ldr	r3, [r3, #0]
 8001a1c:	791b      	ldrb	r3, [r3, #4]
 8001a1e:	f103 32ff 	add.w	r2, r3, #4294967295
 8001a22:	4994      	ldr	r1, [pc, #592]	; (8001c74 <Watering_Next_Set+0xa14>)
 8001a24:	4613      	mov	r3, r2
 8001a26:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001a2a:	189b      	adds	r3, r3, r2
 8001a2c:	18cb      	adds	r3, r1, r3
 8001a2e:	f103 0308 	add.w	r3, r3, #8
 8001a32:	781b      	ldrb	r3, [r3, #0]
 8001a34:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 8001a38:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001a3c:	b2d9      	uxtb	r1, r3
 8001a3e:	4b8f      	ldr	r3, [pc, #572]	; (8001c7c <Watering_Next_Set+0xa1c>)
 8001a40:	681b      	ldr	r3, [r3, #0]
 8001a42:	791b      	ldrb	r3, [r3, #4]
 8001a44:	f103 32ff 	add.w	r2, r3, #4294967295
 8001a48:	488a      	ldr	r0, [pc, #552]	; (8001c74 <Watering_Next_Set+0xa14>)
 8001a4a:	4613      	mov	r3, r2
 8001a4c:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001a50:	189b      	adds	r3, r3, r2
 8001a52:	18c3      	adds	r3, r0, r3
 8001a54:	f103 0309 	add.w	r3, r3, #9
 8001a58:	781b      	ldrb	r3, [r3, #0]
 8001a5a:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 8001a5e:	b2db      	uxtb	r3, r3
 8001a60:	b2db      	uxtb	r3, r3
 8001a62:	460a      	mov	r2, r1
 8001a64:	4313      	orrs	r3, r2
 8001a66:	b2db      	uxtb	r3, r3
 8001a68:	b2da      	uxtb	r2, r3
 8001a6a:	4b86      	ldr	r3, [pc, #536]	; (8001c84 <Watering_Next_Set+0xa24>)
 8001a6c:	701a      	strb	r2, [r3, #0]
    RTC_AlarmStructure.RTC_AlarmTime.RTC_Minutes = ((watering_temp[(watering_current->designator) - 1][11] - ASCII_OFFSEET) << 4 | (watering_temp[(watering_current->designator) - 1][12] - ASCII_OFFSEET));
 8001a6e:	4b83      	ldr	r3, [pc, #524]	; (8001c7c <Watering_Next_Set+0xa1c>)
 8001a70:	681b      	ldr	r3, [r3, #0]
 8001a72:	791b      	ldrb	r3, [r3, #4]
 8001a74:	f103 32ff 	add.w	r2, r3, #4294967295
 8001a78:	497e      	ldr	r1, [pc, #504]	; (8001c74 <Watering_Next_Set+0xa14>)
 8001a7a:	4613      	mov	r3, r2
 8001a7c:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001a80:	189b      	adds	r3, r3, r2
 8001a82:	18cb      	adds	r3, r1, r3
 8001a84:	f103 030b 	add.w	r3, r3, #11
 8001a88:	781b      	ldrb	r3, [r3, #0]
 8001a8a:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 8001a8e:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001a92:	b2d9      	uxtb	r1, r3
 8001a94:	4b79      	ldr	r3, [pc, #484]	; (8001c7c <Watering_Next_Set+0xa1c>)
 8001a96:	681b      	ldr	r3, [r3, #0]
 8001a98:	791b      	ldrb	r3, [r3, #4]
 8001a9a:	f103 32ff 	add.w	r2, r3, #4294967295
 8001a9e:	4875      	ldr	r0, [pc, #468]	; (8001c74 <Watering_Next_Set+0xa14>)
 8001aa0:	4613      	mov	r3, r2
 8001aa2:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001aa6:	189b      	adds	r3, r3, r2
 8001aa8:	18c3      	adds	r3, r0, r3
 8001aaa:	f103 030c 	add.w	r3, r3, #12
 8001aae:	781b      	ldrb	r3, [r3, #0]
 8001ab0:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 8001ab4:	b2db      	uxtb	r3, r3
 8001ab6:	b2db      	uxtb	r3, r3
 8001ab8:	460a      	mov	r2, r1
 8001aba:	4313      	orrs	r3, r2
 8001abc:	b2db      	uxtb	r3, r3
 8001abe:	b2da      	uxtb	r2, r3
 8001ac0:	4b70      	ldr	r3, [pc, #448]	; (8001c84 <Watering_Next_Set+0xa24>)
 8001ac2:	705a      	strb	r2, [r3, #1]
    RTC_AlarmStructure.RTC_AlarmTime.RTC_Seconds = (0 << 4 | 0);
 8001ac4:	4b6f      	ldr	r3, [pc, #444]	; (8001c84 <Watering_Next_Set+0xa24>)
 8001ac6:	f04f 0200 	mov.w	r2, #0
 8001aca:	709a      	strb	r2, [r3, #2]
    RTC_AlarmStructure.RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
 8001acc:	4b6d      	ldr	r3, [pc, #436]	; (8001c84 <Watering_Next_Set+0xa24>)
 8001ace:	f04f 0200 	mov.w	r2, #0
 8001ad2:	609a      	str	r2, [r3, #8]
    RTC_AlarmStructure.RTC_AlarmMask = RTC_AlarmMask_DateWeekDay;
 8001ad4:	4b6b      	ldr	r3, [pc, #428]	; (8001c84 <Watering_Next_Set+0xa24>)
 8001ad6:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8001ada:	605a      	str	r2, [r3, #4]

    RTC_SetAlarm(RTC_Format_BCD, RTC_Alarm_A, &RTC_AlarmStructure);
 8001adc:	f04f 0001 	mov.w	r0, #1
 8001ae0:	f44f 7180 	mov.w	r1, #256	; 0x100
 8001ae4:	4a67      	ldr	r2, [pc, #412]	; (8001c84 <Watering_Next_Set+0xa24>)
 8001ae6:	f007 f9e3 	bl	8008eb0 <RTC_SetAlarm>

    alarm_temp = RTC->ALRMAR;
 8001aea:	4b67      	ldr	r3, [pc, #412]	; (8001c88 <Watering_Next_Set+0xa28>)
 8001aec:	69db      	ldr	r3, [r3, #28]
 8001aee:	461a      	mov	r2, r3
 8001af0:	4b61      	ldr	r3, [pc, #388]	; (8001c78 <Watering_Next_Set+0xa18>)
 8001af2:	601a      	str	r2, [r3, #0]

    RTC_ITConfig(RTC_IT_ALRA, ENABLE);
 8001af4:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8001af8:	f04f 0101 	mov.w	r1, #1
 8001afc:	f008 f826 	bl	8009b4c <RTC_ITConfig>

    RTC_AlarmCmd(RTC_Alarm_A, ENABLE);
 8001b00:	f44f 7080 	mov.w	r0, #256	; 0x100
 8001b04:	f04f 0101 	mov.w	r1, #1
 8001b08:	f007 fb14 	bl	8009134 <RTC_AlarmCmd>

    RTC_ClearFlag(RTC_FLAG_ALRAF);
 8001b0c:	f44f 7080 	mov.w	r0, #256	; 0x100
 8001b10:	f008 f884 	bl	8009c1c <RTC_ClearFlag>

    alarm_temp = ((watering_temp[(watering_current->designator) - 1][8] - ASCII_OFFSEET) * 36000 + (watering_temp[(watering_current->designator - 1)][9] - ASCII_OFFSEET) * 3600 + (watering_temp[(watering_current->designator) - 1][11] - ASCII_OFFSEET) * 600 + (watering_temp[(watering_current->designator) - 1][12] - ASCII_OFFSEET) * 60);
 8001b14:	4b59      	ldr	r3, [pc, #356]	; (8001c7c <Watering_Next_Set+0xa1c>)
 8001b16:	681b      	ldr	r3, [r3, #0]
 8001b18:	791b      	ldrb	r3, [r3, #4]
 8001b1a:	f103 32ff 	add.w	r2, r3, #4294967295
 8001b1e:	4955      	ldr	r1, [pc, #340]	; (8001c74 <Watering_Next_Set+0xa14>)
 8001b20:	4613      	mov	r3, r2
 8001b22:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001b26:	189b      	adds	r3, r3, r2
 8001b28:	18cb      	adds	r3, r1, r3
 8001b2a:	f103 0308 	add.w	r3, r3, #8
 8001b2e:	781b      	ldrb	r3, [r3, #0]
 8001b30:	f648 42a0 	movw	r2, #36000	; 0x8ca0
 8001b34:	fb02 f303 	mul.w	r3, r2, r3
 8001b38:	f5a3 12d2 	sub.w	r2, r3, #1720320	; 0x1a4000
 8001b3c:	f5a2 52f0 	sub.w	r2, r2, #7680	; 0x1e00
 8001b40:	4b4e      	ldr	r3, [pc, #312]	; (8001c7c <Watering_Next_Set+0xa1c>)
 8001b42:	681b      	ldr	r3, [r3, #0]
 8001b44:	791b      	ldrb	r3, [r3, #4]
 8001b46:	f103 31ff 	add.w	r1, r3, #4294967295
 8001b4a:	484a      	ldr	r0, [pc, #296]	; (8001c74 <Watering_Next_Set+0xa14>)
 8001b4c:	460b      	mov	r3, r1
 8001b4e:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001b52:	185b      	adds	r3, r3, r1
 8001b54:	18c3      	adds	r3, r0, r3
 8001b56:	f103 0309 	add.w	r3, r3, #9
 8001b5a:	781b      	ldrb	r3, [r3, #0]
 8001b5c:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 8001b60:	fb01 f303 	mul.w	r3, r1, r3
 8001b64:	f5a3 3328 	sub.w	r3, r3, #172032	; 0x2a000
 8001b68:	f5a3 7340 	sub.w	r3, r3, #768	; 0x300
 8001b6c:	18d1      	adds	r1, r2, r3
 8001b6e:	4b43      	ldr	r3, [pc, #268]	; (8001c7c <Watering_Next_Set+0xa1c>)
 8001b70:	681b      	ldr	r3, [r3, #0]
 8001b72:	791b      	ldrb	r3, [r3, #4]
 8001b74:	f103 32ff 	add.w	r2, r3, #4294967295
 8001b78:	483e      	ldr	r0, [pc, #248]	; (8001c74 <Watering_Next_Set+0xa14>)
 8001b7a:	4613      	mov	r3, r2
 8001b7c:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001b80:	189b      	adds	r3, r3, r2
 8001b82:	18c3      	adds	r3, r0, r3
 8001b84:	f103 030b 	add.w	r3, r3, #11
 8001b88:	781b      	ldrb	r3, [r3, #0]
 8001b8a:	f44f 7216 	mov.w	r2, #600	; 0x258
 8001b8e:	fb02 f303 	mul.w	r3, r2, r3
 8001b92:	f5a3 43e1 	sub.w	r3, r3, #28800	; 0x7080
 8001b96:	18c9      	adds	r1, r1, r3
 8001b98:	4b38      	ldr	r3, [pc, #224]	; (8001c7c <Watering_Next_Set+0xa1c>)
 8001b9a:	681b      	ldr	r3, [r3, #0]
 8001b9c:	791b      	ldrb	r3, [r3, #4]
 8001b9e:	f103 32ff 	add.w	r2, r3, #4294967295
 8001ba2:	4834      	ldr	r0, [pc, #208]	; (8001c74 <Watering_Next_Set+0xa14>)
 8001ba4:	4613      	mov	r3, r2
 8001ba6:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001baa:	189b      	adds	r3, r3, r2
 8001bac:	18c3      	adds	r3, r0, r3
 8001bae:	f103 030c 	add.w	r3, r3, #12
 8001bb2:	781b      	ldrb	r3, [r3, #0]
 8001bb4:	461a      	mov	r2, r3
 8001bb6:	4613      	mov	r3, r2
 8001bb8:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001bbc:	1a9b      	subs	r3, r3, r2
 8001bbe:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001bc2:	f5a3 6334 	sub.w	r3, r3, #2880	; 0xb40
 8001bc6:	18ca      	adds	r2, r1, r3
 8001bc8:	4b2b      	ldr	r3, [pc, #172]	; (8001c78 <Watering_Next_Set+0xa18>)
 8001bca:	601a      	str	r2, [r3, #0]
    alarm_temp += (((watering_temp[(watering_current->designator) - 1][14] - ASCII_OFFSEET) * 600) + ((watering_temp[(watering_current->designator - 1)][15] - ASCII_OFFSEET) * 60));
 8001bcc:	4b2b      	ldr	r3, [pc, #172]	; (8001c7c <Watering_Next_Set+0xa1c>)
 8001bce:	681b      	ldr	r3, [r3, #0]
 8001bd0:	791b      	ldrb	r3, [r3, #4]
 8001bd2:	f103 32ff 	add.w	r2, r3, #4294967295
 8001bd6:	4927      	ldr	r1, [pc, #156]	; (8001c74 <Watering_Next_Set+0xa14>)
 8001bd8:	4613      	mov	r3, r2
 8001bda:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001bde:	189b      	adds	r3, r3, r2
 8001be0:	18cb      	adds	r3, r1, r3
 8001be2:	f103 030e 	add.w	r3, r3, #14
 8001be6:	781b      	ldrb	r3, [r3, #0]
 8001be8:	f44f 7216 	mov.w	r2, #600	; 0x258
 8001bec:	fb02 f303 	mul.w	r3, r2, r3
 8001bf0:	f5a3 41e1 	sub.w	r1, r3, #28800	; 0x7080
 8001bf4:	4b21      	ldr	r3, [pc, #132]	; (8001c7c <Watering_Next_Set+0xa1c>)
 8001bf6:	681b      	ldr	r3, [r3, #0]
 8001bf8:	791b      	ldrb	r3, [r3, #4]
 8001bfa:	f103 32ff 	add.w	r2, r3, #4294967295
 8001bfe:	481d      	ldr	r0, [pc, #116]	; (8001c74 <Watering_Next_Set+0xa14>)
 8001c00:	4613      	mov	r3, r2
 8001c02:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001c06:	189b      	adds	r3, r3, r2
 8001c08:	18c3      	adds	r3, r0, r3
 8001c0a:	f103 030f 	add.w	r3, r3, #15
 8001c0e:	781b      	ldrb	r3, [r3, #0]
 8001c10:	461a      	mov	r2, r3
 8001c12:	4613      	mov	r3, r2
 8001c14:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001c18:	1a9b      	subs	r3, r3, r2
 8001c1a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001c1e:	f5a3 6334 	sub.w	r3, r3, #2880	; 0xb40
 8001c22:	18ca      	adds	r2, r1, r3
 8001c24:	4b14      	ldr	r3, [pc, #80]	; (8001c78 <Watering_Next_Set+0xa18>)
 8001c26:	681b      	ldr	r3, [r3, #0]
 8001c28:	18d2      	adds	r2, r2, r3
 8001c2a:	4b13      	ldr	r3, [pc, #76]	; (8001c78 <Watering_Next_Set+0xa18>)
 8001c2c:	601a      	str	r2, [r3, #0]

    RTC_AlarmStructure.RTC_AlarmTime.RTC_H12     = RTC_H12_AM;
 8001c2e:	4b15      	ldr	r3, [pc, #84]	; (8001c84 <Watering_Next_Set+0xa24>)
 8001c30:	f04f 0200 	mov.w	r2, #0
 8001c34:	70da      	strb	r2, [r3, #3]
    RTC_AlarmStructure.RTC_AlarmTime.RTC_Hours   = (((alarm_temp / 36000) << 4) | ((alarm_temp / 3600) - ((alarm_temp / 36000) * 10)));
 8001c36:	4b10      	ldr	r3, [pc, #64]	; (8001c78 <Watering_Next_Set+0xa18>)
 8001c38:	681b      	ldr	r3, [r3, #0]
 8001c3a:	4a14      	ldr	r2, [pc, #80]	; (8001c8c <Watering_Next_Set+0xa2c>)
 8001c3c:	fb82 0203 	smull	r0, r2, r2, r3
 8001c40:	ea4f 32a2 	mov.w	r2, r2, asr #14
 8001c44:	ea4f 73e3 	mov.w	r3, r3, asr #31
 8001c48:	1ad3      	subs	r3, r2, r3
 8001c4a:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001c4e:	b2da      	uxtb	r2, r3
 8001c50:	4b09      	ldr	r3, [pc, #36]	; (8001c78 <Watering_Next_Set+0xa18>)
 8001c52:	681b      	ldr	r3, [r3, #0]
 8001c54:	490e      	ldr	r1, [pc, #56]	; (8001c90 <Watering_Next_Set+0xa30>)
 8001c56:	fb81 c103 	smull	ip, r1, r1, r3
 8001c5a:	18c9      	adds	r1, r1, r3
 8001c5c:	ea4f 21e1 	mov.w	r1, r1, asr #11
 8001c60:	ea4f 73e3 	mov.w	r3, r3, asr #31
 8001c64:	1acb      	subs	r3, r1, r3
 8001c66:	b2d9      	uxtb	r1, r3
 8001c68:	4b03      	ldr	r3, [pc, #12]	; (8001c78 <Watering_Next_Set+0xa18>)
 8001c6a:	681b      	ldr	r3, [r3, #0]
 8001c6c:	e012      	b.n	8001c94 <Watering_Next_Set+0xa34>
 8001c6e:	bf00      	nop
 8001c70:	200012f8 	.word	0x200012f8
 8001c74:	20000dac 	.word	0x20000dac
 8001c78:	20000e14 	.word	0x20000e14
 8001c7c:	20001314 	.word	0x20001314
 8001c80:	20000fa8 	.word	0x20000fa8
 8001c84:	20000f44 	.word	0x20000f44
 8001c88:	40002800 	.word	0x40002800
 8001c8c:	7482296b 	.word	0x7482296b
 8001c90:	91a2b3c5 	.word	0x91a2b3c5
 8001c94:	4861      	ldr	r0, [pc, #388]	; (8001e1c <Watering_Next_Set+0xbbc>)
 8001c96:	fb80 c003 	smull	ip, r0, r0, r3
 8001c9a:	ea4f 30a0 	mov.w	r0, r0, asr #14
 8001c9e:	ea4f 73e3 	mov.w	r3, r3, asr #31
 8001ca2:	1ac3      	subs	r3, r0, r3
 8001ca4:	b2db      	uxtb	r3, r3
 8001ca6:	4618      	mov	r0, r3
 8001ca8:	ea4f 1040 	mov.w	r0, r0, lsl #5
 8001cac:	1ac0      	subs	r0, r0, r3
 8001cae:	ea4f 0080 	mov.w	r0, r0, lsl #2
 8001cb2:	1ac3      	subs	r3, r0, r3
 8001cb4:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8001cb8:	b2db      	uxtb	r3, r3
 8001cba:	18cb      	adds	r3, r1, r3
 8001cbc:	b2db      	uxtb	r3, r3
 8001cbe:	b2db      	uxtb	r3, r3
 8001cc0:	4313      	orrs	r3, r2
 8001cc2:	b2db      	uxtb	r3, r3
 8001cc4:	b2da      	uxtb	r2, r3
 8001cc6:	4b56      	ldr	r3, [pc, #344]	; (8001e20 <Watering_Next_Set+0xbc0>)
 8001cc8:	701a      	strb	r2, [r3, #0]

    alarm_temp -= ((((RTC_AlarmStructure.RTC_AlarmTime.RTC_Hours & 0xF0) >> 4) * 36000) + ((RTC_AlarmStructure.RTC_AlarmTime.RTC_Hours & 0xF) * 3600));
 8001cca:	4b55      	ldr	r3, [pc, #340]	; (8001e20 <Watering_Next_Set+0xbc0>)
 8001ccc:	781b      	ldrb	r3, [r3, #0]
 8001cce:	f003 030f 	and.w	r3, r3, #15
 8001cd2:	4a54      	ldr	r2, [pc, #336]	; (8001e24 <Watering_Next_Set+0xbc4>)
 8001cd4:	fb02 f203 	mul.w	r2, r2, r3
 8001cd8:	4b51      	ldr	r3, [pc, #324]	; (8001e20 <Watering_Next_Set+0xbc0>)
 8001cda:	781b      	ldrb	r3, [r3, #0]
 8001cdc:	ea4f 1313 	mov.w	r3, r3, lsr #4
 8001ce0:	b2db      	uxtb	r3, r3
 8001ce2:	4951      	ldr	r1, [pc, #324]	; (8001e28 <Watering_Next_Set+0xbc8>)
 8001ce4:	fb01 f303 	mul.w	r3, r1, r3
 8001ce8:	18d2      	adds	r2, r2, r3
 8001cea:	4b50      	ldr	r3, [pc, #320]	; (8001e2c <Watering_Next_Set+0xbcc>)
 8001cec:	681b      	ldr	r3, [r3, #0]
 8001cee:	18d2      	adds	r2, r2, r3
 8001cf0:	4b4e      	ldr	r3, [pc, #312]	; (8001e2c <Watering_Next_Set+0xbcc>)
 8001cf2:	601a      	str	r2, [r3, #0]

    RTC_AlarmStructure.RTC_AlarmTime.RTC_Minutes = (((alarm_temp / 600) << 4) | ((alarm_temp / 60) - ((alarm_temp / 600) * 10)));
 8001cf4:	4b4d      	ldr	r3, [pc, #308]	; (8001e2c <Watering_Next_Set+0xbcc>)
 8001cf6:	681b      	ldr	r3, [r3, #0]
 8001cf8:	4a4d      	ldr	r2, [pc, #308]	; (8001e30 <Watering_Next_Set+0xbd0>)
 8001cfa:	fb82 0203 	smull	r0, r2, r2, r3
 8001cfe:	ea4f 12a2 	mov.w	r2, r2, asr #6
 8001d02:	ea4f 73e3 	mov.w	r3, r3, asr #31
 8001d06:	1ad3      	subs	r3, r2, r3
 8001d08:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001d0c:	b2da      	uxtb	r2, r3
 8001d0e:	4b47      	ldr	r3, [pc, #284]	; (8001e2c <Watering_Next_Set+0xbcc>)
 8001d10:	681b      	ldr	r3, [r3, #0]
 8001d12:	4948      	ldr	r1, [pc, #288]	; (8001e34 <Watering_Next_Set+0xbd4>)
 8001d14:	fb81 c103 	smull	ip, r1, r1, r3
 8001d18:	18c9      	adds	r1, r1, r3
 8001d1a:	ea4f 1161 	mov.w	r1, r1, asr #5
 8001d1e:	ea4f 73e3 	mov.w	r3, r3, asr #31
 8001d22:	1acb      	subs	r3, r1, r3
 8001d24:	b2d9      	uxtb	r1, r3
 8001d26:	4b41      	ldr	r3, [pc, #260]	; (8001e2c <Watering_Next_Set+0xbcc>)
 8001d28:	681b      	ldr	r3, [r3, #0]
 8001d2a:	4841      	ldr	r0, [pc, #260]	; (8001e30 <Watering_Next_Set+0xbd0>)
 8001d2c:	fb80 c003 	smull	ip, r0, r0, r3
 8001d30:	ea4f 10a0 	mov.w	r0, r0, asr #6
 8001d34:	ea4f 73e3 	mov.w	r3, r3, asr #31
 8001d38:	1ac3      	subs	r3, r0, r3
 8001d3a:	b2db      	uxtb	r3, r3
 8001d3c:	4618      	mov	r0, r3
 8001d3e:	ea4f 1040 	mov.w	r0, r0, lsl #5
 8001d42:	1ac0      	subs	r0, r0, r3
 8001d44:	ea4f 0080 	mov.w	r0, r0, lsl #2
 8001d48:	1ac3      	subs	r3, r0, r3
 8001d4a:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8001d4e:	b2db      	uxtb	r3, r3
 8001d50:	18cb      	adds	r3, r1, r3
 8001d52:	b2db      	uxtb	r3, r3
 8001d54:	b2db      	uxtb	r3, r3
 8001d56:	4313      	orrs	r3, r2
 8001d58:	b2db      	uxtb	r3, r3
 8001d5a:	b2da      	uxtb	r2, r3
 8001d5c:	4b30      	ldr	r3, [pc, #192]	; (8001e20 <Watering_Next_Set+0xbc0>)
 8001d5e:	705a      	strb	r2, [r3, #1]

    alarm_temp -= ((((RTC_AlarmStructure.RTC_AlarmTime.RTC_Minutes & 0xF0) >> 4) * 600) + ((RTC_AlarmStructure.RTC_AlarmTime.RTC_Minutes & 0xF) * 60));
 8001d60:	4b2f      	ldr	r3, [pc, #188]	; (8001e20 <Watering_Next_Set+0xbc0>)
 8001d62:	785b      	ldrb	r3, [r3, #1]
 8001d64:	f003 020f 	and.w	r2, r3, #15
 8001d68:	4613      	mov	r3, r2
 8001d6a:	ea4f 1202 	mov.w	r2, r2, lsl #4
 8001d6e:	1a9b      	subs	r3, r3, r2
 8001d70:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001d74:	461a      	mov	r2, r3
 8001d76:	4b2a      	ldr	r3, [pc, #168]	; (8001e20 <Watering_Next_Set+0xbc0>)
 8001d78:	785b      	ldrb	r3, [r3, #1]
 8001d7a:	ea4f 1313 	mov.w	r3, r3, lsr #4
 8001d7e:	b2db      	uxtb	r3, r3
 8001d80:	492d      	ldr	r1, [pc, #180]	; (8001e38 <Watering_Next_Set+0xbd8>)
 8001d82:	fb01 f303 	mul.w	r3, r1, r3
 8001d86:	18d2      	adds	r2, r2, r3
 8001d88:	4b28      	ldr	r3, [pc, #160]	; (8001e2c <Watering_Next_Set+0xbcc>)
 8001d8a:	681b      	ldr	r3, [r3, #0]
 8001d8c:	18d2      	adds	r2, r2, r3
 8001d8e:	4b27      	ldr	r3, [pc, #156]	; (8001e2c <Watering_Next_Set+0xbcc>)
 8001d90:	601a      	str	r2, [r3, #0]

    RTC_AlarmStructure.RTC_AlarmTime.RTC_Seconds = ((alarm_temp / 10) << 4 | (alarm_temp - ((alarm_temp / 10) * 10)));
 8001d92:	4b26      	ldr	r3, [pc, #152]	; (8001e2c <Watering_Next_Set+0xbcc>)
 8001d94:	681b      	ldr	r3, [r3, #0]
 8001d96:	4a29      	ldr	r2, [pc, #164]	; (8001e3c <Watering_Next_Set+0xbdc>)
 8001d98:	fb82 0203 	smull	r0, r2, r2, r3
 8001d9c:	ea4f 02a2 	mov.w	r2, r2, asr #2
 8001da0:	ea4f 73e3 	mov.w	r3, r3, asr #31
 8001da4:	1ad3      	subs	r3, r2, r3
 8001da6:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001daa:	b2d8      	uxtb	r0, r3
 8001dac:	4b1f      	ldr	r3, [pc, #124]	; (8001e2c <Watering_Next_Set+0xbcc>)
 8001dae:	6819      	ldr	r1, [r3, #0]
 8001db0:	4b22      	ldr	r3, [pc, #136]	; (8001e3c <Watering_Next_Set+0xbdc>)
 8001db2:	fb83 2301 	smull	r2, r3, r3, r1
 8001db6:	ea4f 02a3 	mov.w	r2, r3, asr #2
 8001dba:	ea4f 73e1 	mov.w	r3, r1, asr #31
 8001dbe:	1ad2      	subs	r2, r2, r3
 8001dc0:	4613      	mov	r3, r2
 8001dc2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001dc6:	189b      	adds	r3, r3, r2
 8001dc8:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8001dcc:	1aca      	subs	r2, r1, r3
 8001dce:	b2d3      	uxtb	r3, r2
 8001dd0:	4602      	mov	r2, r0
 8001dd2:	4313      	orrs	r3, r2
 8001dd4:	b2db      	uxtb	r3, r3
 8001dd6:	b2da      	uxtb	r2, r3
 8001dd8:	4b11      	ldr	r3, [pc, #68]	; (8001e20 <Watering_Next_Set+0xbc0>)
 8001dda:	709a      	strb	r2, [r3, #2]
    RTC_AlarmStructure.RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
 8001ddc:	4b10      	ldr	r3, [pc, #64]	; (8001e20 <Watering_Next_Set+0xbc0>)
 8001dde:	f04f 0200 	mov.w	r2, #0
 8001de2:	609a      	str	r2, [r3, #8]
    RTC_AlarmStructure.RTC_AlarmMask = RTC_AlarmMask_DateWeekDay;
 8001de4:	4b0e      	ldr	r3, [pc, #56]	; (8001e20 <Watering_Next_Set+0xbc0>)
 8001de6:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8001dea:	605a      	str	r2, [r3, #4]

    RTC_SetAlarm(RTC_Format_BCD, RTC_Alarm_B, &RTC_AlarmStructure);
 8001dec:	f04f 0001 	mov.w	r0, #1
 8001df0:	f44f 7100 	mov.w	r1, #512	; 0x200
 8001df4:	4a0a      	ldr	r2, [pc, #40]	; (8001e20 <Watering_Next_Set+0xbc0>)
 8001df6:	f007 f85b 	bl	8008eb0 <RTC_SetAlarm>

    RTC_ITConfig(RTC_IT_ALRB, ENABLE);
 8001dfa:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8001dfe:	f04f 0101 	mov.w	r1, #1
 8001e02:	f007 fea3 	bl	8009b4c <RTC_ITConfig>

    RTC_AlarmCmd(RTC_Alarm_B, ENABLE);
 8001e06:	f44f 7000 	mov.w	r0, #512	; 0x200
 8001e0a:	f04f 0101 	mov.w	r1, #1
 8001e0e:	f007 f991 	bl	8009134 <RTC_AlarmCmd>

    RTC_ClearFlag(RTC_FLAG_ALRBF);
 8001e12:	f44f 7000 	mov.w	r0, #512	; 0x200
 8001e16:	f007 ff01 	bl	8009c1c <RTC_ClearFlag>
}
 8001e1a:	bd98      	pop	{r3, r4, r7, pc}
 8001e1c:	7482296b 	.word	0x7482296b
 8001e20:	20000f44 	.word	0x20000f44
 8001e24:	fffff1f0 	.word	0xfffff1f0
 8001e28:	ffff7360 	.word	0xffff7360
 8001e2c:	20000e14 	.word	0x20000e14
 8001e30:	1b4e81b5 	.word	0x1b4e81b5
 8001e34:	88888889 	.word	0x88888889
 8001e38:	fffffda8 	.word	0xfffffda8
 8001e3c:	66666667 	.word	0x66666667

08001e40 <DateChanger>:


int DateChanger(char param)
{
 8001e40:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001e42:	b08f      	sub	sp, #60	; 0x3c
 8001e44:	af0a      	add	r7, sp, #40	; 0x28
 8001e46:	4603      	mov	r3, r0
 8001e48:	71fb      	strb	r3, [r7, #7]
    if(param == menu_date.designator)
 8001e4a:	4b91      	ldr	r3, [pc, #580]	; (8002090 <DateChanger+0x250>)
 8001e4c:	791b      	ldrb	r3, [r3, #4]
 8001e4e:	79fa      	ldrb	r2, [r7, #7]
 8001e50:	429a      	cmp	r2, r3
 8001e52:	d17b      	bne.n	8001f4c <DateChanger+0x10c>
    {
        datechanger_i = 0;
 8001e54:	4b8f      	ldr	r3, [pc, #572]	; (8002094 <DateChanger+0x254>)
 8001e56:	f04f 0200 	mov.w	r2, #0
 8001e5a:	701a      	strb	r2, [r3, #0]
        menu_special_function = MENU_SPECIAL_FUNCTION_TIME_DATE;
 8001e5c:	4b8e      	ldr	r3, [pc, #568]	; (8002098 <DateChanger+0x258>)
 8001e5e:	f04f 0201 	mov.w	r2, #1
 8001e62:	701a      	strb	r2, [r3, #0]
        datechanger_function = menu_date.designator;
 8001e64:	4b8a      	ldr	r3, [pc, #552]	; (8002090 <DateChanger+0x250>)
 8001e66:	791a      	ldrb	r2, [r3, #4]
 8001e68:	4b8c      	ldr	r3, [pc, #560]	; (800209c <DateChanger+0x25c>)
 8001e6a:	701a      	strb	r2, [r3, #0]

        ClearLcmScreen();
 8001e6c:	f7fe fc62 	bl	8000734 <ClearLcmScreen>

        datechanger_date[0]=(((RTC->DR & DATE_JEAR_BCD_1) >> DATE_JEAR_BCD_1_OFFSET) + ASCII_OFFSEET);
 8001e70:	4b8b      	ldr	r3, [pc, #556]	; (80020a0 <DateChanger+0x260>)
 8001e72:	685b      	ldr	r3, [r3, #4]
 8001e74:	f403 0370 	and.w	r3, r3, #15728640	; 0xf00000
 8001e78:	ea4f 5313 	mov.w	r3, r3, lsr #20
 8001e7c:	b2db      	uxtb	r3, r3
 8001e7e:	f103 0330 	add.w	r3, r3, #48	; 0x30
 8001e82:	b2da      	uxtb	r2, r3
 8001e84:	4b87      	ldr	r3, [pc, #540]	; (80020a4 <DateChanger+0x264>)
 8001e86:	701a      	strb	r2, [r3, #0]
        datechanger_date[1]=(((RTC->DR & DATE_JEAR_BCD_2) >> DATE_JEAR_BCD_2_OFFSET) + ASCII_OFFSEET);
 8001e88:	4b85      	ldr	r3, [pc, #532]	; (80020a0 <DateChanger+0x260>)
 8001e8a:	685b      	ldr	r3, [r3, #4]
 8001e8c:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
 8001e90:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8001e94:	b2db      	uxtb	r3, r3
 8001e96:	f103 0330 	add.w	r3, r3, #48	; 0x30
 8001e9a:	b2da      	uxtb	r2, r3
 8001e9c:	4b81      	ldr	r3, [pc, #516]	; (80020a4 <DateChanger+0x264>)
 8001e9e:	705a      	strb	r2, [r3, #1]
        datechanger_date[2]=':';
 8001ea0:	4b80      	ldr	r3, [pc, #512]	; (80020a4 <DateChanger+0x264>)
 8001ea2:	f04f 023a 	mov.w	r2, #58	; 0x3a
 8001ea6:	709a      	strb	r2, [r3, #2]
        datechanger_date[3]=(((RTC->DR & DATE_MONTH_BCD_1) >> DATE_MONTH_BCD_1_OFFSET) + ASCII_OFFSEET);
 8001ea8:	4b7d      	ldr	r3, [pc, #500]	; (80020a0 <DateChanger+0x260>)
 8001eaa:	685b      	ldr	r3, [r3, #4]
 8001eac:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8001eb0:	ea4f 3313 	mov.w	r3, r3, lsr #12
 8001eb4:	b2db      	uxtb	r3, r3
 8001eb6:	f103 0330 	add.w	r3, r3, #48	; 0x30
 8001eba:	b2da      	uxtb	r2, r3
 8001ebc:	4b79      	ldr	r3, [pc, #484]	; (80020a4 <DateChanger+0x264>)
 8001ebe:	70da      	strb	r2, [r3, #3]
        datechanger_date[4]=(((RTC->DR & DATE_MONTH_BCD_2) >> DATE_MONTH_BCD_2_OFFSET) + ASCII_OFFSEET);
 8001ec0:	4b77      	ldr	r3, [pc, #476]	; (80020a0 <DateChanger+0x260>)
 8001ec2:	685b      	ldr	r3, [r3, #4]
 8001ec4:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 8001ec8:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8001ecc:	b2db      	uxtb	r3, r3
 8001ece:	f103 0330 	add.w	r3, r3, #48	; 0x30
 8001ed2:	b2da      	uxtb	r2, r3
 8001ed4:	4b73      	ldr	r3, [pc, #460]	; (80020a4 <DateChanger+0x264>)
 8001ed6:	711a      	strb	r2, [r3, #4]
        datechanger_date[5]=':';
 8001ed8:	4b72      	ldr	r3, [pc, #456]	; (80020a4 <DateChanger+0x264>)
 8001eda:	f04f 023a 	mov.w	r2, #58	; 0x3a
 8001ede:	715a      	strb	r2, [r3, #5]
        datechanger_date[6]=(((RTC->DR & DATE_DATE_BCD_1) >> DATE_DATE_BCD_1_OFFSET) + ASCII_OFFSEET);
 8001ee0:	4b6f      	ldr	r3, [pc, #444]	; (80020a0 <DateChanger+0x260>)
 8001ee2:	685b      	ldr	r3, [r3, #4]
 8001ee4:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8001ee8:	ea4f 1313 	mov.w	r3, r3, lsr #4
 8001eec:	b2db      	uxtb	r3, r3
 8001eee:	f103 0330 	add.w	r3, r3, #48	; 0x30
 8001ef2:	b2da      	uxtb	r2, r3
 8001ef4:	4b6b      	ldr	r3, [pc, #428]	; (80020a4 <DateChanger+0x264>)
 8001ef6:	719a      	strb	r2, [r3, #6]
        datechanger_date[7]=(((RTC->DR & DATE_DATE_BCD_2) >> DATE_DATE_BCD_2_OFFSET) + ASCII_OFFSEET);
 8001ef8:	4b69      	ldr	r3, [pc, #420]	; (80020a0 <DateChanger+0x260>)
 8001efa:	685b      	ldr	r3, [r3, #4]
 8001efc:	b2db      	uxtb	r3, r3
 8001efe:	f003 0307 	and.w	r3, r3, #7
 8001f02:	b2db      	uxtb	r3, r3
 8001f04:	f103 0330 	add.w	r3, r3, #48	; 0x30
 8001f08:	b2da      	uxtb	r2, r3
 8001f0a:	4b66      	ldr	r3, [pc, #408]	; (80020a4 <DateChanger+0x264>)
 8001f0c:	71da      	strb	r2, [r3, #7]
        datechanger_date[8]='\0';
 8001f0e:	4b65      	ldr	r3, [pc, #404]	; (80020a4 <DateChanger+0x264>)
 8001f10:	f04f 0200 	mov.w	r2, #0
 8001f14:	721a      	strb	r2, [r3, #8]

        Cursor(0, 0);
 8001f16:	f04f 0000 	mov.w	r0, #0
 8001f1a:	f04f 0100 	mov.w	r1, #0
 8001f1e:	f7fe fbd1 	bl	80006c4 <Cursor>
        PrintStr(menu_date.nev);
 8001f22:	4b5b      	ldr	r3, [pc, #364]	; (8002090 <DateChanger+0x250>)
 8001f24:	681b      	ldr	r3, [r3, #0]
 8001f26:	4618      	mov	r0, r3
 8001f28:	f7fe fdda 	bl	8000ae0 <PrintStr>

        Cursor(2, 0);
 8001f2c:	f04f 0002 	mov.w	r0, #2
 8001f30:	f04f 0100 	mov.w	r1, #0
 8001f34:	f7fe fbc6 	bl	80006c4 <Cursor>
        PrintStr(datechanger_date);
 8001f38:	485a      	ldr	r0, [pc, #360]	; (80020a4 <DateChanger+0x264>)
 8001f3a:	f7fe fdd1 	bl	8000ae0 <PrintStr>
        Cursor(2, 0);
 8001f3e:	f04f 0002 	mov.w	r0, #2
 8001f42:	f04f 0100 	mov.w	r1, #0
 8001f46:	f7fe fbbd 	bl	80006c4 <Cursor>
 8001f4a:	e36c      	b.n	8002626 <DateChanger+0x7e6>
    }
    else if(param == menu_current_time.designator)
 8001f4c:	4b56      	ldr	r3, [pc, #344]	; (80020a8 <DateChanger+0x268>)
 8001f4e:	791b      	ldrb	r3, [r3, #4]
 8001f50:	79fa      	ldrb	r2, [r7, #7]
 8001f52:	429a      	cmp	r2, r3
 8001f54:	d17b      	bne.n	800204e <DateChanger+0x20e>
    {
        datechanger_i = 0;
 8001f56:	4b4f      	ldr	r3, [pc, #316]	; (8002094 <DateChanger+0x254>)
 8001f58:	f04f 0200 	mov.w	r2, #0
 8001f5c:	701a      	strb	r2, [r3, #0]
        menu_special_function = MENU_SPECIAL_FUNCTION_TIME_DATE;
 8001f5e:	4b4e      	ldr	r3, [pc, #312]	; (8002098 <DateChanger+0x258>)
 8001f60:	f04f 0201 	mov.w	r2, #1
 8001f64:	701a      	strb	r2, [r3, #0]
        datechanger_function = menu_current_time.designator;
 8001f66:	4b50      	ldr	r3, [pc, #320]	; (80020a8 <DateChanger+0x268>)
 8001f68:	791a      	ldrb	r2, [r3, #4]
 8001f6a:	4b4c      	ldr	r3, [pc, #304]	; (800209c <DateChanger+0x25c>)
 8001f6c:	701a      	strb	r2, [r3, #0]

        ClearLcmScreen();
 8001f6e:	f7fe fbe1 	bl	8000734 <ClearLcmScreen>

        datechanger_date[0]=(((RTC->TR & TIME_HOUR_BCD_1) >> TIME_HOUR_BCD_1_OFFSET) + ASCII_OFFSEET);
 8001f72:	4b4b      	ldr	r3, [pc, #300]	; (80020a0 <DateChanger+0x260>)
 8001f74:	681b      	ldr	r3, [r3, #0]
 8001f76:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 8001f7a:	ea4f 5313 	mov.w	r3, r3, lsr #20
 8001f7e:	b2db      	uxtb	r3, r3
 8001f80:	f103 0330 	add.w	r3, r3, #48	; 0x30
 8001f84:	b2da      	uxtb	r2, r3
 8001f86:	4b47      	ldr	r3, [pc, #284]	; (80020a4 <DateChanger+0x264>)
 8001f88:	701a      	strb	r2, [r3, #0]
        datechanger_date[1]=(((RTC->TR & TIME_HOUR_BCD_2) >> TIME_HOUR_BCD_2_OFFSET) + ASCII_OFFSEET);
 8001f8a:	4b45      	ldr	r3, [pc, #276]	; (80020a0 <DateChanger+0x260>)
 8001f8c:	681b      	ldr	r3, [r3, #0]
 8001f8e:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
 8001f92:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8001f96:	b2db      	uxtb	r3, r3
 8001f98:	f103 0330 	add.w	r3, r3, #48	; 0x30
 8001f9c:	b2da      	uxtb	r2, r3
 8001f9e:	4b41      	ldr	r3, [pc, #260]	; (80020a4 <DateChanger+0x264>)
 8001fa0:	705a      	strb	r2, [r3, #1]
        datechanger_date[2]=':';
 8001fa2:	4b40      	ldr	r3, [pc, #256]	; (80020a4 <DateChanger+0x264>)
 8001fa4:	f04f 023a 	mov.w	r2, #58	; 0x3a
 8001fa8:	709a      	strb	r2, [r3, #2]
        datechanger_date[3]=(((RTC->TR & TIME_MINUTE_BCD_1) >> TIME_MINUTE_BCD_1_OFFSET) + ASCII_OFFSEET);
 8001faa:	4b3d      	ldr	r3, [pc, #244]	; (80020a0 <DateChanger+0x260>)
 8001fac:	681b      	ldr	r3, [r3, #0]
 8001fae:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
 8001fb2:	ea4f 3313 	mov.w	r3, r3, lsr #12
 8001fb6:	b2db      	uxtb	r3, r3
 8001fb8:	f103 0330 	add.w	r3, r3, #48	; 0x30
 8001fbc:	b2da      	uxtb	r2, r3
 8001fbe:	4b39      	ldr	r3, [pc, #228]	; (80020a4 <DateChanger+0x264>)
 8001fc0:	70da      	strb	r2, [r3, #3]
        datechanger_date[4]=(((RTC->TR & TIME_MINUTE_BCD_2) >> TIME_MINUTE_BCD_2_OFFSET) + ASCII_OFFSEET);
 8001fc2:	4b37      	ldr	r3, [pc, #220]	; (80020a0 <DateChanger+0x260>)
 8001fc4:	681b      	ldr	r3, [r3, #0]
 8001fc6:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 8001fca:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8001fce:	b2db      	uxtb	r3, r3
 8001fd0:	f103 0330 	add.w	r3, r3, #48	; 0x30
 8001fd4:	b2da      	uxtb	r2, r3
 8001fd6:	4b33      	ldr	r3, [pc, #204]	; (80020a4 <DateChanger+0x264>)
 8001fd8:	711a      	strb	r2, [r3, #4]
        datechanger_date[5]=':';
 8001fda:	4b32      	ldr	r3, [pc, #200]	; (80020a4 <DateChanger+0x264>)
 8001fdc:	f04f 023a 	mov.w	r2, #58	; 0x3a
 8001fe0:	715a      	strb	r2, [r3, #5]
        datechanger_date[6]=(((RTC->TR & TIME_SECOND_BCD_1) >> TIME_SECOND_BCD_1_OFFSET) + ASCII_OFFSEET);
 8001fe2:	4b2f      	ldr	r3, [pc, #188]	; (80020a0 <DateChanger+0x260>)
 8001fe4:	681b      	ldr	r3, [r3, #0]
 8001fe6:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8001fea:	ea4f 1313 	mov.w	r3, r3, lsr #4
 8001fee:	b2db      	uxtb	r3, r3
 8001ff0:	f103 0330 	add.w	r3, r3, #48	; 0x30
 8001ff4:	b2da      	uxtb	r2, r3
 8001ff6:	4b2b      	ldr	r3, [pc, #172]	; (80020a4 <DateChanger+0x264>)
 8001ff8:	719a      	strb	r2, [r3, #6]
        datechanger_date[7]=(((RTC->TR & TIME_SECOND_BCD_2) >> TIME_SECOND_BCD_2_OFFSET) + ASCII_OFFSEET);
 8001ffa:	4b29      	ldr	r3, [pc, #164]	; (80020a0 <DateChanger+0x260>)
 8001ffc:	681b      	ldr	r3, [r3, #0]
 8001ffe:	b2db      	uxtb	r3, r3
 8002000:	f003 030f 	and.w	r3, r3, #15
 8002004:	b2db      	uxtb	r3, r3
 8002006:	f103 0330 	add.w	r3, r3, #48	; 0x30
 800200a:	b2da      	uxtb	r2, r3
 800200c:	4b25      	ldr	r3, [pc, #148]	; (80020a4 <DateChanger+0x264>)
 800200e:	71da      	strb	r2, [r3, #7]
        datechanger_date[8]='\0';
 8002010:	4b24      	ldr	r3, [pc, #144]	; (80020a4 <DateChanger+0x264>)
 8002012:	f04f 0200 	mov.w	r2, #0
 8002016:	721a      	strb	r2, [r3, #8]

        Cursor(0, 0);
 8002018:	f04f 0000 	mov.w	r0, #0
 800201c:	f04f 0100 	mov.w	r1, #0
 8002020:	f7fe fb50 	bl	80006c4 <Cursor>
        PrintStr(menu_current_time.nev);
 8002024:	4b20      	ldr	r3, [pc, #128]	; (80020a8 <DateChanger+0x268>)
 8002026:	681b      	ldr	r3, [r3, #0]
 8002028:	4618      	mov	r0, r3
 800202a:	f7fe fd59 	bl	8000ae0 <PrintStr>

        Cursor(2, 0);
 800202e:	f04f 0002 	mov.w	r0, #2
 8002032:	f04f 0100 	mov.w	r1, #0
 8002036:	f7fe fb45 	bl	80006c4 <Cursor>
        PrintStr(datechanger_date);
 800203a:	481a      	ldr	r0, [pc, #104]	; (80020a4 <DateChanger+0x264>)
 800203c:	f7fe fd50 	bl	8000ae0 <PrintStr>
        Cursor(2, 0);
 8002040:	f04f 0002 	mov.w	r0, #2
 8002044:	f04f 0100 	mov.w	r1, #0
 8002048:	f7fe fb3c 	bl	80006c4 <Cursor>
 800204c:	e2eb      	b.n	8002626 <DateChanger+0x7e6>
    }

    else if(param == MENU_ENTER)
 800204e:	79fb      	ldrb	r3, [r7, #7]
 8002050:	2b09      	cmp	r3, #9
 8002052:	d12b      	bne.n	80020ac <DateChanger+0x26c>
    {
        datechanger_i++;
 8002054:	4b0f      	ldr	r3, [pc, #60]	; (8002094 <DateChanger+0x254>)
 8002056:	781b      	ldrb	r3, [r3, #0]
 8002058:	f103 0301 	add.w	r3, r3, #1
 800205c:	b2da      	uxtb	r2, r3
 800205e:	4b0d      	ldr	r3, [pc, #52]	; (8002094 <DateChanger+0x254>)
 8002060:	701a      	strb	r2, [r3, #0]
        if(datechanger_i == 2 || datechanger_i == 5)
 8002062:	4b0c      	ldr	r3, [pc, #48]	; (8002094 <DateChanger+0x254>)
 8002064:	781b      	ldrb	r3, [r3, #0]
 8002066:	2b02      	cmp	r3, #2
 8002068:	d003      	beq.n	8002072 <DateChanger+0x232>
 800206a:	4b0a      	ldr	r3, [pc, #40]	; (8002094 <DateChanger+0x254>)
 800206c:	781b      	ldrb	r3, [r3, #0]
 800206e:	2b05      	cmp	r3, #5
 8002070:	d106      	bne.n	8002080 <DateChanger+0x240>
            datechanger_i++;
 8002072:	4b08      	ldr	r3, [pc, #32]	; (8002094 <DateChanger+0x254>)
 8002074:	781b      	ldrb	r3, [r3, #0]
 8002076:	f103 0301 	add.w	r3, r3, #1
 800207a:	b2da      	uxtb	r2, r3
 800207c:	4b05      	ldr	r3, [pc, #20]	; (8002094 <DateChanger+0x254>)
 800207e:	701a      	strb	r2, [r3, #0]
        Cursor(2, datechanger_i);
 8002080:	4b04      	ldr	r3, [pc, #16]	; (8002094 <DateChanger+0x254>)
 8002082:	781b      	ldrb	r3, [r3, #0]
 8002084:	f04f 0002 	mov.w	r0, #2
 8002088:	4619      	mov	r1, r3
 800208a:	f7fe fb1b 	bl	80006c4 <Cursor>
 800208e:	e2ca      	b.n	8002626 <DateChanger+0x7e6>
 8002090:	200012a4 	.word	0x200012a4
 8002094:	20000d4c 	.word	0x20000d4c
 8002098:	20000e12 	.word	0x20000e12
 800209c:	20000ff8 	.word	0x20000ff8
 80020a0:	40002800 	.word	0x40002800
 80020a4:	200012fc 	.word	0x200012fc
 80020a8:	200013e0 	.word	0x200013e0
    }

    else if(param == MENU_DOWN)
 80020ac:	79fb      	ldrb	r3, [r7, #7]
 80020ae:	2b07      	cmp	r3, #7
 80020b0:	f040 8273 	bne.w	800259a <DateChanger+0x75a>
    {
        if(datechanger_function == menu_current_time.designator)
 80020b4:	4b7d      	ldr	r3, [pc, #500]	; (80022ac <DateChanger+0x46c>)
 80020b6:	791a      	ldrb	r2, [r3, #4]
 80020b8:	4b7d      	ldr	r3, [pc, #500]	; (80022b0 <DateChanger+0x470>)
 80020ba:	781b      	ldrb	r3, [r3, #0]
 80020bc:	429a      	cmp	r2, r3
 80020be:	f040 808a 	bne.w	80021d6 <DateChanger+0x396>
        {
            if(datechanger_i == 0)
 80020c2:	4b7c      	ldr	r3, [pc, #496]	; (80022b4 <DateChanger+0x474>)
 80020c4:	781b      	ldrb	r3, [r3, #0]
 80020c6:	2b00      	cmp	r3, #0
 80020c8:	d11d      	bne.n	8002106 <DateChanger+0x2c6>
                {
                    datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] >= '2') ? '0' : (datechanger_date[datechanger_i] + 1));
 80020ca:	4b7a      	ldr	r3, [pc, #488]	; (80022b4 <DateChanger+0x474>)
 80020cc:	781b      	ldrb	r3, [r3, #0]
 80020ce:	461a      	mov	r2, r3
 80020d0:	4b78      	ldr	r3, [pc, #480]	; (80022b4 <DateChanger+0x474>)
 80020d2:	781b      	ldrb	r3, [r3, #0]
 80020d4:	4978      	ldr	r1, [pc, #480]	; (80022b8 <DateChanger+0x478>)
 80020d6:	5ccb      	ldrb	r3, [r1, r3]
 80020d8:	2b31      	cmp	r3, #49	; 0x31
 80020da:	d807      	bhi.n	80020ec <DateChanger+0x2ac>
 80020dc:	4b75      	ldr	r3, [pc, #468]	; (80022b4 <DateChanger+0x474>)
 80020de:	781b      	ldrb	r3, [r3, #0]
 80020e0:	4975      	ldr	r1, [pc, #468]	; (80022b8 <DateChanger+0x478>)
 80020e2:	5ccb      	ldrb	r3, [r1, r3]
 80020e4:	f103 0301 	add.w	r3, r3, #1
 80020e8:	b2db      	uxtb	r3, r3
 80020ea:	e001      	b.n	80020f0 <DateChanger+0x2b0>
 80020ec:	f04f 0330 	mov.w	r3, #48	; 0x30
 80020f0:	4971      	ldr	r1, [pc, #452]	; (80022b8 <DateChanger+0x478>)
 80020f2:	548b      	strb	r3, [r1, r2]
                    datechanger_date[datechanger_i + 1] = '0';
 80020f4:	4b6f      	ldr	r3, [pc, #444]	; (80022b4 <DateChanger+0x474>)
 80020f6:	781b      	ldrb	r3, [r3, #0]
 80020f8:	f103 0301 	add.w	r3, r3, #1
 80020fc:	4a6e      	ldr	r2, [pc, #440]	; (80022b8 <DateChanger+0x478>)
 80020fe:	f04f 0130 	mov.w	r1, #48	; 0x30
 8002102:	54d1      	strb	r1, [r2, r3]
                    datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] >= '9') ? '0' : (datechanger_date[datechanger_i] + 1));
            }
            else if(datechanger_i == 3 || datechanger_i == 6)
                datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] == '5') ? '0' : (datechanger_date[datechanger_i] + 1));
            else
                datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] == '9') ? '0' : (datechanger_date[datechanger_i] + 1));
 8002104:	e238      	b.n	8002578 <DateChanger+0x738>
            if(datechanger_i == 0)
                {
                    datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] >= '2') ? '0' : (datechanger_date[datechanger_i] + 1));
                    datechanger_date[datechanger_i + 1] = '0';
                }
            else if(datechanger_i == 1)
 8002106:	4b6b      	ldr	r3, [pc, #428]	; (80022b4 <DateChanger+0x474>)
 8002108:	781b      	ldrb	r3, [r3, #0]
 800210a:	2b01      	cmp	r3, #1
 800210c:	d12f      	bne.n	800216e <DateChanger+0x32e>
            {
                if(datechanger_date[0] == '2')
 800210e:	4b6a      	ldr	r3, [pc, #424]	; (80022b8 <DateChanger+0x478>)
 8002110:	781b      	ldrb	r3, [r3, #0]
 8002112:	2b32      	cmp	r3, #50	; 0x32
 8002114:	d115      	bne.n	8002142 <DateChanger+0x302>
                    datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] >= '3') ? '0' : (datechanger_date[datechanger_i] + 1));
 8002116:	4b67      	ldr	r3, [pc, #412]	; (80022b4 <DateChanger+0x474>)
 8002118:	781b      	ldrb	r3, [r3, #0]
 800211a:	461a      	mov	r2, r3
 800211c:	4b65      	ldr	r3, [pc, #404]	; (80022b4 <DateChanger+0x474>)
 800211e:	781b      	ldrb	r3, [r3, #0]
 8002120:	4965      	ldr	r1, [pc, #404]	; (80022b8 <DateChanger+0x478>)
 8002122:	5ccb      	ldrb	r3, [r1, r3]
 8002124:	2b32      	cmp	r3, #50	; 0x32
 8002126:	d807      	bhi.n	8002138 <DateChanger+0x2f8>
 8002128:	4b62      	ldr	r3, [pc, #392]	; (80022b4 <DateChanger+0x474>)
 800212a:	781b      	ldrb	r3, [r3, #0]
 800212c:	4962      	ldr	r1, [pc, #392]	; (80022b8 <DateChanger+0x478>)
 800212e:	5ccb      	ldrb	r3, [r1, r3]
 8002130:	f103 0301 	add.w	r3, r3, #1
 8002134:	b2db      	uxtb	r3, r3
 8002136:	e001      	b.n	800213c <DateChanger+0x2fc>
 8002138:	f04f 0330 	mov.w	r3, #48	; 0x30
 800213c:	495e      	ldr	r1, [pc, #376]	; (80022b8 <DateChanger+0x478>)
 800213e:	548b      	strb	r3, [r1, r2]
                    datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] >= '9') ? '0' : (datechanger_date[datechanger_i] + 1));
            }
            else if(datechanger_i == 3 || datechanger_i == 6)
                datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] == '5') ? '0' : (datechanger_date[datechanger_i] + 1));
            else
                datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] == '9') ? '0' : (datechanger_date[datechanger_i] + 1));
 8002140:	e21a      	b.n	8002578 <DateChanger+0x738>
            else if(datechanger_i == 1)
            {
                if(datechanger_date[0] == '2')
                    datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] >= '3') ? '0' : (datechanger_date[datechanger_i] + 1));
                else
                    datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] >= '9') ? '0' : (datechanger_date[datechanger_i] + 1));
 8002142:	4b5c      	ldr	r3, [pc, #368]	; (80022b4 <DateChanger+0x474>)
 8002144:	781b      	ldrb	r3, [r3, #0]
 8002146:	461a      	mov	r2, r3
 8002148:	4b5a      	ldr	r3, [pc, #360]	; (80022b4 <DateChanger+0x474>)
 800214a:	781b      	ldrb	r3, [r3, #0]
 800214c:	495a      	ldr	r1, [pc, #360]	; (80022b8 <DateChanger+0x478>)
 800214e:	5ccb      	ldrb	r3, [r1, r3]
 8002150:	2b38      	cmp	r3, #56	; 0x38
 8002152:	d807      	bhi.n	8002164 <DateChanger+0x324>
 8002154:	4b57      	ldr	r3, [pc, #348]	; (80022b4 <DateChanger+0x474>)
 8002156:	781b      	ldrb	r3, [r3, #0]
 8002158:	4957      	ldr	r1, [pc, #348]	; (80022b8 <DateChanger+0x478>)
 800215a:	5ccb      	ldrb	r3, [r1, r3]
 800215c:	f103 0301 	add.w	r3, r3, #1
 8002160:	b2db      	uxtb	r3, r3
 8002162:	e001      	b.n	8002168 <DateChanger+0x328>
 8002164:	f04f 0330 	mov.w	r3, #48	; 0x30
 8002168:	4953      	ldr	r1, [pc, #332]	; (80022b8 <DateChanger+0x478>)
 800216a:	548b      	strb	r3, [r1, r2]
            }
            else if(datechanger_i == 3 || datechanger_i == 6)
                datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] == '5') ? '0' : (datechanger_date[datechanger_i] + 1));
            else
                datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] == '9') ? '0' : (datechanger_date[datechanger_i] + 1));
 800216c:	e204      	b.n	8002578 <DateChanger+0x738>
                if(datechanger_date[0] == '2')
                    datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] >= '3') ? '0' : (datechanger_date[datechanger_i] + 1));
                else
                    datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] >= '9') ? '0' : (datechanger_date[datechanger_i] + 1));
            }
            else if(datechanger_i == 3 || datechanger_i == 6)
 800216e:	4b51      	ldr	r3, [pc, #324]	; (80022b4 <DateChanger+0x474>)
 8002170:	781b      	ldrb	r3, [r3, #0]
 8002172:	2b03      	cmp	r3, #3
 8002174:	d003      	beq.n	800217e <DateChanger+0x33e>
 8002176:	4b4f      	ldr	r3, [pc, #316]	; (80022b4 <DateChanger+0x474>)
 8002178:	781b      	ldrb	r3, [r3, #0]
 800217a:	2b06      	cmp	r3, #6
 800217c:	d115      	bne.n	80021aa <DateChanger+0x36a>
                datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] == '5') ? '0' : (datechanger_date[datechanger_i] + 1));
 800217e:	4b4d      	ldr	r3, [pc, #308]	; (80022b4 <DateChanger+0x474>)
 8002180:	781b      	ldrb	r3, [r3, #0]
 8002182:	461a      	mov	r2, r3
 8002184:	4b4b      	ldr	r3, [pc, #300]	; (80022b4 <DateChanger+0x474>)
 8002186:	781b      	ldrb	r3, [r3, #0]
 8002188:	494b      	ldr	r1, [pc, #300]	; (80022b8 <DateChanger+0x478>)
 800218a:	5ccb      	ldrb	r3, [r1, r3]
 800218c:	2b35      	cmp	r3, #53	; 0x35
 800218e:	d007      	beq.n	80021a0 <DateChanger+0x360>
 8002190:	4b48      	ldr	r3, [pc, #288]	; (80022b4 <DateChanger+0x474>)
 8002192:	781b      	ldrb	r3, [r3, #0]
 8002194:	4948      	ldr	r1, [pc, #288]	; (80022b8 <DateChanger+0x478>)
 8002196:	5ccb      	ldrb	r3, [r1, r3]
 8002198:	f103 0301 	add.w	r3, r3, #1
 800219c:	b2db      	uxtb	r3, r3
 800219e:	e001      	b.n	80021a4 <DateChanger+0x364>
 80021a0:	f04f 0330 	mov.w	r3, #48	; 0x30
 80021a4:	4944      	ldr	r1, [pc, #272]	; (80022b8 <DateChanger+0x478>)
 80021a6:	548b      	strb	r3, [r1, r2]
 80021a8:	e1e6      	b.n	8002578 <DateChanger+0x738>
            else
                datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] == '9') ? '0' : (datechanger_date[datechanger_i] + 1));
 80021aa:	4b42      	ldr	r3, [pc, #264]	; (80022b4 <DateChanger+0x474>)
 80021ac:	781b      	ldrb	r3, [r3, #0]
 80021ae:	461a      	mov	r2, r3
 80021b0:	4b40      	ldr	r3, [pc, #256]	; (80022b4 <DateChanger+0x474>)
 80021b2:	781b      	ldrb	r3, [r3, #0]
 80021b4:	4940      	ldr	r1, [pc, #256]	; (80022b8 <DateChanger+0x478>)
 80021b6:	5ccb      	ldrb	r3, [r1, r3]
 80021b8:	2b39      	cmp	r3, #57	; 0x39
 80021ba:	d007      	beq.n	80021cc <DateChanger+0x38c>
 80021bc:	4b3d      	ldr	r3, [pc, #244]	; (80022b4 <DateChanger+0x474>)
 80021be:	781b      	ldrb	r3, [r3, #0]
 80021c0:	493d      	ldr	r1, [pc, #244]	; (80022b8 <DateChanger+0x478>)
 80021c2:	5ccb      	ldrb	r3, [r1, r3]
 80021c4:	f103 0301 	add.w	r3, r3, #1
 80021c8:	b2db      	uxtb	r3, r3
 80021ca:	e001      	b.n	80021d0 <DateChanger+0x390>
 80021cc:	f04f 0330 	mov.w	r3, #48	; 0x30
 80021d0:	4939      	ldr	r1, [pc, #228]	; (80022b8 <DateChanger+0x478>)
 80021d2:	548b      	strb	r3, [r1, r2]
 80021d4:	e1d0      	b.n	8002578 <DateChanger+0x738>
        }

        else if(datechanger_function == menu_date.designator)
 80021d6:	4b39      	ldr	r3, [pc, #228]	; (80022bc <DateChanger+0x47c>)
 80021d8:	791a      	ldrb	r2, [r3, #4]
 80021da:	4b35      	ldr	r3, [pc, #212]	; (80022b0 <DateChanger+0x470>)
 80021dc:	781b      	ldrb	r3, [r3, #0]
 80021de:	429a      	cmp	r2, r3
 80021e0:	f040 81ca 	bne.w	8002578 <DateChanger+0x738>
        {
            if(datechanger_i == 3)
 80021e4:	4b33      	ldr	r3, [pc, #204]	; (80022b4 <DateChanger+0x474>)
 80021e6:	781b      	ldrb	r3, [r3, #0]
 80021e8:	2b03      	cmp	r3, #3
 80021ea:	d126      	bne.n	800223a <DateChanger+0x3fa>
                {
                    datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] >= '1') ? '0' : (datechanger_date[datechanger_i] + 1));
 80021ec:	4b31      	ldr	r3, [pc, #196]	; (80022b4 <DateChanger+0x474>)
 80021ee:	781b      	ldrb	r3, [r3, #0]
 80021f0:	461a      	mov	r2, r3
 80021f2:	4b30      	ldr	r3, [pc, #192]	; (80022b4 <DateChanger+0x474>)
 80021f4:	781b      	ldrb	r3, [r3, #0]
 80021f6:	4930      	ldr	r1, [pc, #192]	; (80022b8 <DateChanger+0x478>)
 80021f8:	5ccb      	ldrb	r3, [r1, r3]
 80021fa:	2b30      	cmp	r3, #48	; 0x30
 80021fc:	d807      	bhi.n	800220e <DateChanger+0x3ce>
 80021fe:	4b2d      	ldr	r3, [pc, #180]	; (80022b4 <DateChanger+0x474>)
 8002200:	781b      	ldrb	r3, [r3, #0]
 8002202:	492d      	ldr	r1, [pc, #180]	; (80022b8 <DateChanger+0x478>)
 8002204:	5ccb      	ldrb	r3, [r1, r3]
 8002206:	f103 0301 	add.w	r3, r3, #1
 800220a:	b2db      	uxtb	r3, r3
 800220c:	e001      	b.n	8002212 <DateChanger+0x3d2>
 800220e:	f04f 0330 	mov.w	r3, #48	; 0x30
 8002212:	4929      	ldr	r1, [pc, #164]	; (80022b8 <DateChanger+0x478>)
 8002214:	548b      	strb	r3, [r1, r2]
                    datechanger_date[datechanger_i + 1] = ((datechanger_date[datechanger_i] == '0') ? '1' : '0');
 8002216:	4b27      	ldr	r3, [pc, #156]	; (80022b4 <DateChanger+0x474>)
 8002218:	781b      	ldrb	r3, [r3, #0]
 800221a:	f103 0201 	add.w	r2, r3, #1
 800221e:	4b25      	ldr	r3, [pc, #148]	; (80022b4 <DateChanger+0x474>)
 8002220:	781b      	ldrb	r3, [r3, #0]
 8002222:	4925      	ldr	r1, [pc, #148]	; (80022b8 <DateChanger+0x478>)
 8002224:	5ccb      	ldrb	r3, [r1, r3]
 8002226:	2b30      	cmp	r3, #48	; 0x30
 8002228:	d102      	bne.n	8002230 <DateChanger+0x3f0>
 800222a:	f04f 0331 	mov.w	r3, #49	; 0x31
 800222e:	e001      	b.n	8002234 <DateChanger+0x3f4>
 8002230:	f04f 0330 	mov.w	r3, #48	; 0x30
 8002234:	4920      	ldr	r1, [pc, #128]	; (80022b8 <DateChanger+0x478>)
 8002236:	548b      	strb	r3, [r1, r2]
 8002238:	e19e      	b.n	8002578 <DateChanger+0x738>
                }
            else if(datechanger_i == 4)
 800223a:	4b1e      	ldr	r3, [pc, #120]	; (80022b4 <DateChanger+0x474>)
 800223c:	781b      	ldrb	r3, [r3, #0]
 800223e:	2b04      	cmp	r3, #4
 8002240:	d13e      	bne.n	80022c0 <DateChanger+0x480>
            {
                if(datechanger_date[3] == '0')
 8002242:	4b1d      	ldr	r3, [pc, #116]	; (80022b8 <DateChanger+0x478>)
 8002244:	78db      	ldrb	r3, [r3, #3]
 8002246:	2b30      	cmp	r3, #48	; 0x30
 8002248:	d115      	bne.n	8002276 <DateChanger+0x436>
                    datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] >= '9') ? '1' : (datechanger_date[datechanger_i] + 1));
 800224a:	4b1a      	ldr	r3, [pc, #104]	; (80022b4 <DateChanger+0x474>)
 800224c:	781b      	ldrb	r3, [r3, #0]
 800224e:	461a      	mov	r2, r3
 8002250:	4b18      	ldr	r3, [pc, #96]	; (80022b4 <DateChanger+0x474>)
 8002252:	781b      	ldrb	r3, [r3, #0]
 8002254:	4918      	ldr	r1, [pc, #96]	; (80022b8 <DateChanger+0x478>)
 8002256:	5ccb      	ldrb	r3, [r1, r3]
 8002258:	2b38      	cmp	r3, #56	; 0x38
 800225a:	d807      	bhi.n	800226c <DateChanger+0x42c>
 800225c:	4b15      	ldr	r3, [pc, #84]	; (80022b4 <DateChanger+0x474>)
 800225e:	781b      	ldrb	r3, [r3, #0]
 8002260:	4915      	ldr	r1, [pc, #84]	; (80022b8 <DateChanger+0x478>)
 8002262:	5ccb      	ldrb	r3, [r1, r3]
 8002264:	f103 0301 	add.w	r3, r3, #1
 8002268:	b2db      	uxtb	r3, r3
 800226a:	e001      	b.n	8002270 <DateChanger+0x430>
 800226c:	f04f 0331 	mov.w	r3, #49	; 0x31
 8002270:	4911      	ldr	r1, [pc, #68]	; (80022b8 <DateChanger+0x478>)
 8002272:	548b      	strb	r3, [r1, r2]
 8002274:	e180      	b.n	8002578 <DateChanger+0x738>
                else if(datechanger_date[3] == '1')
 8002276:	4b10      	ldr	r3, [pc, #64]	; (80022b8 <DateChanger+0x478>)
 8002278:	78db      	ldrb	r3, [r3, #3]
 800227a:	2b31      	cmp	r3, #49	; 0x31
 800227c:	f040 817c 	bne.w	8002578 <DateChanger+0x738>
                    datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] >= '2') ? '0' : (datechanger_date[datechanger_i] + 1));
 8002280:	4b0c      	ldr	r3, [pc, #48]	; (80022b4 <DateChanger+0x474>)
 8002282:	781b      	ldrb	r3, [r3, #0]
 8002284:	461a      	mov	r2, r3
 8002286:	4b0b      	ldr	r3, [pc, #44]	; (80022b4 <DateChanger+0x474>)
 8002288:	781b      	ldrb	r3, [r3, #0]
 800228a:	490b      	ldr	r1, [pc, #44]	; (80022b8 <DateChanger+0x478>)
 800228c:	5ccb      	ldrb	r3, [r1, r3]
 800228e:	2b31      	cmp	r3, #49	; 0x31
 8002290:	d807      	bhi.n	80022a2 <DateChanger+0x462>
 8002292:	4b08      	ldr	r3, [pc, #32]	; (80022b4 <DateChanger+0x474>)
 8002294:	781b      	ldrb	r3, [r3, #0]
 8002296:	4908      	ldr	r1, [pc, #32]	; (80022b8 <DateChanger+0x478>)
 8002298:	5ccb      	ldrb	r3, [r1, r3]
 800229a:	f103 0301 	add.w	r3, r3, #1
 800229e:	b2db      	uxtb	r3, r3
 80022a0:	e001      	b.n	80022a6 <DateChanger+0x466>
 80022a2:	f04f 0330 	mov.w	r3, #48	; 0x30
 80022a6:	4904      	ldr	r1, [pc, #16]	; (80022b8 <DateChanger+0x478>)
 80022a8:	548b      	strb	r3, [r1, r2]
 80022aa:	e165      	b.n	8002578 <DateChanger+0x738>
 80022ac:	200013e0 	.word	0x200013e0
 80022b0:	20000ff8 	.word	0x20000ff8
 80022b4:	20000d4c 	.word	0x20000d4c
 80022b8:	200012fc 	.word	0x200012fc
 80022bc:	200012a4 	.word	0x200012a4
            }
            else if(datechanger_i == 6)
 80022c0:	4b8f      	ldr	r3, [pc, #572]	; (8002500 <DateChanger+0x6c0>)
 80022c2:	781b      	ldrb	r3, [r3, #0]
 80022c4:	2b06      	cmp	r3, #6
 80022c6:	d15d      	bne.n	8002384 <DateChanger+0x544>
            {
                datechanger_temp = (((datechanger_date[0] - ASCII_OFFSEET) * 10) + ((datechanger_date[1] - ASCII_OFFSEET)));
 80022c8:	4b8e      	ldr	r3, [pc, #568]	; (8002504 <DateChanger+0x6c4>)
 80022ca:	781b      	ldrb	r3, [r3, #0]
 80022cc:	461a      	mov	r2, r3
 80022ce:	ea4f 0282 	mov.w	r2, r2, lsl #2
 80022d2:	18d3      	adds	r3, r2, r3
 80022d4:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80022d8:	b2da      	uxtb	r2, r3
 80022da:	4b8a      	ldr	r3, [pc, #552]	; (8002504 <DateChanger+0x6c4>)
 80022dc:	785b      	ldrb	r3, [r3, #1]
 80022de:	18d3      	adds	r3, r2, r3
 80022e0:	b2db      	uxtb	r3, r3
 80022e2:	f1a3 0310 	sub.w	r3, r3, #16
 80022e6:	b2da      	uxtb	r2, r3
 80022e8:	4b87      	ldr	r3, [pc, #540]	; (8002508 <DateChanger+0x6c8>)
 80022ea:	701a      	strb	r2, [r3, #0]

                if(((datechanger_temp % 4) == 0) && ((datechanger_date[3] - ASCII_OFFSEET) == 0) && ((datechanger_date[4] - ASCII_OFFSEET) == 2))   //ha szökõév van és február hónap
 80022ec:	4b86      	ldr	r3, [pc, #536]	; (8002508 <DateChanger+0x6c8>)
 80022ee:	781b      	ldrb	r3, [r3, #0]
 80022f0:	f003 0303 	and.w	r3, r3, #3
 80022f4:	b2db      	uxtb	r3, r3
 80022f6:	2b00      	cmp	r3, #0
 80022f8:	d11d      	bne.n	8002336 <DateChanger+0x4f6>
 80022fa:	4b82      	ldr	r3, [pc, #520]	; (8002504 <DateChanger+0x6c4>)
 80022fc:	78db      	ldrb	r3, [r3, #3]
 80022fe:	2b30      	cmp	r3, #48	; 0x30
 8002300:	d119      	bne.n	8002336 <DateChanger+0x4f6>
 8002302:	4b80      	ldr	r3, [pc, #512]	; (8002504 <DateChanger+0x6c4>)
 8002304:	791b      	ldrb	r3, [r3, #4]
 8002306:	2b32      	cmp	r3, #50	; 0x32
 8002308:	d115      	bne.n	8002336 <DateChanger+0x4f6>
                    datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] >= '2') ? '0' : (datechanger_date[datechanger_i] + 1));
 800230a:	4b7d      	ldr	r3, [pc, #500]	; (8002500 <DateChanger+0x6c0>)
 800230c:	781b      	ldrb	r3, [r3, #0]
 800230e:	461a      	mov	r2, r3
 8002310:	4b7b      	ldr	r3, [pc, #492]	; (8002500 <DateChanger+0x6c0>)
 8002312:	781b      	ldrb	r3, [r3, #0]
 8002314:	497b      	ldr	r1, [pc, #492]	; (8002504 <DateChanger+0x6c4>)
 8002316:	5ccb      	ldrb	r3, [r1, r3]
 8002318:	2b31      	cmp	r3, #49	; 0x31
 800231a:	d807      	bhi.n	800232c <DateChanger+0x4ec>
 800231c:	4b78      	ldr	r3, [pc, #480]	; (8002500 <DateChanger+0x6c0>)
 800231e:	781b      	ldrb	r3, [r3, #0]
 8002320:	4978      	ldr	r1, [pc, #480]	; (8002504 <DateChanger+0x6c4>)
 8002322:	5ccb      	ldrb	r3, [r1, r3]
 8002324:	f103 0301 	add.w	r3, r3, #1
 8002328:	b2db      	uxtb	r3, r3
 800232a:	e001      	b.n	8002330 <DateChanger+0x4f0>
 800232c:	f04f 0330 	mov.w	r3, #48	; 0x30
 8002330:	4974      	ldr	r1, [pc, #464]	; (8002504 <DateChanger+0x6c4>)
 8002332:	548b      	strb	r3, [r1, r2]
 8002334:	e014      	b.n	8002360 <DateChanger+0x520>

                else
                    datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] >= '3') ? '0' : (datechanger_date[datechanger_i] + 1));
 8002336:	4b72      	ldr	r3, [pc, #456]	; (8002500 <DateChanger+0x6c0>)
 8002338:	781b      	ldrb	r3, [r3, #0]
 800233a:	461a      	mov	r2, r3
 800233c:	4b70      	ldr	r3, [pc, #448]	; (8002500 <DateChanger+0x6c0>)
 800233e:	781b      	ldrb	r3, [r3, #0]
 8002340:	4970      	ldr	r1, [pc, #448]	; (8002504 <DateChanger+0x6c4>)
 8002342:	5ccb      	ldrb	r3, [r1, r3]
 8002344:	2b32      	cmp	r3, #50	; 0x32
 8002346:	d807      	bhi.n	8002358 <DateChanger+0x518>
 8002348:	4b6d      	ldr	r3, [pc, #436]	; (8002500 <DateChanger+0x6c0>)
 800234a:	781b      	ldrb	r3, [r3, #0]
 800234c:	496d      	ldr	r1, [pc, #436]	; (8002504 <DateChanger+0x6c4>)
 800234e:	5ccb      	ldrb	r3, [r1, r3]
 8002350:	f103 0301 	add.w	r3, r3, #1
 8002354:	b2db      	uxtb	r3, r3
 8002356:	e001      	b.n	800235c <DateChanger+0x51c>
 8002358:	f04f 0330 	mov.w	r3, #48	; 0x30
 800235c:	4969      	ldr	r1, [pc, #420]	; (8002504 <DateChanger+0x6c4>)
 800235e:	548b      	strb	r3, [r1, r2]
                datechanger_date[datechanger_i + 1] = (datechanger_date[datechanger_i] == '0') ? '1' : '0';
 8002360:	4b67      	ldr	r3, [pc, #412]	; (8002500 <DateChanger+0x6c0>)
 8002362:	781b      	ldrb	r3, [r3, #0]
 8002364:	f103 0201 	add.w	r2, r3, #1
 8002368:	4b65      	ldr	r3, [pc, #404]	; (8002500 <DateChanger+0x6c0>)
 800236a:	781b      	ldrb	r3, [r3, #0]
 800236c:	4965      	ldr	r1, [pc, #404]	; (8002504 <DateChanger+0x6c4>)
 800236e:	5ccb      	ldrb	r3, [r1, r3]
 8002370:	2b30      	cmp	r3, #48	; 0x30
 8002372:	d102      	bne.n	800237a <DateChanger+0x53a>
 8002374:	f04f 0331 	mov.w	r3, #49	; 0x31
 8002378:	e001      	b.n	800237e <DateChanger+0x53e>
 800237a:	f04f 0330 	mov.w	r3, #48	; 0x30
 800237e:	4961      	ldr	r1, [pc, #388]	; (8002504 <DateChanger+0x6c4>)
 8002380:	548b      	strb	r3, [r1, r2]
 8002382:	e0f9      	b.n	8002578 <DateChanger+0x738>
            }
            else if(datechanger_i == 7)
 8002384:	4b5e      	ldr	r3, [pc, #376]	; (8002500 <DateChanger+0x6c0>)
 8002386:	781b      	ldrb	r3, [r3, #0]
 8002388:	2b07      	cmp	r3, #7
 800238a:	f040 80e0 	bne.w	800254e <DateChanger+0x70e>
            {
                if( ((datechanger_date[3] - ASCII_OFFSEET) == 0) && ((datechanger_date[4] - ASCII_OFFSEET) == 2))       //ha február van
 800238e:	4b5d      	ldr	r3, [pc, #372]	; (8002504 <DateChanger+0x6c4>)
 8002390:	78db      	ldrb	r3, [r3, #3]
 8002392:	2b30      	cmp	r3, #48	; 0x30
 8002394:	d14c      	bne.n	8002430 <DateChanger+0x5f0>
 8002396:	4b5b      	ldr	r3, [pc, #364]	; (8002504 <DateChanger+0x6c4>)
 8002398:	791b      	ldrb	r3, [r3, #4]
 800239a:	2b32      	cmp	r3, #50	; 0x32
 800239c:	d148      	bne.n	8002430 <DateChanger+0x5f0>
                {
                    if(((datechanger_temp % 4) == 0))                                           //ha ez egy szökõév
 800239e:	4b5a      	ldr	r3, [pc, #360]	; (8002508 <DateChanger+0x6c8>)
 80023a0:	781b      	ldrb	r3, [r3, #0]
 80023a2:	f003 0303 	and.w	r3, r3, #3
 80023a6:	b2db      	uxtb	r3, r3
 80023a8:	2b00      	cmp	r3, #0
 80023aa:	d120      	bne.n	80023ee <DateChanger+0x5ae>
                        datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] >= '9') ? ((datechanger_date[datechanger_i - 1] == '0') ? '1' : '0') : (datechanger_date[datechanger_i] + 1));
 80023ac:	4b54      	ldr	r3, [pc, #336]	; (8002500 <DateChanger+0x6c0>)
 80023ae:	781b      	ldrb	r3, [r3, #0]
 80023b0:	461a      	mov	r2, r3
 80023b2:	4b53      	ldr	r3, [pc, #332]	; (8002500 <DateChanger+0x6c0>)
 80023b4:	781b      	ldrb	r3, [r3, #0]
 80023b6:	4953      	ldr	r1, [pc, #332]	; (8002504 <DateChanger+0x6c4>)
 80023b8:	5ccb      	ldrb	r3, [r1, r3]
 80023ba:	2b38      	cmp	r3, #56	; 0x38
 80023bc:	d90d      	bls.n	80023da <DateChanger+0x59a>
 80023be:	4b50      	ldr	r3, [pc, #320]	; (8002500 <DateChanger+0x6c0>)
 80023c0:	781b      	ldrb	r3, [r3, #0]
 80023c2:	f103 33ff 	add.w	r3, r3, #4294967295
 80023c6:	494f      	ldr	r1, [pc, #316]	; (8002504 <DateChanger+0x6c4>)
 80023c8:	5ccb      	ldrb	r3, [r1, r3]
 80023ca:	2b30      	cmp	r3, #48	; 0x30
 80023cc:	d102      	bne.n	80023d4 <DateChanger+0x594>
 80023ce:	f04f 0331 	mov.w	r3, #49	; 0x31
 80023d2:	e001      	b.n	80023d8 <DateChanger+0x598>
 80023d4:	f04f 0330 	mov.w	r3, #48	; 0x30
 80023d8:	e006      	b.n	80023e8 <DateChanger+0x5a8>
 80023da:	4b49      	ldr	r3, [pc, #292]	; (8002500 <DateChanger+0x6c0>)
 80023dc:	781b      	ldrb	r3, [r3, #0]
 80023de:	4949      	ldr	r1, [pc, #292]	; (8002504 <DateChanger+0x6c4>)
 80023e0:	5ccb      	ldrb	r3, [r1, r3]
 80023e2:	f103 0301 	add.w	r3, r3, #1
 80023e6:	b2db      	uxtb	r3, r3
 80023e8:	4946      	ldr	r1, [pc, #280]	; (8002504 <DateChanger+0x6c4>)
 80023ea:	548b      	strb	r3, [r1, r2]
            }
            else if(datechanger_i == 7)
            {
                if( ((datechanger_date[3] - ASCII_OFFSEET) == 0) && ((datechanger_date[4] - ASCII_OFFSEET) == 2))       //ha február van
                {
                    if(((datechanger_temp % 4) == 0))                                           //ha ez egy szökõév
 80023ec:	e0c4      	b.n	8002578 <DateChanger+0x738>
                        datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] >= '9') ? ((datechanger_date[datechanger_i - 1] == '0') ? '1' : '0') : (datechanger_date[datechanger_i] + 1));
                    else
                        datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] >= '8') ? ((datechanger_date[datechanger_i - 1] == '0') ? '1' : '0') : (datechanger_date[datechanger_i] + 1));
 80023ee:	4b44      	ldr	r3, [pc, #272]	; (8002500 <DateChanger+0x6c0>)
 80023f0:	781b      	ldrb	r3, [r3, #0]
 80023f2:	461a      	mov	r2, r3
 80023f4:	4b42      	ldr	r3, [pc, #264]	; (8002500 <DateChanger+0x6c0>)
 80023f6:	781b      	ldrb	r3, [r3, #0]
 80023f8:	4942      	ldr	r1, [pc, #264]	; (8002504 <DateChanger+0x6c4>)
 80023fa:	5ccb      	ldrb	r3, [r1, r3]
 80023fc:	2b37      	cmp	r3, #55	; 0x37
 80023fe:	d90d      	bls.n	800241c <DateChanger+0x5dc>
 8002400:	4b3f      	ldr	r3, [pc, #252]	; (8002500 <DateChanger+0x6c0>)
 8002402:	781b      	ldrb	r3, [r3, #0]
 8002404:	f103 33ff 	add.w	r3, r3, #4294967295
 8002408:	493e      	ldr	r1, [pc, #248]	; (8002504 <DateChanger+0x6c4>)
 800240a:	5ccb      	ldrb	r3, [r1, r3]
 800240c:	2b30      	cmp	r3, #48	; 0x30
 800240e:	d102      	bne.n	8002416 <DateChanger+0x5d6>
 8002410:	f04f 0331 	mov.w	r3, #49	; 0x31
 8002414:	e001      	b.n	800241a <DateChanger+0x5da>
 8002416:	f04f 0330 	mov.w	r3, #48	; 0x30
 800241a:	e006      	b.n	800242a <DateChanger+0x5ea>
 800241c:	4b38      	ldr	r3, [pc, #224]	; (8002500 <DateChanger+0x6c0>)
 800241e:	781b      	ldrb	r3, [r3, #0]
 8002420:	4938      	ldr	r1, [pc, #224]	; (8002504 <DateChanger+0x6c4>)
 8002422:	5ccb      	ldrb	r3, [r1, r3]
 8002424:	f103 0301 	add.w	r3, r3, #1
 8002428:	b2db      	uxtb	r3, r3
 800242a:	4936      	ldr	r1, [pc, #216]	; (8002504 <DateChanger+0x6c4>)
 800242c:	548b      	strb	r3, [r1, r2]
            }
            else if(datechanger_i == 7)
            {
                if( ((datechanger_date[3] - ASCII_OFFSEET) == 0) && ((datechanger_date[4] - ASCII_OFFSEET) == 2))       //ha február van
                {
                    if(((datechanger_temp % 4) == 0))                                           //ha ez egy szökõév
 800242e:	e0a3      	b.n	8002578 <DateChanger+0x738>
                        datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] >= '9') ? ((datechanger_date[datechanger_i - 1] == '0') ? '1' : '0') : (datechanger_date[datechanger_i] + 1));
                    else
                        datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] >= '8') ? ((datechanger_date[datechanger_i - 1] == '0') ? '1' : '0') : (datechanger_date[datechanger_i] + 1));
                }

                else if(((datechanger_date[3] == '0') && (datechanger_date[4] == '4')) || ((datechanger_date[3] == '0') && (datechanger_date[4] == '6')) || ((datechanger_date[3] == '0') && (datechanger_date[4] == '8')) || ((datechanger_date[3] == '1') && (datechanger_date[4] == '1')))   //Ha a hónap 31 napos               {
 8002430:	4b34      	ldr	r3, [pc, #208]	; (8002504 <DateChanger+0x6c4>)
 8002432:	78db      	ldrb	r3, [r3, #3]
 8002434:	2b30      	cmp	r3, #48	; 0x30
 8002436:	d103      	bne.n	8002440 <DateChanger+0x600>
 8002438:	4b32      	ldr	r3, [pc, #200]	; (8002504 <DateChanger+0x6c4>)
 800243a:	791b      	ldrb	r3, [r3, #4]
 800243c:	2b34      	cmp	r3, #52	; 0x34
 800243e:	d017      	beq.n	8002470 <DateChanger+0x630>
 8002440:	4b30      	ldr	r3, [pc, #192]	; (8002504 <DateChanger+0x6c4>)
 8002442:	78db      	ldrb	r3, [r3, #3]
 8002444:	2b30      	cmp	r3, #48	; 0x30
 8002446:	d103      	bne.n	8002450 <DateChanger+0x610>
 8002448:	4b2e      	ldr	r3, [pc, #184]	; (8002504 <DateChanger+0x6c4>)
 800244a:	791b      	ldrb	r3, [r3, #4]
 800244c:	2b36      	cmp	r3, #54	; 0x36
 800244e:	d00f      	beq.n	8002470 <DateChanger+0x630>
 8002450:	4b2c      	ldr	r3, [pc, #176]	; (8002504 <DateChanger+0x6c4>)
 8002452:	78db      	ldrb	r3, [r3, #3]
 8002454:	2b30      	cmp	r3, #48	; 0x30
 8002456:	d103      	bne.n	8002460 <DateChanger+0x620>
 8002458:	4b2a      	ldr	r3, [pc, #168]	; (8002504 <DateChanger+0x6c4>)
 800245a:	791b      	ldrb	r3, [r3, #4]
 800245c:	2b38      	cmp	r3, #56	; 0x38
 800245e:	d007      	beq.n	8002470 <DateChanger+0x630>
 8002460:	4b28      	ldr	r3, [pc, #160]	; (8002504 <DateChanger+0x6c4>)
 8002462:	78db      	ldrb	r3, [r3, #3]
 8002464:	2b31      	cmp	r3, #49	; 0x31
 8002466:	d130      	bne.n	80024ca <DateChanger+0x68a>
 8002468:	4b26      	ldr	r3, [pc, #152]	; (8002504 <DateChanger+0x6c4>)
 800246a:	791b      	ldrb	r3, [r3, #4]
 800246c:	2b31      	cmp	r3, #49	; 0x31
 800246e:	d12c      	bne.n	80024ca <DateChanger+0x68a>
                {
                    if(datechanger_date[6] == '3')
 8002470:	4b24      	ldr	r3, [pc, #144]	; (8002504 <DateChanger+0x6c4>)
 8002472:	799b      	ldrb	r3, [r3, #6]
 8002474:	2b33      	cmp	r3, #51	; 0x33
 8002476:	d106      	bne.n	8002486 <DateChanger+0x646>
                        datechanger_date[datechanger_i] = '0';
 8002478:	4b21      	ldr	r3, [pc, #132]	; (8002500 <DateChanger+0x6c0>)
 800247a:	781b      	ldrb	r3, [r3, #0]
 800247c:	4a21      	ldr	r2, [pc, #132]	; (8002504 <DateChanger+0x6c4>)
 800247e:	f04f 0130 	mov.w	r1, #48	; 0x30
 8002482:	54d1      	strb	r1, [r2, r3]
                        datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] >= '8') ? ((datechanger_date[datechanger_i - 1] == '0') ? '1' : '0') : (datechanger_date[datechanger_i] + 1));
                }

                else if(((datechanger_date[3] == '0') && (datechanger_date[4] == '4')) || ((datechanger_date[3] == '0') && (datechanger_date[4] == '6')) || ((datechanger_date[3] == '0') && (datechanger_date[4] == '8')) || ((datechanger_date[3] == '1') && (datechanger_date[4] == '1')))   //Ha a hónap 31 napos               {
                {
                    if(datechanger_date[6] == '3')
 8002484:	e078      	b.n	8002578 <DateChanger+0x738>
                        datechanger_date[datechanger_i] = '0';
                    else
                        datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] >= '9') ? ((datechanger_date[datechanger_i - 1] == '0') ? '1' : '0') : (datechanger_date[datechanger_i] + 1));
 8002486:	4b1e      	ldr	r3, [pc, #120]	; (8002500 <DateChanger+0x6c0>)
 8002488:	781b      	ldrb	r3, [r3, #0]
 800248a:	461a      	mov	r2, r3
 800248c:	4b1c      	ldr	r3, [pc, #112]	; (8002500 <DateChanger+0x6c0>)
 800248e:	781b      	ldrb	r3, [r3, #0]
 8002490:	491c      	ldr	r1, [pc, #112]	; (8002504 <DateChanger+0x6c4>)
 8002492:	5ccb      	ldrb	r3, [r1, r3]
 8002494:	2b38      	cmp	r3, #56	; 0x38
 8002496:	d90d      	bls.n	80024b4 <DateChanger+0x674>
 8002498:	4b19      	ldr	r3, [pc, #100]	; (8002500 <DateChanger+0x6c0>)
 800249a:	781b      	ldrb	r3, [r3, #0]
 800249c:	f103 33ff 	add.w	r3, r3, #4294967295
 80024a0:	4918      	ldr	r1, [pc, #96]	; (8002504 <DateChanger+0x6c4>)
 80024a2:	5ccb      	ldrb	r3, [r1, r3]
 80024a4:	2b30      	cmp	r3, #48	; 0x30
 80024a6:	d102      	bne.n	80024ae <DateChanger+0x66e>
 80024a8:	f04f 0331 	mov.w	r3, #49	; 0x31
 80024ac:	e001      	b.n	80024b2 <DateChanger+0x672>
 80024ae:	f04f 0330 	mov.w	r3, #48	; 0x30
 80024b2:	e006      	b.n	80024c2 <DateChanger+0x682>
 80024b4:	4b12      	ldr	r3, [pc, #72]	; (8002500 <DateChanger+0x6c0>)
 80024b6:	781b      	ldrb	r3, [r3, #0]
 80024b8:	4912      	ldr	r1, [pc, #72]	; (8002504 <DateChanger+0x6c4>)
 80024ba:	5ccb      	ldrb	r3, [r1, r3]
 80024bc:	f103 0301 	add.w	r3, r3, #1
 80024c0:	b2db      	uxtb	r3, r3
 80024c2:	4910      	ldr	r1, [pc, #64]	; (8002504 <DateChanger+0x6c4>)
 80024c4:	548b      	strb	r3, [r1, r2]
                        datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] >= '8') ? ((datechanger_date[datechanger_i - 1] == '0') ? '1' : '0') : (datechanger_date[datechanger_i] + 1));
                }

                else if(((datechanger_date[3] == '0') && (datechanger_date[4] == '4')) || ((datechanger_date[3] == '0') && (datechanger_date[4] == '6')) || ((datechanger_date[3] == '0') && (datechanger_date[4] == '8')) || ((datechanger_date[3] == '1') && (datechanger_date[4] == '1')))   //Ha a hónap 31 napos               {
                {
                    if(datechanger_date[6] == '3')
 80024c6:	bf00      	nop
 80024c8:	e056      	b.n	8002578 <DateChanger+0x738>
                        datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] >= '9') ? ((datechanger_date[datechanger_i - 1] == '0') ? '1' : '0') : (datechanger_date[datechanger_i] + 1));
                }

                else        //ha 31 napos a hónap
                {
                    if(datechanger_date[6] == '3')
 80024ca:	4b0e      	ldr	r3, [pc, #56]	; (8002504 <DateChanger+0x6c4>)
 80024cc:	799b      	ldrb	r3, [r3, #6]
 80024ce:	2b33      	cmp	r3, #51	; 0x33
 80024d0:	d11c      	bne.n	800250c <DateChanger+0x6cc>
                        datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] >= '1') ? '0' : (datechanger_date[datechanger_i] + 1));
 80024d2:	4b0b      	ldr	r3, [pc, #44]	; (8002500 <DateChanger+0x6c0>)
 80024d4:	781b      	ldrb	r3, [r3, #0]
 80024d6:	461a      	mov	r2, r3
 80024d8:	4b09      	ldr	r3, [pc, #36]	; (8002500 <DateChanger+0x6c0>)
 80024da:	781b      	ldrb	r3, [r3, #0]
 80024dc:	4909      	ldr	r1, [pc, #36]	; (8002504 <DateChanger+0x6c4>)
 80024de:	5ccb      	ldrb	r3, [r1, r3]
 80024e0:	2b30      	cmp	r3, #48	; 0x30
 80024e2:	d807      	bhi.n	80024f4 <DateChanger+0x6b4>
 80024e4:	4b06      	ldr	r3, [pc, #24]	; (8002500 <DateChanger+0x6c0>)
 80024e6:	781b      	ldrb	r3, [r3, #0]
 80024e8:	4906      	ldr	r1, [pc, #24]	; (8002504 <DateChanger+0x6c4>)
 80024ea:	5ccb      	ldrb	r3, [r1, r3]
 80024ec:	f103 0301 	add.w	r3, r3, #1
 80024f0:	b2db      	uxtb	r3, r3
 80024f2:	e001      	b.n	80024f8 <DateChanger+0x6b8>
 80024f4:	f04f 0330 	mov.w	r3, #48	; 0x30
 80024f8:	4902      	ldr	r1, [pc, #8]	; (8002504 <DateChanger+0x6c4>)
 80024fa:	548b      	strb	r3, [r1, r2]
                    else
                        datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] >= '9') ? ((datechanger_date[datechanger_i - 1] == '0') ? '1' : '0') : (datechanger_date[datechanger_i] + 1));
 80024fc:	e03c      	b.n	8002578 <DateChanger+0x738>
 80024fe:	bf00      	nop
 8002500:	20000d4c 	.word	0x20000d4c
 8002504:	200012fc 	.word	0x200012fc
 8002508:	20001400 	.word	0x20001400
 800250c:	4b7a      	ldr	r3, [pc, #488]	; (80026f8 <DateChanger+0x8b8>)
 800250e:	781b      	ldrb	r3, [r3, #0]
 8002510:	461a      	mov	r2, r3
 8002512:	4b79      	ldr	r3, [pc, #484]	; (80026f8 <DateChanger+0x8b8>)
 8002514:	781b      	ldrb	r3, [r3, #0]
 8002516:	4979      	ldr	r1, [pc, #484]	; (80026fc <DateChanger+0x8bc>)
 8002518:	5ccb      	ldrb	r3, [r1, r3]
 800251a:	2b38      	cmp	r3, #56	; 0x38
 800251c:	d90d      	bls.n	800253a <DateChanger+0x6fa>
 800251e:	4b76      	ldr	r3, [pc, #472]	; (80026f8 <DateChanger+0x8b8>)
 8002520:	781b      	ldrb	r3, [r3, #0]
 8002522:	f103 33ff 	add.w	r3, r3, #4294967295
 8002526:	4975      	ldr	r1, [pc, #468]	; (80026fc <DateChanger+0x8bc>)
 8002528:	5ccb      	ldrb	r3, [r1, r3]
 800252a:	2b30      	cmp	r3, #48	; 0x30
 800252c:	d102      	bne.n	8002534 <DateChanger+0x6f4>
 800252e:	f04f 0331 	mov.w	r3, #49	; 0x31
 8002532:	e001      	b.n	8002538 <DateChanger+0x6f8>
 8002534:	f04f 0330 	mov.w	r3, #48	; 0x30
 8002538:	e006      	b.n	8002548 <DateChanger+0x708>
 800253a:	4b6f      	ldr	r3, [pc, #444]	; (80026f8 <DateChanger+0x8b8>)
 800253c:	781b      	ldrb	r3, [r3, #0]
 800253e:	496f      	ldr	r1, [pc, #444]	; (80026fc <DateChanger+0x8bc>)
 8002540:	5ccb      	ldrb	r3, [r1, r3]
 8002542:	f103 0301 	add.w	r3, r3, #1
 8002546:	b2db      	uxtb	r3, r3
 8002548:	496c      	ldr	r1, [pc, #432]	; (80026fc <DateChanger+0x8bc>)
 800254a:	548b      	strb	r3, [r1, r2]
 800254c:	e014      	b.n	8002578 <DateChanger+0x738>
                }
            }
            else
                datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] == '9') ? '0' : (datechanger_date[datechanger_i] + 1));
 800254e:	4b6a      	ldr	r3, [pc, #424]	; (80026f8 <DateChanger+0x8b8>)
 8002550:	781b      	ldrb	r3, [r3, #0]
 8002552:	461a      	mov	r2, r3
 8002554:	4b68      	ldr	r3, [pc, #416]	; (80026f8 <DateChanger+0x8b8>)
 8002556:	781b      	ldrb	r3, [r3, #0]
 8002558:	4968      	ldr	r1, [pc, #416]	; (80026fc <DateChanger+0x8bc>)
 800255a:	5ccb      	ldrb	r3, [r1, r3]
 800255c:	2b39      	cmp	r3, #57	; 0x39
 800255e:	d007      	beq.n	8002570 <DateChanger+0x730>
 8002560:	4b65      	ldr	r3, [pc, #404]	; (80026f8 <DateChanger+0x8b8>)
 8002562:	781b      	ldrb	r3, [r3, #0]
 8002564:	4965      	ldr	r1, [pc, #404]	; (80026fc <DateChanger+0x8bc>)
 8002566:	5ccb      	ldrb	r3, [r1, r3]
 8002568:	f103 0301 	add.w	r3, r3, #1
 800256c:	b2db      	uxtb	r3, r3
 800256e:	e001      	b.n	8002574 <DateChanger+0x734>
 8002570:	f04f 0330 	mov.w	r3, #48	; 0x30
 8002574:	4961      	ldr	r1, [pc, #388]	; (80026fc <DateChanger+0x8bc>)
 8002576:	548b      	strb	r3, [r1, r2]
        }
        Cursor(2, 0);
 8002578:	f04f 0002 	mov.w	r0, #2
 800257c:	f04f 0100 	mov.w	r1, #0
 8002580:	f7fe f8a0 	bl	80006c4 <Cursor>
        PrintStr(datechanger_date);
 8002584:	485d      	ldr	r0, [pc, #372]	; (80026fc <DateChanger+0x8bc>)
 8002586:	f7fe faab 	bl	8000ae0 <PrintStr>
        Cursor(2, datechanger_i);
 800258a:	4b5b      	ldr	r3, [pc, #364]	; (80026f8 <DateChanger+0x8b8>)
 800258c:	781b      	ldrb	r3, [r3, #0]
 800258e:	f04f 0002 	mov.w	r0, #2
 8002592:	4619      	mov	r1, r3
 8002594:	f7fe f896 	bl	80006c4 <Cursor>
 8002598:	e045      	b.n	8002626 <DateChanger+0x7e6>
    }

    else if(param == MENU_UP)
 800259a:	79fb      	ldrb	r3, [r7, #7]
 800259c:	2b08      	cmp	r3, #8
 800259e:	d142      	bne.n	8002626 <DateChanger+0x7e6>
    {
        if(datechanger_i == 3 || datechanger_i == 6)
 80025a0:	4b55      	ldr	r3, [pc, #340]	; (80026f8 <DateChanger+0x8b8>)
 80025a2:	781b      	ldrb	r3, [r3, #0]
 80025a4:	2b03      	cmp	r3, #3
 80025a6:	d003      	beq.n	80025b0 <DateChanger+0x770>
 80025a8:	4b53      	ldr	r3, [pc, #332]	; (80026f8 <DateChanger+0x8b8>)
 80025aa:	781b      	ldrb	r3, [r3, #0]
 80025ac:	2b06      	cmp	r3, #6
 80025ae:	d115      	bne.n	80025dc <DateChanger+0x79c>
            datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] == '0') ? (5 + ASCII_OFFSEET) : (datechanger_date[datechanger_i] - 1));
 80025b0:	4b51      	ldr	r3, [pc, #324]	; (80026f8 <DateChanger+0x8b8>)
 80025b2:	781b      	ldrb	r3, [r3, #0]
 80025b4:	461a      	mov	r2, r3
 80025b6:	4b50      	ldr	r3, [pc, #320]	; (80026f8 <DateChanger+0x8b8>)
 80025b8:	781b      	ldrb	r3, [r3, #0]
 80025ba:	4950      	ldr	r1, [pc, #320]	; (80026fc <DateChanger+0x8bc>)
 80025bc:	5ccb      	ldrb	r3, [r1, r3]
 80025be:	2b30      	cmp	r3, #48	; 0x30
 80025c0:	d007      	beq.n	80025d2 <DateChanger+0x792>
 80025c2:	4b4d      	ldr	r3, [pc, #308]	; (80026f8 <DateChanger+0x8b8>)
 80025c4:	781b      	ldrb	r3, [r3, #0]
 80025c6:	494d      	ldr	r1, [pc, #308]	; (80026fc <DateChanger+0x8bc>)
 80025c8:	5ccb      	ldrb	r3, [r1, r3]
 80025ca:	f103 33ff 	add.w	r3, r3, #4294967295
 80025ce:	b2db      	uxtb	r3, r3
 80025d0:	e001      	b.n	80025d6 <DateChanger+0x796>
 80025d2:	f04f 0335 	mov.w	r3, #53	; 0x35
 80025d6:	4949      	ldr	r1, [pc, #292]	; (80026fc <DateChanger+0x8bc>)
 80025d8:	548b      	strb	r3, [r1, r2]
 80025da:	e014      	b.n	8002606 <DateChanger+0x7c6>
        else
            datechanger_date[datechanger_i] = ((datechanger_date[datechanger_i] == '0') ? (9 + ASCII_OFFSEET) : (datechanger_date[datechanger_i] - 1));
 80025dc:	4b46      	ldr	r3, [pc, #280]	; (80026f8 <DateChanger+0x8b8>)
 80025de:	781b      	ldrb	r3, [r3, #0]
 80025e0:	461a      	mov	r2, r3
 80025e2:	4b45      	ldr	r3, [pc, #276]	; (80026f8 <DateChanger+0x8b8>)
 80025e4:	781b      	ldrb	r3, [r3, #0]
 80025e6:	4945      	ldr	r1, [pc, #276]	; (80026fc <DateChanger+0x8bc>)
 80025e8:	5ccb      	ldrb	r3, [r1, r3]
 80025ea:	2b30      	cmp	r3, #48	; 0x30
 80025ec:	d007      	beq.n	80025fe <DateChanger+0x7be>
 80025ee:	4b42      	ldr	r3, [pc, #264]	; (80026f8 <DateChanger+0x8b8>)
 80025f0:	781b      	ldrb	r3, [r3, #0]
 80025f2:	4942      	ldr	r1, [pc, #264]	; (80026fc <DateChanger+0x8bc>)
 80025f4:	5ccb      	ldrb	r3, [r1, r3]
 80025f6:	f103 33ff 	add.w	r3, r3, #4294967295
 80025fa:	b2db      	uxtb	r3, r3
 80025fc:	e001      	b.n	8002602 <DateChanger+0x7c2>
 80025fe:	f04f 0339 	mov.w	r3, #57	; 0x39
 8002602:	493e      	ldr	r1, [pc, #248]	; (80026fc <DateChanger+0x8bc>)
 8002604:	548b      	strb	r3, [r1, r2]

        Cursor(2, 0);
 8002606:	f04f 0002 	mov.w	r0, #2
 800260a:	f04f 0100 	mov.w	r1, #0
 800260e:	f7fe f859 	bl	80006c4 <Cursor>
        PrintStr(datechanger_date);
 8002612:	483a      	ldr	r0, [pc, #232]	; (80026fc <DateChanger+0x8bc>)
 8002614:	f7fe fa64 	bl	8000ae0 <PrintStr>
        Cursor(2, datechanger_i);
 8002618:	4b37      	ldr	r3, [pc, #220]	; (80026f8 <DateChanger+0x8b8>)
 800261a:	781b      	ldrb	r3, [r3, #0]
 800261c:	f04f 0002 	mov.w	r0, #2
 8002620:	4619      	mov	r1, r3
 8002622:	f7fe f84f 	bl	80006c4 <Cursor>
    }

    if(datechanger_i == 8)
 8002626:	4b34      	ldr	r3, [pc, #208]	; (80026f8 <DateChanger+0x8b8>)
 8002628:	781b      	ldrb	r3, [r3, #0]
 800262a:	2b08      	cmp	r3, #8
 800262c:	f040 80c2 	bne.w	80027b4 <DateChanger+0x974>

          RTC_WakeUpClockConfig(RTC_WakeUpClock_CK_SPRE_16bits);
          RTC_SetWakeUpCounter(0x0);
          RTC_ITConfig(RTC_IT_WUT, ENABLE);*/

        DisplayFill(*menu_current, *menu_first);
 8002630:	4b33      	ldr	r3, [pc, #204]	; (8002700 <DateChanger+0x8c0>)
 8002632:	681e      	ldr	r6, [r3, #0]
 8002634:	4b33      	ldr	r3, [pc, #204]	; (8002704 <DateChanger+0x8c4>)
 8002636:	681b      	ldr	r3, [r3, #0]
 8002638:	ad03      	add	r5, sp, #12
 800263a:	461c      	mov	r4, r3
 800263c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800263e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8002640:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8002644:	e885 0007 	stmia.w	r5, {r0, r1, r2}
 8002648:	466b      	mov	r3, sp
 800264a:	f106 0210 	add.w	r2, r6, #16
 800264e:	ca07      	ldmia	r2, {r0, r1, r2}
 8002650:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 8002654:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 8002658:	f7fe fac4 	bl	8000be4 <DisplayFill>

        //**********************************************************************************

        RTC_WriteProtectionCmd(DISABLE);
 800265c:	f04f 0000 	mov.w	r0, #0
 8002660:	f006 f902 	bl	8008868 <RTC_WriteProtectionCmd>
        RTC_EnterInitMode();
 8002664:	f006 f91c 	bl	80088a0 <RTC_EnterInitMode>

        //**********************************************************************************

        if(datechanger_function == menu_date.designator)
 8002668:	4b27      	ldr	r3, [pc, #156]	; (8002708 <DateChanger+0x8c8>)
 800266a:	791a      	ldrb	r2, [r3, #4]
 800266c:	4b27      	ldr	r3, [pc, #156]	; (800270c <DateChanger+0x8cc>)
 800266e:	781b      	ldrb	r3, [r3, #0]
 8002670:	429a      	cmp	r2, r3
 8002672:	d14d      	bne.n	8002710 <DateChanger+0x8d0>
        {
            RTC_DateTypeDef RTC_DateStructure;

            RTC_DateStructure.RTC_Year  = (((datechanger_date[0] - ASCII_OFFSEET) << 4)  | (datechanger_date[1] - ASCII_OFFSEET));
 8002674:	4b21      	ldr	r3, [pc, #132]	; (80026fc <DateChanger+0x8bc>)
 8002676:	781b      	ldrb	r3, [r3, #0]
 8002678:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 800267c:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002680:	b2da      	uxtb	r2, r3
 8002682:	4b1e      	ldr	r3, [pc, #120]	; (80026fc <DateChanger+0x8bc>)
 8002684:	785b      	ldrb	r3, [r3, #1]
 8002686:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 800268a:	b2db      	uxtb	r3, r3
 800268c:	b2db      	uxtb	r3, r3
 800268e:	4313      	orrs	r3, r2
 8002690:	b2db      	uxtb	r3, r3
 8002692:	b2db      	uxtb	r3, r3
 8002694:	73fb      	strb	r3, [r7, #15]
            RTC_DateStructure.RTC_Month = (((datechanger_date[3] - ASCII_OFFSEET) << 4)  | (datechanger_date[4] - ASCII_OFFSEET));
 8002696:	4b19      	ldr	r3, [pc, #100]	; (80026fc <DateChanger+0x8bc>)
 8002698:	78db      	ldrb	r3, [r3, #3]
 800269a:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 800269e:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80026a2:	b2da      	uxtb	r2, r3
 80026a4:	4b15      	ldr	r3, [pc, #84]	; (80026fc <DateChanger+0x8bc>)
 80026a6:	791b      	ldrb	r3, [r3, #4]
 80026a8:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 80026ac:	b2db      	uxtb	r3, r3
 80026ae:	b2db      	uxtb	r3, r3
 80026b0:	4313      	orrs	r3, r2
 80026b2:	b2db      	uxtb	r3, r3
 80026b4:	b2db      	uxtb	r3, r3
 80026b6:	737b      	strb	r3, [r7, #13]
            RTC_DateStructure.RTC_Date  = (((datechanger_date[6] - ASCII_OFFSEET) << 4)  | (datechanger_date[7] - ASCII_OFFSEET));
 80026b8:	4b10      	ldr	r3, [pc, #64]	; (80026fc <DateChanger+0x8bc>)
 80026ba:	799b      	ldrb	r3, [r3, #6]
 80026bc:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 80026c0:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80026c4:	b2da      	uxtb	r2, r3
 80026c6:	4b0d      	ldr	r3, [pc, #52]	; (80026fc <DateChanger+0x8bc>)
 80026c8:	79db      	ldrb	r3, [r3, #7]
 80026ca:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 80026ce:	b2db      	uxtb	r3, r3
 80026d0:	b2db      	uxtb	r3, r3
 80026d2:	4313      	orrs	r3, r2
 80026d4:	b2db      	uxtb	r3, r3
 80026d6:	b2db      	uxtb	r3, r3
 80026d8:	73bb      	strb	r3, [r7, #14]

            RTC_SetDate(RTC_Format_BCD, &RTC_DateStructure);
 80026da:	f107 030c 	add.w	r3, r7, #12
 80026de:	f04f 0001 	mov.w	r0, #1
 80026e2:	4619      	mov	r1, r3
 80026e4:	f006 fae2 	bl	8008cac <RTC_SetDate>
            RTC_WriteBackupRegister(RTC_BKP_DR0, 0x32F2);
 80026e8:	f04f 0000 	mov.w	r0, #0
 80026ec:	f243 21f2 	movw	r1, #13042	; 0x32f2
 80026f0:	f007 f956 	bl	80099a0 <RTC_WriteBackupRegister>
 80026f4:	e04c      	b.n	8002790 <DateChanger+0x950>
 80026f6:	bf00      	nop
 80026f8:	20000d4c 	.word	0x20000d4c
 80026fc:	200012fc 	.word	0x200012fc
 8002700:	2000124c 	.word	0x2000124c
 8002704:	20000d48 	.word	0x20000d48
 8002708:	200012a4 	.word	0x200012a4
 800270c:	20000ff8 	.word	0x20000ff8
        }

        else if(datechanger_function == menu_current_time.designator)
 8002710:	4b2c      	ldr	r3, [pc, #176]	; (80027c4 <DateChanger+0x984>)
 8002712:	791a      	ldrb	r2, [r3, #4]
 8002714:	4b2c      	ldr	r3, [pc, #176]	; (80027c8 <DateChanger+0x988>)
 8002716:	781b      	ldrb	r3, [r3, #0]
 8002718:	429a      	cmp	r2, r3
 800271a:	d139      	bne.n	8002790 <DateChanger+0x950>
        {
            RTC_TimeTypeDef  RTC_TimeStructure;

            RTC_TimeStructure.RTC_Hours   = (((datechanger_date[0] - ASCII_OFFSEET) << 4)  | (datechanger_date[1] - ASCII_OFFSEET));
 800271c:	4b2b      	ldr	r3, [pc, #172]	; (80027cc <DateChanger+0x98c>)
 800271e:	781b      	ldrb	r3, [r3, #0]
 8002720:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 8002724:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002728:	b2da      	uxtb	r2, r3
 800272a:	4b28      	ldr	r3, [pc, #160]	; (80027cc <DateChanger+0x98c>)
 800272c:	785b      	ldrb	r3, [r3, #1]
 800272e:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 8002732:	b2db      	uxtb	r3, r3
 8002734:	b2db      	uxtb	r3, r3
 8002736:	4313      	orrs	r3, r2
 8002738:	b2db      	uxtb	r3, r3
 800273a:	b2db      	uxtb	r3, r3
 800273c:	723b      	strb	r3, [r7, #8]
            RTC_TimeStructure.RTC_Minutes = (((datechanger_date[3] - ASCII_OFFSEET) << 4)  | (datechanger_date[4] - ASCII_OFFSEET));
 800273e:	4b23      	ldr	r3, [pc, #140]	; (80027cc <DateChanger+0x98c>)
 8002740:	78db      	ldrb	r3, [r3, #3]
 8002742:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 8002746:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800274a:	b2da      	uxtb	r2, r3
 800274c:	4b1f      	ldr	r3, [pc, #124]	; (80027cc <DateChanger+0x98c>)
 800274e:	791b      	ldrb	r3, [r3, #4]
 8002750:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 8002754:	b2db      	uxtb	r3, r3
 8002756:	b2db      	uxtb	r3, r3
 8002758:	4313      	orrs	r3, r2
 800275a:	b2db      	uxtb	r3, r3
 800275c:	b2db      	uxtb	r3, r3
 800275e:	727b      	strb	r3, [r7, #9]
            RTC_TimeStructure.RTC_Seconds = (((datechanger_date[6] - ASCII_OFFSEET) << 4)  | (datechanger_date[7] - ASCII_OFFSEET));
 8002760:	4b1a      	ldr	r3, [pc, #104]	; (80027cc <DateChanger+0x98c>)
 8002762:	799b      	ldrb	r3, [r3, #6]
 8002764:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 8002768:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800276c:	b2da      	uxtb	r2, r3
 800276e:	4b17      	ldr	r3, [pc, #92]	; (80027cc <DateChanger+0x98c>)
 8002770:	79db      	ldrb	r3, [r3, #7]
 8002772:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 8002776:	b2db      	uxtb	r3, r3
 8002778:	b2db      	uxtb	r3, r3
 800277a:	4313      	orrs	r3, r2
 800277c:	b2db      	uxtb	r3, r3
 800277e:	b2db      	uxtb	r3, r3
 8002780:	72bb      	strb	r3, [r7, #10]

            RTC_SetTime(RTC_Format_BCD, &RTC_TimeStructure);
 8002782:	f107 0308 	add.w	r3, r7, #8
 8002786:	f04f 0001 	mov.w	r0, #1
 800278a:	4619      	mov	r1, r3
 800278c:	f006 f97c 	bl	8008a88 <RTC_SetTime>
        }
        //**********************************************************************************

        RTC_ExitInitMode();
 8002790:	f006 f8c6 	bl	8008920 <RTC_ExitInitMode>
        RTC_WaitForSynchro();
 8002794:	f006 f8d2 	bl	800893c <RTC_WaitForSynchro>
        //Megnézni, hogy az új idõpont belül van-e a jelenlegi öntözéses cikluson. Ha belül van, hagyom, ha nem megkeressük a kövit, és azzá váltjuk a jelenlegit
//        if(!TimeCompare(watering_current))
 //       {
            OutputOff(Output_all);
 8002798:	f04f 000b 	mov.w	r0, #11
 800279c:	f7fe fb72 	bl	8000e84 <OutputOff>
            else
            {
                watering_temporary2 = &watering[0];
                watering_current = watering_temporary2->next;
            }*/
            Watering_Next_Set();
 80027a0:	f7fe fd5e 	bl	8001260 <Watering_Next_Set>
    //    }

        //**********************************************************************************
        datechanger_function = 0;
 80027a4:	4b08      	ldr	r3, [pc, #32]	; (80027c8 <DateChanger+0x988>)
 80027a6:	f04f 0200 	mov.w	r2, #0
 80027aa:	701a      	strb	r2, [r3, #0]
        menu_special_function = 0;
 80027ac:	4b08      	ldr	r3, [pc, #32]	; (80027d0 <DateChanger+0x990>)
 80027ae:	f04f 0200 	mov.w	r2, #0
 80027b2:	701a      	strb	r2, [r3, #0]
    }
    return 0;
 80027b4:	f04f 0300 	mov.w	r3, #0
}
 80027b8:	4618      	mov	r0, r3
 80027ba:	f107 0714 	add.w	r7, r7, #20
 80027be:	46bd      	mov	sp, r7
 80027c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80027c2:	bf00      	nop
 80027c4:	200013e0 	.word	0x200013e0
 80027c8:	20000ff8 	.word	0x20000ff8
 80027cc:	200012fc 	.word	0x200012fc
 80027d0:	20000e12 	.word	0x20000e12

080027d4 <ReDesignator>:

char watering_function;
void ReDesignator()
{
 80027d4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80027d6:	b08b      	sub	sp, #44	; 0x2c
 80027d8:	af0a      	add	r7, sp, #40	; 0x28
    while(menu_temporary->previous)
 80027da:	e004      	b.n	80027e6 <ReDesignator+0x12>
        menu_temporary = menu_temporary->previous;
 80027dc:	4b1a      	ldr	r3, [pc, #104]	; (8002848 <ReDesignator+0x74>)
 80027de:	681b      	ldr	r3, [r3, #0]
 80027e0:	691a      	ldr	r2, [r3, #16]
 80027e2:	4b19      	ldr	r3, [pc, #100]	; (8002848 <ReDesignator+0x74>)
 80027e4:	601a      	str	r2, [r3, #0]
}

char watering_function;
void ReDesignator()
{
    while(menu_temporary->previous)
 80027e6:	4b18      	ldr	r3, [pc, #96]	; (8002848 <ReDesignator+0x74>)
 80027e8:	681b      	ldr	r3, [r3, #0]
 80027ea:	691b      	ldr	r3, [r3, #16]
 80027ec:	2b00      	cmp	r3, #0
 80027ee:	d1f5      	bne.n	80027dc <ReDesignator+0x8>
        menu_temporary = menu_temporary->previous;

    menu_current = menu_temporary;
 80027f0:	4b15      	ldr	r3, [pc, #84]	; (8002848 <ReDesignator+0x74>)
 80027f2:	681a      	ldr	r2, [r3, #0]
 80027f4:	4b15      	ldr	r3, [pc, #84]	; (800284c <ReDesignator+0x78>)
 80027f6:	601a      	str	r2, [r3, #0]
    menu_first = menu_temporary;
 80027f8:	4b13      	ldr	r3, [pc, #76]	; (8002848 <ReDesignator+0x74>)
 80027fa:	681a      	ldr	r2, [r3, #0]
 80027fc:	4b14      	ldr	r3, [pc, #80]	; (8002850 <ReDesignator+0x7c>)
 80027fe:	601a      	str	r2, [r3, #0]
        menu_temporary = menu_temporary->next;
    }
*/
/*    if(watering_function == watering_delete.designator)
    {*/
        ClearLcmScreen();
 8002800:	f7fd ff98 	bl	8000734 <ClearLcmScreen>
        DisplayFill(*menu_current, *menu_first);
 8002804:	4b11      	ldr	r3, [pc, #68]	; (800284c <ReDesignator+0x78>)
 8002806:	681e      	ldr	r6, [r3, #0]
 8002808:	4b11      	ldr	r3, [pc, #68]	; (8002850 <ReDesignator+0x7c>)
 800280a:	681b      	ldr	r3, [r3, #0]
 800280c:	ad03      	add	r5, sp, #12
 800280e:	461c      	mov	r4, r3
 8002810:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8002812:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8002814:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8002818:	e885 0007 	stmia.w	r5, {r0, r1, r2}
 800281c:	466b      	mov	r3, sp
 800281e:	f106 0210 	add.w	r2, r6, #16
 8002822:	ca07      	ldmia	r2, {r0, r1, r2}
 8002824:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 8002828:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 800282c:	f7fe f9da 	bl	8000be4 <DisplayFill>

        datechanger_function = 0;
 8002830:	4b08      	ldr	r3, [pc, #32]	; (8002854 <ReDesignator+0x80>)
 8002832:	f04f 0200 	mov.w	r2, #0
 8002836:	701a      	strb	r2, [r3, #0]
        menu_special_function = 0;
 8002838:	4b07      	ldr	r3, [pc, #28]	; (8002858 <ReDesignator+0x84>)
 800283a:	f04f 0200 	mov.w	r2, #0
 800283e:	701a      	strb	r2, [r3, #0]
  /*  }*/

}
 8002840:	f107 0704 	add.w	r7, r7, #4
 8002844:	46bd      	mov	sp, r7
 8002846:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002848:	20001310 	.word	0x20001310
 800284c:	2000124c 	.word	0x2000124c
 8002850:	20000d48 	.word	0x20000d48
 8002854:	20000ff8 	.word	0x20000ff8
 8002858:	20000e12 	.word	0x20000e12

0800285c <Watering>:
char watering_temp[6][17];
char watproc1_text[6];	//Öntözési képernyõhöz tartozó tömb. Tartalmát jelenítem meg az öntözési képernyõn.
char watering_process2[6];

int Watering(char param)
{
 800285c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800285e:	b08d      	sub	sp, #52	; 0x34
 8002860:	af0a      	add	r7, sp, #40	; 0x28
 8002862:	4603      	mov	r3, r0
 8002864:	71fb      	strb	r3, [r7, #7]
    if(param == watering_delete.designator || param == watering_edit.designator)
 8002866:	4b9c      	ldr	r3, [pc, #624]	; (8002ad8 <Watering+0x27c>)
 8002868:	791b      	ldrb	r3, [r3, #4]
 800286a:	79fa      	ldrb	r2, [r7, #7]
 800286c:	429a      	cmp	r2, r3
 800286e:	d004      	beq.n	800287a <Watering+0x1e>
 8002870:	4b9a      	ldr	r3, [pc, #616]	; (8002adc <Watering+0x280>)
 8002872:	791b      	ldrb	r3, [r3, #4]
 8002874:	79fa      	ldrb	r2, [r7, #7]
 8002876:	429a      	cmp	r2, r3
 8002878:	d136      	bne.n	80028e8 <Watering+0x8c>
    {
        menu_special_function = MENU_SPECIAL_FUNCTION_ONTOZES;
 800287a:	4b99      	ldr	r3, [pc, #612]	; (8002ae0 <Watering+0x284>)
 800287c:	f04f 0202 	mov.w	r2, #2
 8002880:	701a      	strb	r2, [r3, #0]
        watering_i = 0;
 8002882:	4b98      	ldr	r3, [pc, #608]	; (8002ae4 <Watering+0x288>)
 8002884:	f04f 0200 	mov.w	r2, #0
 8002888:	701a      	strb	r2, [r3, #0]

        menu_level--;
 800288a:	4b97      	ldr	r3, [pc, #604]	; (8002ae8 <Watering+0x28c>)
 800288c:	781b      	ldrb	r3, [r3, #0]
 800288e:	f103 33ff 	add.w	r3, r3, #4294967295
 8002892:	b2da      	uxtb	r2, r3
 8002894:	4b94      	ldr	r3, [pc, #592]	; (8002ae8 <Watering+0x28c>)
 8002896:	701a      	strb	r2, [r3, #0]
        menu_current = &menu_level_current[menu_level];
 8002898:	4b93      	ldr	r3, [pc, #588]	; (8002ae8 <Watering+0x28c>)
 800289a:	781b      	ldrb	r3, [r3, #0]
 800289c:	461a      	mov	r2, r3
 800289e:	4613      	mov	r3, r2
 80028a0:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80028a4:	1a9b      	subs	r3, r3, r2
 80028a6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80028aa:	4a90      	ldr	r2, [pc, #576]	; (8002aec <Watering+0x290>)
 80028ac:	189a      	adds	r2, r3, r2
 80028ae:	4b90      	ldr	r3, [pc, #576]	; (8002af0 <Watering+0x294>)
 80028b0:	601a      	str	r2, [r3, #0]
        menu_first = &menu_level_first[menu_level];
 80028b2:	4b8d      	ldr	r3, [pc, #564]	; (8002ae8 <Watering+0x28c>)
 80028b4:	781b      	ldrb	r3, [r3, #0]
 80028b6:	461a      	mov	r2, r3
 80028b8:	4613      	mov	r3, r2
 80028ba:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80028be:	1a9b      	subs	r3, r3, r2
 80028c0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80028c4:	4a8b      	ldr	r2, [pc, #556]	; (8002af4 <Watering+0x298>)
 80028c6:	189a      	adds	r2, r3, r2
 80028c8:	4b8b      	ldr	r3, [pc, #556]	; (8002af8 <Watering+0x29c>)
 80028ca:	601a      	str	r2, [r3, #0]
        watering_temporary = &watering[(menu_current->designator)];
 80028cc:	4b88      	ldr	r3, [pc, #544]	; (8002af0 <Watering+0x294>)
 80028ce:	681b      	ldr	r3, [r3, #0]
 80028d0:	791b      	ldrb	r3, [r3, #4]
 80028d2:	461a      	mov	r2, r3
 80028d4:	4613      	mov	r3, r2
 80028d6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80028da:	189b      	adds	r3, r3, r2
 80028dc:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80028e0:	4a86      	ldr	r2, [pc, #536]	; (8002afc <Watering+0x2a0>)
 80028e2:	189a      	adds	r2, r3, r2
 80028e4:	4b86      	ldr	r3, [pc, #536]	; (8002b00 <Watering+0x2a4>)
 80028e6:	601a      	str	r2, [r3, #0]
    }

    if(param == watering_delete.designator)
 80028e8:	4b7b      	ldr	r3, [pc, #492]	; (8002ad8 <Watering+0x27c>)
 80028ea:	791b      	ldrb	r3, [r3, #4]
 80028ec:	79fa      	ldrb	r2, [r7, #7]
 80028ee:	429a      	cmp	r2, r3
 80028f0:	f040 810c 	bne.w	8002b0c <Watering+0x2b0>
    {
    	if(!TimeCompare(watering_temporary))
 80028f4:	4b82      	ldr	r3, [pc, #520]	; (8002b00 <Watering+0x2a4>)
 80028f6:	681b      	ldr	r3, [r3, #0]
 80028f8:	4618      	mov	r0, r3
 80028fa:	f7fe fad3 	bl	8000ea4 <TimeCompare>
 80028fe:	4603      	mov	r3, r0
 8002900:	2b00      	cmp	r3, #0
 8002902:	d11d      	bne.n	8002940 <Watering+0xe4>
    	{
    		OutputOff(Output_all);
 8002904:	f04f 000b 	mov.w	r0, #11
 8002908:	f7fe fabc 	bl	8000e84 <OutputOff>
    	    watering_prcess1.nev[0] = '0';
 800290c:	4b7d      	ldr	r3, [pc, #500]	; (8002b04 <Watering+0x2a8>)
 800290e:	681b      	ldr	r3, [r3, #0]
 8002910:	f04f 0230 	mov.w	r2, #48	; 0x30
 8002914:	701a      	strb	r2, [r3, #0]
    	    watering_prcess1.nev[1] = '0';
 8002916:	4b7b      	ldr	r3, [pc, #492]	; (8002b04 <Watering+0x2a8>)
 8002918:	681b      	ldr	r3, [r3, #0]
 800291a:	f103 0301 	add.w	r3, r3, #1
 800291e:	f04f 0230 	mov.w	r2, #48	; 0x30
 8002922:	701a      	strb	r2, [r3, #0]
    	    watering_prcess1.nev[3] = '0';
 8002924:	4b77      	ldr	r3, [pc, #476]	; (8002b04 <Watering+0x2a8>)
 8002926:	681b      	ldr	r3, [r3, #0]
 8002928:	f103 0303 	add.w	r3, r3, #3
 800292c:	f04f 0230 	mov.w	r2, #48	; 0x30
 8002930:	701a      	strb	r2, [r3, #0]
    	    watering_prcess1.nev[4] = '0';
 8002932:	4b74      	ldr	r3, [pc, #464]	; (8002b04 <Watering+0x2a8>)
 8002934:	681b      	ldr	r3, [r3, #0]
 8002936:	f103 0304 	add.w	r3, r3, #4
 800293a:	f04f 0230 	mov.w	r2, #48	; 0x30
 800293e:	701a      	strb	r2, [r3, #0]
    	}

    	watering_temp[watering_temporary->designator - 1][8] = watering_temp[watering_temporary->designator - 1][9] = watering_temp[watering_temporary->designator - 1][11] = 'x';
 8002940:	4b6f      	ldr	r3, [pc, #444]	; (8002b00 <Watering+0x2a4>)
 8002942:	681b      	ldr	r3, [r3, #0]
 8002944:	791b      	ldrb	r3, [r3, #4]
 8002946:	f103 30ff 	add.w	r0, r3, #4294967295
 800294a:	4b6d      	ldr	r3, [pc, #436]	; (8002b00 <Watering+0x2a4>)
 800294c:	681b      	ldr	r3, [r3, #0]
 800294e:	791b      	ldrb	r3, [r3, #4]
 8002950:	f103 32ff 	add.w	r2, r3, #4294967295
 8002954:	4b6a      	ldr	r3, [pc, #424]	; (8002b00 <Watering+0x2a4>)
 8002956:	681b      	ldr	r3, [r3, #0]
 8002958:	791b      	ldrb	r3, [r3, #4]
 800295a:	f103 31ff 	add.w	r1, r3, #4294967295
 800295e:	4c6a      	ldr	r4, [pc, #424]	; (8002b08 <Watering+0x2ac>)
 8002960:	460b      	mov	r3, r1
 8002962:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002966:	185b      	adds	r3, r3, r1
 8002968:	18e3      	adds	r3, r4, r3
 800296a:	f103 030b 	add.w	r3, r3, #11
 800296e:	f04f 0478 	mov.w	r4, #120	; 0x78
 8002972:	701c      	strb	r4, [r3, #0]
 8002974:	4c64      	ldr	r4, [pc, #400]	; (8002b08 <Watering+0x2ac>)
 8002976:	460b      	mov	r3, r1
 8002978:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800297c:	185b      	adds	r3, r3, r1
 800297e:	18e3      	adds	r3, r4, r3
 8002980:	f103 030b 	add.w	r3, r3, #11
 8002984:	7819      	ldrb	r1, [r3, #0]
 8002986:	4c60      	ldr	r4, [pc, #384]	; (8002b08 <Watering+0x2ac>)
 8002988:	4613      	mov	r3, r2
 800298a:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800298e:	189b      	adds	r3, r3, r2
 8002990:	18e3      	adds	r3, r4, r3
 8002992:	f103 0309 	add.w	r3, r3, #9
 8002996:	7019      	strb	r1, [r3, #0]
 8002998:	495b      	ldr	r1, [pc, #364]	; (8002b08 <Watering+0x2ac>)
 800299a:	4613      	mov	r3, r2
 800299c:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80029a0:	189b      	adds	r3, r3, r2
 80029a2:	18cb      	adds	r3, r1, r3
 80029a4:	f103 0309 	add.w	r3, r3, #9
 80029a8:	781a      	ldrb	r2, [r3, #0]
 80029aa:	4957      	ldr	r1, [pc, #348]	; (8002b08 <Watering+0x2ac>)
 80029ac:	4603      	mov	r3, r0
 80029ae:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80029b2:	181b      	adds	r3, r3, r0
 80029b4:	18cb      	adds	r3, r1, r3
 80029b6:	f103 0308 	add.w	r3, r3, #8
 80029ba:	701a      	strb	r2, [r3, #0]
    	watering_temp[watering_temporary->designator - 1][6] = '1';
 80029bc:	4b50      	ldr	r3, [pc, #320]	; (8002b00 <Watering+0x2a4>)
 80029be:	681b      	ldr	r3, [r3, #0]
 80029c0:	791b      	ldrb	r3, [r3, #4]
 80029c2:	f103 32ff 	add.w	r2, r3, #4294967295
 80029c6:	4950      	ldr	r1, [pc, #320]	; (8002b08 <Watering+0x2ac>)
 80029c8:	4613      	mov	r3, r2
 80029ca:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80029ce:	189b      	adds	r3, r3, r2
 80029d0:	18cb      	adds	r3, r1, r3
 80029d2:	f103 0306 	add.w	r3, r3, #6
 80029d6:	f04f 0231 	mov.w	r2, #49	; 0x31
 80029da:	701a      	strb	r2, [r3, #0]
    	watering_temp[watering_temporary->designator - 1][12] = watering_temp[watering_temporary->designator - 1][14] = watering_temp[watering_temporary->designator - 1][15] = 'x';
 80029dc:	4b48      	ldr	r3, [pc, #288]	; (8002b00 <Watering+0x2a4>)
 80029de:	681b      	ldr	r3, [r3, #0]
 80029e0:	791b      	ldrb	r3, [r3, #4]
 80029e2:	f103 30ff 	add.w	r0, r3, #4294967295
 80029e6:	4b46      	ldr	r3, [pc, #280]	; (8002b00 <Watering+0x2a4>)
 80029e8:	681b      	ldr	r3, [r3, #0]
 80029ea:	791b      	ldrb	r3, [r3, #4]
 80029ec:	f103 32ff 	add.w	r2, r3, #4294967295
 80029f0:	4b43      	ldr	r3, [pc, #268]	; (8002b00 <Watering+0x2a4>)
 80029f2:	681b      	ldr	r3, [r3, #0]
 80029f4:	791b      	ldrb	r3, [r3, #4]
 80029f6:	f103 31ff 	add.w	r1, r3, #4294967295
 80029fa:	4c43      	ldr	r4, [pc, #268]	; (8002b08 <Watering+0x2ac>)
 80029fc:	460b      	mov	r3, r1
 80029fe:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002a02:	185b      	adds	r3, r3, r1
 8002a04:	18e3      	adds	r3, r4, r3
 8002a06:	f103 030f 	add.w	r3, r3, #15
 8002a0a:	f04f 0478 	mov.w	r4, #120	; 0x78
 8002a0e:	701c      	strb	r4, [r3, #0]
 8002a10:	4c3d      	ldr	r4, [pc, #244]	; (8002b08 <Watering+0x2ac>)
 8002a12:	460b      	mov	r3, r1
 8002a14:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002a18:	185b      	adds	r3, r3, r1
 8002a1a:	18e3      	adds	r3, r4, r3
 8002a1c:	f103 030f 	add.w	r3, r3, #15
 8002a20:	7819      	ldrb	r1, [r3, #0]
 8002a22:	4c39      	ldr	r4, [pc, #228]	; (8002b08 <Watering+0x2ac>)
 8002a24:	4613      	mov	r3, r2
 8002a26:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002a2a:	189b      	adds	r3, r3, r2
 8002a2c:	18e3      	adds	r3, r4, r3
 8002a2e:	f103 030e 	add.w	r3, r3, #14
 8002a32:	7019      	strb	r1, [r3, #0]
 8002a34:	4934      	ldr	r1, [pc, #208]	; (8002b08 <Watering+0x2ac>)
 8002a36:	4613      	mov	r3, r2
 8002a38:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002a3c:	189b      	adds	r3, r3, r2
 8002a3e:	18cb      	adds	r3, r1, r3
 8002a40:	f103 030e 	add.w	r3, r3, #14
 8002a44:	781a      	ldrb	r2, [r3, #0]
 8002a46:	4930      	ldr	r1, [pc, #192]	; (8002b08 <Watering+0x2ac>)
 8002a48:	4603      	mov	r3, r0
 8002a4a:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002a4e:	181b      	adds	r3, r3, r0
 8002a50:	18cb      	adds	r3, r1, r3
 8002a52:	f103 030c 	add.w	r3, r3, #12
 8002a56:	701a      	strb	r2, [r3, #0]

    	Watering_Next_Set();
 8002a58:	f7fe fc02 	bl	8001260 <Watering_Next_Set>

        ClearLcmScreen();
 8002a5c:	f7fd fe6a 	bl	8000734 <ClearLcmScreen>

        menu_level--;
 8002a60:	4b21      	ldr	r3, [pc, #132]	; (8002ae8 <Watering+0x28c>)
 8002a62:	781b      	ldrb	r3, [r3, #0]
 8002a64:	f103 33ff 	add.w	r3, r3, #4294967295
 8002a68:	b2da      	uxtb	r2, r3
 8002a6a:	4b1f      	ldr	r3, [pc, #124]	; (8002ae8 <Watering+0x28c>)
 8002a6c:	701a      	strb	r2, [r3, #0]
        menu_current = &menu_level_current[menu_level];
 8002a6e:	4b1e      	ldr	r3, [pc, #120]	; (8002ae8 <Watering+0x28c>)
 8002a70:	781b      	ldrb	r3, [r3, #0]
 8002a72:	461a      	mov	r2, r3
 8002a74:	4613      	mov	r3, r2
 8002a76:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8002a7a:	1a9b      	subs	r3, r3, r2
 8002a7c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002a80:	4a1a      	ldr	r2, [pc, #104]	; (8002aec <Watering+0x290>)
 8002a82:	189a      	adds	r2, r3, r2
 8002a84:	4b1a      	ldr	r3, [pc, #104]	; (8002af0 <Watering+0x294>)
 8002a86:	601a      	str	r2, [r3, #0]
        menu_first = &menu_level_first[menu_level];
 8002a88:	4b17      	ldr	r3, [pc, #92]	; (8002ae8 <Watering+0x28c>)
 8002a8a:	781b      	ldrb	r3, [r3, #0]
 8002a8c:	461a      	mov	r2, r3
 8002a8e:	4613      	mov	r3, r2
 8002a90:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8002a94:	1a9b      	subs	r3, r3, r2
 8002a96:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002a9a:	4a16      	ldr	r2, [pc, #88]	; (8002af4 <Watering+0x298>)
 8002a9c:	189a      	adds	r2, r3, r2
 8002a9e:	4b16      	ldr	r3, [pc, #88]	; (8002af8 <Watering+0x29c>)
 8002aa0:	601a      	str	r2, [r3, #0]

        DisplayFill(*menu_current, *menu_first);
 8002aa2:	4b13      	ldr	r3, [pc, #76]	; (8002af0 <Watering+0x294>)
 8002aa4:	681e      	ldr	r6, [r3, #0]
 8002aa6:	4b14      	ldr	r3, [pc, #80]	; (8002af8 <Watering+0x29c>)
 8002aa8:	681b      	ldr	r3, [r3, #0]
 8002aaa:	ad03      	add	r5, sp, #12
 8002aac:	461c      	mov	r4, r3
 8002aae:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8002ab0:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8002ab2:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8002ab6:	e885 0007 	stmia.w	r5, {r0, r1, r2}
 8002aba:	466b      	mov	r3, sp
 8002abc:	f106 0210 	add.w	r2, r6, #16
 8002ac0:	ca07      	ldmia	r2, {r0, r1, r2}
 8002ac2:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 8002ac6:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 8002aca:	f7fe f88b 	bl	8000be4 <DisplayFill>
        menu_special_function = 0;
 8002ace:	4b04      	ldr	r3, [pc, #16]	; (8002ae0 <Watering+0x284>)
 8002ad0:	f04f 0200 	mov.w	r2, #0
 8002ad4:	701a      	strb	r2, [r3, #0]
 8002ad6:	e33d      	b.n	8003154 <Watering+0x8f8>
 8002ad8:	20000cf4 	.word	0x20000cf4
 8002adc:	20001318 	.word	0x20001318
 8002ae0:	20000e12 	.word	0x20000e12
 8002ae4:	20000fa8 	.word	0x20000fa8
 8002ae8:	2000130e 	.word	0x2000130e
 8002aec:	20001054 	.word	0x20001054
 8002af0:	2000124c 	.word	0x2000124c
 8002af4:	20000eb8 	.word	0x20000eb8
 8002af8:	20000d48 	.word	0x20000d48
 8002afc:	20001134 	.word	0x20001134
 8002b00:	20000e60 	.word	0x20000e60
 8002b04:	20001034 	.word	0x20001034
 8002b08:	20000dac 	.word	0x20000dac
    }

    else if(param == watering_edit.designator)
 8002b0c:	4ba6      	ldr	r3, [pc, #664]	; (8002da8 <Watering+0x54c>)
 8002b0e:	791b      	ldrb	r3, [r3, #4]
 8002b10:	79fa      	ldrb	r2, [r7, #7]
 8002b12:	429a      	cmp	r2, r3
 8002b14:	f040 81c0 	bne.w	8002e98 <Watering+0x63c>
    {
        ClearLcmScreen();
 8002b18:	f7fd fe0c 	bl	8000734 <ClearLcmScreen>

        watering_function = watering_edit.designator;
 8002b1c:	4ba2      	ldr	r3, [pc, #648]	; (8002da8 <Watering+0x54c>)
 8002b1e:	791a      	ldrb	r2, [r3, #4]
 8002b20:	4ba2      	ldr	r3, [pc, #648]	; (8002dac <Watering+0x550>)
 8002b22:	701a      	strb	r2, [r3, #0]

        datechanger_date[0] = (watering_temp[watering_temporary->designator - 1][8] <= '9' && watering_temp[watering_temporary->designator - 1][8] >= '0') ? watering_temp[watering_temporary->designator - 1][8] : '0';
 8002b24:	4ba2      	ldr	r3, [pc, #648]	; (8002db0 <Watering+0x554>)
 8002b26:	681b      	ldr	r3, [r3, #0]
 8002b28:	791b      	ldrb	r3, [r3, #4]
 8002b2a:	f103 32ff 	add.w	r2, r3, #4294967295
 8002b2e:	49a1      	ldr	r1, [pc, #644]	; (8002db4 <Watering+0x558>)
 8002b30:	4613      	mov	r3, r2
 8002b32:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002b36:	189b      	adds	r3, r3, r2
 8002b38:	18cb      	adds	r3, r1, r3
 8002b3a:	f103 0308 	add.w	r3, r3, #8
 8002b3e:	781b      	ldrb	r3, [r3, #0]
 8002b40:	2b39      	cmp	r3, #57	; 0x39
 8002b42:	d81e      	bhi.n	8002b82 <Watering+0x326>
 8002b44:	4b9a      	ldr	r3, [pc, #616]	; (8002db0 <Watering+0x554>)
 8002b46:	681b      	ldr	r3, [r3, #0]
 8002b48:	791b      	ldrb	r3, [r3, #4]
 8002b4a:	f103 32ff 	add.w	r2, r3, #4294967295
 8002b4e:	4999      	ldr	r1, [pc, #612]	; (8002db4 <Watering+0x558>)
 8002b50:	4613      	mov	r3, r2
 8002b52:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002b56:	189b      	adds	r3, r3, r2
 8002b58:	18cb      	adds	r3, r1, r3
 8002b5a:	f103 0308 	add.w	r3, r3, #8
 8002b5e:	781b      	ldrb	r3, [r3, #0]
 8002b60:	2b2f      	cmp	r3, #47	; 0x2f
 8002b62:	d90e      	bls.n	8002b82 <Watering+0x326>
 8002b64:	4b92      	ldr	r3, [pc, #584]	; (8002db0 <Watering+0x554>)
 8002b66:	681b      	ldr	r3, [r3, #0]
 8002b68:	791b      	ldrb	r3, [r3, #4]
 8002b6a:	f103 32ff 	add.w	r2, r3, #4294967295
 8002b6e:	4991      	ldr	r1, [pc, #580]	; (8002db4 <Watering+0x558>)
 8002b70:	4613      	mov	r3, r2
 8002b72:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002b76:	189b      	adds	r3, r3, r2
 8002b78:	18cb      	adds	r3, r1, r3
 8002b7a:	f103 0308 	add.w	r3, r3, #8
 8002b7e:	781b      	ldrb	r3, [r3, #0]
 8002b80:	e001      	b.n	8002b86 <Watering+0x32a>
 8002b82:	f04f 0330 	mov.w	r3, #48	; 0x30
 8002b86:	4a8c      	ldr	r2, [pc, #560]	; (8002db8 <Watering+0x55c>)
 8002b88:	7013      	strb	r3, [r2, #0]
        datechanger_date[1] = (watering_temp[watering_temporary->designator - 1][9] <= '9' && watering_temp[watering_temporary->designator - 1][9] >= '0') ? watering_temp[watering_temporary->designator - 1][9] : '0';
 8002b8a:	4b89      	ldr	r3, [pc, #548]	; (8002db0 <Watering+0x554>)
 8002b8c:	681b      	ldr	r3, [r3, #0]
 8002b8e:	791b      	ldrb	r3, [r3, #4]
 8002b90:	f103 32ff 	add.w	r2, r3, #4294967295
 8002b94:	4987      	ldr	r1, [pc, #540]	; (8002db4 <Watering+0x558>)
 8002b96:	4613      	mov	r3, r2
 8002b98:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002b9c:	189b      	adds	r3, r3, r2
 8002b9e:	18cb      	adds	r3, r1, r3
 8002ba0:	f103 0309 	add.w	r3, r3, #9
 8002ba4:	781b      	ldrb	r3, [r3, #0]
 8002ba6:	2b39      	cmp	r3, #57	; 0x39
 8002ba8:	d81e      	bhi.n	8002be8 <Watering+0x38c>
 8002baa:	4b81      	ldr	r3, [pc, #516]	; (8002db0 <Watering+0x554>)
 8002bac:	681b      	ldr	r3, [r3, #0]
 8002bae:	791b      	ldrb	r3, [r3, #4]
 8002bb0:	f103 32ff 	add.w	r2, r3, #4294967295
 8002bb4:	497f      	ldr	r1, [pc, #508]	; (8002db4 <Watering+0x558>)
 8002bb6:	4613      	mov	r3, r2
 8002bb8:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002bbc:	189b      	adds	r3, r3, r2
 8002bbe:	18cb      	adds	r3, r1, r3
 8002bc0:	f103 0309 	add.w	r3, r3, #9
 8002bc4:	781b      	ldrb	r3, [r3, #0]
 8002bc6:	2b2f      	cmp	r3, #47	; 0x2f
 8002bc8:	d90e      	bls.n	8002be8 <Watering+0x38c>
 8002bca:	4b79      	ldr	r3, [pc, #484]	; (8002db0 <Watering+0x554>)
 8002bcc:	681b      	ldr	r3, [r3, #0]
 8002bce:	791b      	ldrb	r3, [r3, #4]
 8002bd0:	f103 32ff 	add.w	r2, r3, #4294967295
 8002bd4:	4977      	ldr	r1, [pc, #476]	; (8002db4 <Watering+0x558>)
 8002bd6:	4613      	mov	r3, r2
 8002bd8:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002bdc:	189b      	adds	r3, r3, r2
 8002bde:	18cb      	adds	r3, r1, r3
 8002be0:	f103 0309 	add.w	r3, r3, #9
 8002be4:	781b      	ldrb	r3, [r3, #0]
 8002be6:	e001      	b.n	8002bec <Watering+0x390>
 8002be8:	f04f 0330 	mov.w	r3, #48	; 0x30
 8002bec:	4a72      	ldr	r2, [pc, #456]	; (8002db8 <Watering+0x55c>)
 8002bee:	7053      	strb	r3, [r2, #1]
        datechanger_date[3] = (watering_temp[watering_temporary->designator - 1][11] <= '9' && watering_temp[watering_temporary->designator - 1][11] >= '0') ? watering_temp[watering_temporary->designator - 1][11] : '0';
 8002bf0:	4b6f      	ldr	r3, [pc, #444]	; (8002db0 <Watering+0x554>)
 8002bf2:	681b      	ldr	r3, [r3, #0]
 8002bf4:	791b      	ldrb	r3, [r3, #4]
 8002bf6:	f103 32ff 	add.w	r2, r3, #4294967295
 8002bfa:	496e      	ldr	r1, [pc, #440]	; (8002db4 <Watering+0x558>)
 8002bfc:	4613      	mov	r3, r2
 8002bfe:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002c02:	189b      	adds	r3, r3, r2
 8002c04:	18cb      	adds	r3, r1, r3
 8002c06:	f103 030b 	add.w	r3, r3, #11
 8002c0a:	781b      	ldrb	r3, [r3, #0]
 8002c0c:	2b39      	cmp	r3, #57	; 0x39
 8002c0e:	d81e      	bhi.n	8002c4e <Watering+0x3f2>
 8002c10:	4b67      	ldr	r3, [pc, #412]	; (8002db0 <Watering+0x554>)
 8002c12:	681b      	ldr	r3, [r3, #0]
 8002c14:	791b      	ldrb	r3, [r3, #4]
 8002c16:	f103 32ff 	add.w	r2, r3, #4294967295
 8002c1a:	4966      	ldr	r1, [pc, #408]	; (8002db4 <Watering+0x558>)
 8002c1c:	4613      	mov	r3, r2
 8002c1e:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002c22:	189b      	adds	r3, r3, r2
 8002c24:	18cb      	adds	r3, r1, r3
 8002c26:	f103 030b 	add.w	r3, r3, #11
 8002c2a:	781b      	ldrb	r3, [r3, #0]
 8002c2c:	2b2f      	cmp	r3, #47	; 0x2f
 8002c2e:	d90e      	bls.n	8002c4e <Watering+0x3f2>
 8002c30:	4b5f      	ldr	r3, [pc, #380]	; (8002db0 <Watering+0x554>)
 8002c32:	681b      	ldr	r3, [r3, #0]
 8002c34:	791b      	ldrb	r3, [r3, #4]
 8002c36:	f103 32ff 	add.w	r2, r3, #4294967295
 8002c3a:	495e      	ldr	r1, [pc, #376]	; (8002db4 <Watering+0x558>)
 8002c3c:	4613      	mov	r3, r2
 8002c3e:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002c42:	189b      	adds	r3, r3, r2
 8002c44:	18cb      	adds	r3, r1, r3
 8002c46:	f103 030b 	add.w	r3, r3, #11
 8002c4a:	781b      	ldrb	r3, [r3, #0]
 8002c4c:	e001      	b.n	8002c52 <Watering+0x3f6>
 8002c4e:	f04f 0330 	mov.w	r3, #48	; 0x30
 8002c52:	4a59      	ldr	r2, [pc, #356]	; (8002db8 <Watering+0x55c>)
 8002c54:	70d3      	strb	r3, [r2, #3]
        datechanger_date[4] = (watering_temp[watering_temporary->designator - 1][12] <= '9' && watering_temp[watering_temporary->designator - 1][12] >= '0') ? watering_temp[watering_temporary->designator - 1][12] : '0';
 8002c56:	4b56      	ldr	r3, [pc, #344]	; (8002db0 <Watering+0x554>)
 8002c58:	681b      	ldr	r3, [r3, #0]
 8002c5a:	791b      	ldrb	r3, [r3, #4]
 8002c5c:	f103 32ff 	add.w	r2, r3, #4294967295
 8002c60:	4954      	ldr	r1, [pc, #336]	; (8002db4 <Watering+0x558>)
 8002c62:	4613      	mov	r3, r2
 8002c64:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002c68:	189b      	adds	r3, r3, r2
 8002c6a:	18cb      	adds	r3, r1, r3
 8002c6c:	f103 030c 	add.w	r3, r3, #12
 8002c70:	781b      	ldrb	r3, [r3, #0]
 8002c72:	2b39      	cmp	r3, #57	; 0x39
 8002c74:	d81e      	bhi.n	8002cb4 <Watering+0x458>
 8002c76:	4b4e      	ldr	r3, [pc, #312]	; (8002db0 <Watering+0x554>)
 8002c78:	681b      	ldr	r3, [r3, #0]
 8002c7a:	791b      	ldrb	r3, [r3, #4]
 8002c7c:	f103 32ff 	add.w	r2, r3, #4294967295
 8002c80:	494c      	ldr	r1, [pc, #304]	; (8002db4 <Watering+0x558>)
 8002c82:	4613      	mov	r3, r2
 8002c84:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002c88:	189b      	adds	r3, r3, r2
 8002c8a:	18cb      	adds	r3, r1, r3
 8002c8c:	f103 030c 	add.w	r3, r3, #12
 8002c90:	781b      	ldrb	r3, [r3, #0]
 8002c92:	2b2f      	cmp	r3, #47	; 0x2f
 8002c94:	d90e      	bls.n	8002cb4 <Watering+0x458>
 8002c96:	4b46      	ldr	r3, [pc, #280]	; (8002db0 <Watering+0x554>)
 8002c98:	681b      	ldr	r3, [r3, #0]
 8002c9a:	791b      	ldrb	r3, [r3, #4]
 8002c9c:	f103 32ff 	add.w	r2, r3, #4294967295
 8002ca0:	4944      	ldr	r1, [pc, #272]	; (8002db4 <Watering+0x558>)
 8002ca2:	4613      	mov	r3, r2
 8002ca4:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002ca8:	189b      	adds	r3, r3, r2
 8002caa:	18cb      	adds	r3, r1, r3
 8002cac:	f103 030c 	add.w	r3, r3, #12
 8002cb0:	781b      	ldrb	r3, [r3, #0]
 8002cb2:	e001      	b.n	8002cb8 <Watering+0x45c>
 8002cb4:	f04f 0330 	mov.w	r3, #48	; 0x30
 8002cb8:	4a3f      	ldr	r2, [pc, #252]	; (8002db8 <Watering+0x55c>)
 8002cba:	7113      	strb	r3, [r2, #4]
        datechanger_date[6] = datechanger_date[7] = '0';
 8002cbc:	4b3e      	ldr	r3, [pc, #248]	; (8002db8 <Watering+0x55c>)
 8002cbe:	f04f 0230 	mov.w	r2, #48	; 0x30
 8002cc2:	71da      	strb	r2, [r3, #7]
 8002cc4:	4b3c      	ldr	r3, [pc, #240]	; (8002db8 <Watering+0x55c>)
 8002cc6:	79da      	ldrb	r2, [r3, #7]
 8002cc8:	4b3b      	ldr	r3, [pc, #236]	; (8002db8 <Watering+0x55c>)
 8002cca:	719a      	strb	r2, [r3, #6]
        datechanger_date[2] = datechanger_date[5] = ':';
 8002ccc:	4b3a      	ldr	r3, [pc, #232]	; (8002db8 <Watering+0x55c>)
 8002cce:	f04f 023a 	mov.w	r2, #58	; 0x3a
 8002cd2:	715a      	strb	r2, [r3, #5]
 8002cd4:	4b38      	ldr	r3, [pc, #224]	; (8002db8 <Watering+0x55c>)
 8002cd6:	795a      	ldrb	r2, [r3, #5]
 8002cd8:	4b37      	ldr	r3, [pc, #220]	; (8002db8 <Watering+0x55c>)
 8002cda:	709a      	strb	r2, [r3, #2]
        datechanger_date[8]='\0';
 8002cdc:	4b36      	ldr	r3, [pc, #216]	; (8002db8 <Watering+0x55c>)
 8002cde:	f04f 0200 	mov.w	r2, #0
 8002ce2:	721a      	strb	r2, [r3, #8]

        watering_lenght[0] = (watering_temp[watering_temporary->designator - 1][14] <= '9' && watering_temp[watering_temporary->designator - 1][14] >= '0') ? watering_temp[watering_temporary->designator - 1][14] : '0';
 8002ce4:	4b32      	ldr	r3, [pc, #200]	; (8002db0 <Watering+0x554>)
 8002ce6:	681b      	ldr	r3, [r3, #0]
 8002ce8:	791b      	ldrb	r3, [r3, #4]
 8002cea:	f103 32ff 	add.w	r2, r3, #4294967295
 8002cee:	4931      	ldr	r1, [pc, #196]	; (8002db4 <Watering+0x558>)
 8002cf0:	4613      	mov	r3, r2
 8002cf2:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002cf6:	189b      	adds	r3, r3, r2
 8002cf8:	18cb      	adds	r3, r1, r3
 8002cfa:	f103 030e 	add.w	r3, r3, #14
 8002cfe:	781b      	ldrb	r3, [r3, #0]
 8002d00:	2b39      	cmp	r3, #57	; 0x39
 8002d02:	d81e      	bhi.n	8002d42 <Watering+0x4e6>
 8002d04:	4b2a      	ldr	r3, [pc, #168]	; (8002db0 <Watering+0x554>)
 8002d06:	681b      	ldr	r3, [r3, #0]
 8002d08:	791b      	ldrb	r3, [r3, #4]
 8002d0a:	f103 32ff 	add.w	r2, r3, #4294967295
 8002d0e:	4929      	ldr	r1, [pc, #164]	; (8002db4 <Watering+0x558>)
 8002d10:	4613      	mov	r3, r2
 8002d12:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002d16:	189b      	adds	r3, r3, r2
 8002d18:	18cb      	adds	r3, r1, r3
 8002d1a:	f103 030e 	add.w	r3, r3, #14
 8002d1e:	781b      	ldrb	r3, [r3, #0]
 8002d20:	2b2f      	cmp	r3, #47	; 0x2f
 8002d22:	d90e      	bls.n	8002d42 <Watering+0x4e6>
 8002d24:	4b22      	ldr	r3, [pc, #136]	; (8002db0 <Watering+0x554>)
 8002d26:	681b      	ldr	r3, [r3, #0]
 8002d28:	791b      	ldrb	r3, [r3, #4]
 8002d2a:	f103 32ff 	add.w	r2, r3, #4294967295
 8002d2e:	4921      	ldr	r1, [pc, #132]	; (8002db4 <Watering+0x558>)
 8002d30:	4613      	mov	r3, r2
 8002d32:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002d36:	189b      	adds	r3, r3, r2
 8002d38:	18cb      	adds	r3, r1, r3
 8002d3a:	f103 030e 	add.w	r3, r3, #14
 8002d3e:	781b      	ldrb	r3, [r3, #0]
 8002d40:	e001      	b.n	8002d46 <Watering+0x4ea>
 8002d42:	f04f 0330 	mov.w	r3, #48	; 0x30
 8002d46:	4a1d      	ldr	r2, [pc, #116]	; (8002dbc <Watering+0x560>)
 8002d48:	7013      	strb	r3, [r2, #0]
        watering_lenght[1] = (watering_temp[watering_temporary->designator - 1][15] <= '9' && watering_temp[watering_temporary->designator - 1][15] >= '0') ? watering_temp[watering_temporary->designator - 1][15] : '0';
 8002d4a:	4b19      	ldr	r3, [pc, #100]	; (8002db0 <Watering+0x554>)
 8002d4c:	681b      	ldr	r3, [r3, #0]
 8002d4e:	791b      	ldrb	r3, [r3, #4]
 8002d50:	f103 32ff 	add.w	r2, r3, #4294967295
 8002d54:	4917      	ldr	r1, [pc, #92]	; (8002db4 <Watering+0x558>)
 8002d56:	4613      	mov	r3, r2
 8002d58:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002d5c:	189b      	adds	r3, r3, r2
 8002d5e:	18cb      	adds	r3, r1, r3
 8002d60:	f103 030f 	add.w	r3, r3, #15
 8002d64:	781b      	ldrb	r3, [r3, #0]
 8002d66:	2b39      	cmp	r3, #57	; 0x39
 8002d68:	d82a      	bhi.n	8002dc0 <Watering+0x564>
 8002d6a:	4b11      	ldr	r3, [pc, #68]	; (8002db0 <Watering+0x554>)
 8002d6c:	681b      	ldr	r3, [r3, #0]
 8002d6e:	791b      	ldrb	r3, [r3, #4]
 8002d70:	f103 32ff 	add.w	r2, r3, #4294967295
 8002d74:	490f      	ldr	r1, [pc, #60]	; (8002db4 <Watering+0x558>)
 8002d76:	4613      	mov	r3, r2
 8002d78:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002d7c:	189b      	adds	r3, r3, r2
 8002d7e:	18cb      	adds	r3, r1, r3
 8002d80:	f103 030f 	add.w	r3, r3, #15
 8002d84:	781b      	ldrb	r3, [r3, #0]
 8002d86:	2b2f      	cmp	r3, #47	; 0x2f
 8002d88:	d91a      	bls.n	8002dc0 <Watering+0x564>
 8002d8a:	4b09      	ldr	r3, [pc, #36]	; (8002db0 <Watering+0x554>)
 8002d8c:	681b      	ldr	r3, [r3, #0]
 8002d8e:	791b      	ldrb	r3, [r3, #4]
 8002d90:	f103 32ff 	add.w	r2, r3, #4294967295
 8002d94:	4907      	ldr	r1, [pc, #28]	; (8002db4 <Watering+0x558>)
 8002d96:	4613      	mov	r3, r2
 8002d98:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002d9c:	189b      	adds	r3, r3, r2
 8002d9e:	18cb      	adds	r3, r1, r3
 8002da0:	f103 030f 	add.w	r3, r3, #15
 8002da4:	781b      	ldrb	r3, [r3, #0]
 8002da6:	e00d      	b.n	8002dc4 <Watering+0x568>
 8002da8:	20001318 	.word	0x20001318
 8002dac:	20000d6c 	.word	0x20000d6c
 8002db0:	20000e60 	.word	0x20000e60
 8002db4:	20000dac 	.word	0x20000dac
 8002db8:	200012fc 	.word	0x200012fc
 8002dbc:	20000e3c 	.word	0x20000e3c
 8002dc0:	f04f 0330 	mov.w	r3, #48	; 0x30
 8002dc4:	4a9a      	ldr	r2, [pc, #616]	; (8003030 <Watering+0x7d4>)
 8002dc6:	7053      	strb	r3, [r2, #1]
        watering_lenght[2] = '\0';
 8002dc8:	4b99      	ldr	r3, [pc, #612]	; (8003030 <Watering+0x7d4>)
 8002dca:	f04f 0200 	mov.w	r2, #0
 8002dce:	709a      	strb	r2, [r3, #2]

        watering_channel[0] = (watering_temp[watering_temporary->designator - 1][6] <= '9' && watering_temp[watering_temporary->designator - 1][6] >= '1') ? watering_temp[watering_temporary->designator - 1][6] : '1';
 8002dd0:	4b98      	ldr	r3, [pc, #608]	; (8003034 <Watering+0x7d8>)
 8002dd2:	681b      	ldr	r3, [r3, #0]
 8002dd4:	791b      	ldrb	r3, [r3, #4]
 8002dd6:	f103 32ff 	add.w	r2, r3, #4294967295
 8002dda:	4997      	ldr	r1, [pc, #604]	; (8003038 <Watering+0x7dc>)
 8002ddc:	4613      	mov	r3, r2
 8002dde:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002de2:	189b      	adds	r3, r3, r2
 8002de4:	18cb      	adds	r3, r1, r3
 8002de6:	f103 0306 	add.w	r3, r3, #6
 8002dea:	781b      	ldrb	r3, [r3, #0]
 8002dec:	2b39      	cmp	r3, #57	; 0x39
 8002dee:	d81e      	bhi.n	8002e2e <Watering+0x5d2>
 8002df0:	4b90      	ldr	r3, [pc, #576]	; (8003034 <Watering+0x7d8>)
 8002df2:	681b      	ldr	r3, [r3, #0]
 8002df4:	791b      	ldrb	r3, [r3, #4]
 8002df6:	f103 32ff 	add.w	r2, r3, #4294967295
 8002dfa:	498f      	ldr	r1, [pc, #572]	; (8003038 <Watering+0x7dc>)
 8002dfc:	4613      	mov	r3, r2
 8002dfe:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002e02:	189b      	adds	r3, r3, r2
 8002e04:	18cb      	adds	r3, r1, r3
 8002e06:	f103 0306 	add.w	r3, r3, #6
 8002e0a:	781b      	ldrb	r3, [r3, #0]
 8002e0c:	2b30      	cmp	r3, #48	; 0x30
 8002e0e:	d90e      	bls.n	8002e2e <Watering+0x5d2>
 8002e10:	4b88      	ldr	r3, [pc, #544]	; (8003034 <Watering+0x7d8>)
 8002e12:	681b      	ldr	r3, [r3, #0]
 8002e14:	791b      	ldrb	r3, [r3, #4]
 8002e16:	f103 32ff 	add.w	r2, r3, #4294967295
 8002e1a:	4987      	ldr	r1, [pc, #540]	; (8003038 <Watering+0x7dc>)
 8002e1c:	4613      	mov	r3, r2
 8002e1e:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002e22:	189b      	adds	r3, r3, r2
 8002e24:	18cb      	adds	r3, r1, r3
 8002e26:	f103 0306 	add.w	r3, r3, #6
 8002e2a:	781b      	ldrb	r3, [r3, #0]
 8002e2c:	e001      	b.n	8002e32 <Watering+0x5d6>
 8002e2e:	f04f 0331 	mov.w	r3, #49	; 0x31
 8002e32:	4a82      	ldr	r2, [pc, #520]	; (800303c <Watering+0x7e0>)
 8002e34:	7013      	strb	r3, [r2, #0]
        watering_channel[1] = '\0';
 8002e36:	4b81      	ldr	r3, [pc, #516]	; (800303c <Watering+0x7e0>)
 8002e38:	f04f 0200 	mov.w	r2, #0
 8002e3c:	705a      	strb	r2, [r3, #1]

        Cursor(0, 0);
 8002e3e:	f04f 0000 	mov.w	r0, #0
 8002e42:	f04f 0100 	mov.w	r1, #0
 8002e46:	f7fd fc3d 	bl	80006c4 <Cursor>
        PrintStr(watering_edit.nev);
 8002e4a:	4b7d      	ldr	r3, [pc, #500]	; (8003040 <Watering+0x7e4>)
 8002e4c:	681b      	ldr	r3, [r3, #0]
 8002e4e:	4618      	mov	r0, r3
 8002e50:	f7fd fe46 	bl	8000ae0 <PrintStr>

        Cursor(1, 0);
 8002e54:	f04f 0001 	mov.w	r0, #1
 8002e58:	f04f 0100 	mov.w	r1, #0
 8002e5c:	f7fd fc32 	bl	80006c4 <Cursor>
        PrintStr(watering_channel);
 8002e60:	4876      	ldr	r0, [pc, #472]	; (800303c <Watering+0x7e0>)
 8002e62:	f7fd fe3d 	bl	8000ae0 <PrintStr>

        Cursor(2, 0);
 8002e66:	f04f 0002 	mov.w	r0, #2
 8002e6a:	f04f 0100 	mov.w	r1, #0
 8002e6e:	f7fd fc29 	bl	80006c4 <Cursor>
        PrintStr(datechanger_date);
 8002e72:	4874      	ldr	r0, [pc, #464]	; (8003044 <Watering+0x7e8>)
 8002e74:	f7fd fe34 	bl	8000ae0 <PrintStr>

        Cursor(3, 0);
 8002e78:	f04f 0003 	mov.w	r0, #3
 8002e7c:	f04f 0100 	mov.w	r1, #0
 8002e80:	f7fd fc20 	bl	80006c4 <Cursor>
        PrintStr(watering_lenght);
 8002e84:	486a      	ldr	r0, [pc, #424]	; (8003030 <Watering+0x7d4>)
 8002e86:	f7fd fe2b 	bl	8000ae0 <PrintStr>
        Cursor(1, 0);
 8002e8a:	f04f 0001 	mov.w	r0, #1
 8002e8e:	f04f 0100 	mov.w	r1, #0
 8002e92:	f7fd fc17 	bl	80006c4 <Cursor>
 8002e96:	e15d      	b.n	8003154 <Watering+0x8f8>
    }


    else if(param == MENU_ENTER)
 8002e98:	79fb      	ldrb	r3, [r7, #7]
 8002e9a:	2b09      	cmp	r3, #9
 8002e9c:	d151      	bne.n	8002f42 <Watering+0x6e6>
    {
        if(watering_i == 0)
 8002e9e:	4b6a      	ldr	r3, [pc, #424]	; (8003048 <Watering+0x7ec>)
 8002ea0:	781b      	ldrb	r3, [r3, #0]
 8002ea2:	2b00      	cmp	r3, #0
 8002ea4:	d111      	bne.n	8002eca <Watering+0x66e>
        {
            watering_i++;
 8002ea6:	4b68      	ldr	r3, [pc, #416]	; (8003048 <Watering+0x7ec>)
 8002ea8:	781b      	ldrb	r3, [r3, #0]
 8002eaa:	f103 0301 	add.w	r3, r3, #1
 8002eae:	b2da      	uxtb	r2, r3
 8002eb0:	4b65      	ldr	r3, [pc, #404]	; (8003048 <Watering+0x7ec>)
 8002eb2:	701a      	strb	r2, [r3, #0]
            Cursor(2, (watering_i) - 1);
 8002eb4:	4b64      	ldr	r3, [pc, #400]	; (8003048 <Watering+0x7ec>)
 8002eb6:	781b      	ldrb	r3, [r3, #0]
 8002eb8:	f103 33ff 	add.w	r3, r3, #4294967295
 8002ebc:	b2db      	uxtb	r3, r3
 8002ebe:	f04f 0002 	mov.w	r0, #2
 8002ec2:	4619      	mov	r1, r3
 8002ec4:	f7fd fbfe 	bl	80006c4 <Cursor>
 8002ec8:	e144      	b.n	8003154 <Watering+0x8f8>
        }

        else if(watering_i < 8)
 8002eca:	4b5f      	ldr	r3, [pc, #380]	; (8003048 <Watering+0x7ec>)
 8002ecc:	781b      	ldrb	r3, [r3, #0]
 8002ece:	2b07      	cmp	r3, #7
 8002ed0:	d820      	bhi.n	8002f14 <Watering+0x6b8>
        {
            watering_i++;
 8002ed2:	4b5d      	ldr	r3, [pc, #372]	; (8003048 <Watering+0x7ec>)
 8002ed4:	781b      	ldrb	r3, [r3, #0]
 8002ed6:	f103 0301 	add.w	r3, r3, #1
 8002eda:	b2da      	uxtb	r2, r3
 8002edc:	4b5a      	ldr	r3, [pc, #360]	; (8003048 <Watering+0x7ec>)
 8002ede:	701a      	strb	r2, [r3, #0]

            if(watering_i == 3 || watering_i == 6)
 8002ee0:	4b59      	ldr	r3, [pc, #356]	; (8003048 <Watering+0x7ec>)
 8002ee2:	781b      	ldrb	r3, [r3, #0]
 8002ee4:	2b03      	cmp	r3, #3
 8002ee6:	d003      	beq.n	8002ef0 <Watering+0x694>
 8002ee8:	4b57      	ldr	r3, [pc, #348]	; (8003048 <Watering+0x7ec>)
 8002eea:	781b      	ldrb	r3, [r3, #0]
 8002eec:	2b06      	cmp	r3, #6
 8002eee:	d106      	bne.n	8002efe <Watering+0x6a2>
                watering_i++;
 8002ef0:	4b55      	ldr	r3, [pc, #340]	; (8003048 <Watering+0x7ec>)
 8002ef2:	781b      	ldrb	r3, [r3, #0]
 8002ef4:	f103 0301 	add.w	r3, r3, #1
 8002ef8:	b2da      	uxtb	r2, r3
 8002efa:	4b53      	ldr	r3, [pc, #332]	; (8003048 <Watering+0x7ec>)
 8002efc:	701a      	strb	r2, [r3, #0]
            Cursor(2, (watering_i - 1));
 8002efe:	4b52      	ldr	r3, [pc, #328]	; (8003048 <Watering+0x7ec>)
 8002f00:	781b      	ldrb	r3, [r3, #0]
 8002f02:	f103 33ff 	add.w	r3, r3, #4294967295
 8002f06:	b2db      	uxtb	r3, r3
 8002f08:	f04f 0002 	mov.w	r0, #2
 8002f0c:	4619      	mov	r1, r3
 8002f0e:	f7fd fbd9 	bl	80006c4 <Cursor>
 8002f12:	e11f      	b.n	8003154 <Watering+0x8f8>
        }

        else if(watering_i >= 8 )
 8002f14:	4b4c      	ldr	r3, [pc, #304]	; (8003048 <Watering+0x7ec>)
 8002f16:	781b      	ldrb	r3, [r3, #0]
 8002f18:	2b07      	cmp	r3, #7
 8002f1a:	f240 811b 	bls.w	8003154 <Watering+0x8f8>
        {
            watering_i++;
 8002f1e:	4b4a      	ldr	r3, [pc, #296]	; (8003048 <Watering+0x7ec>)
 8002f20:	781b      	ldrb	r3, [r3, #0]
 8002f22:	f103 0301 	add.w	r3, r3, #1
 8002f26:	b2da      	uxtb	r2, r3
 8002f28:	4b47      	ldr	r3, [pc, #284]	; (8003048 <Watering+0x7ec>)
 8002f2a:	701a      	strb	r2, [r3, #0]
            Cursor(3, (watering_i - 9));
 8002f2c:	4b46      	ldr	r3, [pc, #280]	; (8003048 <Watering+0x7ec>)
 8002f2e:	781b      	ldrb	r3, [r3, #0]
 8002f30:	f1a3 0309 	sub.w	r3, r3, #9
 8002f34:	b2db      	uxtb	r3, r3
 8002f36:	f04f 0003 	mov.w	r0, #3
 8002f3a:	4619      	mov	r1, r3
 8002f3c:	f7fd fbc2 	bl	80006c4 <Cursor>
 8002f40:	e108      	b.n	8003154 <Watering+0x8f8>
        }
    }

    else if(param == MENU_DOWN)
 8002f42:	79fb      	ldrb	r3, [r7, #7]
 8002f44:	2b07      	cmp	r3, #7
 8002f46:	f040 8105 	bne.w	8003154 <Watering+0x8f8>
    {
        if(watering_i == 0)
 8002f4a:	4b3f      	ldr	r3, [pc, #252]	; (8003048 <Watering+0x7ec>)
 8002f4c:	781b      	ldrb	r3, [r3, #0]
 8002f4e:	2b00      	cmp	r3, #0
 8002f50:	d10e      	bne.n	8002f70 <Watering+0x714>
        {
            watering_channel[0] = (watering_channel[0] >= '9') ? '1' : (watering_channel[0] + 1);
 8002f52:	4b3a      	ldr	r3, [pc, #232]	; (800303c <Watering+0x7e0>)
 8002f54:	781b      	ldrb	r3, [r3, #0]
 8002f56:	2b38      	cmp	r3, #56	; 0x38
 8002f58:	d805      	bhi.n	8002f66 <Watering+0x70a>
 8002f5a:	4b38      	ldr	r3, [pc, #224]	; (800303c <Watering+0x7e0>)
 8002f5c:	781b      	ldrb	r3, [r3, #0]
 8002f5e:	f103 0301 	add.w	r3, r3, #1
 8002f62:	b2db      	uxtb	r3, r3
 8002f64:	e001      	b.n	8002f6a <Watering+0x70e>
 8002f66:	f04f 0331 	mov.w	r3, #49	; 0x31
 8002f6a:	4a34      	ldr	r2, [pc, #208]	; (800303c <Watering+0x7e0>)
 8002f6c:	7013      	strb	r3, [r2, #0]
 8002f6e:	e0b2      	b.n	80030d6 <Watering+0x87a>
        }
        else if(watering_i == 1)
 8002f70:	4b35      	ldr	r3, [pc, #212]	; (8003048 <Watering+0x7ec>)
 8002f72:	781b      	ldrb	r3, [r3, #0]
 8002f74:	2b01      	cmp	r3, #1
 8002f76:	d112      	bne.n	8002f9e <Watering+0x742>
            {
                datechanger_date[0] = ((datechanger_date[0] >= '2') ? '0' : (datechanger_date[0] + 1));
 8002f78:	4b32      	ldr	r3, [pc, #200]	; (8003044 <Watering+0x7e8>)
 8002f7a:	781b      	ldrb	r3, [r3, #0]
 8002f7c:	2b31      	cmp	r3, #49	; 0x31
 8002f7e:	d805      	bhi.n	8002f8c <Watering+0x730>
 8002f80:	4b30      	ldr	r3, [pc, #192]	; (8003044 <Watering+0x7e8>)
 8002f82:	781b      	ldrb	r3, [r3, #0]
 8002f84:	f103 0301 	add.w	r3, r3, #1
 8002f88:	b2db      	uxtb	r3, r3
 8002f8a:	e001      	b.n	8002f90 <Watering+0x734>
 8002f8c:	f04f 0330 	mov.w	r3, #48	; 0x30
 8002f90:	4a2c      	ldr	r2, [pc, #176]	; (8003044 <Watering+0x7e8>)
 8002f92:	7013      	strb	r3, [r2, #0]
                datechanger_date[1] = '0';
 8002f94:	4b2b      	ldr	r3, [pc, #172]	; (8003044 <Watering+0x7e8>)
 8002f96:	f04f 0230 	mov.w	r2, #48	; 0x30
 8002f9a:	705a      	strb	r2, [r3, #1]
 8002f9c:	e09b      	b.n	80030d6 <Watering+0x87a>
            }
        else if(watering_i == 2)
 8002f9e:	4b2a      	ldr	r3, [pc, #168]	; (8003048 <Watering+0x7ec>)
 8002fa0:	781b      	ldrb	r3, [r3, #0]
 8002fa2:	2b02      	cmp	r3, #2
 8002fa4:	d121      	bne.n	8002fea <Watering+0x78e>
        {
            if(datechanger_date[0] == '2')
 8002fa6:	4b27      	ldr	r3, [pc, #156]	; (8003044 <Watering+0x7e8>)
 8002fa8:	781b      	ldrb	r3, [r3, #0]
 8002faa:	2b32      	cmp	r3, #50	; 0x32
 8002fac:	d10e      	bne.n	8002fcc <Watering+0x770>
                datechanger_date[1] = ((datechanger_date[1] >= '3') ? '0' : (datechanger_date[1] + 1));
 8002fae:	4b25      	ldr	r3, [pc, #148]	; (8003044 <Watering+0x7e8>)
 8002fb0:	785b      	ldrb	r3, [r3, #1]
 8002fb2:	2b32      	cmp	r3, #50	; 0x32
 8002fb4:	d805      	bhi.n	8002fc2 <Watering+0x766>
 8002fb6:	4b23      	ldr	r3, [pc, #140]	; (8003044 <Watering+0x7e8>)
 8002fb8:	785b      	ldrb	r3, [r3, #1]
 8002fba:	f103 0301 	add.w	r3, r3, #1
 8002fbe:	b2db      	uxtb	r3, r3
 8002fc0:	e001      	b.n	8002fc6 <Watering+0x76a>
 8002fc2:	f04f 0330 	mov.w	r3, #48	; 0x30
 8002fc6:	4a1f      	ldr	r2, [pc, #124]	; (8003044 <Watering+0x7e8>)
 8002fc8:	7053      	strb	r3, [r2, #1]
 8002fca:	e084      	b.n	80030d6 <Watering+0x87a>
            else
                datechanger_date[1] = ((datechanger_date[1] >= '9') ? '0' : (datechanger_date[1] + 1));
 8002fcc:	4b1d      	ldr	r3, [pc, #116]	; (8003044 <Watering+0x7e8>)
 8002fce:	785b      	ldrb	r3, [r3, #1]
 8002fd0:	2b38      	cmp	r3, #56	; 0x38
 8002fd2:	d805      	bhi.n	8002fe0 <Watering+0x784>
 8002fd4:	4b1b      	ldr	r3, [pc, #108]	; (8003044 <Watering+0x7e8>)
 8002fd6:	785b      	ldrb	r3, [r3, #1]
 8002fd8:	f103 0301 	add.w	r3, r3, #1
 8002fdc:	b2db      	uxtb	r3, r3
 8002fde:	e001      	b.n	8002fe4 <Watering+0x788>
 8002fe0:	f04f 0330 	mov.w	r3, #48	; 0x30
 8002fe4:	4a17      	ldr	r2, [pc, #92]	; (8003044 <Watering+0x7e8>)
 8002fe6:	7053      	strb	r3, [r2, #1]
 8002fe8:	e075      	b.n	80030d6 <Watering+0x87a>
        }
        else if(watering_i == 4 || watering_i == 7)
 8002fea:	4b17      	ldr	r3, [pc, #92]	; (8003048 <Watering+0x7ec>)
 8002fec:	781b      	ldrb	r3, [r3, #0]
 8002fee:	2b04      	cmp	r3, #4
 8002ff0:	d003      	beq.n	8002ffa <Watering+0x79e>
 8002ff2:	4b15      	ldr	r3, [pc, #84]	; (8003048 <Watering+0x7ec>)
 8002ff4:	781b      	ldrb	r3, [r3, #0]
 8002ff6:	2b07      	cmp	r3, #7
 8002ff8:	d128      	bne.n	800304c <Watering+0x7f0>
            datechanger_date[watering_i - 1] = ((datechanger_date[watering_i - 1] == '5') ? '0' : (datechanger_date[watering_i - 1] + 1));
 8002ffa:	4b13      	ldr	r3, [pc, #76]	; (8003048 <Watering+0x7ec>)
 8002ffc:	781b      	ldrb	r3, [r3, #0]
 8002ffe:	f103 32ff 	add.w	r2, r3, #4294967295
 8003002:	4b11      	ldr	r3, [pc, #68]	; (8003048 <Watering+0x7ec>)
 8003004:	781b      	ldrb	r3, [r3, #0]
 8003006:	f103 33ff 	add.w	r3, r3, #4294967295
 800300a:	490e      	ldr	r1, [pc, #56]	; (8003044 <Watering+0x7e8>)
 800300c:	5ccb      	ldrb	r3, [r1, r3]
 800300e:	2b35      	cmp	r3, #53	; 0x35
 8003010:	d009      	beq.n	8003026 <Watering+0x7ca>
 8003012:	4b0d      	ldr	r3, [pc, #52]	; (8003048 <Watering+0x7ec>)
 8003014:	781b      	ldrb	r3, [r3, #0]
 8003016:	f103 33ff 	add.w	r3, r3, #4294967295
 800301a:	490a      	ldr	r1, [pc, #40]	; (8003044 <Watering+0x7e8>)
 800301c:	5ccb      	ldrb	r3, [r1, r3]
 800301e:	f103 0301 	add.w	r3, r3, #1
 8003022:	b2db      	uxtb	r3, r3
 8003024:	e001      	b.n	800302a <Watering+0x7ce>
 8003026:	f04f 0330 	mov.w	r3, #48	; 0x30
 800302a:	4906      	ldr	r1, [pc, #24]	; (8003044 <Watering+0x7e8>)
 800302c:	548b      	strb	r3, [r1, r2]
 800302e:	e052      	b.n	80030d6 <Watering+0x87a>
 8003030:	20000e3c 	.word	0x20000e3c
 8003034:	20000e60 	.word	0x20000e60
 8003038:	20000dac 	.word	0x20000dac
 800303c:	20000d70 	.word	0x20000d70
 8003040:	20001318 	.word	0x20001318
 8003044:	200012fc 	.word	0x200012fc
 8003048:	20000fa8 	.word	0x20000fa8
        else if(watering_i == 5 || watering_i == 8)
 800304c:	4b7f      	ldr	r3, [pc, #508]	; (800324c <Watering+0x9f0>)
 800304e:	781b      	ldrb	r3, [r3, #0]
 8003050:	2b05      	cmp	r3, #5
 8003052:	d003      	beq.n	800305c <Watering+0x800>
 8003054:	4b7d      	ldr	r3, [pc, #500]	; (800324c <Watering+0x9f0>)
 8003056:	781b      	ldrb	r3, [r3, #0]
 8003058:	2b08      	cmp	r3, #8
 800305a:	d11a      	bne.n	8003092 <Watering+0x836>
            datechanger_date[watering_i - 1] = ((datechanger_date[watering_i - 1] == '9') ? '0' : (datechanger_date[watering_i - 1] + 1));
 800305c:	4b7b      	ldr	r3, [pc, #492]	; (800324c <Watering+0x9f0>)
 800305e:	781b      	ldrb	r3, [r3, #0]
 8003060:	f103 32ff 	add.w	r2, r3, #4294967295
 8003064:	4b79      	ldr	r3, [pc, #484]	; (800324c <Watering+0x9f0>)
 8003066:	781b      	ldrb	r3, [r3, #0]
 8003068:	f103 33ff 	add.w	r3, r3, #4294967295
 800306c:	4978      	ldr	r1, [pc, #480]	; (8003250 <Watering+0x9f4>)
 800306e:	5ccb      	ldrb	r3, [r1, r3]
 8003070:	2b39      	cmp	r3, #57	; 0x39
 8003072:	d009      	beq.n	8003088 <Watering+0x82c>
 8003074:	4b75      	ldr	r3, [pc, #468]	; (800324c <Watering+0x9f0>)
 8003076:	781b      	ldrb	r3, [r3, #0]
 8003078:	f103 33ff 	add.w	r3, r3, #4294967295
 800307c:	4974      	ldr	r1, [pc, #464]	; (8003250 <Watering+0x9f4>)
 800307e:	5ccb      	ldrb	r3, [r1, r3]
 8003080:	f103 0301 	add.w	r3, r3, #1
 8003084:	b2db      	uxtb	r3, r3
 8003086:	e001      	b.n	800308c <Watering+0x830>
 8003088:	f04f 0330 	mov.w	r3, #48	; 0x30
 800308c:	4970      	ldr	r1, [pc, #448]	; (8003250 <Watering+0x9f4>)
 800308e:	548b      	strb	r3, [r1, r2]
 8003090:	e021      	b.n	80030d6 <Watering+0x87a>
        else if(watering_i == 9 || watering_i == 10)
 8003092:	4b6e      	ldr	r3, [pc, #440]	; (800324c <Watering+0x9f0>)
 8003094:	781b      	ldrb	r3, [r3, #0]
 8003096:	2b09      	cmp	r3, #9
 8003098:	d003      	beq.n	80030a2 <Watering+0x846>
 800309a:	4b6c      	ldr	r3, [pc, #432]	; (800324c <Watering+0x9f0>)
 800309c:	781b      	ldrb	r3, [r3, #0]
 800309e:	2b0a      	cmp	r3, #10
 80030a0:	d119      	bne.n	80030d6 <Watering+0x87a>
            watering_lenght[watering_i - 9] = ((watering_lenght[watering_i - 9] == '9') ? '0' : (watering_lenght[watering_i - 9] + 1));
 80030a2:	4b6a      	ldr	r3, [pc, #424]	; (800324c <Watering+0x9f0>)
 80030a4:	781b      	ldrb	r3, [r3, #0]
 80030a6:	f1a3 0209 	sub.w	r2, r3, #9
 80030aa:	4b68      	ldr	r3, [pc, #416]	; (800324c <Watering+0x9f0>)
 80030ac:	781b      	ldrb	r3, [r3, #0]
 80030ae:	f1a3 0309 	sub.w	r3, r3, #9
 80030b2:	4968      	ldr	r1, [pc, #416]	; (8003254 <Watering+0x9f8>)
 80030b4:	5ccb      	ldrb	r3, [r1, r3]
 80030b6:	2b39      	cmp	r3, #57	; 0x39
 80030b8:	d009      	beq.n	80030ce <Watering+0x872>
 80030ba:	4b64      	ldr	r3, [pc, #400]	; (800324c <Watering+0x9f0>)
 80030bc:	781b      	ldrb	r3, [r3, #0]
 80030be:	f1a3 0309 	sub.w	r3, r3, #9
 80030c2:	4964      	ldr	r1, [pc, #400]	; (8003254 <Watering+0x9f8>)
 80030c4:	5ccb      	ldrb	r3, [r1, r3]
 80030c6:	f103 0301 	add.w	r3, r3, #1
 80030ca:	b2db      	uxtb	r3, r3
 80030cc:	e001      	b.n	80030d2 <Watering+0x876>
 80030ce:	f04f 0330 	mov.w	r3, #48	; 0x30
 80030d2:	4960      	ldr	r1, [pc, #384]	; (8003254 <Watering+0x9f8>)
 80030d4:	548b      	strb	r3, [r1, r2]


        if(watering_i == 0)
 80030d6:	4b5d      	ldr	r3, [pc, #372]	; (800324c <Watering+0x9f0>)
 80030d8:	781b      	ldrb	r3, [r3, #0]
 80030da:	2b00      	cmp	r3, #0
 80030dc:	d10f      	bne.n	80030fe <Watering+0x8a2>
        {
            Cursor(1, 0);
 80030de:	f04f 0001 	mov.w	r0, #1
 80030e2:	f04f 0100 	mov.w	r1, #0
 80030e6:	f7fd faed 	bl	80006c4 <Cursor>
            PrintStr(watering_channel);
 80030ea:	485b      	ldr	r0, [pc, #364]	; (8003258 <Watering+0x9fc>)
 80030ec:	f7fd fcf8 	bl	8000ae0 <PrintStr>
            Cursor(1, 0);
 80030f0:	f04f 0001 	mov.w	r0, #1
 80030f4:	f04f 0100 	mov.w	r1, #0
 80030f8:	f7fd fae4 	bl	80006c4 <Cursor>
 80030fc:	e02a      	b.n	8003154 <Watering+0x8f8>
        }

        else if(watering_i < 9)
 80030fe:	4b53      	ldr	r3, [pc, #332]	; (800324c <Watering+0x9f0>)
 8003100:	781b      	ldrb	r3, [r3, #0]
 8003102:	2b08      	cmp	r3, #8
 8003104:	d813      	bhi.n	800312e <Watering+0x8d2>
        {
            Cursor(2, 0);
 8003106:	f04f 0002 	mov.w	r0, #2
 800310a:	f04f 0100 	mov.w	r1, #0
 800310e:	f7fd fad9 	bl	80006c4 <Cursor>
            PrintStr(datechanger_date);
 8003112:	484f      	ldr	r0, [pc, #316]	; (8003250 <Watering+0x9f4>)
 8003114:	f7fd fce4 	bl	8000ae0 <PrintStr>
            Cursor(2, watering_i - 1);
 8003118:	4b4c      	ldr	r3, [pc, #304]	; (800324c <Watering+0x9f0>)
 800311a:	781b      	ldrb	r3, [r3, #0]
 800311c:	f103 33ff 	add.w	r3, r3, #4294967295
 8003120:	b2db      	uxtb	r3, r3
 8003122:	f04f 0002 	mov.w	r0, #2
 8003126:	4619      	mov	r1, r3
 8003128:	f7fd facc 	bl	80006c4 <Cursor>
 800312c:	e012      	b.n	8003154 <Watering+0x8f8>
        }
        else
        {
            Cursor(3, 0);
 800312e:	f04f 0003 	mov.w	r0, #3
 8003132:	f04f 0100 	mov.w	r1, #0
 8003136:	f7fd fac5 	bl	80006c4 <Cursor>
            PrintStr(watering_lenght);
 800313a:	4846      	ldr	r0, [pc, #280]	; (8003254 <Watering+0x9f8>)
 800313c:	f7fd fcd0 	bl	8000ae0 <PrintStr>
            Cursor(3, watering_i - 9);
 8003140:	4b42      	ldr	r3, [pc, #264]	; (800324c <Watering+0x9f0>)
 8003142:	781b      	ldrb	r3, [r3, #0]
 8003144:	f1a3 0309 	sub.w	r3, r3, #9
 8003148:	b2db      	uxtb	r3, r3
 800314a:	f04f 0003 	mov.w	r0, #3
 800314e:	4619      	mov	r1, r3
 8003150:	f7fd fab8 	bl	80006c4 <Cursor>
        }
    }

    if(watering_i == 11)
 8003154:	4b3d      	ldr	r3, [pc, #244]	; (800324c <Watering+0x9f0>)
 8003156:	781b      	ldrb	r3, [r3, #0]
 8003158:	2b0b      	cmp	r3, #11
 800315a:	f040 816c 	bne.w	8003436 <Watering+0xbda>
    {
        watering_temporary2 = &watering[1];
 800315e:	4b3f      	ldr	r3, [pc, #252]	; (800325c <Watering+0xa00>)
 8003160:	4a3f      	ldr	r2, [pc, #252]	; (8003260 <Watering+0xa04>)
 8003162:	601a      	str	r2, [r3, #0]
        alarm_temp = 0;
 8003164:	4b3f      	ldr	r3, [pc, #252]	; (8003264 <Watering+0xa08>)
 8003166:	f04f 0200 	mov.w	r2, #0
 800316a:	601a      	str	r2, [r3, #0]
        watering_j = 0;
 800316c:	4b3e      	ldr	r3, [pc, #248]	; (8003268 <Watering+0xa0c>)
 800316e:	f04f 0200 	mov.w	r2, #0
 8003172:	701a      	strb	r2, [r3, #0]

        for(watering_i = 0; watering_i < 6; watering_i++)
 8003174:	4b35      	ldr	r3, [pc, #212]	; (800324c <Watering+0x9f0>)
 8003176:	f04f 0200 	mov.w	r2, #0
 800317a:	701a      	strb	r2, [r3, #0]
 800317c:	e094      	b.n	80032a8 <Watering+0xa4c>
        {
        	if((watering_temporary != watering_temporary2) && (!TimeCompare2(watering_temporary, watering_temporary2)))
 800317e:	4b3b      	ldr	r3, [pc, #236]	; (800326c <Watering+0xa10>)
 8003180:	681a      	ldr	r2, [r3, #0]
 8003182:	4b36      	ldr	r3, [pc, #216]	; (800325c <Watering+0xa00>)
 8003184:	681b      	ldr	r3, [r3, #0]
 8003186:	429a      	cmp	r2, r3
 8003188:	f000 8082 	beq.w	8003290 <Watering+0xa34>
 800318c:	4b37      	ldr	r3, [pc, #220]	; (800326c <Watering+0xa10>)
 800318e:	681a      	ldr	r2, [r3, #0]
 8003190:	4b32      	ldr	r3, [pc, #200]	; (800325c <Watering+0xa00>)
 8003192:	681b      	ldr	r3, [r3, #0]
 8003194:	4610      	mov	r0, r2
 8003196:	4619      	mov	r1, r3
 8003198:	f7fd ff66 	bl	8001068 <TimeCompare2>
 800319c:	4603      	mov	r3, r0
 800319e:	2b00      	cmp	r3, #0
 80031a0:	d176      	bne.n	8003290 <Watering+0xa34>
        	{
                ClearLcmScreen();
 80031a2:	f7fd fac7 	bl	8000734 <ClearLcmScreen>

                Cursor(0,0);
 80031a6:	f04f 0000 	mov.w	r0, #0
 80031aa:	f04f 0100 	mov.w	r1, #0
 80031ae:	f7fd fa89 	bl	80006c4 <Cursor>
                StrAlign(menu_utkozes.nev, temp, ALIGN_CENTER);
 80031b2:	4b2f      	ldr	r3, [pc, #188]	; (8003270 <Watering+0xa14>)
 80031b4:	681b      	ldr	r3, [r3, #0]
 80031b6:	4618      	mov	r0, r3
 80031b8:	492e      	ldr	r1, [pc, #184]	; (8003274 <Watering+0xa18>)
 80031ba:	f04f 0203 	mov.w	r2, #3
 80031be:	f7fd fb4f 	bl	8000860 <StrAlign>
                PrintStr(temp);
 80031c2:	482c      	ldr	r0, [pc, #176]	; (8003274 <Watering+0xa18>)
 80031c4:	f7fd fc8c 	bl	8000ae0 <PrintStr>
                menu_level_first[menu_level] = *menu_first;
 80031c8:	4b2b      	ldr	r3, [pc, #172]	; (8003278 <Watering+0xa1c>)
 80031ca:	781b      	ldrb	r3, [r3, #0]
 80031cc:	461a      	mov	r2, r3
 80031ce:	4b2b      	ldr	r3, [pc, #172]	; (800327c <Watering+0xa20>)
 80031d0:	6819      	ldr	r1, [r3, #0]
 80031d2:	482b      	ldr	r0, [pc, #172]	; (8003280 <Watering+0xa24>)
 80031d4:	4613      	mov	r3, r2
 80031d6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80031da:	1a9b      	subs	r3, r3, r2
 80031dc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80031e0:	18c3      	adds	r3, r0, r3
 80031e2:	461c      	mov	r4, r3
 80031e4:	460d      	mov	r5, r1
 80031e6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80031e8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80031ea:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 80031ee:	e884 0007 	stmia.w	r4, {r0, r1, r2}
                menu_level_current[menu_level] = *menu_current;
 80031f2:	4b21      	ldr	r3, [pc, #132]	; (8003278 <Watering+0xa1c>)
 80031f4:	781b      	ldrb	r3, [r3, #0]
 80031f6:	461a      	mov	r2, r3
 80031f8:	4b22      	ldr	r3, [pc, #136]	; (8003284 <Watering+0xa28>)
 80031fa:	6819      	ldr	r1, [r3, #0]
 80031fc:	4822      	ldr	r0, [pc, #136]	; (8003288 <Watering+0xa2c>)
 80031fe:	4613      	mov	r3, r2
 8003200:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8003204:	1a9b      	subs	r3, r3, r2
 8003206:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800320a:	18c3      	adds	r3, r0, r3
 800320c:	461c      	mov	r4, r3
 800320e:	460d      	mov	r5, r1
 8003210:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8003212:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8003214:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8003218:	e884 0007 	stmia.w	r4, {r0, r1, r2}
                menu_first = menu_current = menu_current->down;
 800321c:	4b19      	ldr	r3, [pc, #100]	; (8003284 <Watering+0xa28>)
 800321e:	681b      	ldr	r3, [r3, #0]
 8003220:	699a      	ldr	r2, [r3, #24]
 8003222:	4b18      	ldr	r3, [pc, #96]	; (8003284 <Watering+0xa28>)
 8003224:	601a      	str	r2, [r3, #0]
 8003226:	4b17      	ldr	r3, [pc, #92]	; (8003284 <Watering+0xa28>)
 8003228:	681a      	ldr	r2, [r3, #0]
 800322a:	4b14      	ldr	r3, [pc, #80]	; (800327c <Watering+0xa20>)
 800322c:	601a      	str	r2, [r3, #0]
                menu_level++;
 800322e:	4b12      	ldr	r3, [pc, #72]	; (8003278 <Watering+0xa1c>)
 8003230:	781b      	ldrb	r3, [r3, #0]
 8003232:	f103 0301 	add.w	r3, r3, #1
 8003236:	b2da      	uxtb	r2, r3
 8003238:	4b0f      	ldr	r3, [pc, #60]	; (8003278 <Watering+0xa1c>)
 800323a:	701a      	strb	r2, [r3, #0]
                menu_special_function = 0;
 800323c:	4b13      	ldr	r3, [pc, #76]	; (800328c <Watering+0xa30>)
 800323e:	f04f 0200 	mov.w	r2, #0
 8003242:	701a      	strb	r2, [r3, #0]

                return 0;
 8003244:	f04f 0300 	mov.w	r3, #0
 8003248:	e0f7      	b.n	800343a <Watering+0xbde>
 800324a:	bf00      	nop
 800324c:	20000fa8 	.word	0x20000fa8
 8003250:	200012fc 	.word	0x200012fc
 8003254:	20000e3c 	.word	0x20000e3c
 8003258:	20000d70 	.word	0x20000d70
 800325c:	200012f8 	.word	0x200012f8
 8003260:	2000115c 	.word	0x2000115c
 8003264:	20000e14 	.word	0x20000e14
 8003268:	20001334 	.word	0x20001334
 800326c:	20000e60 	.word	0x20000e60
 8003270:	20001354 	.word	0x20001354
 8003274:	20000fac 	.word	0x20000fac
 8003278:	2000130e 	.word	0x2000130e
 800327c:	20000d48 	.word	0x20000d48
 8003280:	20000eb8 	.word	0x20000eb8
 8003284:	2000124c 	.word	0x2000124c
 8003288:	20001054 	.word	0x20001054
 800328c:	20000e12 	.word	0x20000e12
        	}
        	watering_temporary2 = watering_temporary2->next;
 8003290:	4b6c      	ldr	r3, [pc, #432]	; (8003444 <Watering+0xbe8>)
 8003292:	681b      	ldr	r3, [r3, #0]
 8003294:	68da      	ldr	r2, [r3, #12]
 8003296:	4b6b      	ldr	r3, [pc, #428]	; (8003444 <Watering+0xbe8>)
 8003298:	601a      	str	r2, [r3, #0]
    {
        watering_temporary2 = &watering[1];
        alarm_temp = 0;
        watering_j = 0;

        for(watering_i = 0; watering_i < 6; watering_i++)
 800329a:	4b6b      	ldr	r3, [pc, #428]	; (8003448 <Watering+0xbec>)
 800329c:	781b      	ldrb	r3, [r3, #0]
 800329e:	f103 0301 	add.w	r3, r3, #1
 80032a2:	b2da      	uxtb	r2, r3
 80032a4:	4b68      	ldr	r3, [pc, #416]	; (8003448 <Watering+0xbec>)
 80032a6:	701a      	strb	r2, [r3, #0]
 80032a8:	4b67      	ldr	r3, [pc, #412]	; (8003448 <Watering+0xbec>)
 80032aa:	781b      	ldrb	r3, [r3, #0]
 80032ac:	2b05      	cmp	r3, #5
 80032ae:	f67f af66 	bls.w	800317e <Watering+0x922>
                return 0;
        	}
        	watering_temporary2 = watering_temporary2->next;
        }

    	watering_temp[(watering_temporary->designator) - 1][8] = datechanger_date[0];
 80032b2:	4b66      	ldr	r3, [pc, #408]	; (800344c <Watering+0xbf0>)
 80032b4:	681b      	ldr	r3, [r3, #0]
 80032b6:	791b      	ldrb	r3, [r3, #4]
 80032b8:	f103 32ff 	add.w	r2, r3, #4294967295
 80032bc:	4b64      	ldr	r3, [pc, #400]	; (8003450 <Watering+0xbf4>)
 80032be:	7819      	ldrb	r1, [r3, #0]
 80032c0:	4864      	ldr	r0, [pc, #400]	; (8003454 <Watering+0xbf8>)
 80032c2:	4613      	mov	r3, r2
 80032c4:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80032c8:	189b      	adds	r3, r3, r2
 80032ca:	18c3      	adds	r3, r0, r3
 80032cc:	f103 0308 	add.w	r3, r3, #8
 80032d0:	460a      	mov	r2, r1
 80032d2:	701a      	strb	r2, [r3, #0]
    	watering_temp[(watering_temporary->designator) - 1][9] = datechanger_date[1];
 80032d4:	4b5d      	ldr	r3, [pc, #372]	; (800344c <Watering+0xbf0>)
 80032d6:	681b      	ldr	r3, [r3, #0]
 80032d8:	791b      	ldrb	r3, [r3, #4]
 80032da:	f103 32ff 	add.w	r2, r3, #4294967295
 80032de:	4b5c      	ldr	r3, [pc, #368]	; (8003450 <Watering+0xbf4>)
 80032e0:	7859      	ldrb	r1, [r3, #1]
 80032e2:	485c      	ldr	r0, [pc, #368]	; (8003454 <Watering+0xbf8>)
 80032e4:	4613      	mov	r3, r2
 80032e6:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80032ea:	189b      	adds	r3, r3, r2
 80032ec:	18c3      	adds	r3, r0, r3
 80032ee:	f103 0309 	add.w	r3, r3, #9
 80032f2:	460a      	mov	r2, r1
 80032f4:	701a      	strb	r2, [r3, #0]
    	watering_temp[(watering_temporary->designator) - 1][11] = datechanger_date[3];
 80032f6:	4b55      	ldr	r3, [pc, #340]	; (800344c <Watering+0xbf0>)
 80032f8:	681b      	ldr	r3, [r3, #0]
 80032fa:	791b      	ldrb	r3, [r3, #4]
 80032fc:	f103 32ff 	add.w	r2, r3, #4294967295
 8003300:	4b53      	ldr	r3, [pc, #332]	; (8003450 <Watering+0xbf4>)
 8003302:	78d9      	ldrb	r1, [r3, #3]
 8003304:	4853      	ldr	r0, [pc, #332]	; (8003454 <Watering+0xbf8>)
 8003306:	4613      	mov	r3, r2
 8003308:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800330c:	189b      	adds	r3, r3, r2
 800330e:	18c3      	adds	r3, r0, r3
 8003310:	f103 030b 	add.w	r3, r3, #11
 8003314:	460a      	mov	r2, r1
 8003316:	701a      	strb	r2, [r3, #0]
    	watering_temp[(watering_temporary->designator) - 1][12] = datechanger_date[4];
 8003318:	4b4c      	ldr	r3, [pc, #304]	; (800344c <Watering+0xbf0>)
 800331a:	681b      	ldr	r3, [r3, #0]
 800331c:	791b      	ldrb	r3, [r3, #4]
 800331e:	f103 32ff 	add.w	r2, r3, #4294967295
 8003322:	4b4b      	ldr	r3, [pc, #300]	; (8003450 <Watering+0xbf4>)
 8003324:	7919      	ldrb	r1, [r3, #4]
 8003326:	484b      	ldr	r0, [pc, #300]	; (8003454 <Watering+0xbf8>)
 8003328:	4613      	mov	r3, r2
 800332a:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800332e:	189b      	adds	r3, r3, r2
 8003330:	18c3      	adds	r3, r0, r3
 8003332:	f103 030c 	add.w	r3, r3, #12
 8003336:	460a      	mov	r2, r1
 8003338:	701a      	strb	r2, [r3, #0]

        watering_temp[(watering_temporary->designator) - 1][6] = watering_channel[0];
 800333a:	4b44      	ldr	r3, [pc, #272]	; (800344c <Watering+0xbf0>)
 800333c:	681b      	ldr	r3, [r3, #0]
 800333e:	791b      	ldrb	r3, [r3, #4]
 8003340:	f103 32ff 	add.w	r2, r3, #4294967295
 8003344:	4b44      	ldr	r3, [pc, #272]	; (8003458 <Watering+0xbfc>)
 8003346:	7819      	ldrb	r1, [r3, #0]
 8003348:	4842      	ldr	r0, [pc, #264]	; (8003454 <Watering+0xbf8>)
 800334a:	4613      	mov	r3, r2
 800334c:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8003350:	189b      	adds	r3, r3, r2
 8003352:	18c3      	adds	r3, r0, r3
 8003354:	f103 0306 	add.w	r3, r3, #6
 8003358:	460a      	mov	r2, r1
 800335a:	701a      	strb	r2, [r3, #0]

        watering_temp[(watering_temporary->designator) - 1][14] = watering_lenght[0];
 800335c:	4b3b      	ldr	r3, [pc, #236]	; (800344c <Watering+0xbf0>)
 800335e:	681b      	ldr	r3, [r3, #0]
 8003360:	791b      	ldrb	r3, [r3, #4]
 8003362:	f103 32ff 	add.w	r2, r3, #4294967295
 8003366:	4b3d      	ldr	r3, [pc, #244]	; (800345c <Watering+0xc00>)
 8003368:	7819      	ldrb	r1, [r3, #0]
 800336a:	483a      	ldr	r0, [pc, #232]	; (8003454 <Watering+0xbf8>)
 800336c:	4613      	mov	r3, r2
 800336e:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8003372:	189b      	adds	r3, r3, r2
 8003374:	18c3      	adds	r3, r0, r3
 8003376:	f103 030e 	add.w	r3, r3, #14
 800337a:	460a      	mov	r2, r1
 800337c:	701a      	strb	r2, [r3, #0]
        watering_temp[(watering_temporary->designator) - 1][15] = watering_lenght[1];
 800337e:	4b33      	ldr	r3, [pc, #204]	; (800344c <Watering+0xbf0>)
 8003380:	681b      	ldr	r3, [r3, #0]
 8003382:	791b      	ldrb	r3, [r3, #4]
 8003384:	f103 32ff 	add.w	r2, r3, #4294967295
 8003388:	4b34      	ldr	r3, [pc, #208]	; (800345c <Watering+0xc00>)
 800338a:	7859      	ldrb	r1, [r3, #1]
 800338c:	4831      	ldr	r0, [pc, #196]	; (8003454 <Watering+0xbf8>)
 800338e:	4613      	mov	r3, r2
 8003390:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8003394:	189b      	adds	r3, r3, r2
 8003396:	18c3      	adds	r3, r0, r3
 8003398:	f103 030f 	add.w	r3, r3, #15
 800339c:	460a      	mov	r2, r1
 800339e:	701a      	strb	r2, [r3, #0]


        menu_temporary3 = watering_temporary;
 80033a0:	4b2a      	ldr	r3, [pc, #168]	; (800344c <Watering+0xbf0>)
 80033a2:	681a      	ldr	r2, [r3, #0]
 80033a4:	4b2e      	ldr	r3, [pc, #184]	; (8003460 <Watering+0xc04>)
 80033a6:	601a      	str	r2, [r3, #0]
        menu_temporary = menu_temporary3;
 80033a8:	4b2d      	ldr	r3, [pc, #180]	; (8003460 <Watering+0xc04>)
 80033aa:	681a      	ldr	r2, [r3, #0]
 80033ac:	4b2d      	ldr	r3, [pc, #180]	; (8003464 <Watering+0xc08>)
 80033ae:	601a      	str	r2, [r3, #0]
        menu_current = menu_temporary;
 80033b0:	4b2c      	ldr	r3, [pc, #176]	; (8003464 <Watering+0xc08>)
 80033b2:	681a      	ldr	r2, [r3, #0]
 80033b4:	4b2c      	ldr	r3, [pc, #176]	; (8003468 <Watering+0xc0c>)
 80033b6:	601a      	str	r2, [r3, #0]

        ReDesignator();
 80033b8:	f7ff fa0c 	bl	80027d4 <ReDesignator>

        watering_temporary2 = &watering[1];
 80033bc:	4b21      	ldr	r3, [pc, #132]	; (8003444 <Watering+0xbe8>)
 80033be:	4a2b      	ldr	r2, [pc, #172]	; (800346c <Watering+0xc10>)
 80033c0:	601a      	str	r2, [r3, #0]
        alarm_temp = 0;
 80033c2:	4b2b      	ldr	r3, [pc, #172]	; (8003470 <Watering+0xc14>)
 80033c4:	f04f 0200 	mov.w	r2, #0
 80033c8:	601a      	str	r2, [r3, #0]
        watering_j = 0;
 80033ca:	4b2a      	ldr	r3, [pc, #168]	; (8003474 <Watering+0xc18>)
 80033cc:	f04f 0200 	mov.w	r2, #0
 80033d0:	701a      	strb	r2, [r3, #0]

        for(watering_i = 0; watering_i < 6; watering_i++)
 80033d2:	4b1d      	ldr	r3, [pc, #116]	; (8003448 <Watering+0xbec>)
 80033d4:	f04f 0200 	mov.w	r2, #0
 80033d8:	701a      	strb	r2, [r3, #0]
 80033da:	e018      	b.n	800340e <Watering+0xbb2>
        {
        	if(!TimeCompare(watering_temporary2))		//Ha van egy aktív program. Ekkor ugyan a tömb része az új öntözés, mégsem fogjuk megnézni, hogy melyik a következõ program, hiszen ekkor már megy egy.
 80033dc:	4b19      	ldr	r3, [pc, #100]	; (8003444 <Watering+0xbe8>)
 80033de:	681b      	ldr	r3, [r3, #0]
 80033e0:	4618      	mov	r0, r3
 80033e2:	f7fd fd5f 	bl	8000ea4 <TimeCompare>
 80033e6:	4603      	mov	r3, r0
 80033e8:	2b00      	cmp	r3, #0
 80033ea:	d104      	bne.n	80033f6 <Watering+0xb9a>
        	{
        		watering_i = 9;
 80033ec:	4b16      	ldr	r3, [pc, #88]	; (8003448 <Watering+0xbec>)
 80033ee:	f04f 0209 	mov.w	r2, #9
 80033f2:	701a      	strb	r2, [r3, #0]

        		break;
 80033f4:	e00f      	b.n	8003416 <Watering+0xbba>
        	}
        	watering_temporary2 = watering_temporary2->next;
 80033f6:	4b13      	ldr	r3, [pc, #76]	; (8003444 <Watering+0xbe8>)
 80033f8:	681b      	ldr	r3, [r3, #0]
 80033fa:	68da      	ldr	r2, [r3, #12]
 80033fc:	4b11      	ldr	r3, [pc, #68]	; (8003444 <Watering+0xbe8>)
 80033fe:	601a      	str	r2, [r3, #0]

        watering_temporary2 = &watering[1];
        alarm_temp = 0;
        watering_j = 0;

        for(watering_i = 0; watering_i < 6; watering_i++)
 8003400:	4b11      	ldr	r3, [pc, #68]	; (8003448 <Watering+0xbec>)
 8003402:	781b      	ldrb	r3, [r3, #0]
 8003404:	f103 0301 	add.w	r3, r3, #1
 8003408:	b2da      	uxtb	r2, r3
 800340a:	4b0f      	ldr	r3, [pc, #60]	; (8003448 <Watering+0xbec>)
 800340c:	701a      	strb	r2, [r3, #0]
 800340e:	4b0e      	ldr	r3, [pc, #56]	; (8003448 <Watering+0xbec>)
 8003410:	781b      	ldrb	r3, [r3, #0]
 8003412:	2b05      	cmp	r3, #5
 8003414:	d9e2      	bls.n	80033dc <Watering+0xb80>
        		break;
        	}
        	watering_temporary2 = watering_temporary2->next;
        }

      	if(watering_i != 9)											//Ha nincs aktív program
 8003416:	4b0c      	ldr	r3, [pc, #48]	; (8003448 <Watering+0xbec>)
 8003418:	781b      	ldrb	r3, [r3, #0]
 800341a:	2b09      	cmp	r3, #9
 800341c:	d007      	beq.n	800342e <Watering+0xbd2>
        {
      		Watering_Next_Set();
 800341e:	f7fd ff1f 	bl	8001260 <Watering_Next_Set>
      		RTC_WriteBackupRegister(RTC_BKP_DR0, 0x32F2);
 8003422:	f04f 0000 	mov.w	r0, #0
 8003426:	f243 21f2 	movw	r1, #13042	; 0x32f2
 800342a:	f006 fab9 	bl	80099a0 <RTC_WriteBackupRegister>

            RTC_ClearFlag(RTC_FLAG_ALRBF);*/

        }

        menu_special_function = 0;
 800342e:	4b12      	ldr	r3, [pc, #72]	; (8003478 <Watering+0xc1c>)
 8003430:	f04f 0200 	mov.w	r2, #0
 8003434:	701a      	strb	r2, [r3, #0]
    }
    return 0;
 8003436:	f04f 0300 	mov.w	r3, #0
}
 800343a:	4618      	mov	r0, r3
 800343c:	f107 070c 	add.w	r7, r7, #12
 8003440:	46bd      	mov	sp, r7
 8003442:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003444:	200012f8 	.word	0x200012f8
 8003448:	20000fa8 	.word	0x20000fa8
 800344c:	20000e60 	.word	0x20000e60
 8003450:	200012fc 	.word	0x200012fc
 8003454:	20000dac 	.word	0x20000dac
 8003458:	20000d70 	.word	0x20000d70
 800345c:	20000e3c 	.word	0x20000e3c
 8003460:	200013fc 	.word	0x200013fc
 8003464:	20001310 	.word	0x20001310
 8003468:	2000124c 	.word	0x2000124c
 800346c:	2000115c 	.word	0x2000115c
 8003470:	20000e14 	.word	0x20000e14
 8003474:	20001334 	.word	0x20001334
 8003478:	20000e12 	.word	0x20000e12

0800347c <main>:




int main(void)
{
 800347c:	b580      	push	{r7, lr}
 800347e:	b082      	sub	sp, #8
 8003480:	af00      	add	r7, sp, #0
    //***********************************INICIALIZÁLÁS********************************
	watering_temp[0][0] = 'T';
 8003482:	4b99      	ldr	r3, [pc, #612]	; (80036e8 <main+0x26c>)
 8003484:	f04f 0254 	mov.w	r2, #84	; 0x54
 8003488:	701a      	strb	r2, [r3, #0]
	watering_temp[0][1] = 'e';
 800348a:	4b97      	ldr	r3, [pc, #604]	; (80036e8 <main+0x26c>)
 800348c:	f04f 0265 	mov.w	r2, #101	; 0x65
 8003490:	705a      	strb	r2, [r3, #1]
	watering_temp[0][2] = 'r';
 8003492:	4b95      	ldr	r3, [pc, #596]	; (80036e8 <main+0x26c>)
 8003494:	f04f 0272 	mov.w	r2, #114	; 0x72
 8003498:	709a      	strb	r2, [r3, #2]
	watering_temp[0][3] = '1';
 800349a:	4b93      	ldr	r3, [pc, #588]	; (80036e8 <main+0x26c>)
 800349c:	f04f 0231 	mov.w	r2, #49	; 0x31
 80034a0:	70da      	strb	r2, [r3, #3]
	watering_temp[0][4] = 'S';
 80034a2:	4b91      	ldr	r3, [pc, #580]	; (80036e8 <main+0x26c>)
 80034a4:	f04f 0253 	mov.w	r2, #83	; 0x53
 80034a8:	711a      	strb	r2, [r3, #4]
	watering_temp[0][5] = 'N';
 80034aa:	4b8f      	ldr	r3, [pc, #572]	; (80036e8 <main+0x26c>)
 80034ac:	f04f 024e 	mov.w	r2, #78	; 0x4e
 80034b0:	715a      	strb	r2, [r3, #5]
	watering_temp[0][6] = 'x';
 80034b2:	4b8d      	ldr	r3, [pc, #564]	; (80036e8 <main+0x26c>)
 80034b4:	f04f 0278 	mov.w	r2, #120	; 0x78
 80034b8:	719a      	strb	r2, [r3, #6]
	watering_temp[0][7] = ' ';
 80034ba:	4b8b      	ldr	r3, [pc, #556]	; (80036e8 <main+0x26c>)
 80034bc:	f04f 0220 	mov.w	r2, #32
 80034c0:	71da      	strb	r2, [r3, #7]
	watering_temp[0][8] = 'x';
 80034c2:	4b89      	ldr	r3, [pc, #548]	; (80036e8 <main+0x26c>)
 80034c4:	f04f 0278 	mov.w	r2, #120	; 0x78
 80034c8:	721a      	strb	r2, [r3, #8]
	watering_temp[0][9] = 'x';
 80034ca:	4b87      	ldr	r3, [pc, #540]	; (80036e8 <main+0x26c>)
 80034cc:	f04f 0278 	mov.w	r2, #120	; 0x78
 80034d0:	725a      	strb	r2, [r3, #9]
	watering_temp[0][10] = ':';
 80034d2:	4b85      	ldr	r3, [pc, #532]	; (80036e8 <main+0x26c>)
 80034d4:	f04f 023a 	mov.w	r2, #58	; 0x3a
 80034d8:	729a      	strb	r2, [r3, #10]
	watering_temp[0][11] = 'x';
 80034da:	4b83      	ldr	r3, [pc, #524]	; (80036e8 <main+0x26c>)
 80034dc:	f04f 0278 	mov.w	r2, #120	; 0x78
 80034e0:	72da      	strb	r2, [r3, #11]
	watering_temp[0][12] = 'x';
 80034e2:	4b81      	ldr	r3, [pc, #516]	; (80036e8 <main+0x26c>)
 80034e4:	f04f 0278 	mov.w	r2, #120	; 0x78
 80034e8:	731a      	strb	r2, [r3, #12]
	watering_temp[0][13] = ' ';
 80034ea:	4b7f      	ldr	r3, [pc, #508]	; (80036e8 <main+0x26c>)
 80034ec:	f04f 0220 	mov.w	r2, #32
 80034f0:	735a      	strb	r2, [r3, #13]
	watering_temp[0][14] = 'x';
 80034f2:	4b7d      	ldr	r3, [pc, #500]	; (80036e8 <main+0x26c>)
 80034f4:	f04f 0278 	mov.w	r2, #120	; 0x78
 80034f8:	739a      	strb	r2, [r3, #14]
	watering_temp[0][15] = 'x';
 80034fa:	4b7b      	ldr	r3, [pc, #492]	; (80036e8 <main+0x26c>)
 80034fc:	f04f 0278 	mov.w	r2, #120	; 0x78
 8003500:	73da      	strb	r2, [r3, #15]
	watering_temp[0][16] = '\0';
 8003502:	4b79      	ldr	r3, [pc, #484]	; (80036e8 <main+0x26c>)
 8003504:	f04f 0200 	mov.w	r2, #0
 8003508:	741a      	strb	r2, [r3, #16]

	watering_temp[1][0] = 'T';
 800350a:	4b77      	ldr	r3, [pc, #476]	; (80036e8 <main+0x26c>)
 800350c:	f04f 0254 	mov.w	r2, #84	; 0x54
 8003510:	745a      	strb	r2, [r3, #17]
	watering_temp[1][1] = 'e';
 8003512:	4b75      	ldr	r3, [pc, #468]	; (80036e8 <main+0x26c>)
 8003514:	f04f 0265 	mov.w	r2, #101	; 0x65
 8003518:	749a      	strb	r2, [r3, #18]
	watering_temp[1][2] = 'r';
 800351a:	4b73      	ldr	r3, [pc, #460]	; (80036e8 <main+0x26c>)
 800351c:	f04f 0272 	mov.w	r2, #114	; 0x72
 8003520:	74da      	strb	r2, [r3, #19]
	watering_temp[1][3] = '2';
 8003522:	4b71      	ldr	r3, [pc, #452]	; (80036e8 <main+0x26c>)
 8003524:	f04f 0232 	mov.w	r2, #50	; 0x32
 8003528:	751a      	strb	r2, [r3, #20]
	watering_temp[1][4] = 'S';
 800352a:	4b6f      	ldr	r3, [pc, #444]	; (80036e8 <main+0x26c>)
 800352c:	f04f 0253 	mov.w	r2, #83	; 0x53
 8003530:	755a      	strb	r2, [r3, #21]
	watering_temp[1][5] = 'N';
 8003532:	4b6d      	ldr	r3, [pc, #436]	; (80036e8 <main+0x26c>)
 8003534:	f04f 024e 	mov.w	r2, #78	; 0x4e
 8003538:	759a      	strb	r2, [r3, #22]
	watering_temp[1][6] = 'x';
 800353a:	4b6b      	ldr	r3, [pc, #428]	; (80036e8 <main+0x26c>)
 800353c:	f04f 0278 	mov.w	r2, #120	; 0x78
 8003540:	75da      	strb	r2, [r3, #23]
	watering_temp[1][7] = ' ';
 8003542:	4b69      	ldr	r3, [pc, #420]	; (80036e8 <main+0x26c>)
 8003544:	f04f 0220 	mov.w	r2, #32
 8003548:	761a      	strb	r2, [r3, #24]
	watering_temp[1][8] = 'x';
 800354a:	4b67      	ldr	r3, [pc, #412]	; (80036e8 <main+0x26c>)
 800354c:	f04f 0278 	mov.w	r2, #120	; 0x78
 8003550:	765a      	strb	r2, [r3, #25]
	watering_temp[1][9] = 'x';
 8003552:	4b65      	ldr	r3, [pc, #404]	; (80036e8 <main+0x26c>)
 8003554:	f04f 0278 	mov.w	r2, #120	; 0x78
 8003558:	769a      	strb	r2, [r3, #26]
	watering_temp[1][10] = ':';
 800355a:	4b63      	ldr	r3, [pc, #396]	; (80036e8 <main+0x26c>)
 800355c:	f04f 023a 	mov.w	r2, #58	; 0x3a
 8003560:	76da      	strb	r2, [r3, #27]
	watering_temp[1][11] = 'x';
 8003562:	4b61      	ldr	r3, [pc, #388]	; (80036e8 <main+0x26c>)
 8003564:	f04f 0278 	mov.w	r2, #120	; 0x78
 8003568:	771a      	strb	r2, [r3, #28]
	watering_temp[1][12] = 'x';
 800356a:	4b5f      	ldr	r3, [pc, #380]	; (80036e8 <main+0x26c>)
 800356c:	f04f 0278 	mov.w	r2, #120	; 0x78
 8003570:	775a      	strb	r2, [r3, #29]
	watering_temp[1][13] = ' ';
 8003572:	4b5d      	ldr	r3, [pc, #372]	; (80036e8 <main+0x26c>)
 8003574:	f04f 0220 	mov.w	r2, #32
 8003578:	779a      	strb	r2, [r3, #30]
	watering_temp[1][14] = 'x';
 800357a:	4b5b      	ldr	r3, [pc, #364]	; (80036e8 <main+0x26c>)
 800357c:	f04f 0278 	mov.w	r2, #120	; 0x78
 8003580:	77da      	strb	r2, [r3, #31]
	watering_temp[1][15] = 'x';
 8003582:	4b59      	ldr	r3, [pc, #356]	; (80036e8 <main+0x26c>)
 8003584:	f04f 0278 	mov.w	r2, #120	; 0x78
 8003588:	f883 2020 	strb.w	r2, [r3, #32]
	watering_temp[1][16] = '\0';
 800358c:	4b56      	ldr	r3, [pc, #344]	; (80036e8 <main+0x26c>)
 800358e:	f04f 0200 	mov.w	r2, #0
 8003592:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

	watering_temp[2][0] = 'T';
 8003596:	4b54      	ldr	r3, [pc, #336]	; (80036e8 <main+0x26c>)
 8003598:	f04f 0254 	mov.w	r2, #84	; 0x54
 800359c:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
	watering_temp[2][1] = 'e';
 80035a0:	4b51      	ldr	r3, [pc, #324]	; (80036e8 <main+0x26c>)
 80035a2:	f04f 0265 	mov.w	r2, #101	; 0x65
 80035a6:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
	watering_temp[2][2] = 'r';
 80035aa:	4b4f      	ldr	r3, [pc, #316]	; (80036e8 <main+0x26c>)
 80035ac:	f04f 0272 	mov.w	r2, #114	; 0x72
 80035b0:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
	watering_temp[2][3] = 'C';
 80035b4:	4b4c      	ldr	r3, [pc, #304]	; (80036e8 <main+0x26c>)
 80035b6:	f04f 0243 	mov.w	r2, #67	; 0x43
 80035ba:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
	watering_temp[2][4] = 's';
 80035be:	4b4a      	ldr	r3, [pc, #296]	; (80036e8 <main+0x26c>)
 80035c0:	f04f 0273 	mov.w	r2, #115	; 0x73
 80035c4:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
	watering_temp[2][5] = 'N';
 80035c8:	4b47      	ldr	r3, [pc, #284]	; (80036e8 <main+0x26c>)
 80035ca:	f04f 024e 	mov.w	r2, #78	; 0x4e
 80035ce:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
	watering_temp[2][6] = 'x';
 80035d2:	4b45      	ldr	r3, [pc, #276]	; (80036e8 <main+0x26c>)
 80035d4:	f04f 0278 	mov.w	r2, #120	; 0x78
 80035d8:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
	watering_temp[2][7] = ' ';
 80035dc:	4b42      	ldr	r3, [pc, #264]	; (80036e8 <main+0x26c>)
 80035de:	f04f 0220 	mov.w	r2, #32
 80035e2:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
	watering_temp[2][8] = 'x';
 80035e6:	4b40      	ldr	r3, [pc, #256]	; (80036e8 <main+0x26c>)
 80035e8:	f04f 0278 	mov.w	r2, #120	; 0x78
 80035ec:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
	watering_temp[2][9] = 'x';
 80035f0:	4b3d      	ldr	r3, [pc, #244]	; (80036e8 <main+0x26c>)
 80035f2:	f04f 0278 	mov.w	r2, #120	; 0x78
 80035f6:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
	watering_temp[2][10] = ':';
 80035fa:	4b3b      	ldr	r3, [pc, #236]	; (80036e8 <main+0x26c>)
 80035fc:	f04f 023a 	mov.w	r2, #58	; 0x3a
 8003600:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
	watering_temp[2][11] = 'x';
 8003604:	4b38      	ldr	r3, [pc, #224]	; (80036e8 <main+0x26c>)
 8003606:	f04f 0278 	mov.w	r2, #120	; 0x78
 800360a:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
	watering_temp[2][12] = 'x';
 800360e:	4b36      	ldr	r3, [pc, #216]	; (80036e8 <main+0x26c>)
 8003610:	f04f 0278 	mov.w	r2, #120	; 0x78
 8003614:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
	watering_temp[2][13] = ' ';
 8003618:	4b33      	ldr	r3, [pc, #204]	; (80036e8 <main+0x26c>)
 800361a:	f04f 0220 	mov.w	r2, #32
 800361e:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
	watering_temp[2][14] = 'x';
 8003622:	4b31      	ldr	r3, [pc, #196]	; (80036e8 <main+0x26c>)
 8003624:	f04f 0278 	mov.w	r2, #120	; 0x78
 8003628:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
	watering_temp[2][15] = 'x';
 800362c:	4b2e      	ldr	r3, [pc, #184]	; (80036e8 <main+0x26c>)
 800362e:	f04f 0278 	mov.w	r2, #120	; 0x78
 8003632:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
	watering_temp[2][16] = '\0';
 8003636:	4b2c      	ldr	r3, [pc, #176]	; (80036e8 <main+0x26c>)
 8003638:	f04f 0200 	mov.w	r2, #0
 800363c:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32

	watering_temp[3][0] = 'K';
 8003640:	4b29      	ldr	r3, [pc, #164]	; (80036e8 <main+0x26c>)
 8003642:	f04f 024b 	mov.w	r2, #75	; 0x4b
 8003646:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
	watering_temp[3][1] = 'e';
 800364a:	4b27      	ldr	r3, [pc, #156]	; (80036e8 <main+0x26c>)
 800364c:	f04f 0265 	mov.w	r2, #101	; 0x65
 8003650:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
	watering_temp[3][2] = 'r';
 8003654:	4b24      	ldr	r3, [pc, #144]	; (80036e8 <main+0x26c>)
 8003656:	f04f 0272 	mov.w	r2, #114	; 0x72
 800365a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
	watering_temp[3][3] = 't';
 800365e:	4b22      	ldr	r3, [pc, #136]	; (80036e8 <main+0x26c>)
 8003660:	f04f 0274 	mov.w	r2, #116	; 0x74
 8003664:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
	watering_temp[3][4] = '1';
 8003668:	4b1f      	ldr	r3, [pc, #124]	; (80036e8 <main+0x26c>)
 800366a:	f04f 0231 	mov.w	r2, #49	; 0x31
 800366e:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37
	watering_temp[3][5] = 'N';
 8003672:	4b1d      	ldr	r3, [pc, #116]	; (80036e8 <main+0x26c>)
 8003674:	f04f 024e 	mov.w	r2, #78	; 0x4e
 8003678:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
	watering_temp[3][6] = 'x';
 800367c:	4b1a      	ldr	r3, [pc, #104]	; (80036e8 <main+0x26c>)
 800367e:	f04f 0278 	mov.w	r2, #120	; 0x78
 8003682:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
	watering_temp[3][7] = ' ';
 8003686:	4b18      	ldr	r3, [pc, #96]	; (80036e8 <main+0x26c>)
 8003688:	f04f 0220 	mov.w	r2, #32
 800368c:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
	watering_temp[3][8] = 'x';
 8003690:	4b15      	ldr	r3, [pc, #84]	; (80036e8 <main+0x26c>)
 8003692:	f04f 0278 	mov.w	r2, #120	; 0x78
 8003696:	f883 203b 	strb.w	r2, [r3, #59]	; 0x3b
	watering_temp[3][9] = 'x';
 800369a:	4b13      	ldr	r3, [pc, #76]	; (80036e8 <main+0x26c>)
 800369c:	f04f 0278 	mov.w	r2, #120	; 0x78
 80036a0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
	watering_temp[3][10] = ':';
 80036a4:	4b10      	ldr	r3, [pc, #64]	; (80036e8 <main+0x26c>)
 80036a6:	f04f 023a 	mov.w	r2, #58	; 0x3a
 80036aa:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
	watering_temp[3][11] = 'x';
 80036ae:	4b0e      	ldr	r3, [pc, #56]	; (80036e8 <main+0x26c>)
 80036b0:	f04f 0278 	mov.w	r2, #120	; 0x78
 80036b4:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
	watering_temp[3][12] = 'x';
 80036b8:	4b0b      	ldr	r3, [pc, #44]	; (80036e8 <main+0x26c>)
 80036ba:	f04f 0278 	mov.w	r2, #120	; 0x78
 80036be:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
	watering_temp[3][13] = ' ';
 80036c2:	4b09      	ldr	r3, [pc, #36]	; (80036e8 <main+0x26c>)
 80036c4:	f04f 0220 	mov.w	r2, #32
 80036c8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
	watering_temp[3][14] = 'x';
 80036cc:	4b06      	ldr	r3, [pc, #24]	; (80036e8 <main+0x26c>)
 80036ce:	f04f 0278 	mov.w	r2, #120	; 0x78
 80036d2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
	watering_temp[3][15] = 'x';
 80036d6:	4b04      	ldr	r3, [pc, #16]	; (80036e8 <main+0x26c>)
 80036d8:	f04f 0278 	mov.w	r2, #120	; 0x78
 80036dc:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
	watering_temp[3][16] = '\0';
 80036e0:	4b01      	ldr	r3, [pc, #4]	; (80036e8 <main+0x26c>)
 80036e2:	f04f 0200 	mov.w	r2, #0
 80036e6:	e001      	b.n	80036ec <main+0x270>
 80036e8:	20000dac 	.word	0x20000dac
 80036ec:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

	watering_temp[4][0] = 'K';
 80036f0:	4b98      	ldr	r3, [pc, #608]	; (8003954 <main+0x4d8>)
 80036f2:	f04f 024b 	mov.w	r2, #75	; 0x4b
 80036f6:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	watering_temp[4][1] = 'e';
 80036fa:	4b96      	ldr	r3, [pc, #600]	; (8003954 <main+0x4d8>)
 80036fc:	f04f 0265 	mov.w	r2, #101	; 0x65
 8003700:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
	watering_temp[4][2] = 'r';
 8003704:	4b93      	ldr	r3, [pc, #588]	; (8003954 <main+0x4d8>)
 8003706:	f04f 0272 	mov.w	r2, #114	; 0x72
 800370a:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
	watering_temp[4][3] = 't';
 800370e:	4b91      	ldr	r3, [pc, #580]	; (8003954 <main+0x4d8>)
 8003710:	f04f 0274 	mov.w	r2, #116	; 0x74
 8003714:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
	watering_temp[4][4] = '2';
 8003718:	4b8e      	ldr	r3, [pc, #568]	; (8003954 <main+0x4d8>)
 800371a:	f04f 0232 	mov.w	r2, #50	; 0x32
 800371e:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
	watering_temp[4][5] = 'N';
 8003722:	4b8c      	ldr	r3, [pc, #560]	; (8003954 <main+0x4d8>)
 8003724:	f04f 024e 	mov.w	r2, #78	; 0x4e
 8003728:	f883 2049 	strb.w	r2, [r3, #73]	; 0x49
	watering_temp[4][6] = 'x';
 800372c:	4b89      	ldr	r3, [pc, #548]	; (8003954 <main+0x4d8>)
 800372e:	f04f 0278 	mov.w	r2, #120	; 0x78
 8003732:	f883 204a 	strb.w	r2, [r3, #74]	; 0x4a
	watering_temp[4][7] = ' ';
 8003736:	4b87      	ldr	r3, [pc, #540]	; (8003954 <main+0x4d8>)
 8003738:	f04f 0220 	mov.w	r2, #32
 800373c:	f883 204b 	strb.w	r2, [r3, #75]	; 0x4b
	watering_temp[4][8] = 'x';
 8003740:	4b84      	ldr	r3, [pc, #528]	; (8003954 <main+0x4d8>)
 8003742:	f04f 0278 	mov.w	r2, #120	; 0x78
 8003746:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
	watering_temp[4][9] = 'x';
 800374a:	4b82      	ldr	r3, [pc, #520]	; (8003954 <main+0x4d8>)
 800374c:	f04f 0278 	mov.w	r2, #120	; 0x78
 8003750:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
	watering_temp[4][10] = ':';
 8003754:	4b7f      	ldr	r3, [pc, #508]	; (8003954 <main+0x4d8>)
 8003756:	f04f 023a 	mov.w	r2, #58	; 0x3a
 800375a:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
	watering_temp[4][11] = 'x';
 800375e:	4b7d      	ldr	r3, [pc, #500]	; (8003954 <main+0x4d8>)
 8003760:	f04f 0278 	mov.w	r2, #120	; 0x78
 8003764:	f883 204f 	strb.w	r2, [r3, #79]	; 0x4f
	watering_temp[4][12] = 'x';
 8003768:	4b7a      	ldr	r3, [pc, #488]	; (8003954 <main+0x4d8>)
 800376a:	f04f 0278 	mov.w	r2, #120	; 0x78
 800376e:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
	watering_temp[4][13] = ' ';
 8003772:	4b78      	ldr	r3, [pc, #480]	; (8003954 <main+0x4d8>)
 8003774:	f04f 0220 	mov.w	r2, #32
 8003778:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
	watering_temp[4][14] = 'x';
 800377c:	4b75      	ldr	r3, [pc, #468]	; (8003954 <main+0x4d8>)
 800377e:	f04f 0278 	mov.w	r2, #120	; 0x78
 8003782:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52
	watering_temp[4][15] = 'x';
 8003786:	4b73      	ldr	r3, [pc, #460]	; (8003954 <main+0x4d8>)
 8003788:	f04f 0278 	mov.w	r2, #120	; 0x78
 800378c:	f883 2053 	strb.w	r2, [r3, #83]	; 0x53
	watering_temp[4][16] = '\0';
 8003790:	4b70      	ldr	r3, [pc, #448]	; (8003954 <main+0x4d8>)
 8003792:	f04f 0200 	mov.w	r2, #0
 8003796:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54

	watering_temp[5][0] = 'C';
 800379a:	4b6e      	ldr	r3, [pc, #440]	; (8003954 <main+0x4d8>)
 800379c:	f04f 0243 	mov.w	r2, #67	; 0x43
 80037a0:	f883 2055 	strb.w	r2, [r3, #85]	; 0x55
	watering_temp[5][1] = 's';
 80037a4:	4b6b      	ldr	r3, [pc, #428]	; (8003954 <main+0x4d8>)
 80037a6:	f04f 0273 	mov.w	r2, #115	; 0x73
 80037aa:	f883 2056 	strb.w	r2, [r3, #86]	; 0x56
	watering_temp[5][2] = 'e';
 80037ae:	4b69      	ldr	r3, [pc, #420]	; (8003954 <main+0x4d8>)
 80037b0:	f04f 0265 	mov.w	r2, #101	; 0x65
 80037b4:	f883 2057 	strb.w	r2, [r3, #87]	; 0x57
	watering_temp[5][3] = 'r';
 80037b8:	4b66      	ldr	r3, [pc, #408]	; (8003954 <main+0x4d8>)
 80037ba:	f04f 0272 	mov.w	r2, #114	; 0x72
 80037be:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
	watering_temp[5][4] = '1';
 80037c2:	4b64      	ldr	r3, [pc, #400]	; (8003954 <main+0x4d8>)
 80037c4:	f04f 0231 	mov.w	r2, #49	; 0x31
 80037c8:	f883 2059 	strb.w	r2, [r3, #89]	; 0x59
	watering_temp[5][5] = 'N';
 80037cc:	4b61      	ldr	r3, [pc, #388]	; (8003954 <main+0x4d8>)
 80037ce:	f04f 024e 	mov.w	r2, #78	; 0x4e
 80037d2:	f883 205a 	strb.w	r2, [r3, #90]	; 0x5a
	watering_temp[5][6] = 'x';
 80037d6:	4b5f      	ldr	r3, [pc, #380]	; (8003954 <main+0x4d8>)
 80037d8:	f04f 0278 	mov.w	r2, #120	; 0x78
 80037dc:	f883 205b 	strb.w	r2, [r3, #91]	; 0x5b
	watering_temp[5][7] = ' ';
 80037e0:	4b5c      	ldr	r3, [pc, #368]	; (8003954 <main+0x4d8>)
 80037e2:	f04f 0220 	mov.w	r2, #32
 80037e6:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
	watering_temp[5][8] = 'x';
 80037ea:	4b5a      	ldr	r3, [pc, #360]	; (8003954 <main+0x4d8>)
 80037ec:	f04f 0278 	mov.w	r2, #120	; 0x78
 80037f0:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
	watering_temp[5][9] = 'x';
 80037f4:	4b57      	ldr	r3, [pc, #348]	; (8003954 <main+0x4d8>)
 80037f6:	f04f 0278 	mov.w	r2, #120	; 0x78
 80037fa:	f883 205e 	strb.w	r2, [r3, #94]	; 0x5e
	watering_temp[5][10] = ':';
 80037fe:	4b55      	ldr	r3, [pc, #340]	; (8003954 <main+0x4d8>)
 8003800:	f04f 023a 	mov.w	r2, #58	; 0x3a
 8003804:	f883 205f 	strb.w	r2, [r3, #95]	; 0x5f
	watering_temp[5][11] = 'x';
 8003808:	4b52      	ldr	r3, [pc, #328]	; (8003954 <main+0x4d8>)
 800380a:	f04f 0278 	mov.w	r2, #120	; 0x78
 800380e:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
	watering_temp[5][12] = 'x';
 8003812:	4b50      	ldr	r3, [pc, #320]	; (8003954 <main+0x4d8>)
 8003814:	f04f 0278 	mov.w	r2, #120	; 0x78
 8003818:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61
	watering_temp[5][13] = ' ';
 800381c:	4b4d      	ldr	r3, [pc, #308]	; (8003954 <main+0x4d8>)
 800381e:	f04f 0220 	mov.w	r2, #32
 8003822:	f883 2062 	strb.w	r2, [r3, #98]	; 0x62
	watering_temp[5][14] = 'x';
 8003826:	4b4b      	ldr	r3, [pc, #300]	; (8003954 <main+0x4d8>)
 8003828:	f04f 0278 	mov.w	r2, #120	; 0x78
 800382c:	f883 2063 	strb.w	r2, [r3, #99]	; 0x63
	watering_temp[5][15] = 'x';
 8003830:	4b48      	ldr	r3, [pc, #288]	; (8003954 <main+0x4d8>)
 8003832:	f04f 0278 	mov.w	r2, #120	; 0x78
 8003836:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
	watering_temp[5][16] = '\0';
 800383a:	4b46      	ldr	r3, [pc, #280]	; (8003954 <main+0x4d8>)
 800383c:	f04f 0200 	mov.w	r2, #0
 8003840:	f883 2065 	strb.w	r2, [r3, #101]	; 0x65

	watproc1_text[0] = '0';
 8003844:	4b44      	ldr	r3, [pc, #272]	; (8003958 <main+0x4dc>)
 8003846:	f04f 0230 	mov.w	r2, #48	; 0x30
 800384a:	701a      	strb	r2, [r3, #0]
	watproc1_text[1] = '0';
 800384c:	4b42      	ldr	r3, [pc, #264]	; (8003958 <main+0x4dc>)
 800384e:	f04f 0230 	mov.w	r2, #48	; 0x30
 8003852:	705a      	strb	r2, [r3, #1]
	watproc1_text[2] = ':';
 8003854:	4b40      	ldr	r3, [pc, #256]	; (8003958 <main+0x4dc>)
 8003856:	f04f 023a 	mov.w	r2, #58	; 0x3a
 800385a:	709a      	strb	r2, [r3, #2]
	watproc1_text[3] = '0';
 800385c:	4b3e      	ldr	r3, [pc, #248]	; (8003958 <main+0x4dc>)
 800385e:	f04f 0230 	mov.w	r2, #48	; 0x30
 8003862:	70da      	strb	r2, [r3, #3]
	watproc1_text[4] = '0';
 8003864:	4b3c      	ldr	r3, [pc, #240]	; (8003958 <main+0x4dc>)
 8003866:	f04f 0230 	mov.w	r2, #48	; 0x30
 800386a:	711a      	strb	r2, [r3, #4]
	watproc1_text[5] = '\0';
 800386c:	4b3a      	ldr	r3, [pc, #232]	; (8003958 <main+0x4dc>)
 800386e:	f04f 0200 	mov.w	r2, #0
 8003872:	715a      	strb	r2, [r3, #5]

	watering_process2[0] = '0';
 8003874:	4b39      	ldr	r3, [pc, #228]	; (800395c <main+0x4e0>)
 8003876:	f04f 0230 	mov.w	r2, #48	; 0x30
 800387a:	701a      	strb	r2, [r3, #0]
	watering_process2[1] = '0';
 800387c:	4b37      	ldr	r3, [pc, #220]	; (800395c <main+0x4e0>)
 800387e:	f04f 0230 	mov.w	r2, #48	; 0x30
 8003882:	705a      	strb	r2, [r3, #1]
	watering_process2[2] = ':';
 8003884:	4b35      	ldr	r3, [pc, #212]	; (800395c <main+0x4e0>)
 8003886:	f04f 023a 	mov.w	r2, #58	; 0x3a
 800388a:	709a      	strb	r2, [r3, #2]
	watering_process2[3] = '0';
 800388c:	4b33      	ldr	r3, [pc, #204]	; (800395c <main+0x4e0>)
 800388e:	f04f 0230 	mov.w	r2, #48	; 0x30
 8003892:	70da      	strb	r2, [r3, #3]
	watering_process2[4] = '0';
 8003894:	4b31      	ldr	r3, [pc, #196]	; (800395c <main+0x4e0>)
 8003896:	f04f 0230 	mov.w	r2, #48	; 0x30
 800389a:	711a      	strb	r2, [r3, #4]
	watering_process2[5] = '\0';
 800389c:	4b2f      	ldr	r3, [pc, #188]	; (800395c <main+0x4e0>)
 800389e:	f04f 0200 	mov.w	r2, #0
 80038a2:	715a      	strb	r2, [r3, #5]

    menu_MENU.designator=0;
 80038a4:	4b2e      	ldr	r3, [pc, #184]	; (8003960 <main+0x4e4>)
 80038a6:	f04f 0200 	mov.w	r2, #0
 80038aa:	711a      	strb	r2, [r3, #4]
    menu_MENU.nev="MENU";
 80038ac:	4b2c      	ldr	r3, [pc, #176]	; (8003960 <main+0x4e4>)
 80038ae:	4a2d      	ldr	r2, [pc, #180]	; (8003964 <main+0x4e8>)
 80038b0:	601a      	str	r2, [r3, #0]
    menu_MENU.next=0;
 80038b2:	4b2b      	ldr	r3, [pc, #172]	; (8003960 <main+0x4e4>)
 80038b4:	f04f 0200 	mov.w	r2, #0
 80038b8:	60da      	str	r2, [r3, #12]
    menu_MENU.down=(&menu_outputs_on);
 80038ba:	4b29      	ldr	r3, [pc, #164]	; (8003960 <main+0x4e4>)
 80038bc:	4a2a      	ldr	r2, [pc, #168]	; (8003968 <main+0x4ec>)
 80038be:	619a      	str	r2, [r3, #24]
    menu_MENU.previous=0;
 80038c0:	4b27      	ldr	r3, [pc, #156]	; (8003960 <main+0x4e4>)
 80038c2:	f04f 0200 	mov.w	r2, #0
 80038c6:	611a      	str	r2, [r3, #16]
    menu_MENU.up=0;
 80038c8:	4b25      	ldr	r3, [pc, #148]	; (8003960 <main+0x4e4>)
 80038ca:	f04f 0200 	mov.w	r2, #0
 80038ce:	615a      	str	r2, [r3, #20]
    menu_MENU.fgvnev=0;
 80038d0:	4b23      	ldr	r3, [pc, #140]	; (8003960 <main+0x4e4>)
 80038d2:	f04f 0200 	mov.w	r2, #0
 80038d6:	609a      	str	r2, [r3, #8]

    menu_outputs_on.designator=0;
 80038d8:	4b23      	ldr	r3, [pc, #140]	; (8003968 <main+0x4ec>)
 80038da:	f04f 0200 	mov.w	r2, #0
 80038de:	711a      	strb	r2, [r3, #4]
    menu_outputs_on.nev="Outputs On";
 80038e0:	4b21      	ldr	r3, [pc, #132]	; (8003968 <main+0x4ec>)
 80038e2:	4a22      	ldr	r2, [pc, #136]	; (800396c <main+0x4f0>)
 80038e4:	601a      	str	r2, [r3, #0]
    menu_outputs_on.fgvnev=0; 						//talán ki sem kell tölteni, hiszen a down alapján fogom a függvény létezését eldönteni.
 80038e6:	4b20      	ldr	r3, [pc, #128]	; (8003968 <main+0x4ec>)
 80038e8:	f04f 0200 	mov.w	r2, #0
 80038ec:	609a      	str	r2, [r3, #8]
    menu_outputs_on.next=(&menu_outputs_off);
 80038ee:	4b1e      	ldr	r3, [pc, #120]	; (8003968 <main+0x4ec>)
 80038f0:	4a1f      	ldr	r2, [pc, #124]	; (8003970 <main+0x4f4>)
 80038f2:	60da      	str	r2, [r3, #12]
    menu_outputs_on.previous=0;
 80038f4:	4b1c      	ldr	r3, [pc, #112]	; (8003968 <main+0x4ec>)
 80038f6:	f04f 0200 	mov.w	r2, #0
 80038fa:	611a      	str	r2, [r3, #16]
    menu_outputs_on.up=(&menu_MENU);
 80038fc:	4b1a      	ldr	r3, [pc, #104]	; (8003968 <main+0x4ec>)
 80038fe:	4a18      	ldr	r2, [pc, #96]	; (8003960 <main+0x4e4>)
 8003900:	615a      	str	r2, [r3, #20]
    menu_outputs_on.down=(&menu_outputs_on0);
 8003902:	4b19      	ldr	r3, [pc, #100]	; (8003968 <main+0x4ec>)
 8003904:	4a1b      	ldr	r2, [pc, #108]	; (8003974 <main+0x4f8>)
 8003906:	619a      	str	r2, [r3, #24]

    menu_outputs_off.designator=1;
 8003908:	4b19      	ldr	r3, [pc, #100]	; (8003970 <main+0x4f4>)
 800390a:	f04f 0201 	mov.w	r2, #1
 800390e:	711a      	strb	r2, [r3, #4]
    menu_outputs_off.nev="Outputs Off";
 8003910:	4b17      	ldr	r3, [pc, #92]	; (8003970 <main+0x4f4>)
 8003912:	4a19      	ldr	r2, [pc, #100]	; (8003978 <main+0x4fc>)
 8003914:	601a      	str	r2, [r3, #0]
    menu_outputs_off.next=(&menu_time);
 8003916:	4b16      	ldr	r3, [pc, #88]	; (8003970 <main+0x4f4>)
 8003918:	4a18      	ldr	r2, [pc, #96]	; (800397c <main+0x500>)
 800391a:	60da      	str	r2, [r3, #12]
    menu_outputs_off.previous=(&menu_outputs_on);
 800391c:	4b14      	ldr	r3, [pc, #80]	; (8003970 <main+0x4f4>)
 800391e:	4a12      	ldr	r2, [pc, #72]	; (8003968 <main+0x4ec>)
 8003920:	611a      	str	r2, [r3, #16]
    menu_outputs_off.up=0;
 8003922:	4b13      	ldr	r3, [pc, #76]	; (8003970 <main+0x4f4>)
 8003924:	f04f 0200 	mov.w	r2, #0
 8003928:	615a      	str	r2, [r3, #20]
    menu_outputs_off.down=(&menu_outputs_off0);
 800392a:	4b11      	ldr	r3, [pc, #68]	; (8003970 <main+0x4f4>)
 800392c:	4a14      	ldr	r2, [pc, #80]	; (8003980 <main+0x504>)
 800392e:	619a      	str	r2, [r3, #24]

    menu_time.designator=2;
 8003930:	4b12      	ldr	r3, [pc, #72]	; (800397c <main+0x500>)
 8003932:	f04f 0202 	mov.w	r2, #2
 8003936:	711a      	strb	r2, [r3, #4]
    menu_time.nev="Time";
 8003938:	4b10      	ldr	r3, [pc, #64]	; (800397c <main+0x500>)
 800393a:	4a12      	ldr	r2, [pc, #72]	; (8003984 <main+0x508>)
 800393c:	601a      	str	r2, [r3, #0]
    menu_time.next=(&menu_ontozes);
 800393e:	4b0f      	ldr	r3, [pc, #60]	; (800397c <main+0x500>)
 8003940:	4a11      	ldr	r2, [pc, #68]	; (8003988 <main+0x50c>)
 8003942:	60da      	str	r2, [r3, #12]
    menu_time.previous=(&menu_outputs_off);
 8003944:	4b0d      	ldr	r3, [pc, #52]	; (800397c <main+0x500>)
 8003946:	4a0a      	ldr	r2, [pc, #40]	; (8003970 <main+0x4f4>)
 8003948:	611a      	str	r2, [r3, #16]
    menu_time.up=0;
 800394a:	4b0c      	ldr	r3, [pc, #48]	; (800397c <main+0x500>)
 800394c:	f04f 0200 	mov.w	r2, #0
 8003950:	e01c      	b.n	800398c <main+0x510>
 8003952:	bf00      	nop
 8003954:	20000dac 	.word	0x20000dac
 8003958:	20001308 	.word	0x20001308
 800395c:	20000e34 	.word	0x20000e34
 8003960:	20000f8c 	.word	0x20000f8c
 8003964:	0800d06c 	.word	0x0800d06c
 8003968:	20000ffc 	.word	0x20000ffc
 800396c:	0800d074 	.word	0x0800d074
 8003970:	20000d2c 	.word	0x20000d2c
 8003974:	200010e0 	.word	0x200010e0
 8003978:	0800d080 	.word	0x0800d080
 800397c:	200010fc 	.word	0x200010fc
 8003980:	20000fdc 	.word	0x20000fdc
 8003984:	0800d08c 	.word	0x0800d08c
 8003988:	20001018 	.word	0x20001018
 800398c:	615a      	str	r2, [r3, #20]
    menu_time.down=&(menu_time0);
 800398e:	4b94      	ldr	r3, [pc, #592]	; (8003be0 <main+0x764>)
 8003990:	4a94      	ldr	r2, [pc, #592]	; (8003be4 <main+0x768>)
 8003992:	619a      	str	r2, [r3, #24]

    menu_ontozes.designator=3;
 8003994:	4b94      	ldr	r3, [pc, #592]	; (8003be8 <main+0x76c>)
 8003996:	f04f 0203 	mov.w	r2, #3
 800399a:	711a      	strb	r2, [r3, #4]
    menu_ontozes.nev="Ontozes";
 800399c:	4b92      	ldr	r3, [pc, #584]	; (8003be8 <main+0x76c>)
 800399e:	4a93      	ldr	r2, [pc, #588]	; (8003bec <main+0x770>)
 80039a0:	601a      	str	r2, [r3, #0]
    menu_ontozes.next=(&menu_ingyen_sor);
 80039a2:	4b91      	ldr	r3, [pc, #580]	; (8003be8 <main+0x76c>)
 80039a4:	4a92      	ldr	r2, [pc, #584]	; (8003bf0 <main+0x774>)
 80039a6:	60da      	str	r2, [r3, #12]
    menu_ontozes.previous=(&menu_time);
 80039a8:	4b8f      	ldr	r3, [pc, #572]	; (8003be8 <main+0x76c>)
 80039aa:	4a8d      	ldr	r2, [pc, #564]	; (8003be0 <main+0x764>)
 80039ac:	611a      	str	r2, [r3, #16]
    menu_ontozes.up=0;
 80039ae:	4b8e      	ldr	r3, [pc, #568]	; (8003be8 <main+0x76c>)
 80039b0:	f04f 0200 	mov.w	r2, #0
 80039b4:	615a      	str	r2, [r3, #20]
    menu_ontozes.down=&watering[0];
 80039b6:	4b8c      	ldr	r3, [pc, #560]	; (8003be8 <main+0x76c>)
 80039b8:	4a8e      	ldr	r2, [pc, #568]	; (8003bf4 <main+0x778>)
 80039ba:	619a      	str	r2, [r3, #24]

    menu_ingyen_sor.designator=4;
 80039bc:	4b8c      	ldr	r3, [pc, #560]	; (8003bf0 <main+0x774>)
 80039be:	f04f 0204 	mov.w	r2, #4
 80039c2:	711a      	strb	r2, [r3, #4]
    menu_ingyen_sor.nev="Ingyen Sor";
 80039c4:	4b8a      	ldr	r3, [pc, #552]	; (8003bf0 <main+0x774>)
 80039c6:	4a8c      	ldr	r2, [pc, #560]	; (8003bf8 <main+0x77c>)
 80039c8:	601a      	str	r2, [r3, #0]
    menu_ingyen_sor.next=0;
 80039ca:	4b89      	ldr	r3, [pc, #548]	; (8003bf0 <main+0x774>)
 80039cc:	f04f 0200 	mov.w	r2, #0
 80039d0:	60da      	str	r2, [r3, #12]
    menu_ingyen_sor.previous=(&menu_ontozes);
 80039d2:	4b87      	ldr	r3, [pc, #540]	; (8003bf0 <main+0x774>)
 80039d4:	4a84      	ldr	r2, [pc, #528]	; (8003be8 <main+0x76c>)
 80039d6:	611a      	str	r2, [r3, #16]
    menu_ingyen_sor.up=0;
 80039d8:	4b85      	ldr	r3, [pc, #532]	; (8003bf0 <main+0x774>)
 80039da:	f04f 0200 	mov.w	r2, #0
 80039de:	615a      	str	r2, [r3, #20]
    menu_ingyen_sor.down=0;
 80039e0:	4b83      	ldr	r3, [pc, #524]	; (8003bf0 <main+0x774>)
 80039e2:	f04f 0200 	mov.w	r2, #0
 80039e6:	619a      	str	r2, [r3, #24]

    menu_time0.designator=0;
 80039e8:	4b7e      	ldr	r3, [pc, #504]	; (8003be4 <main+0x768>)
 80039ea:	f04f 0200 	mov.w	r2, #0
 80039ee:	711a      	strb	r2, [r3, #4]
    menu_time0.nev="...";
 80039f0:	4b7c      	ldr	r3, [pc, #496]	; (8003be4 <main+0x768>)
 80039f2:	4a82      	ldr	r2, [pc, #520]	; (8003bfc <main+0x780>)
 80039f4:	601a      	str	r2, [r3, #0]
    menu_time0.next=&(menu_date);
 80039f6:	4b7b      	ldr	r3, [pc, #492]	; (8003be4 <main+0x768>)
 80039f8:	4a81      	ldr	r2, [pc, #516]	; (8003c00 <main+0x784>)
 80039fa:	60da      	str	r2, [r3, #12]
    menu_time0.previous=0;
 80039fc:	4b79      	ldr	r3, [pc, #484]	; (8003be4 <main+0x768>)
 80039fe:	f04f 0200 	mov.w	r2, #0
 8003a02:	611a      	str	r2, [r3, #16]
    menu_time0.up=&(menu_time);
 8003a04:	4b77      	ldr	r3, [pc, #476]	; (8003be4 <main+0x768>)
 8003a06:	4a76      	ldr	r2, [pc, #472]	; (8003be0 <main+0x764>)
 8003a08:	615a      	str	r2, [r3, #20]
    menu_time0.down=0;
 8003a0a:	4b76      	ldr	r3, [pc, #472]	; (8003be4 <main+0x768>)
 8003a0c:	f04f 0200 	mov.w	r2, #0
 8003a10:	619a      	str	r2, [r3, #24]

    menu_date.designator=1;
 8003a12:	4b7b      	ldr	r3, [pc, #492]	; (8003c00 <main+0x784>)
 8003a14:	f04f 0201 	mov.w	r2, #1
 8003a18:	711a      	strb	r2, [r3, #4]
    menu_date.nev="Datum";
 8003a1a:	4b79      	ldr	r3, [pc, #484]	; (8003c00 <main+0x784>)
 8003a1c:	4a79      	ldr	r2, [pc, #484]	; (8003c04 <main+0x788>)
 8003a1e:	601a      	str	r2, [r3, #0]
    menu_date.fgvnev=DateChanger;
 8003a20:	4b77      	ldr	r3, [pc, #476]	; (8003c00 <main+0x784>)
 8003a22:	4a79      	ldr	r2, [pc, #484]	; (8003c08 <main+0x78c>)
 8003a24:	609a      	str	r2, [r3, #8]
    menu_date.next=&(menu_current_time);
 8003a26:	4b76      	ldr	r3, [pc, #472]	; (8003c00 <main+0x784>)
 8003a28:	4a78      	ldr	r2, [pc, #480]	; (8003c0c <main+0x790>)
 8003a2a:	60da      	str	r2, [r3, #12]
    menu_date.previous=&(menu_time0);
 8003a2c:	4b74      	ldr	r3, [pc, #464]	; (8003c00 <main+0x784>)
 8003a2e:	4a6d      	ldr	r2, [pc, #436]	; (8003be4 <main+0x768>)
 8003a30:	611a      	str	r2, [r3, #16]
    menu_date.up=0;
 8003a32:	4b73      	ldr	r3, [pc, #460]	; (8003c00 <main+0x784>)
 8003a34:	f04f 0200 	mov.w	r2, #0
 8003a38:	615a      	str	r2, [r3, #20]
    menu_date.down=0;
 8003a3a:	4b71      	ldr	r3, [pc, #452]	; (8003c00 <main+0x784>)
 8003a3c:	f04f 0200 	mov.w	r2, #0
 8003a40:	619a      	str	r2, [r3, #24]

    menu_current_time.designator=2;
 8003a42:	4b72      	ldr	r3, [pc, #456]	; (8003c0c <main+0x790>)
 8003a44:	f04f 0202 	mov.w	r2, #2
 8003a48:	711a      	strb	r2, [r3, #4]
    menu_current_time.nev="Ido";
 8003a4a:	4b70      	ldr	r3, [pc, #448]	; (8003c0c <main+0x790>)
 8003a4c:	4a70      	ldr	r2, [pc, #448]	; (8003c10 <main+0x794>)
 8003a4e:	601a      	str	r2, [r3, #0]
    menu_current_time.fgvnev=DateChanger;
 8003a50:	4b6e      	ldr	r3, [pc, #440]	; (8003c0c <main+0x790>)
 8003a52:	4a6d      	ldr	r2, [pc, #436]	; (8003c08 <main+0x78c>)
 8003a54:	609a      	str	r2, [r3, #8]
    menu_current_time.next=0;
 8003a56:	4b6d      	ldr	r3, [pc, #436]	; (8003c0c <main+0x790>)
 8003a58:	f04f 0200 	mov.w	r2, #0
 8003a5c:	60da      	str	r2, [r3, #12]
    menu_current_time.previous=&(menu_date);
 8003a5e:	4b6b      	ldr	r3, [pc, #428]	; (8003c0c <main+0x790>)
 8003a60:	4a67      	ldr	r2, [pc, #412]	; (8003c00 <main+0x784>)
 8003a62:	611a      	str	r2, [r3, #16]
    menu_current_time.up=0;
 8003a64:	4b69      	ldr	r3, [pc, #420]	; (8003c0c <main+0x790>)
 8003a66:	f04f 0200 	mov.w	r2, #0
 8003a6a:	615a      	str	r2, [r3, #20]
    menu_current_time.down=0;
 8003a6c:	4b67      	ldr	r3, [pc, #412]	; (8003c0c <main+0x790>)
 8003a6e:	f04f 0200 	mov.w	r2, #0
 8003a72:	619a      	str	r2, [r3, #24]

    menu_outputs_on0.designator=0;
 8003a74:	4b67      	ldr	r3, [pc, #412]	; (8003c14 <main+0x798>)
 8003a76:	f04f 0200 	mov.w	r2, #0
 8003a7a:	711a      	strb	r2, [r3, #4]
    menu_outputs_on0.nev="...";
 8003a7c:	4b65      	ldr	r3, [pc, #404]	; (8003c14 <main+0x798>)
 8003a7e:	4a5f      	ldr	r2, [pc, #380]	; (8003bfc <main+0x780>)
 8003a80:	601a      	str	r2, [r3, #0]
    menu_outputs_on0.next=(&menu_outputs_on1);
 8003a82:	4b64      	ldr	r3, [pc, #400]	; (8003c14 <main+0x798>)
 8003a84:	4a64      	ldr	r2, [pc, #400]	; (8003c18 <main+0x79c>)
 8003a86:	60da      	str	r2, [r3, #12]
    menu_outputs_on0.previous=0;
 8003a88:	4b62      	ldr	r3, [pc, #392]	; (8003c14 <main+0x798>)
 8003a8a:	f04f 0200 	mov.w	r2, #0
 8003a8e:	611a      	str	r2, [r3, #16]
    menu_outputs_on0.up=(&menu_outputs_on);
 8003a90:	4b60      	ldr	r3, [pc, #384]	; (8003c14 <main+0x798>)
 8003a92:	4a62      	ldr	r2, [pc, #392]	; (8003c1c <main+0x7a0>)
 8003a94:	615a      	str	r2, [r3, #20]
    menu_outputs_on0.down=0;
 8003a96:	4b5f      	ldr	r3, [pc, #380]	; (8003c14 <main+0x798>)
 8003a98:	f04f 0200 	mov.w	r2, #0
 8003a9c:	619a      	str	r2, [r3, #24]

    menu_outputs_off0.designator=0;
 8003a9e:	4b60      	ldr	r3, [pc, #384]	; (8003c20 <main+0x7a4>)
 8003aa0:	f04f 0200 	mov.w	r2, #0
 8003aa4:	711a      	strb	r2, [r3, #4]
    menu_outputs_off0.nev="...";
 8003aa6:	4b5e      	ldr	r3, [pc, #376]	; (8003c20 <main+0x7a4>)
 8003aa8:	4a54      	ldr	r2, [pc, #336]	; (8003bfc <main+0x780>)
 8003aaa:	601a      	str	r2, [r3, #0]
    menu_outputs_off0.next=(&menu_outputs_off1);
 8003aac:	4b5c      	ldr	r3, [pc, #368]	; (8003c20 <main+0x7a4>)
 8003aae:	4a5d      	ldr	r2, [pc, #372]	; (8003c24 <main+0x7a8>)
 8003ab0:	60da      	str	r2, [r3, #12]
    menu_outputs_off0.previous=0;
 8003ab2:	4b5b      	ldr	r3, [pc, #364]	; (8003c20 <main+0x7a4>)
 8003ab4:	f04f 0200 	mov.w	r2, #0
 8003ab8:	611a      	str	r2, [r3, #16]
    menu_outputs_off0.up=(&menu_outputs_off);
 8003aba:	4b59      	ldr	r3, [pc, #356]	; (8003c20 <main+0x7a4>)
 8003abc:	4a5a      	ldr	r2, [pc, #360]	; (8003c28 <main+0x7ac>)
 8003abe:	615a      	str	r2, [r3, #20]
    menu_outputs_off0.down=0;
 8003ac0:	4b57      	ldr	r3, [pc, #348]	; (8003c20 <main+0x7a4>)
 8003ac2:	f04f 0200 	mov.w	r2, #0
 8003ac6:	619a      	str	r2, [r3, #24]

    menu_utkozes.designator=0;
 8003ac8:	4b58      	ldr	r3, [pc, #352]	; (8003c2c <main+0x7b0>)
 8003aca:	f04f 0200 	mov.w	r2, #0
 8003ace:	711a      	strb	r2, [r3, #4]
    menu_utkozes.nev="Vigyazz Utkozes!";
 8003ad0:	4b56      	ldr	r3, [pc, #344]	; (8003c2c <main+0x7b0>)
 8003ad2:	4a57      	ldr	r2, [pc, #348]	; (8003c30 <main+0x7b4>)
 8003ad4:	601a      	str	r2, [r3, #0]
    menu_utkozes.next=0;
 8003ad6:	4b55      	ldr	r3, [pc, #340]	; (8003c2c <main+0x7b0>)
 8003ad8:	f04f 0200 	mov.w	r2, #0
 8003adc:	60da      	str	r2, [r3, #12]
    menu_utkozes.previous=0;
 8003ade:	4b53      	ldr	r3, [pc, #332]	; (8003c2c <main+0x7b0>)
 8003ae0:	f04f 0200 	mov.w	r2, #0
 8003ae4:	611a      	str	r2, [r3, #16]
    menu_utkozes.up=&watering[0];
 8003ae6:	4b51      	ldr	r3, [pc, #324]	; (8003c2c <main+0x7b0>)
 8003ae8:	4a42      	ldr	r2, [pc, #264]	; (8003bf4 <main+0x778>)
 8003aea:	615a      	str	r2, [r3, #20]
    menu_utkozes.down=0;
 8003aec:	4b4f      	ldr	r3, [pc, #316]	; (8003c2c <main+0x7b0>)
 8003aee:	f04f 0200 	mov.w	r2, #0
 8003af2:	619a      	str	r2, [r3, #24]

    watering[0].designator = 0;
 8003af4:	4b3f      	ldr	r3, [pc, #252]	; (8003bf4 <main+0x778>)
 8003af6:	f04f 0200 	mov.w	r2, #0
 8003afa:	711a      	strb	r2, [r3, #4]
    watering[0].nev="...";
 8003afc:	4b3d      	ldr	r3, [pc, #244]	; (8003bf4 <main+0x778>)
 8003afe:	4a3f      	ldr	r2, [pc, #252]	; (8003bfc <main+0x780>)
 8003b00:	601a      	str	r2, [r3, #0]
    watering[0].next=(&watering[1]);
 8003b02:	4b3c      	ldr	r3, [pc, #240]	; (8003bf4 <main+0x778>)
 8003b04:	4a4b      	ldr	r2, [pc, #300]	; (8003c34 <main+0x7b8>)
 8003b06:	60da      	str	r2, [r3, #12]
    watering[0].previous=0;
 8003b08:	4b3a      	ldr	r3, [pc, #232]	; (8003bf4 <main+0x778>)
 8003b0a:	f04f 0200 	mov.w	r2, #0
 8003b0e:	611a      	str	r2, [r3, #16]
    watering[0].up=(&menu_ontozes);
 8003b10:	4b38      	ldr	r3, [pc, #224]	; (8003bf4 <main+0x778>)
 8003b12:	4a35      	ldr	r2, [pc, #212]	; (8003be8 <main+0x76c>)
 8003b14:	615a      	str	r2, [r3, #20]
    watering[0].down=0;
 8003b16:	4b37      	ldr	r3, [pc, #220]	; (8003bf4 <main+0x778>)
 8003b18:	f04f 0200 	mov.w	r2, #0
 8003b1c:	619a      	str	r2, [r3, #24]

    watering[1].designator=1;
 8003b1e:	4b35      	ldr	r3, [pc, #212]	; (8003bf4 <main+0x778>)
 8003b20:	f04f 0201 	mov.w	r2, #1
 8003b24:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
    watering[1].nev=&watering_temp[0];
 8003b28:	4b32      	ldr	r3, [pc, #200]	; (8003bf4 <main+0x778>)
 8003b2a:	4a43      	ldr	r2, [pc, #268]	; (8003c38 <main+0x7bc>)
 8003b2c:	629a      	str	r2, [r3, #40]	; 0x28
    watering[1].next=(&watering[2]);
 8003b2e:	4b31      	ldr	r3, [pc, #196]	; (8003bf4 <main+0x778>)
 8003b30:	4a42      	ldr	r2, [pc, #264]	; (8003c3c <main+0x7c0>)
 8003b32:	635a      	str	r2, [r3, #52]	; 0x34
    watering[1].previous=(&watering[0]);
 8003b34:	4b2f      	ldr	r3, [pc, #188]	; (8003bf4 <main+0x778>)
 8003b36:	4a2f      	ldr	r2, [pc, #188]	; (8003bf4 <main+0x778>)
 8003b38:	639a      	str	r2, [r3, #56]	; 0x38
    watering[1].up=0;
 8003b3a:	4b2e      	ldr	r3, [pc, #184]	; (8003bf4 <main+0x778>)
 8003b3c:	f04f 0200 	mov.w	r2, #0
 8003b40:	63da      	str	r2, [r3, #60]	; 0x3c
    watering[1].down=&(watering_settings_0);
 8003b42:	4b2c      	ldr	r3, [pc, #176]	; (8003bf4 <main+0x778>)
 8003b44:	4a3e      	ldr	r2, [pc, #248]	; (8003c40 <main+0x7c4>)
 8003b46:	641a      	str	r2, [r3, #64]	; 0x40
    watering[1].Watering_channel = 1;
 8003b48:	4b2a      	ldr	r3, [pc, #168]	; (8003bf4 <main+0x778>)
 8003b4a:	f04f 0201 	mov.w	r2, #1
 8003b4e:	f883 204b 	strb.w	r2, [r3, #75]	; 0x4b

    watering[2].designator=2;
 8003b52:	4b28      	ldr	r3, [pc, #160]	; (8003bf4 <main+0x778>)
 8003b54:	f04f 0202 	mov.w	r2, #2
 8003b58:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
    watering[2].nev=&watering_temp[1];
 8003b5c:	4b25      	ldr	r3, [pc, #148]	; (8003bf4 <main+0x778>)
 8003b5e:	4a39      	ldr	r2, [pc, #228]	; (8003c44 <main+0x7c8>)
 8003b60:	651a      	str	r2, [r3, #80]	; 0x50
    watering[2].next=(&watering[3]);
 8003b62:	4b24      	ldr	r3, [pc, #144]	; (8003bf4 <main+0x778>)
 8003b64:	4a38      	ldr	r2, [pc, #224]	; (8003c48 <main+0x7cc>)
 8003b66:	65da      	str	r2, [r3, #92]	; 0x5c
    watering[2].previous=(&watering[1]);
 8003b68:	4b22      	ldr	r3, [pc, #136]	; (8003bf4 <main+0x778>)
 8003b6a:	4a32      	ldr	r2, [pc, #200]	; (8003c34 <main+0x7b8>)
 8003b6c:	661a      	str	r2, [r3, #96]	; 0x60
    watering[2].up=0;
 8003b6e:	4b21      	ldr	r3, [pc, #132]	; (8003bf4 <main+0x778>)
 8003b70:	f04f 0200 	mov.w	r2, #0
 8003b74:	665a      	str	r2, [r3, #100]	; 0x64
    watering[2].down=&(watering_settings_0);
 8003b76:	4b1f      	ldr	r3, [pc, #124]	; (8003bf4 <main+0x778>)
 8003b78:	4a31      	ldr	r2, [pc, #196]	; (8003c40 <main+0x7c4>)
 8003b7a:	669a      	str	r2, [r3, #104]	; 0x68
    watering[2].Watering_channel = 2;
 8003b7c:	4b1d      	ldr	r3, [pc, #116]	; (8003bf4 <main+0x778>)
 8003b7e:	f04f 0202 	mov.w	r2, #2
 8003b82:	f883 2073 	strb.w	r2, [r3, #115]	; 0x73

    watering[3].designator=3;
 8003b86:	4b1b      	ldr	r3, [pc, #108]	; (8003bf4 <main+0x778>)
 8003b88:	f04f 0203 	mov.w	r2, #3
 8003b8c:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c
    watering[3].nev=&watering_temp[2];
 8003b90:	4b18      	ldr	r3, [pc, #96]	; (8003bf4 <main+0x778>)
 8003b92:	4a2e      	ldr	r2, [pc, #184]	; (8003c4c <main+0x7d0>)
 8003b94:	679a      	str	r2, [r3, #120]	; 0x78
    watering[3].next=(&watering[4]);
 8003b96:	4b17      	ldr	r3, [pc, #92]	; (8003bf4 <main+0x778>)
 8003b98:	4a2d      	ldr	r2, [pc, #180]	; (8003c50 <main+0x7d4>)
 8003b9a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    watering[3].previous=(&watering[2]);
 8003b9e:	4b15      	ldr	r3, [pc, #84]	; (8003bf4 <main+0x778>)
 8003ba0:	4a26      	ldr	r2, [pc, #152]	; (8003c3c <main+0x7c0>)
 8003ba2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    watering[3].up=0;
 8003ba6:	4b13      	ldr	r3, [pc, #76]	; (8003bf4 <main+0x778>)
 8003ba8:	f04f 0200 	mov.w	r2, #0
 8003bac:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    watering[3].down=&(watering_settings_0);
 8003bb0:	4b10      	ldr	r3, [pc, #64]	; (8003bf4 <main+0x778>)
 8003bb2:	4a23      	ldr	r2, [pc, #140]	; (8003c40 <main+0x7c4>)
 8003bb4:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    watering[3].Watering_channel = 3;
 8003bb8:	4b0e      	ldr	r3, [pc, #56]	; (8003bf4 <main+0x778>)
 8003bba:	f04f 0203 	mov.w	r2, #3
 8003bbe:	f883 209b 	strb.w	r2, [r3, #155]	; 0x9b

    watering[4].designator=4;
 8003bc2:	4b0c      	ldr	r3, [pc, #48]	; (8003bf4 <main+0x778>)
 8003bc4:	f04f 0204 	mov.w	r2, #4
 8003bc8:	f883 20a4 	strb.w	r2, [r3, #164]	; 0xa4
    watering[4].nev=&watering_temp[3];
 8003bcc:	4b09      	ldr	r3, [pc, #36]	; (8003bf4 <main+0x778>)
 8003bce:	4a21      	ldr	r2, [pc, #132]	; (8003c54 <main+0x7d8>)
 8003bd0:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
    watering[4].next=(&watering[5]);
 8003bd4:	4b07      	ldr	r3, [pc, #28]	; (8003bf4 <main+0x778>)
 8003bd6:	4a20      	ldr	r2, [pc, #128]	; (8003c58 <main+0x7dc>)
 8003bd8:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
 8003bdc:	e03e      	b.n	8003c5c <main+0x7e0>
 8003bde:	bf00      	nop
 8003be0:	200010fc 	.word	0x200010fc
 8003be4:	20000f54 	.word	0x20000f54
 8003be8:	20001018 	.word	0x20001018
 8003bec:	0800d094 	.word	0x0800d094
 8003bf0:	20000e80 	.word	0x20000e80
 8003bf4:	20001134 	.word	0x20001134
 8003bf8:	0800d09c 	.word	0x0800d09c
 8003bfc:	0800d0a8 	.word	0x0800d0a8
 8003c00:	200012a4 	.word	0x200012a4
 8003c04:	0800d0ac 	.word	0x0800d0ac
 8003c08:	08001e41 	.word	0x08001e41
 8003c0c:	200013e0 	.word	0x200013e0
 8003c10:	0800d0b4 	.word	0x0800d0b4
 8003c14:	200010e0 	.word	0x200010e0
 8003c18:	200013c4 	.word	0x200013c4
 8003c1c:	20000ffc 	.word	0x20000ffc
 8003c20:	20000fdc 	.word	0x20000fdc
 8003c24:	20000d50 	.word	0x20000d50
 8003c28:	20000d2c 	.word	0x20000d2c
 8003c2c:	20001354 	.word	0x20001354
 8003c30:	0800d0b8 	.word	0x0800d0b8
 8003c34:	2000115c 	.word	0x2000115c
 8003c38:	20000dac 	.word	0x20000dac
 8003c3c:	20001184 	.word	0x20001184
 8003c40:	20001118 	.word	0x20001118
 8003c44:	20000dbd 	.word	0x20000dbd
 8003c48:	200011ac 	.word	0x200011ac
 8003c4c:	20000dce 	.word	0x20000dce
 8003c50:	200011d4 	.word	0x200011d4
 8003c54:	20000ddf 	.word	0x20000ddf
 8003c58:	200011fc 	.word	0x200011fc
    watering[4].previous=(&watering[3]);
 8003c5c:	4b6a      	ldr	r3, [pc, #424]	; (8003e08 <main+0x98c>)
 8003c5e:	4a6b      	ldr	r2, [pc, #428]	; (8003e0c <main+0x990>)
 8003c60:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
    watering[4].up=0;
 8003c64:	4b68      	ldr	r3, [pc, #416]	; (8003e08 <main+0x98c>)
 8003c66:	f04f 0200 	mov.w	r2, #0
 8003c6a:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
    watering[4].down=&(watering_settings_0);
 8003c6e:	4b66      	ldr	r3, [pc, #408]	; (8003e08 <main+0x98c>)
 8003c70:	4a67      	ldr	r2, [pc, #412]	; (8003e10 <main+0x994>)
 8003c72:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
    watering[4].Watering_channel = 4;
 8003c76:	4b64      	ldr	r3, [pc, #400]	; (8003e08 <main+0x98c>)
 8003c78:	f04f 0204 	mov.w	r2, #4
 8003c7c:	f883 20c3 	strb.w	r2, [r3, #195]	; 0xc3

    watering[5].designator=5;
 8003c80:	4b61      	ldr	r3, [pc, #388]	; (8003e08 <main+0x98c>)
 8003c82:	f04f 0205 	mov.w	r2, #5
 8003c86:	f883 20cc 	strb.w	r2, [r3, #204]	; 0xcc
    watering[5].nev=&watering_temp[4];
 8003c8a:	4b5f      	ldr	r3, [pc, #380]	; (8003e08 <main+0x98c>)
 8003c8c:	4a61      	ldr	r2, [pc, #388]	; (8003e14 <main+0x998>)
 8003c8e:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    watering[5].next=(&watering[6]);
 8003c92:	4b5d      	ldr	r3, [pc, #372]	; (8003e08 <main+0x98c>)
 8003c94:	4a60      	ldr	r2, [pc, #384]	; (8003e18 <main+0x99c>)
 8003c96:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
    watering[5].previous=(&watering[4]);
 8003c9a:	4b5b      	ldr	r3, [pc, #364]	; (8003e08 <main+0x98c>)
 8003c9c:	4a5f      	ldr	r2, [pc, #380]	; (8003e1c <main+0x9a0>)
 8003c9e:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
    watering[5].up=0;
 8003ca2:	4b59      	ldr	r3, [pc, #356]	; (8003e08 <main+0x98c>)
 8003ca4:	f04f 0200 	mov.w	r2, #0
 8003ca8:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
    watering[5].down=&(watering_settings_0);
 8003cac:	4b56      	ldr	r3, [pc, #344]	; (8003e08 <main+0x98c>)
 8003cae:	4a58      	ldr	r2, [pc, #352]	; (8003e10 <main+0x994>)
 8003cb0:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
    watering[5].Watering_channel = 5;
 8003cb4:	4b54      	ldr	r3, [pc, #336]	; (8003e08 <main+0x98c>)
 8003cb6:	f04f 0205 	mov.w	r2, #5
 8003cba:	f883 20eb 	strb.w	r2, [r3, #235]	; 0xeb

    watering[6].designator=6;
 8003cbe:	4b52      	ldr	r3, [pc, #328]	; (8003e08 <main+0x98c>)
 8003cc0:	f04f 0206 	mov.w	r2, #6
 8003cc4:	f883 20f4 	strb.w	r2, [r3, #244]	; 0xf4
    watering[6].nev=&watering_temp[5];
 8003cc8:	4b4f      	ldr	r3, [pc, #316]	; (8003e08 <main+0x98c>)
 8003cca:	4a55      	ldr	r2, [pc, #340]	; (8003e20 <main+0x9a4>)
 8003ccc:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
    watering[6].next=0;
 8003cd0:	4b4d      	ldr	r3, [pc, #308]	; (8003e08 <main+0x98c>)
 8003cd2:	f04f 0200 	mov.w	r2, #0
 8003cd6:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
    watering[6].previous=(&watering[5]);
 8003cda:	4b4b      	ldr	r3, [pc, #300]	; (8003e08 <main+0x98c>)
 8003cdc:	4a51      	ldr	r2, [pc, #324]	; (8003e24 <main+0x9a8>)
 8003cde:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    watering[6].up=0;
 8003ce2:	4b49      	ldr	r3, [pc, #292]	; (8003e08 <main+0x98c>)
 8003ce4:	f04f 0200 	mov.w	r2, #0
 8003ce8:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    watering[6].down=&(watering_settings_0);
 8003cec:	4b46      	ldr	r3, [pc, #280]	; (8003e08 <main+0x98c>)
 8003cee:	4a48      	ldr	r2, [pc, #288]	; (8003e10 <main+0x994>)
 8003cf0:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
    watering[6].Watering_channel = 6;
 8003cf4:	4b44      	ldr	r3, [pc, #272]	; (8003e08 <main+0x98c>)
 8003cf6:	f04f 0206 	mov.w	r2, #6
 8003cfa:	f883 2113 	strb.w	r2, [r3, #275]	; 0x113

    watering_settings_0.designator=0;
 8003cfe:	4b44      	ldr	r3, [pc, #272]	; (8003e10 <main+0x994>)
 8003d00:	f04f 0200 	mov.w	r2, #0
 8003d04:	711a      	strb	r2, [r3, #4]
    watering_settings_0.nev="...";
 8003d06:	4b42      	ldr	r3, [pc, #264]	; (8003e10 <main+0x994>)
 8003d08:	4a47      	ldr	r2, [pc, #284]	; (8003e28 <main+0x9ac>)
 8003d0a:	601a      	str	r2, [r3, #0]
    watering_settings_0.next=&(watering_delete);
 8003d0c:	4b40      	ldr	r3, [pc, #256]	; (8003e10 <main+0x994>)
 8003d0e:	4a47      	ldr	r2, [pc, #284]	; (8003e2c <main+0x9b0>)
 8003d10:	60da      	str	r2, [r3, #12]
    watering_settings_0.previous=0;
 8003d12:	4b3f      	ldr	r3, [pc, #252]	; (8003e10 <main+0x994>)
 8003d14:	f04f 0200 	mov.w	r2, #0
 8003d18:	611a      	str	r2, [r3, #16]
    watering_settings_0.up=&watering[0];
 8003d1a:	4b3d      	ldr	r3, [pc, #244]	; (8003e10 <main+0x994>)
 8003d1c:	4a3a      	ldr	r2, [pc, #232]	; (8003e08 <main+0x98c>)
 8003d1e:	615a      	str	r2, [r3, #20]
    watering_settings_0.down=0;
 8003d20:	4b3b      	ldr	r3, [pc, #236]	; (8003e10 <main+0x994>)
 8003d22:	f04f 0200 	mov.w	r2, #0
 8003d26:	619a      	str	r2, [r3, #24]

    watering_delete.designator=1;
 8003d28:	4b40      	ldr	r3, [pc, #256]	; (8003e2c <main+0x9b0>)
 8003d2a:	f04f 0201 	mov.w	r2, #1
 8003d2e:	711a      	strb	r2, [r3, #4]
    watering_delete.nev="Torles";
 8003d30:	4b3e      	ldr	r3, [pc, #248]	; (8003e2c <main+0x9b0>)
 8003d32:	4a3f      	ldr	r2, [pc, #252]	; (8003e30 <main+0x9b4>)
 8003d34:	601a      	str	r2, [r3, #0]
    watering_delete.fgvnev=Watering;
 8003d36:	4b3d      	ldr	r3, [pc, #244]	; (8003e2c <main+0x9b0>)
 8003d38:	4a3e      	ldr	r2, [pc, #248]	; (8003e34 <main+0x9b8>)
 8003d3a:	609a      	str	r2, [r3, #8]
    watering_delete.next=&(watering_edit);
 8003d3c:	4b3b      	ldr	r3, [pc, #236]	; (8003e2c <main+0x9b0>)
 8003d3e:	4a3e      	ldr	r2, [pc, #248]	; (8003e38 <main+0x9bc>)
 8003d40:	60da      	str	r2, [r3, #12]
    watering_delete.previous=&(watering_settings_0);
 8003d42:	4b3a      	ldr	r3, [pc, #232]	; (8003e2c <main+0x9b0>)
 8003d44:	4a32      	ldr	r2, [pc, #200]	; (8003e10 <main+0x994>)
 8003d46:	611a      	str	r2, [r3, #16]
    watering_delete.up=0;
 8003d48:	4b38      	ldr	r3, [pc, #224]	; (8003e2c <main+0x9b0>)
 8003d4a:	f04f 0200 	mov.w	r2, #0
 8003d4e:	615a      	str	r2, [r3, #20]
    watering_delete.down=0;
 8003d50:	4b36      	ldr	r3, [pc, #216]	; (8003e2c <main+0x9b0>)
 8003d52:	f04f 0200 	mov.w	r2, #0
 8003d56:	619a      	str	r2, [r3, #24]

    watering_edit.designator=2;
 8003d58:	4b37      	ldr	r3, [pc, #220]	; (8003e38 <main+0x9bc>)
 8003d5a:	f04f 0202 	mov.w	r2, #2
 8003d5e:	711a      	strb	r2, [r3, #4]
    watering_edit.nev="Szerkesztes";
 8003d60:	4b35      	ldr	r3, [pc, #212]	; (8003e38 <main+0x9bc>)
 8003d62:	4a36      	ldr	r2, [pc, #216]	; (8003e3c <main+0x9c0>)
 8003d64:	601a      	str	r2, [r3, #0]
    watering_edit.fgvnev=Watering;
 8003d66:	4b34      	ldr	r3, [pc, #208]	; (8003e38 <main+0x9bc>)
 8003d68:	4a32      	ldr	r2, [pc, #200]	; (8003e34 <main+0x9b8>)
 8003d6a:	609a      	str	r2, [r3, #8]
    watering_edit.next=0;
 8003d6c:	4b32      	ldr	r3, [pc, #200]	; (8003e38 <main+0x9bc>)
 8003d6e:	f04f 0200 	mov.w	r2, #0
 8003d72:	60da      	str	r2, [r3, #12]
    watering_edit.previous=&(watering_delete);
 8003d74:	4b30      	ldr	r3, [pc, #192]	; (8003e38 <main+0x9bc>)
 8003d76:	4a2d      	ldr	r2, [pc, #180]	; (8003e2c <main+0x9b0>)
 8003d78:	611a      	str	r2, [r3, #16]
    watering_edit.up=0;
 8003d7a:	4b2f      	ldr	r3, [pc, #188]	; (8003e38 <main+0x9bc>)
 8003d7c:	f04f 0200 	mov.w	r2, #0
 8003d80:	615a      	str	r2, [r3, #20]
    watering_edit.down=0;
 8003d82:	4b2d      	ldr	r3, [pc, #180]	; (8003e38 <main+0x9bc>)
 8003d84:	f04f 0200 	mov.w	r2, #0
 8003d88:	619a      	str	r2, [r3, #24]

    watering_prcess1.designator=0;
 8003d8a:	4b2d      	ldr	r3, [pc, #180]	; (8003e40 <main+0x9c4>)
 8003d8c:	f04f 0200 	mov.w	r2, #0
 8003d90:	711a      	strb	r2, [r3, #4]
    watering_prcess1.nev=&watproc1_text;
 8003d92:	4b2b      	ldr	r3, [pc, #172]	; (8003e40 <main+0x9c4>)
 8003d94:	4a2b      	ldr	r2, [pc, #172]	; (8003e44 <main+0x9c8>)
 8003d96:	601a      	str	r2, [r3, #0]
    watering_prcess1.next=&(watering_prcess2);
 8003d98:	4b29      	ldr	r3, [pc, #164]	; (8003e40 <main+0x9c4>)
 8003d9a:	4a2b      	ldr	r2, [pc, #172]	; (8003e48 <main+0x9cc>)
 8003d9c:	60da      	str	r2, [r3, #12]
    watering_prcess1.previous=0;
 8003d9e:	4b28      	ldr	r3, [pc, #160]	; (8003e40 <main+0x9c4>)
 8003da0:	f04f 0200 	mov.w	r2, #0
 8003da4:	611a      	str	r2, [r3, #16]
    watering_prcess1.up=&(menu_outputs_on);
 8003da6:	4b26      	ldr	r3, [pc, #152]	; (8003e40 <main+0x9c4>)
 8003da8:	4a28      	ldr	r2, [pc, #160]	; (8003e4c <main+0x9d0>)
 8003daa:	615a      	str	r2, [r3, #20]
    watering_prcess1.down=0;
 8003dac:	4b24      	ldr	r3, [pc, #144]	; (8003e40 <main+0x9c4>)
 8003dae:	f04f 0200 	mov.w	r2, #0
 8003db2:	619a      	str	r2, [r3, #24]

    watering_prcess2.designator=1;
 8003db4:	4b24      	ldr	r3, [pc, #144]	; (8003e48 <main+0x9cc>)
 8003db6:	f04f 0201 	mov.w	r2, #1
 8003dba:	711a      	strb	r2, [r3, #4]
    watering_prcess2.nev=&watering_process2;
 8003dbc:	4b22      	ldr	r3, [pc, #136]	; (8003e48 <main+0x9cc>)
 8003dbe:	4a24      	ldr	r2, [pc, #144]	; (8003e50 <main+0x9d4>)
 8003dc0:	601a      	str	r2, [r3, #0]
    watering_prcess2.next=0;
 8003dc2:	4b21      	ldr	r3, [pc, #132]	; (8003e48 <main+0x9cc>)
 8003dc4:	f04f 0200 	mov.w	r2, #0
 8003dc8:	60da      	str	r2, [r3, #12]
    watering_prcess2.previous=&(watering_prcess1);
 8003dca:	4b1f      	ldr	r3, [pc, #124]	; (8003e48 <main+0x9cc>)
 8003dcc:	4a1c      	ldr	r2, [pc, #112]	; (8003e40 <main+0x9c4>)
 8003dce:	611a      	str	r2, [r3, #16]
    watering_prcess2.up=0;
 8003dd0:	4b1d      	ldr	r3, [pc, #116]	; (8003e48 <main+0x9cc>)
 8003dd2:	f04f 0200 	mov.w	r2, #0
 8003dd6:	615a      	str	r2, [r3, #20]
    watering_prcess2.down=0;
 8003dd8:	4b1b      	ldr	r3, [pc, #108]	; (8003e48 <main+0x9cc>)
 8003dda:	f04f 0200 	mov.w	r2, #0
 8003dde:	619a      	str	r2, [r3, #24]

    int a = 0, b = 0;
 8003de0:	f04f 0300 	mov.w	r3, #0
 8003de4:	607b      	str	r3, [r7, #4]
 8003de6:	f04f 0300 	mov.w	r3, #0
 8003dea:	603b      	str	r3, [r7, #0]
    day_counter = 1;
 8003dec:	4b19      	ldr	r3, [pc, #100]	; (8003e54 <main+0x9d8>)
 8003dee:	f04f 0201 	mov.w	r2, #1
 8003df2:	601a      	str	r2, [r3, #0]
    menu_special_function = 0;
 8003df4:	4b18      	ldr	r3, [pc, #96]	; (8003e58 <main+0x9dc>)
 8003df6:	f04f 0200 	mov.w	r2, #0
 8003dfa:	701a      	strb	r2, [r3, #0]
    menu_level = 0;
 8003dfc:	4b17      	ldr	r3, [pc, #92]	; (8003e5c <main+0x9e0>)
 8003dfe:	f04f 0200 	mov.w	r2, #0
 8003e02:	701a      	strb	r2, [r3, #0]

    while(a < 100)
 8003e04:	e033      	b.n	8003e6e <main+0x9f2>
 8003e06:	bf00      	nop
 8003e08:	20001134 	.word	0x20001134
 8003e0c:	200011ac 	.word	0x200011ac
 8003e10:	20001118 	.word	0x20001118
 8003e14:	20000df0 	.word	0x20000df0
 8003e18:	20001224 	.word	0x20001224
 8003e1c:	200011d4 	.word	0x200011d4
 8003e20:	20000e01 	.word	0x20000e01
 8003e24:	200011fc 	.word	0x200011fc
 8003e28:	0800d0a8 	.word	0x0800d0a8
 8003e2c:	20000cf4 	.word	0x20000cf4
 8003e30:	0800d0cc 	.word	0x0800d0cc
 8003e34:	0800285d 	.word	0x0800285d
 8003e38:	20001318 	.word	0x20001318
 8003e3c:	0800d0d4 	.word	0x0800d0d4
 8003e40:	20001034 	.word	0x20001034
 8003e44:	20001308 	.word	0x20001308
 8003e48:	20000d10 	.word	0x20000d10
 8003e4c:	20000ffc 	.word	0x20000ffc
 8003e50:	20000e34 	.word	0x20000e34
 8003e54:	20000e5c 	.word	0x20000e5c
 8003e58:	20000e12 	.word	0x20000e12
 8003e5c:	2000130e 	.word	0x2000130e
    {
       __delay_cycles(100000);
 8003e60:	4852      	ldr	r0, [pc, #328]	; (8003fac <main+0xb30>)
 8003e62:	f7fc fb09 	bl	8000478 <__delay_cycles>
       a++;
 8003e66:	687b      	ldr	r3, [r7, #4]
 8003e68:	f103 0301 	add.w	r3, r3, #1
 8003e6c:	607b      	str	r3, [r7, #4]
    int a = 0, b = 0;
    day_counter = 1;
    menu_special_function = 0;
    menu_level = 0;

    while(a < 100)
 8003e6e:	687b      	ldr	r3, [r7, #4]
 8003e70:	2b63      	cmp	r3, #99	; 0x63
 8003e72:	ddf5      	ble.n	8003e60 <main+0x9e4>
    {
       __delay_cycles(100000);
       a++;
    }
    a=0;
 8003e74:	f04f 0300 	mov.w	r3, #0
 8003e78:	607b      	str	r3, [r7, #4]

    Inputs_Init();
 8003e7a:	f7fc f9e9 	bl	8000250 <Inputs_Init>
    Outputs_Init();
 8003e7e:	f000 f8b7 	bl	8003ff0 <Outputs_Init>

    InitializeLcm();
 8003e82:	f7fc fc73 	bl	800076c <InitializeLcm>
    ClearLcmScreen();
 8003e86:	f7fc fc55 	bl	8000734 <ClearLcmScreen>

    STM_EVAL_LEDInit(LED3);
 8003e8a:	f04f 0001 	mov.w	r0, #1
 8003e8e:	f000 fab3 	bl	80043f8 <STM_EVAL_LEDInit>
    STM_EVAL_LEDInit(LED4);
 8003e92:	f04f 0000 	mov.w	r0, #0
 8003e96:	f000 faaf 	bl	80043f8 <STM_EVAL_LEDInit>
    STM_EVAL_LEDInit(LED5);
 8003e9a:	f04f 0002 	mov.w	r0, #2
 8003e9e:	f000 faab 	bl	80043f8 <STM_EVAL_LEDInit>
    STM_EVAL_LEDInit(LED6);
 8003ea2:	f04f 0003 	mov.w	r0, #3
 8003ea6:	f000 faa7 	bl	80043f8 <STM_EVAL_LEDInit>
    STM_EVAL_PBInit(BUTTON_USER, BUTTON_MODE_GPIO);
 8003eaa:	f04f 0000 	mov.w	r0, #0
 8003eae:	f04f 0100 	mov.w	r1, #0
 8003eb2:	f000 fb23 	bl	80044fc <STM_EVAL_PBInit>

    //***********************************VÁRSKOZÁS A NYOMÓGOMBRA********************************

    while(STM_EVAL_PBGetState(BUTTON_USER) != SET)
 8003eb6:	bf00      	nop
 8003eb8:	f04f 0000 	mov.w	r0, #0
 8003ebc:	f000 fb8e 	bl	80045dc <STM_EVAL_PBGetState>
 8003ec0:	4603      	mov	r3, r0
 8003ec2:	2b01      	cmp	r3, #1
 8003ec4:	d1f8      	bne.n	8003eb8 <main+0xa3c>
    {
    }
    STM_EVAL_LEDOn(LED3);
 8003ec6:	f04f 0001 	mov.w	r0, #1
 8003eca:	f000 fac9 	bl	8004460 <STM_EVAL_LEDOn>

    //*************************************flash prog



    menu_first = &menu_outputs_on;
 8003ece:	4b38      	ldr	r3, [pc, #224]	; (8003fb0 <main+0xb34>)
 8003ed0:	4a38      	ldr	r2, [pc, #224]	; (8003fb4 <main+0xb38>)
 8003ed2:	601a      	str	r2, [r3, #0]
    menu_current = &menu_outputs_on;
 8003ed4:	4b38      	ldr	r3, [pc, #224]	; (8003fb8 <main+0xb3c>)
 8003ed6:	4a37      	ldr	r2, [pc, #220]	; (8003fb4 <main+0xb38>)
 8003ed8:	601a      	str	r2, [r3, #0]

    Cursor(0,0);
 8003eda:	f04f 0000 	mov.w	r0, #0
 8003ede:	f04f 0100 	mov.w	r1, #0
 8003ee2:	f7fc fbef 	bl	80006c4 <Cursor>
    StrAlign(menu_MENU.nev, temp, ALIGN_CENTER);
 8003ee6:	4b35      	ldr	r3, [pc, #212]	; (8003fbc <main+0xb40>)
 8003ee8:	681b      	ldr	r3, [r3, #0]
 8003eea:	4618      	mov	r0, r3
 8003eec:	4934      	ldr	r1, [pc, #208]	; (8003fc0 <main+0xb44>)
 8003eee:	f04f 0203 	mov.w	r2, #3
 8003ef2:	f7fc fcb5 	bl	8000860 <StrAlign>
    PrintStr(temp);
 8003ef6:	4832      	ldr	r0, [pc, #200]	; (8003fc0 <main+0xb44>)
 8003ef8:	f7fc fdf2 	bl	8000ae0 <PrintStr>

    menu_temporary = menu_MENU.down;
 8003efc:	4b2f      	ldr	r3, [pc, #188]	; (8003fbc <main+0xb40>)
 8003efe:	699a      	ldr	r2, [r3, #24]
 8003f00:	4b30      	ldr	r3, [pc, #192]	; (8003fc4 <main+0xb48>)
 8003f02:	601a      	str	r2, [r3, #0]
    Cursor(1,0);
 8003f04:	f04f 0001 	mov.w	r0, #1
 8003f08:	f04f 0100 	mov.w	r1, #0
 8003f0c:	f7fc fbda 	bl	80006c4 <Cursor>
    StrAlign(menu_temporary->nev, temp, ALIGN_ARROW);
 8003f10:	4b2c      	ldr	r3, [pc, #176]	; (8003fc4 <main+0xb48>)
 8003f12:	681b      	ldr	r3, [r3, #0]
 8003f14:	681b      	ldr	r3, [r3, #0]
 8003f16:	4618      	mov	r0, r3
 8003f18:	4929      	ldr	r1, [pc, #164]	; (8003fc0 <main+0xb44>)
 8003f1a:	f04f 0204 	mov.w	r2, #4
 8003f1e:	f7fc fc9f 	bl	8000860 <StrAlign>
    PrintStr(temp);
 8003f22:	4827      	ldr	r0, [pc, #156]	; (8003fc0 <main+0xb44>)
 8003f24:	f7fc fddc 	bl	8000ae0 <PrintStr>

    menu_temporary = menu_temporary->next;
 8003f28:	4b26      	ldr	r3, [pc, #152]	; (8003fc4 <main+0xb48>)
 8003f2a:	681b      	ldr	r3, [r3, #0]
 8003f2c:	68da      	ldr	r2, [r3, #12]
 8003f2e:	4b25      	ldr	r3, [pc, #148]	; (8003fc4 <main+0xb48>)
 8003f30:	601a      	str	r2, [r3, #0]
    Cursor(2,0);
 8003f32:	f04f 0002 	mov.w	r0, #2
 8003f36:	f04f 0100 	mov.w	r1, #0
 8003f3a:	f7fc fbc3 	bl	80006c4 <Cursor>
    PrintStr(menu_temporary->nev);
 8003f3e:	4b21      	ldr	r3, [pc, #132]	; (8003fc4 <main+0xb48>)
 8003f40:	681b      	ldr	r3, [r3, #0]
 8003f42:	681b      	ldr	r3, [r3, #0]
 8003f44:	4618      	mov	r0, r3
 8003f46:	f7fc fdcb 	bl	8000ae0 <PrintStr>

    menu_temporary = menu_temporary->next;
 8003f4a:	4b1e      	ldr	r3, [pc, #120]	; (8003fc4 <main+0xb48>)
 8003f4c:	681b      	ldr	r3, [r3, #0]
 8003f4e:	68da      	ldr	r2, [r3, #12]
 8003f50:	4b1c      	ldr	r3, [pc, #112]	; (8003fc4 <main+0xb48>)
 8003f52:	601a      	str	r2, [r3, #0]
    Cursor(3,0);
 8003f54:	f04f 0003 	mov.w	r0, #3
 8003f58:	f04f 0100 	mov.w	r1, #0
 8003f5c:	f7fc fbb2 	bl	80006c4 <Cursor>
    PrintStr(menu_temporary->nev);
 8003f60:	4b18      	ldr	r3, [pc, #96]	; (8003fc4 <main+0xb48>)
 8003f62:	681b      	ldr	r3, [r3, #0]
 8003f64:	681b      	ldr	r3, [r3, #0]
 8003f66:	4618      	mov	r0, r3
 8003f68:	f7fc fdba 	bl	8000ae0 <PrintStr>

    FlashReset();
 8003f6c:	f008 f8a2 	bl	800c0b4 <FlashReset>
    FlashSectorStampToDefault(SectorStampToDefaultMode_Only_First);
 8003f70:	f04f 0002 	mov.w	r0, #2
 8003f74:	f008 fc56 	bl	800c824 <FlashSectorStampToDefault>
    ADC_Driver_Init();
 8003f78:	f007 ff48 	bl	800be0c <ADC_Driver_Init>
    RTC_Config();
 8003f7c:	f000 f97a 	bl	8004274 <RTC_Config>
    RTC_WakeUpCmd(ENABLE);
 8003f80:	f04f 0001 	mov.w	r0, #1
 8003f84:	f005 f9cc 	bl	8009320 <RTC_WakeUpCmd>
    TimerConfig();
 8003f88:	f007 fe44 	bl	800bc14 <TimerConfig>

     b=0;
 8003f8c:	f04f 0300 	mov.w	r3, #0
 8003f90:	603b      	str	r3, [r7, #0]
     while(b<100)
 8003f92:	e006      	b.n	8003fa2 <main+0xb26>
     {
         __delay_cycles(100000);
 8003f94:	4805      	ldr	r0, [pc, #20]	; (8003fac <main+0xb30>)
 8003f96:	f7fc fa6f 	bl	8000478 <__delay_cycles>
         b++;
 8003f9a:	683b      	ldr	r3, [r7, #0]
 8003f9c:	f103 0301 	add.w	r3, r3, #1
 8003fa0:	603b      	str	r3, [r7, #0]
    RTC_Config();
    RTC_WakeUpCmd(ENABLE);
    TimerConfig();

     b=0;
     while(b<100)
 8003fa2:	683b      	ldr	r3, [r7, #0]
 8003fa4:	2b63      	cmp	r3, #99	; 0x63
 8003fa6:	ddf5      	ble.n	8003f94 <main+0xb18>
         __delay_cycles(100000);
         b++;
     }

     //***********************************VÉGTELENÍTETT CIKLUS********************************
     while(1);
 8003fa8:	e7fe      	b.n	8003fa8 <main+0xb2c>
 8003faa:	bf00      	nop
 8003fac:	000186a0 	.word	0x000186a0
 8003fb0:	20000d48 	.word	0x20000d48
 8003fb4:	20000ffc 	.word	0x20000ffc
 8003fb8:	2000124c 	.word	0x2000124c
 8003fbc:	20000f8c 	.word	0x20000f8c
 8003fc0:	20000fac 	.word	0x20000fac
 8003fc4:	20001310 	.word	0x20001310

08003fc8 <EVAL_AUDIO_TransferComplete_CallBack>:





void EVAL_AUDIO_TransferComplete_CallBack(uint32_t pBuffer, uint32_t Size){
 8003fc8:	b480      	push	{r7}
 8003fca:	b083      	sub	sp, #12
 8003fcc:	af00      	add	r7, sp, #0
 8003fce:	6078      	str	r0, [r7, #4]
 8003fd0:	6039      	str	r1, [r7, #0]
  /* TODO, implement your code here */
  return;
 8003fd2:	bf00      	nop
}
 8003fd4:	f107 070c 	add.w	r7, r7, #12
 8003fd8:	46bd      	mov	sp, r7
 8003fda:	bc80      	pop	{r7}
 8003fdc:	4770      	bx	lr
 8003fde:	bf00      	nop

08003fe0 <EVAL_AUDIO_GetSampleCallBack>:

/*
 * Callback used by stm324xg_eval_audio_codec.c.
 * Refer to stm324xg_eval_audio_codec.h for more info.
 */
uint16_t EVAL_AUDIO_GetSampleCallBack(void){
 8003fe0:	b480      	push	{r7}
 8003fe2:	af00      	add	r7, sp, #0
  /* TODO, implement your code here */
  return -1;
 8003fe4:	f64f 73ff 	movw	r3, #65535	; 0xffff
}
 8003fe8:	4618      	mov	r0, r3
 8003fea:	46bd      	mov	sp, r7
 8003fec:	bc80      	pop	{r7}
 8003fee:	4770      	bx	lr

08003ff0 <Outputs_Init>:
#include "outputs.h"
#include "stm32f4xx.h"


void Outputs_Init()
{
 8003ff0:	b580      	push	{r7, lr}
 8003ff2:	b082      	sub	sp, #8
 8003ff4:	af00      	add	r7, sp, #0
      GPIO_InitTypeDef  GPIO_InitStructure;

      /* Output portok engedéélyezése */
      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
 8003ff6:	f04f 0004 	mov.w	r0, #4
 8003ffa:	f04f 0101 	mov.w	r1, #1
 8003ffe:	f004 f8d7 	bl	80081b0 <RCC_AHB1PeriphClockCmd>
      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
 8004002:	f04f 0008 	mov.w	r0, #8
 8004006:	f04f 0101 	mov.w	r1, #1
 800400a:	f004 f8d1 	bl	80081b0 <RCC_AHB1PeriphClockCmd>

      /* Output lábak inicializálása a C porton  */
      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_11 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
 800400e:	f44f 436b 	mov.w	r3, #60160	; 0xeb00
 8004012:	603b      	str	r3, [r7, #0]
      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8004014:	f04f 0301 	mov.w	r3, #1
 8004018:	713b      	strb	r3, [r7, #4]
      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800401a:	f04f 0300 	mov.w	r3, #0
 800401e:	71bb      	strb	r3, [r7, #6]
      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8004020:	f04f 0301 	mov.w	r3, #1
 8004024:	71fb      	strb	r3, [r7, #7]
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 8004026:	f04f 0300 	mov.w	r3, #0
 800402a:	717b      	strb	r3, [r7, #5]
      GPIO_Init(GPIOC, &GPIO_InitStructure);
 800402c:	463b      	mov	r3, r7
 800402e:	480e      	ldr	r0, [pc, #56]	; (8004068 <Outputs_Init+0x78>)
 8004030:	4619      	mov	r1, r3
 8004032:	f003 faab 	bl	800758c <GPIO_Init>

      /* Output lábak inicializálása a D porton  */
      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11;
 8004036:	f44f 6370 	mov.w	r3, #3840	; 0xf00
 800403a:	603b      	str	r3, [r7, #0]
      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 800403c:	f04f 0301 	mov.w	r3, #1
 8004040:	713b      	strb	r3, [r7, #4]
      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004042:	f04f 0300 	mov.w	r3, #0
 8004046:	71bb      	strb	r3, [r7, #6]
      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8004048:	f04f 0301 	mov.w	r3, #1
 800404c:	71fb      	strb	r3, [r7, #7]
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 800404e:	f04f 0300 	mov.w	r3, #0
 8004052:	717b      	strb	r3, [r7, #5]
      GPIO_Init(GPIOD, &GPIO_InitStructure);
 8004054:	463b      	mov	r3, r7
 8004056:	4805      	ldr	r0, [pc, #20]	; (800406c <Outputs_Init+0x7c>)
 8004058:	4619      	mov	r1, r3
 800405a:	f003 fa97 	bl	800758c <GPIO_Init>
}
 800405e:	f107 0708 	add.w	r7, r7, #8
 8004062:	46bd      	mov	sp, r7
 8004064:	bd80      	pop	{r7, pc}
 8004066:	bf00      	nop
 8004068:	40020800 	.word	0x40020800
 800406c:	40020c00 	.word	0x40020c00

08004070 <Output_On>:

void Output_On(Output_TypeDef Output)
{
 8004070:	b580      	push	{r7, lr}
 8004072:	b082      	sub	sp, #8
 8004074:	af00      	add	r7, sp, #0
 8004076:	4603      	mov	r3, r0
 8004078:	71fb      	strb	r3, [r7, #7]
    switch(Output)
 800407a:	79fb      	ldrb	r3, [r7, #7]
 800407c:	f103 33ff 	add.w	r3, r3, #4294967295
 8004080:	2b09      	cmp	r3, #9
 8004082:	d853      	bhi.n	800412c <Output_On+0xbc>
 8004084:	a201      	add	r2, pc, #4	; (adr r2, 800408c <Output_On+0x1c>)
 8004086:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800408a:	bf00      	nop
 800408c:	080040b5 	.word	0x080040b5
 8004090:	080040c1 	.word	0x080040c1
 8004094:	080040cd 	.word	0x080040cd
 8004098:	080040d9 	.word	0x080040d9
 800409c:	080040e5 	.word	0x080040e5
 80040a0:	080040f1 	.word	0x080040f1
 80040a4:	080040fd 	.word	0x080040fd
 80040a8:	08004109 	.word	0x08004109
 80040ac:	08004115 	.word	0x08004115
 80040b0:	08004121 	.word	0x08004121
    {
        case Output_1:
            GPIO_SetBits(OUTPUT_1_PORT, OUTPUT_1_PIN);
 80040b4:	481f      	ldr	r0, [pc, #124]	; (8004134 <Output_On+0xc4>)
 80040b6:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 80040ba:	f003 fba1 	bl	8007800 <GPIO_SetBits>
        break;
 80040be:	e035      	b.n	800412c <Output_On+0xbc>
        case Output_2:
            GPIO_SetBits(OUTPUT_2_PORT, OUTPUT_2_PIN);
 80040c0:	481c      	ldr	r0, [pc, #112]	; (8004134 <Output_On+0xc4>)
 80040c2:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80040c6:	f003 fb9b 	bl	8007800 <GPIO_SetBits>
        break;
 80040ca:	e02f      	b.n	800412c <Output_On+0xbc>
        case Output_3:
            GPIO_SetBits(OUTPUT_3_PORT, OUTPUT_3_PIN);
 80040cc:	4819      	ldr	r0, [pc, #100]	; (8004134 <Output_On+0xc4>)
 80040ce:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80040d2:	f003 fb95 	bl	8007800 <GPIO_SetBits>
        break;
 80040d6:	e029      	b.n	800412c <Output_On+0xbc>
        case Output_4:
            GPIO_SetBits(OUTPUT_4_PORT, OUTPUT_4_PIN);
 80040d8:	4817      	ldr	r0, [pc, #92]	; (8004138 <Output_On+0xc8>)
 80040da:	f44f 7180 	mov.w	r1, #256	; 0x100
 80040de:	f003 fb8f 	bl	8007800 <GPIO_SetBits>
        break;
 80040e2:	e023      	b.n	800412c <Output_On+0xbc>
        case Output_5:
            GPIO_SetBits(OUTPUT_5_PORT, OUTPUT_5_PIN);
 80040e4:	4814      	ldr	r0, [pc, #80]	; (8004138 <Output_On+0xc8>)
 80040e6:	f44f 7100 	mov.w	r1, #512	; 0x200
 80040ea:	f003 fb89 	bl	8007800 <GPIO_SetBits>
        break;
 80040ee:	e01d      	b.n	800412c <Output_On+0xbc>
        case Output_6:
            GPIO_SetBits(OUTPUT_6_PORT, OUTPUT_6_PIN);
 80040f0:	4811      	ldr	r0, [pc, #68]	; (8004138 <Output_On+0xc8>)
 80040f2:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80040f6:	f003 fb83 	bl	8007800 <GPIO_SetBits>
        break;
 80040fa:	e017      	b.n	800412c <Output_On+0xbc>
        case Output_7:
            GPIO_SetBits(OUTPUT_7_PORT, OUTPUT_7_PIN);
 80040fc:	480e      	ldr	r0, [pc, #56]	; (8004138 <Output_On+0xc8>)
 80040fe:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8004102:	f003 fb7d 	bl	8007800 <GPIO_SetBits>
        break;
 8004106:	e011      	b.n	800412c <Output_On+0xbc>
        case Output_8:
            GPIO_SetBits(OUTPUT_8_PORT, OUTPUT_8_PIN);
 8004108:	480a      	ldr	r0, [pc, #40]	; (8004134 <Output_On+0xc4>)
 800410a:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800410e:	f003 fb77 	bl	8007800 <GPIO_SetBits>
        break;
 8004112:	e00b      	b.n	800412c <Output_On+0xbc>
        case Output_9:
            GPIO_SetBits(OUTPUT_9_PORT, OUTPUT_9_PIN);
 8004114:	4807      	ldr	r0, [pc, #28]	; (8004134 <Output_On+0xc4>)
 8004116:	f44f 7180 	mov.w	r1, #256	; 0x100
 800411a:	f003 fb71 	bl	8007800 <GPIO_SetBits>
        break;
 800411e:	e005      	b.n	800412c <Output_On+0xbc>
        case Output_10:
            GPIO_SetBits(OUTPUT_10_PORT, OUTPUT_10_PIN);
 8004120:	4804      	ldr	r0, [pc, #16]	; (8004134 <Output_On+0xc4>)
 8004122:	f44f 7100 	mov.w	r1, #512	; 0x200
 8004126:	f003 fb6b 	bl	8007800 <GPIO_SetBits>
        break;
 800412a:	bf00      	nop
    }
}
 800412c:	f107 0708 	add.w	r7, r7, #8
 8004130:	46bd      	mov	sp, r7
 8004132:	bd80      	pop	{r7, pc}
 8004134:	40020800 	.word	0x40020800
 8004138:	40020c00 	.word	0x40020c00

0800413c <Output_Off>:
void Output_Off(Output_TypeDef Output)
{
 800413c:	b580      	push	{r7, lr}
 800413e:	b082      	sub	sp, #8
 8004140:	af00      	add	r7, sp, #0
 8004142:	4603      	mov	r3, r0
 8004144:	71fb      	strb	r3, [r7, #7]
    switch(Output)
 8004146:	79fb      	ldrb	r3, [r7, #7]
 8004148:	f103 33ff 	add.w	r3, r3, #4294967295
 800414c:	2b0a      	cmp	r3, #10
 800414e:	f200 8088 	bhi.w	8004262 <Output_Off+0x126>
 8004152:	a201      	add	r2, pc, #4	; (adr r2, 8004158 <Output_Off+0x1c>)
 8004154:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8004158:	08004185 	.word	0x08004185
 800415c:	08004191 	.word	0x08004191
 8004160:	0800419d 	.word	0x0800419d
 8004164:	080041a9 	.word	0x080041a9
 8004168:	080041b5 	.word	0x080041b5
 800416c:	080041c1 	.word	0x080041c1
 8004170:	080041cd 	.word	0x080041cd
 8004174:	080041d9 	.word	0x080041d9
 8004178:	080041e5 	.word	0x080041e5
 800417c:	080041f1 	.word	0x080041f1
 8004180:	080041fd 	.word	0x080041fd
    {
        case Output_1:
            GPIO_ResetBits(OUTPUT_1_PORT, OUTPUT_1_PIN);
 8004184:	4839      	ldr	r0, [pc, #228]	; (800426c <Output_Off+0x130>)
 8004186:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 800418a:	f003 fb47 	bl	800781c <GPIO_ResetBits>
        break;
 800418e:	e069      	b.n	8004264 <Output_Off+0x128>
        case Output_2:
            GPIO_ResetBits(OUTPUT_2_PORT, OUTPUT_2_PIN);
 8004190:	4836      	ldr	r0, [pc, #216]	; (800426c <Output_Off+0x130>)
 8004192:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8004196:	f003 fb41 	bl	800781c <GPIO_ResetBits>
        break;
 800419a:	e063      	b.n	8004264 <Output_Off+0x128>
        case Output_3:
            GPIO_ResetBits(OUTPUT_3_PORT, OUTPUT_3_PIN);
 800419c:	4833      	ldr	r0, [pc, #204]	; (800426c <Output_Off+0x130>)
 800419e:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80041a2:	f003 fb3b 	bl	800781c <GPIO_ResetBits>
        break;
 80041a6:	e05d      	b.n	8004264 <Output_Off+0x128>
        case Output_4:
            GPIO_ResetBits(OUTPUT_4_PORT, OUTPUT_4_PIN);
 80041a8:	4831      	ldr	r0, [pc, #196]	; (8004270 <Output_Off+0x134>)
 80041aa:	f44f 7180 	mov.w	r1, #256	; 0x100
 80041ae:	f003 fb35 	bl	800781c <GPIO_ResetBits>
        break;
 80041b2:	e057      	b.n	8004264 <Output_Off+0x128>
        case Output_5:
            GPIO_ResetBits(OUTPUT_5_PORT, OUTPUT_5_PIN);
 80041b4:	482e      	ldr	r0, [pc, #184]	; (8004270 <Output_Off+0x134>)
 80041b6:	f44f 7100 	mov.w	r1, #512	; 0x200
 80041ba:	f003 fb2f 	bl	800781c <GPIO_ResetBits>
        break;
 80041be:	e051      	b.n	8004264 <Output_Off+0x128>
        case Output_6:
            GPIO_ResetBits(OUTPUT_6_PORT, OUTPUT_6_PIN);
 80041c0:	482b      	ldr	r0, [pc, #172]	; (8004270 <Output_Off+0x134>)
 80041c2:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80041c6:	f003 fb29 	bl	800781c <GPIO_ResetBits>
        break;
 80041ca:	e04b      	b.n	8004264 <Output_Off+0x128>
        case Output_7:
            GPIO_ResetBits(OUTPUT_7_PORT, OUTPUT_7_PIN);
 80041cc:	4828      	ldr	r0, [pc, #160]	; (8004270 <Output_Off+0x134>)
 80041ce:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80041d2:	f003 fb23 	bl	800781c <GPIO_ResetBits>
        break;
 80041d6:	e045      	b.n	8004264 <Output_Off+0x128>
        case Output_8:
            GPIO_ResetBits(OUTPUT_8_PORT, OUTPUT_8_PIN);
 80041d8:	4824      	ldr	r0, [pc, #144]	; (800426c <Output_Off+0x130>)
 80041da:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80041de:	f003 fb1d 	bl	800781c <GPIO_ResetBits>
        break;
 80041e2:	e03f      	b.n	8004264 <Output_Off+0x128>
        case Output_9:
            GPIO_ResetBits(OUTPUT_9_PORT, OUTPUT_9_PIN);
 80041e4:	4821      	ldr	r0, [pc, #132]	; (800426c <Output_Off+0x130>)
 80041e6:	f44f 7180 	mov.w	r1, #256	; 0x100
 80041ea:	f003 fb17 	bl	800781c <GPIO_ResetBits>
        break;
 80041ee:	e039      	b.n	8004264 <Output_Off+0x128>
        case Output_10:
            GPIO_ResetBits(OUTPUT_10_PORT, OUTPUT_10_PIN);
 80041f0:	481e      	ldr	r0, [pc, #120]	; (800426c <Output_Off+0x130>)
 80041f2:	f44f 7100 	mov.w	r1, #512	; 0x200
 80041f6:	f003 fb11 	bl	800781c <GPIO_ResetBits>
        break;
 80041fa:	e033      	b.n	8004264 <Output_Off+0x128>
        case Output_all:
            GPIO_ResetBits(OUTPUT_1_PORT, OUTPUT_1_PIN);
 80041fc:	481b      	ldr	r0, [pc, #108]	; (800426c <Output_Off+0x130>)
 80041fe:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8004202:	f003 fb0b 	bl	800781c <GPIO_ResetBits>
            GPIO_ResetBits(OUTPUT_2_PORT, OUTPUT_2_PIN);
 8004206:	4819      	ldr	r0, [pc, #100]	; (800426c <Output_Off+0x130>)
 8004208:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800420c:	f003 fb06 	bl	800781c <GPIO_ResetBits>
            GPIO_ResetBits(OUTPUT_3_PORT, OUTPUT_3_PIN);
 8004210:	4816      	ldr	r0, [pc, #88]	; (800426c <Output_Off+0x130>)
 8004212:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8004216:	f003 fb01 	bl	800781c <GPIO_ResetBits>
            GPIO_ResetBits(OUTPUT_4_PORT, OUTPUT_4_PIN);
 800421a:	4815      	ldr	r0, [pc, #84]	; (8004270 <Output_Off+0x134>)
 800421c:	f44f 7180 	mov.w	r1, #256	; 0x100
 8004220:	f003 fafc 	bl	800781c <GPIO_ResetBits>
            GPIO_ResetBits(OUTPUT_5_PORT, OUTPUT_5_PIN);
 8004224:	4812      	ldr	r0, [pc, #72]	; (8004270 <Output_Off+0x134>)
 8004226:	f44f 7100 	mov.w	r1, #512	; 0x200
 800422a:	f003 faf7 	bl	800781c <GPIO_ResetBits>
            GPIO_ResetBits(OUTPUT_6_PORT, OUTPUT_6_PIN);
 800422e:	4810      	ldr	r0, [pc, #64]	; (8004270 <Output_Off+0x134>)
 8004230:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8004234:	f003 faf2 	bl	800781c <GPIO_ResetBits>
            GPIO_ResetBits(OUTPUT_7_PORT, OUTPUT_7_PIN);
 8004238:	480d      	ldr	r0, [pc, #52]	; (8004270 <Output_Off+0x134>)
 800423a:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800423e:	f003 faed 	bl	800781c <GPIO_ResetBits>
            GPIO_ResetBits(OUTPUT_8_PORT, OUTPUT_8_PIN);
 8004242:	480a      	ldr	r0, [pc, #40]	; (800426c <Output_Off+0x130>)
 8004244:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8004248:	f003 fae8 	bl	800781c <GPIO_ResetBits>
            GPIO_ResetBits(OUTPUT_9_PORT, OUTPUT_9_PIN);
 800424c:	4807      	ldr	r0, [pc, #28]	; (800426c <Output_Off+0x130>)
 800424e:	f44f 7180 	mov.w	r1, #256	; 0x100
 8004252:	f003 fae3 	bl	800781c <GPIO_ResetBits>
            GPIO_ResetBits(OUTPUT_10_PORT, OUTPUT_10_PIN);
 8004256:	4805      	ldr	r0, [pc, #20]	; (800426c <Output_Off+0x130>)
 8004258:	f44f 7100 	mov.w	r1, #512	; 0x200
 800425c:	f003 fade 	bl	800781c <GPIO_ResetBits>
            break;
 8004260:	e000      	b.n	8004264 <Output_Off+0x128>

        default:
            break;
 8004262:	bf00      	nop
    }
}
 8004264:	f107 0708 	add.w	r7, r7, #8
 8004268:	46bd      	mov	sp, r7
 800426a:	bd80      	pop	{r7, pc}
 800426c:	40020800 	.word	0x40020800
 8004270:	40020c00 	.word	0x40020c00

08004274 <RTC_Config>:
#include "stm32f4xx_rtc.h"
#include "stm32f4_discovery.h"

    RTC_InitTypeDef RTC_InitStructure;
void RTC_Config(void)
{
 8004274:	b580      	push	{r7, lr}
 8004276:	b088      	sub	sp, #32
 8004278:	af00      	add	r7, sp, #0
    EXTI_InitTypeDef EXTI_InitStructure;
    RTC_InitTypeDef RTC_InitStructure;


  /* Enable the PWR clock */
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
 800427a:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 800427e:	f04f 0101 	mov.w	r1, #1
 8004282:	f003 fff5 	bl	8008270 <RCC_APB1PeriphClockCmd>

  /* Allow access to RTC */
  PWR_BackupAccessCmd(ENABLE);
 8004286:	f04f 0001 	mov.w	r0, #1
 800428a:	f003 fb71 	bl	8007970 <PWR_BackupAccessCmd>

  RCC_BackupResetCmd(ENABLE);
 800428e:	f04f 0001 	mov.w	r0, #1
 8004292:	f003 ff6f 	bl	8008174 <RCC_BackupResetCmd>
  RCC_BackupResetCmd(DISABLE);
 8004296:	f04f 0000 	mov.w	r0, #0
 800429a:	f003 ff6b 	bl	8008174 <RCC_BackupResetCmd>

  RCC_LSEConfig(RCC_LSE_ON);
 800429e:	f04f 0001 	mov.w	r0, #1
 80042a2:	f003 fd0b 	bl	8007cbc <RCC_LSEConfig>
  while(RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET)
 80042a6:	bf00      	nop
 80042a8:	f04f 0041 	mov.w	r0, #65	; 0x41
 80042ac:	f004 f986 	bl	80085bc <RCC_GetFlagStatus>
 80042b0:	4603      	mov	r3, r0
 80042b2:	2b00      	cmp	r3, #0
 80042b4:	d0f8      	beq.n	80042a8 <RTC_Config+0x34>
  {
  }
  RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
 80042b6:	f44f 7080 	mov.w	r0, #256	; 0x100
 80042ba:	f003 ff1b 	bl	80080f4 <RCC_RTCCLKConfig>
  RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);
*/
  //**********************************************Gergõ**************************************

  /* Enable the RTC Clock */
  RCC_RTCCLKCmd(ENABLE);
 80042be:	f04f 0001 	mov.w	r0, #1
 80042c2:	f003 ff47 	bl	8008154 <RCC_RTCCLKCmd>

  /* Wait for RTC APB registers synchronisation */
  RTC_WaitForSynchro();
 80042c6:	f004 fb39 	bl	800893c <RTC_WaitForSynchro>

  /* Calendar Configuration with LSI supposed at 32KHz */
  RTC_InitStructure.RTC_AsynchPrediv = 0x7F;
 80042ca:	f04f 037f 	mov.w	r3, #127	; 0x7f
 80042ce:	607b      	str	r3, [r7, #4]
  RTC_InitStructure.RTC_SynchPrediv  = 0xFF; /* (32KHz / 128) - 1 = 0xFF*/
 80042d0:	f04f 03ff 	mov.w	r3, #255	; 0xff
 80042d4:	60bb      	str	r3, [r7, #8]
  RTC_InitStructure.RTC_HourFormat = RTC_HourFormat_24;
 80042d6:	f04f 0300 	mov.w	r3, #0
 80042da:	603b      	str	r3, [r7, #0]
  RTC_Init(&RTC_InitStructure);
 80042dc:	463b      	mov	r3, r7
 80042de:	4618      	mov	r0, r3
 80042e0:	f004 fa68 	bl	80087b4 <RTC_Init>

  EXTI_ClearITPendingBit(EXTI_Line17);
 80042e4:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 80042e8:	f002 fca0 	bl	8006c2c <EXTI_ClearITPendingBit>
  EXTI_InitStructure.EXTI_Line = EXTI_Line17;
 80042ec:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 80042f0:	60fb      	str	r3, [r7, #12]
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 80042f2:	f04f 0300 	mov.w	r3, #0
 80042f6:	743b      	strb	r3, [r7, #16]
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
 80042f8:	f04f 0308 	mov.w	r3, #8
 80042fc:	747b      	strb	r3, [r7, #17]
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 80042fe:	f04f 0301 	mov.w	r3, #1
 8004302:	74bb      	strb	r3, [r7, #18]
  EXTI_Init(&EXTI_InitStructure);
 8004304:	f107 030c 	add.w	r3, r7, #12
 8004308:	4618      	mov	r0, r3
 800430a:	f002 fb9b 	bl	8006a44 <EXTI_Init>

  // Enable the RTC Alarm Interrupt
  NVIC_InitStructure.NVIC_IRQChannel = RTC_Alarm_IRQn;
 800430e:	f04f 0329 	mov.w	r3, #41	; 0x29
 8004312:	753b      	strb	r3, [r7, #20]
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 8004314:	f04f 0300 	mov.w	r3, #0
 8004318:	757b      	strb	r3, [r7, #21]
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 800431a:	f04f 0300 	mov.w	r3, #0
 800431e:	75bb      	strb	r3, [r7, #22]
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8004320:	f04f 0301 	mov.w	r3, #1
 8004324:	75fb      	strb	r3, [r7, #23]
  NVIC_Init(&NVIC_InitStructure);
 8004326:	f107 0314 	add.w	r3, r7, #20
 800432a:	4618      	mov	r0, r3
 800432c:	f001 f95a 	bl	80055e4 <NVIC_Init>

  // EXTI configuration
  EXTI_ClearITPendingBit(EXTI_Line22);
 8004330:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 8004334:	f002 fc7a 	bl	8006c2c <EXTI_ClearITPendingBit>
  EXTI_InitStructure.EXTI_Line = EXTI_Line22;
 8004338:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800433c:	60fb      	str	r3, [r7, #12]
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 800433e:	f04f 0300 	mov.w	r3, #0
 8004342:	743b      	strb	r3, [r7, #16]
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
 8004344:	f04f 0308 	mov.w	r3, #8
 8004348:	747b      	strb	r3, [r7, #17]
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 800434a:	f04f 0301 	mov.w	r3, #1
 800434e:	74bb      	strb	r3, [r7, #18]
  EXTI_Init(&EXTI_InitStructure);
 8004350:	f107 030c 	add.w	r3, r7, #12
 8004354:	4618      	mov	r0, r3
 8004356:	f002 fb75 	bl	8006a44 <EXTI_Init>

  // Enable the RTC Wakeup Interrupt
  NVIC_InitStructure.NVIC_IRQChannel = RTC_WKUP_IRQn;
 800435a:	f04f 0303 	mov.w	r3, #3
 800435e:	753b      	strb	r3, [r7, #20]
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 8004360:	f04f 0300 	mov.w	r3, #0
 8004364:	757b      	strb	r3, [r7, #21]
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 8004366:	f04f 0300 	mov.w	r3, #0
 800436a:	75bb      	strb	r3, [r7, #22]
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 800436c:	f04f 0301 	mov.w	r3, #1
 8004370:	75fb      	strb	r3, [r7, #23]
  NVIC_Init(&NVIC_InitStructure);
 8004372:	f107 0314 	add.w	r3, r7, #20
 8004376:	4618      	mov	r0, r3
 8004378:	f001 f934 	bl	80055e4 <NVIC_Init>

  // Configure the RTC WakeUp Clock source: CK_SPRE (1Hz)

  RTC_WakeUpClockConfig(RTC_WakeUpClock_CK_SPRE_16bits);
 800437c:	f04f 0004 	mov.w	r0, #4
 8004380:	f004 ff82 	bl	8009288 <RTC_WakeUpClockConfig>
  RTC_SetWakeUpCounter(0x0);
 8004384:	f04f 0000 	mov.w	r0, #0
 8004388:	f004 ffa2 	bl	80092d0 <RTC_SetWakeUpCounter>
  RTC_ITConfig(RTC_IT_WUT, ENABLE);
 800438c:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8004390:	f04f 0101 	mov.w	r1, #1
 8004394:	f005 fbda 	bl	8009b4c <RTC_ITConfig>
  /* Enable the alarm */
/*  RTC_AlarmCmd(RTC_Alarm_A, ENABLE);*/

/*  RTC_ClearFlag(RTC_FLAG_ALRAF);*/

  RTC_DateStructure.RTC_Year = 0x14;
 8004398:	f04f 0314 	mov.w	r3, #20
 800439c:	76fb      	strb	r3, [r7, #27]
  RTC_DateStructure.RTC_Month = RTC_Month_August;
 800439e:	f04f 0308 	mov.w	r3, #8
 80043a2:	767b      	strb	r3, [r7, #25]
  RTC_DateStructure.RTC_Date = 0x8;
 80043a4:	f04f 0308 	mov.w	r3, #8
 80043a8:	76bb      	strb	r3, [r7, #26]
  RTC_DateStructure.RTC_WeekDay = RTC_Weekday_Friday;
 80043aa:	f04f 0305 	mov.w	r3, #5
 80043ae:	763b      	strb	r3, [r7, #24]
  RTC_SetDate(RTC_Format_BCD, &RTC_DateStructure);
 80043b0:	f107 0318 	add.w	r3, r7, #24
 80043b4:	f04f 0001 	mov.w	r0, #1
 80043b8:	4619      	mov	r1, r3
 80043ba:	f004 fc77 	bl	8008cac <RTC_SetDate>

  RTC_TimeStructure.RTC_H12     = RTC_H12_PM;
 80043be:	f04f 0340 	mov.w	r3, #64	; 0x40
 80043c2:	77fb      	strb	r3, [r7, #31]
  RTC_TimeStructure.RTC_Hours   = 0x00;
 80043c4:	f04f 0300 	mov.w	r3, #0
 80043c8:	773b      	strb	r3, [r7, #28]
  RTC_TimeStructure.RTC_Minutes = 0x14;
 80043ca:	f04f 0314 	mov.w	r3, #20
 80043ce:	777b      	strb	r3, [r7, #29]
  RTC_TimeStructure.RTC_Seconds = 0x00;
 80043d0:	f04f 0300 	mov.w	r3, #0
 80043d4:	77bb      	strb	r3, [r7, #30]
  RTC_SetTime(RTC_Format_BCD, &RTC_TimeStructure);
 80043d6:	f107 031c 	add.w	r3, r7, #28
 80043da:	f04f 0001 	mov.w	r0, #1
 80043de:	4619      	mov	r1, r3
 80043e0:	f004 fb52 	bl	8008a88 <RTC_SetTime>

  RTC_WriteBackupRegister(RTC_BKP_DR0, 0x32F2);
 80043e4:	f04f 0000 	mov.w	r0, #0
 80043e8:	f243 21f2 	movw	r1, #13042	; 0x32f2
 80043ec:	f005 fad8 	bl	80099a0 <RTC_WriteBackupRegister>
  //**********************************************Gergõ**************************************


  /* Enable Wakeup Counter */
//  RTC_WakeUpCmd(ENABLE);
}
 80043f0:	f107 0720 	add.w	r7, r7, #32
 80043f4:	46bd      	mov	sp, r7
 80043f6:	bd80      	pop	{r7, pc}

080043f8 <STM_EVAL_LEDInit>:
  *     @arg LED5
  *     @arg LED6
  * @retval None
  */
void STM_EVAL_LEDInit(Led_TypeDef Led)
{
 80043f8:	b580      	push	{r7, lr}
 80043fa:	b084      	sub	sp, #16
 80043fc:	af00      	add	r7, sp, #0
 80043fe:	4603      	mov	r3, r0
 8004400:	71fb      	strb	r3, [r7, #7]
  GPIO_InitTypeDef  GPIO_InitStructure;

  /* Enable the GPIO_LED Clock */
  RCC_AHB1PeriphClockCmd(GPIO_CLK[Led], ENABLE);
 8004402:	79fa      	ldrb	r2, [r7, #7]
 8004404:	4b13      	ldr	r3, [pc, #76]	; (8004454 <STM_EVAL_LEDInit+0x5c>)
 8004406:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800440a:	4618      	mov	r0, r3
 800440c:	f04f 0101 	mov.w	r1, #1
 8004410:	f003 fece 	bl	80081b0 <RCC_AHB1PeriphClockCmd>

  /* Configure the GPIO_LED pin */
  GPIO_InitStructure.GPIO_Pin = GPIO_PIN[Led];
 8004414:	79fa      	ldrb	r2, [r7, #7]
 8004416:	4b10      	ldr	r3, [pc, #64]	; (8004458 <STM_EVAL_LEDInit+0x60>)
 8004418:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 800441c:	60bb      	str	r3, [r7, #8]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 800441e:	f04f 0301 	mov.w	r3, #1
 8004422:	733b      	strb	r3, [r7, #12]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8004424:	f04f 0300 	mov.w	r3, #0
 8004428:	73bb      	strb	r3, [r7, #14]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 800442a:	f04f 0301 	mov.w	r3, #1
 800442e:	73fb      	strb	r3, [r7, #15]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8004430:	f04f 0302 	mov.w	r3, #2
 8004434:	737b      	strb	r3, [r7, #13]
  GPIO_Init(GPIO_PORT[Led], &GPIO_InitStructure);
 8004436:	79fa      	ldrb	r2, [r7, #7]
 8004438:	4b08      	ldr	r3, [pc, #32]	; (800445c <STM_EVAL_LEDInit+0x64>)
 800443a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800443e:	f107 0308 	add.w	r3, r7, #8
 8004442:	4610      	mov	r0, r2
 8004444:	4619      	mov	r1, r3
 8004446:	f003 f8a1 	bl	800758c <GPIO_Init>
}
 800444a:	f107 0710 	add.w	r7, r7, #16
 800444e:	46bd      	mov	sp, r7
 8004450:	bd80      	pop	{r7, pc}
 8004452:	bf00      	nop
 8004454:	0800d0e8 	.word	0x0800d0e8
 8004458:	0800d0e0 	.word	0x0800d0e0
 800445c:	20000000 	.word	0x20000000

08004460 <STM_EVAL_LEDOn>:
  *     @arg LED5
  *     @arg LED6
  * @retval None
  */
void STM_EVAL_LEDOn(Led_TypeDef Led)
{
 8004460:	b480      	push	{r7}
 8004462:	b083      	sub	sp, #12
 8004464:	af00      	add	r7, sp, #0
 8004466:	4603      	mov	r3, r0
 8004468:	71fb      	strb	r3, [r7, #7]
  GPIO_PORT[Led]->BSRRL = GPIO_PIN[Led];
 800446a:	79fa      	ldrb	r2, [r7, #7]
 800446c:	4b06      	ldr	r3, [pc, #24]	; (8004488 <STM_EVAL_LEDOn+0x28>)
 800446e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8004472:	79f9      	ldrb	r1, [r7, #7]
 8004474:	4a05      	ldr	r2, [pc, #20]	; (800448c <STM_EVAL_LEDOn+0x2c>)
 8004476:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
 800447a:	831a      	strh	r2, [r3, #24]
}
 800447c:	f107 070c 	add.w	r7, r7, #12
 8004480:	46bd      	mov	sp, r7
 8004482:	bc80      	pop	{r7}
 8004484:	4770      	bx	lr
 8004486:	bf00      	nop
 8004488:	20000000 	.word	0x20000000
 800448c:	0800d0e0 	.word	0x0800d0e0

08004490 <STM_EVAL_LEDOff>:
  *     @arg LED5
  *     @arg LED6
  * @retval None
  */
void STM_EVAL_LEDOff(Led_TypeDef Led)
{
 8004490:	b480      	push	{r7}
 8004492:	b083      	sub	sp, #12
 8004494:	af00      	add	r7, sp, #0
 8004496:	4603      	mov	r3, r0
 8004498:	71fb      	strb	r3, [r7, #7]
  GPIO_PORT[Led]->BSRRH = GPIO_PIN[Led];
 800449a:	79fa      	ldrb	r2, [r7, #7]
 800449c:	4b06      	ldr	r3, [pc, #24]	; (80044b8 <STM_EVAL_LEDOff+0x28>)
 800449e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80044a2:	79f9      	ldrb	r1, [r7, #7]
 80044a4:	4a05      	ldr	r2, [pc, #20]	; (80044bc <STM_EVAL_LEDOff+0x2c>)
 80044a6:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
 80044aa:	835a      	strh	r2, [r3, #26]
}
 80044ac:	f107 070c 	add.w	r7, r7, #12
 80044b0:	46bd      	mov	sp, r7
 80044b2:	bc80      	pop	{r7}
 80044b4:	4770      	bx	lr
 80044b6:	bf00      	nop
 80044b8:	20000000 	.word	0x20000000
 80044bc:	0800d0e0 	.word	0x0800d0e0

080044c0 <STM_EVAL_LEDToggle>:
  *     @arg LED5
  *     @arg LED6
  * @retval None
  */
void STM_EVAL_LEDToggle(Led_TypeDef Led)
{
 80044c0:	b480      	push	{r7}
 80044c2:	b083      	sub	sp, #12
 80044c4:	af00      	add	r7, sp, #0
 80044c6:	4603      	mov	r3, r0
 80044c8:	71fb      	strb	r3, [r7, #7]
  GPIO_PORT[Led]->ODR ^= GPIO_PIN[Led];
 80044ca:	79fa      	ldrb	r2, [r7, #7]
 80044cc:	4b09      	ldr	r3, [pc, #36]	; (80044f4 <STM_EVAL_LEDToggle+0x34>)
 80044ce:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80044d2:	79f9      	ldrb	r1, [r7, #7]
 80044d4:	4a07      	ldr	r2, [pc, #28]	; (80044f4 <STM_EVAL_LEDToggle+0x34>)
 80044d6:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 80044da:	6951      	ldr	r1, [r2, #20]
 80044dc:	79f8      	ldrb	r0, [r7, #7]
 80044de:	4a06      	ldr	r2, [pc, #24]	; (80044f8 <STM_EVAL_LEDToggle+0x38>)
 80044e0:	f832 2010 	ldrh.w	r2, [r2, r0, lsl #1]
 80044e4:	404a      	eors	r2, r1
 80044e6:	615a      	str	r2, [r3, #20]
}
 80044e8:	f107 070c 	add.w	r7, r7, #12
 80044ec:	46bd      	mov	sp, r7
 80044ee:	bc80      	pop	{r7}
 80044f0:	4770      	bx	lr
 80044f2:	bf00      	nop
 80044f4:	20000000 	.word	0x20000000
 80044f8:	0800d0e0 	.word	0x0800d0e0

080044fc <STM_EVAL_PBInit>:
  *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
  *                            generation capability
  * @retval None
  */
void STM_EVAL_PBInit(Button_TypeDef Button, ButtonMode_TypeDef Button_Mode)
{
 80044fc:	b580      	push	{r7, lr}
 80044fe:	b088      	sub	sp, #32
 8004500:	af00      	add	r7, sp, #0
 8004502:	4602      	mov	r2, r0
 8004504:	460b      	mov	r3, r1
 8004506:	71fa      	strb	r2, [r7, #7]
 8004508:	71bb      	strb	r3, [r7, #6]
  GPIO_InitTypeDef GPIO_InitStructure;
  EXTI_InitTypeDef EXTI_InitStructure;
  NVIC_InitTypeDef NVIC_InitStructure;

  /* Enable the BUTTON Clock */
  RCC_AHB1PeriphClockCmd(BUTTON_CLK[Button], ENABLE);
 800450a:	79fa      	ldrb	r2, [r7, #7]
 800450c:	4b2c      	ldr	r3, [pc, #176]	; (80045c0 <STM_EVAL_PBInit+0xc4>)
 800450e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8004512:	4618      	mov	r0, r3
 8004514:	f04f 0101 	mov.w	r1, #1
 8004518:	f003 fe4a 	bl	80081b0 <RCC_AHB1PeriphClockCmd>
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 800451c:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8004520:	f04f 0101 	mov.w	r1, #1
 8004524:	f003 fec4 	bl	80082b0 <RCC_APB2PeriphClockCmd>

  /* Configure Button pin as input */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8004528:	f04f 0300 	mov.w	r3, #0
 800452c:	773b      	strb	r3, [r7, #28]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 800452e:	f04f 0300 	mov.w	r3, #0
 8004532:	77fb      	strb	r3, [r7, #31]
  GPIO_InitStructure.GPIO_Pin = BUTTON_PIN[Button];
 8004534:	79fa      	ldrb	r2, [r7, #7]
 8004536:	4b23      	ldr	r3, [pc, #140]	; (80045c4 <STM_EVAL_PBInit+0xc8>)
 8004538:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 800453c:	61bb      	str	r3, [r7, #24]
  GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStructure);
 800453e:	79fa      	ldrb	r2, [r7, #7]
 8004540:	4b21      	ldr	r3, [pc, #132]	; (80045c8 <STM_EVAL_PBInit+0xcc>)
 8004542:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8004546:	f107 0318 	add.w	r3, r7, #24
 800454a:	4610      	mov	r0, r2
 800454c:	4619      	mov	r1, r3
 800454e:	f003 f81d 	bl	800758c <GPIO_Init>

  if (Button_Mode == BUTTON_MODE_EXTI)
 8004552:	79bb      	ldrb	r3, [r7, #6]
 8004554:	2b01      	cmp	r3, #1
 8004556:	d12e      	bne.n	80045b6 <STM_EVAL_PBInit+0xba>
  {
    /* Connect Button EXTI Line to Button GPIO Pin */
    SYSCFG_EXTILineConfig(BUTTON_PORT_SOURCE[Button], BUTTON_PIN_SOURCE[Button]);
 8004558:	79fb      	ldrb	r3, [r7, #7]
 800455a:	4a1c      	ldr	r2, [pc, #112]	; (80045cc <STM_EVAL_PBInit+0xd0>)
 800455c:	5cd2      	ldrb	r2, [r2, r3]
 800455e:	79fb      	ldrb	r3, [r7, #7]
 8004560:	491b      	ldr	r1, [pc, #108]	; (80045d0 <STM_EVAL_PBInit+0xd4>)
 8004562:	5ccb      	ldrb	r3, [r1, r3]
 8004564:	4610      	mov	r0, r2
 8004566:	4619      	mov	r1, r3
 8004568:	f005 fc36 	bl	8009dd8 <SYSCFG_EXTILineConfig>

    /* Configure Button EXTI line */
    EXTI_InitStructure.EXTI_Line = BUTTON_EXTI_LINE[Button];
 800456c:	79fa      	ldrb	r2, [r7, #7]
 800456e:	4b19      	ldr	r3, [pc, #100]	; (80045d4 <STM_EVAL_PBInit+0xd8>)
 8004570:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8004574:	613b      	str	r3, [r7, #16]
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 8004576:	f04f 0300 	mov.w	r3, #0
 800457a:	753b      	strb	r3, [r7, #20]
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
 800457c:	f04f 0308 	mov.w	r3, #8
 8004580:	757b      	strb	r3, [r7, #21]
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 8004582:	f04f 0301 	mov.w	r3, #1
 8004586:	75bb      	strb	r3, [r7, #22]
    EXTI_Init(&EXTI_InitStructure);
 8004588:	f107 0310 	add.w	r3, r7, #16
 800458c:	4618      	mov	r0, r3
 800458e:	f002 fa59 	bl	8006a44 <EXTI_Init>

    /* Enable and set Button EXTI Interrupt to the lowest priority */
    NVIC_InitStructure.NVIC_IRQChannel = BUTTON_IRQn[Button];
 8004592:	79fb      	ldrb	r3, [r7, #7]
 8004594:	4a10      	ldr	r2, [pc, #64]	; (80045d8 <STM_EVAL_PBInit+0xdc>)
 8004596:	5cd3      	ldrb	r3, [r2, r3]
 8004598:	733b      	strb	r3, [r7, #12]
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x0F;
 800459a:	f04f 030f 	mov.w	r3, #15
 800459e:	737b      	strb	r3, [r7, #13]
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x0F;
 80045a0:	f04f 030f 	mov.w	r3, #15
 80045a4:	73bb      	strb	r3, [r7, #14]
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 80045a6:	f04f 0301 	mov.w	r3, #1
 80045aa:	73fb      	strb	r3, [r7, #15]

    NVIC_Init(&NVIC_InitStructure);
 80045ac:	f107 030c 	add.w	r3, r7, #12
 80045b0:	4618      	mov	r0, r3
 80045b2:	f001 f817 	bl	80055e4 <NVIC_Init>
  }
}
 80045b6:	f107 0720 	add.w	r7, r7, #32
 80045ba:	46bd      	mov	sp, r7
 80045bc:	bd80      	pop	{r7, pc}
 80045be:	bf00      	nop
 80045c0:	0800d0fc 	.word	0x0800d0fc
 80045c4:	0800d0f8 	.word	0x0800d0f8
 80045c8:	20000010 	.word	0x20000010
 80045cc:	0800d104 	.word	0x0800d104
 80045d0:	0800d108 	.word	0x0800d108
 80045d4:	0800d100 	.word	0x0800d100
 80045d8:	0800d10c 	.word	0x0800d10c

080045dc <STM_EVAL_PBGetState>:
  * @param  Button: Specifies the Button to be checked.
  *   This parameter should be: BUTTON_USER
  * @retval The Button GPIO pin value.
  */
uint32_t STM_EVAL_PBGetState(Button_TypeDef Button)
{
 80045dc:	b580      	push	{r7, lr}
 80045de:	b082      	sub	sp, #8
 80045e0:	af00      	add	r7, sp, #0
 80045e2:	4603      	mov	r3, r0
 80045e4:	71fb      	strb	r3, [r7, #7]
  return GPIO_ReadInputDataBit(BUTTON_PORT[Button], BUTTON_PIN[Button]);
 80045e6:	79fa      	ldrb	r2, [r7, #7]
 80045e8:	4b08      	ldr	r3, [pc, #32]	; (800460c <STM_EVAL_PBGetState+0x30>)
 80045ea:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80045ee:	79f9      	ldrb	r1, [r7, #7]
 80045f0:	4b07      	ldr	r3, [pc, #28]	; (8004610 <STM_EVAL_PBGetState+0x34>)
 80045f2:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 80045f6:	4610      	mov	r0, r2
 80045f8:	4619      	mov	r1, r3
 80045fa:	f003 f8a9 	bl	8007750 <GPIO_ReadInputDataBit>
 80045fe:	4603      	mov	r3, r0
}
 8004600:	4618      	mov	r0, r3
 8004602:	f107 0708 	add.w	r7, r7, #8
 8004606:	46bd      	mov	sp, r7
 8004608:	bd80      	pop	{r7, pc}
 800460a:	bf00      	nop
 800460c:	20000010 	.word	0x20000010
 8004610:	0800d0f8 	.word	0x0800d0f8

08004614 <NMI_Handler>:
  * @brief   This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
 8004614:	b480      	push	{r7}
 8004616:	af00      	add	r7, sp, #0
}
 8004618:	46bd      	mov	sp, r7
 800461a:	bc80      	pop	{r7}
 800461c:	4770      	bx	lr
 800461e:	bf00      	nop

08004620 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 8004620:	b480      	push	{r7}
 8004622:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
  {
  }
 8004624:	e7fe      	b.n	8004624 <HardFault_Handler+0x4>
 8004626:	bf00      	nop

08004628 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 8004628:	b480      	push	{r7}
 800462a:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
  {
  }
 800462c:	e7fe      	b.n	800462c <MemManage_Handler+0x4>
 800462e:	bf00      	nop

08004630 <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 8004630:	b480      	push	{r7}
 8004632:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
  {
  }
 8004634:	e7fe      	b.n	8004634 <BusFault_Handler+0x4>
 8004636:	bf00      	nop

08004638 <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 8004638:	b480      	push	{r7}
 800463a:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
  {
  }
 800463c:	e7fe      	b.n	800463c <UsageFault_Handler+0x4>
 800463e:	bf00      	nop

08004640 <SVC_Handler>:
  * @brief  This function handles SVCall exception.
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
 8004640:	b480      	push	{r7}
 8004642:	af00      	add	r7, sp, #0
}
 8004644:	46bd      	mov	sp, r7
 8004646:	bc80      	pop	{r7}
 8004648:	4770      	bx	lr
 800464a:	bf00      	nop

0800464c <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
 800464c:	b480      	push	{r7}
 800464e:	af00      	add	r7, sp, #0
}
 8004650:	46bd      	mov	sp, r7
 8004652:	bc80      	pop	{r7}
 8004654:	4770      	bx	lr
 8004656:	bf00      	nop

08004658 <PendSV_Handler>:
  * @brief  This function handles PendSVC exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
 8004658:	b480      	push	{r7}
 800465a:	af00      	add	r7, sp, #0
}
 800465c:	46bd      	mov	sp, r7
 800465e:	bc80      	pop	{r7}
 8004660:	4770      	bx	lr
 8004662:	bf00      	nop

08004664 <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
 8004664:	b480      	push	{r7}
 8004666:	af00      	add	r7, sp, #0
}
 8004668:	46bd      	mov	sp, r7
 800466a:	bc80      	pop	{r7}
 800466c:	4770      	bx	lr
 800466e:	bf00      	nop

08004670 <RTC_WKUP_IRQHandler>:
int limit_swich_counter;
int pump_counter;


void RTC_WKUP_IRQHandler(void)
{
 8004670:	b580      	push	{r7, lr}
 8004672:	b086      	sub	sp, #24
 8004674:	af00      	add	r7, sp, #0
  if(RTC_GetITStatus(RTC_IT_WUT) != RESET)
 8004676:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800467a:	f005 faeb 	bl	8009c54 <RTC_GetITStatus>
 800467e:	4603      	mov	r3, r0
 8004680:	2b00      	cmp	r3, #0
 8004682:	f000 81aa 	beq.w	80049da <RTC_WKUP_IRQHandler+0x36a>
  {
	  char RTC_WKUP_i = 0;
 8004686:	f04f 0300 	mov.w	r3, #0
 800468a:	75fb      	strb	r3, [r7, #23]
	  int RTC_WKUP_divider = 0;
 800468c:	f04f 0300 	mov.w	r3, #0
 8004690:	613b      	str	r3, [r7, #16]
		  day_counter++;
		  if(day_counter >= (WATERING_LKKT + 1))
			  day_counter = 1;
	  }*/

	  if(watering_prcess1.nev[0] != '0' || watering_prcess1.nev[1] != '0' || watering_prcess1.nev[3] != '0' || watering_prcess1.nev[4] != '0')
 8004692:	4bab      	ldr	r3, [pc, #684]	; (8004940 <RTC_WKUP_IRQHandler+0x2d0>)
 8004694:	681b      	ldr	r3, [r3, #0]
 8004696:	781b      	ldrb	r3, [r3, #0]
 8004698:	2b30      	cmp	r3, #48	; 0x30
 800469a:	d115      	bne.n	80046c8 <RTC_WKUP_IRQHandler+0x58>
 800469c:	4ba8      	ldr	r3, [pc, #672]	; (8004940 <RTC_WKUP_IRQHandler+0x2d0>)
 800469e:	681b      	ldr	r3, [r3, #0]
 80046a0:	f103 0301 	add.w	r3, r3, #1
 80046a4:	781b      	ldrb	r3, [r3, #0]
 80046a6:	2b30      	cmp	r3, #48	; 0x30
 80046a8:	d10e      	bne.n	80046c8 <RTC_WKUP_IRQHandler+0x58>
 80046aa:	4ba5      	ldr	r3, [pc, #660]	; (8004940 <RTC_WKUP_IRQHandler+0x2d0>)
 80046ac:	681b      	ldr	r3, [r3, #0]
 80046ae:	f103 0303 	add.w	r3, r3, #3
 80046b2:	781b      	ldrb	r3, [r3, #0]
 80046b4:	2b30      	cmp	r3, #48	; 0x30
 80046b6:	d107      	bne.n	80046c8 <RTC_WKUP_IRQHandler+0x58>
 80046b8:	4ba1      	ldr	r3, [pc, #644]	; (8004940 <RTC_WKUP_IRQHandler+0x2d0>)
 80046ba:	681b      	ldr	r3, [r3, #0]
 80046bc:	f103 0304 	add.w	r3, r3, #4
 80046c0:	781b      	ldrb	r3, [r3, #0]
 80046c2:	2b30      	cmp	r3, #48	; 0x30
 80046c4:	f000 8181 	beq.w	80049ca <RTC_WKUP_IRQHandler+0x35a>
	  {
		  remaining_time = (watering_prcess1.nev[0] - ASCII_OFFSEET) * 600 + (watering_prcess1.nev[1] - ASCII_OFFSEET) * 60 + (watering_prcess1.nev[3] - ASCII_OFFSEET) * 10 + (watering_prcess1.nev[4] - ASCII_OFFSEET);
 80046c8:	4b9d      	ldr	r3, [pc, #628]	; (8004940 <RTC_WKUP_IRQHandler+0x2d0>)
 80046ca:	681b      	ldr	r3, [r3, #0]
 80046cc:	781b      	ldrb	r3, [r3, #0]
 80046ce:	f44f 7216 	mov.w	r2, #600	; 0x258
 80046d2:	fb02 f303 	mul.w	r3, r2, r3
 80046d6:	f5a3 41e1 	sub.w	r1, r3, #28800	; 0x7080
 80046da:	4b99      	ldr	r3, [pc, #612]	; (8004940 <RTC_WKUP_IRQHandler+0x2d0>)
 80046dc:	681b      	ldr	r3, [r3, #0]
 80046de:	f103 0301 	add.w	r3, r3, #1
 80046e2:	781b      	ldrb	r3, [r3, #0]
 80046e4:	461a      	mov	r2, r3
 80046e6:	4613      	mov	r3, r2
 80046e8:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80046ec:	1a9b      	subs	r3, r3, r2
 80046ee:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80046f2:	f5a3 6334 	sub.w	r3, r3, #2880	; 0xb40
 80046f6:	18c9      	adds	r1, r1, r3
 80046f8:	4b91      	ldr	r3, [pc, #580]	; (8004940 <RTC_WKUP_IRQHandler+0x2d0>)
 80046fa:	681b      	ldr	r3, [r3, #0]
 80046fc:	f103 0303 	add.w	r3, r3, #3
 8004700:	781b      	ldrb	r3, [r3, #0]
 8004702:	461a      	mov	r2, r3
 8004704:	4613      	mov	r3, r2
 8004706:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800470a:	189b      	adds	r3, r3, r2
 800470c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8004710:	f5a3 73f0 	sub.w	r3, r3, #480	; 0x1e0
 8004714:	18ca      	adds	r2, r1, r3
 8004716:	4b8a      	ldr	r3, [pc, #552]	; (8004940 <RTC_WKUP_IRQHandler+0x2d0>)
 8004718:	681b      	ldr	r3, [r3, #0]
 800471a:	f103 0304 	add.w	r3, r3, #4
 800471e:	781b      	ldrb	r3, [r3, #0]
 8004720:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 8004724:	18d3      	adds	r3, r2, r3
 8004726:	60fb      	str	r3, [r7, #12]
		  remaining_time--;
 8004728:	68fb      	ldr	r3, [r7, #12]
 800472a:	f103 33ff 	add.w	r3, r3, #4294967295
 800472e:	60fb      	str	r3, [r7, #12]

		  if(&(*menu_current) == &watering_prcess1)
 8004730:	4b84      	ldr	r3, [pc, #528]	; (8004944 <RTC_WKUP_IRQHandler+0x2d4>)
 8004732:	681a      	ldr	r2, [r3, #0]
 8004734:	4b82      	ldr	r3, [pc, #520]	; (8004940 <RTC_WKUP_IRQHandler+0x2d0>)
 8004736:	429a      	cmp	r2, r3
 8004738:	f040 80c7 	bne.w	80048ca <RTC_WKUP_IRQHandler+0x25a>
		  {
		     for(RTC_WKUP_i = 4; RTC_WKUP_i < 255; RTC_WKUP_i--)
 800473c:	f04f 0304 	mov.w	r3, #4
 8004740:	75fb      	strb	r3, [r7, #23]
 8004742:	e049      	b.n	80047d8 <RTC_WKUP_IRQHandler+0x168>
		     {
		    	 if(RTC_WKUP_i == 2)
 8004744:	7dfb      	ldrb	r3, [r7, #23]
 8004746:	2b02      	cmp	r3, #2
 8004748:	d103      	bne.n	8004752 <RTC_WKUP_IRQHandler+0xe2>
		    		 RTC_WKUP_i--;
 800474a:	7dfb      	ldrb	r3, [r7, #23]
 800474c:	f103 33ff 	add.w	r3, r3, #4294967295
 8004750:	75fb      	strb	r3, [r7, #23]

		    	 switch(RTC_WKUP_i)
 8004752:	7dfb      	ldrb	r3, [r7, #23]
 8004754:	2b04      	cmp	r3, #4
 8004756:	d81d      	bhi.n	8004794 <RTC_WKUP_IRQHandler+0x124>
 8004758:	a201      	add	r2, pc, #4	; (adr r2, 8004760 <RTC_WKUP_IRQHandler+0xf0>)
 800475a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800475e:	bf00      	nop
 8004760:	08004775 	.word	0x08004775
 8004764:	0800477d 	.word	0x0800477d
 8004768:	08004795 	.word	0x08004795
 800476c:	08004785 	.word	0x08004785
 8004770:	0800478d 	.word	0x0800478d
		    	 {
		    	 	 case 0:
		    	 		RTC_WKUP_divider = 1;
 8004774:	f04f 0301 	mov.w	r3, #1
 8004778:	613b      	str	r3, [r7, #16]
		    	 		break;
 800477a:	e00b      	b.n	8004794 <RTC_WKUP_IRQHandler+0x124>
		    	 	 case 1:
		    	 		RTC_WKUP_divider = 10;
 800477c:	f04f 030a 	mov.w	r3, #10
 8004780:	613b      	str	r3, [r7, #16]
		    	 		break;
 8004782:	e007      	b.n	8004794 <RTC_WKUP_IRQHandler+0x124>
		    	 	 case 3:
		    	 		RTC_WKUP_divider = 60;
 8004784:	f04f 033c 	mov.w	r3, #60	; 0x3c
 8004788:	613b      	str	r3, [r7, #16]
		    	 		break;
 800478a:	e003      	b.n	8004794 <RTC_WKUP_IRQHandler+0x124>
		    	 	 case 4:
		    	 		RTC_WKUP_divider = 600;
 800478c:	f44f 7316 	mov.w	r3, #600	; 0x258
 8004790:	613b      	str	r3, [r7, #16]
		    	 		break;
 8004792:	bf00      	nop
		    	 }
		    	 watering_prcess1.nev[4 - RTC_WKUP_i] = (char)((remaining_time / RTC_WKUP_divider) + ASCII_OFFSEET);
 8004794:	4b6a      	ldr	r3, [pc, #424]	; (8004940 <RTC_WKUP_IRQHandler+0x2d0>)
 8004796:	681a      	ldr	r2, [r3, #0]
 8004798:	7dfb      	ldrb	r3, [r7, #23]
 800479a:	f1c3 0304 	rsb	r3, r3, #4
 800479e:	18d3      	adds	r3, r2, r3
 80047a0:	68f9      	ldr	r1, [r7, #12]
 80047a2:	693a      	ldr	r2, [r7, #16]
 80047a4:	fb91 f2f2 	sdiv	r2, r1, r2
 80047a8:	b2d2      	uxtb	r2, r2
 80047aa:	f102 0230 	add.w	r2, r2, #48	; 0x30
 80047ae:	b2d2      	uxtb	r2, r2
 80047b0:	701a      	strb	r2, [r3, #0]
		    	 remaining_time -= (watering_prcess1.nev[4 - RTC_WKUP_i] - ASCII_OFFSEET) * RTC_WKUP_divider;
 80047b2:	4b63      	ldr	r3, [pc, #396]	; (8004940 <RTC_WKUP_IRQHandler+0x2d0>)
 80047b4:	681a      	ldr	r2, [r3, #0]
 80047b6:	7dfb      	ldrb	r3, [r7, #23]
 80047b8:	f1c3 0304 	rsb	r3, r3, #4
 80047bc:	18d3      	adds	r3, r2, r3
 80047be:	781b      	ldrb	r3, [r3, #0]
 80047c0:	f1c3 0330 	rsb	r3, r3, #48	; 0x30
 80047c4:	693a      	ldr	r2, [r7, #16]
 80047c6:	fb02 f303 	mul.w	r3, r2, r3
 80047ca:	68fa      	ldr	r2, [r7, #12]
 80047cc:	18d3      	adds	r3, r2, r3
 80047ce:	60fb      	str	r3, [r7, #12]
		  remaining_time = (watering_prcess1.nev[0] - ASCII_OFFSEET) * 600 + (watering_prcess1.nev[1] - ASCII_OFFSEET) * 60 + (watering_prcess1.nev[3] - ASCII_OFFSEET) * 10 + (watering_prcess1.nev[4] - ASCII_OFFSEET);
		  remaining_time--;

		  if(&(*menu_current) == &watering_prcess1)
		  {
		     for(RTC_WKUP_i = 4; RTC_WKUP_i < 255; RTC_WKUP_i--)
 80047d0:	7dfb      	ldrb	r3, [r7, #23]
 80047d2:	f103 33ff 	add.w	r3, r3, #4294967295
 80047d6:	75fb      	strb	r3, [r7, #23]
 80047d8:	7dfb      	ldrb	r3, [r7, #23]
 80047da:	2bff      	cmp	r3, #255	; 0xff
 80047dc:	d1b2      	bne.n	8004744 <RTC_WKUP_IRQHandler+0xd4>
		    	 }
		    	 watering_prcess1.nev[4 - RTC_WKUP_i] = (char)((remaining_time / RTC_WKUP_divider) + ASCII_OFFSEET);
		    	 remaining_time -= (watering_prcess1.nev[4 - RTC_WKUP_i] - ASCII_OFFSEET) * RTC_WKUP_divider;
		       }

		     remaining_time2 = limit_swich_counter;
 80047de:	4b5a      	ldr	r3, [pc, #360]	; (8004948 <RTC_WKUP_IRQHandler+0x2d8>)
 80047e0:	681b      	ldr	r3, [r3, #0]
 80047e2:	60bb      	str	r3, [r7, #8]

		     for(RTC_WKUP_i = 4; RTC_WKUP_i < 255; RTC_WKUP_i--)
 80047e4:	f04f 0304 	mov.w	r3, #4
 80047e8:	75fb      	strb	r3, [r7, #23]
 80047ea:	e049      	b.n	8004880 <RTC_WKUP_IRQHandler+0x210>
		     {
		    	 if(RTC_WKUP_i == 2)
 80047ec:	7dfb      	ldrb	r3, [r7, #23]
 80047ee:	2b02      	cmp	r3, #2
 80047f0:	d103      	bne.n	80047fa <RTC_WKUP_IRQHandler+0x18a>
		    		 RTC_WKUP_i--;
 80047f2:	7dfb      	ldrb	r3, [r7, #23]
 80047f4:	f103 33ff 	add.w	r3, r3, #4294967295
 80047f8:	75fb      	strb	r3, [r7, #23]

		    	 switch(RTC_WKUP_i)
 80047fa:	7dfb      	ldrb	r3, [r7, #23]
 80047fc:	2b04      	cmp	r3, #4
 80047fe:	d81d      	bhi.n	800483c <RTC_WKUP_IRQHandler+0x1cc>
 8004800:	a201      	add	r2, pc, #4	; (adr r2, 8004808 <RTC_WKUP_IRQHandler+0x198>)
 8004802:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8004806:	bf00      	nop
 8004808:	0800481d 	.word	0x0800481d
 800480c:	08004825 	.word	0x08004825
 8004810:	0800483d 	.word	0x0800483d
 8004814:	0800482d 	.word	0x0800482d
 8004818:	08004835 	.word	0x08004835
		    	 {
		    	 	 case 0:
		    	 		RTC_WKUP_divider = 1;
 800481c:	f04f 0301 	mov.w	r3, #1
 8004820:	613b      	str	r3, [r7, #16]
		    	 		break;
 8004822:	e00b      	b.n	800483c <RTC_WKUP_IRQHandler+0x1cc>
		    	 	 case 1:
		    	 		RTC_WKUP_divider = 10;
 8004824:	f04f 030a 	mov.w	r3, #10
 8004828:	613b      	str	r3, [r7, #16]
		    	 		break;
 800482a:	e007      	b.n	800483c <RTC_WKUP_IRQHandler+0x1cc>
		    	 	 case 3:
		    	 		RTC_WKUP_divider = 60;
 800482c:	f04f 033c 	mov.w	r3, #60	; 0x3c
 8004830:	613b      	str	r3, [r7, #16]
		    	 		break;
 8004832:	e003      	b.n	800483c <RTC_WKUP_IRQHandler+0x1cc>
		    	 	 case 4:
		    	 		RTC_WKUP_divider = 600;
 8004834:	f44f 7316 	mov.w	r3, #600	; 0x258
 8004838:	613b      	str	r3, [r7, #16]
		    	 		break;
 800483a:	bf00      	nop
		    	 }

		    	 watering_prcess2.nev[4 - RTC_WKUP_i] = (char)((remaining_time2 / RTC_WKUP_divider) + ASCII_OFFSEET);
 800483c:	4b43      	ldr	r3, [pc, #268]	; (800494c <RTC_WKUP_IRQHandler+0x2dc>)
 800483e:	681a      	ldr	r2, [r3, #0]
 8004840:	7dfb      	ldrb	r3, [r7, #23]
 8004842:	f1c3 0304 	rsb	r3, r3, #4
 8004846:	18d3      	adds	r3, r2, r3
 8004848:	68b9      	ldr	r1, [r7, #8]
 800484a:	693a      	ldr	r2, [r7, #16]
 800484c:	fb91 f2f2 	sdiv	r2, r1, r2
 8004850:	b2d2      	uxtb	r2, r2
 8004852:	f102 0230 	add.w	r2, r2, #48	; 0x30
 8004856:	b2d2      	uxtb	r2, r2
 8004858:	701a      	strb	r2, [r3, #0]
		    	 remaining_time2 -= (watering_prcess2.nev[4 - RTC_WKUP_i] - ASCII_OFFSEET) * RTC_WKUP_divider;
 800485a:	4b3c      	ldr	r3, [pc, #240]	; (800494c <RTC_WKUP_IRQHandler+0x2dc>)
 800485c:	681a      	ldr	r2, [r3, #0]
 800485e:	7dfb      	ldrb	r3, [r7, #23]
 8004860:	f1c3 0304 	rsb	r3, r3, #4
 8004864:	18d3      	adds	r3, r2, r3
 8004866:	781b      	ldrb	r3, [r3, #0]
 8004868:	f1c3 0330 	rsb	r3, r3, #48	; 0x30
 800486c:	693a      	ldr	r2, [r7, #16]
 800486e:	fb02 f303 	mul.w	r3, r2, r3
 8004872:	68ba      	ldr	r2, [r7, #8]
 8004874:	18d3      	adds	r3, r2, r3
 8004876:	60bb      	str	r3, [r7, #8]
		    	 remaining_time -= (watering_prcess1.nev[4 - RTC_WKUP_i] - ASCII_OFFSEET) * RTC_WKUP_divider;
		       }

		     remaining_time2 = limit_swich_counter;

		     for(RTC_WKUP_i = 4; RTC_WKUP_i < 255; RTC_WKUP_i--)
 8004878:	7dfb      	ldrb	r3, [r7, #23]
 800487a:	f103 33ff 	add.w	r3, r3, #4294967295
 800487e:	75fb      	strb	r3, [r7, #23]
 8004880:	7dfb      	ldrb	r3, [r7, #23]
 8004882:	2bff      	cmp	r3, #255	; 0xff
 8004884:	d1b2      	bne.n	80047ec <RTC_WKUP_IRQHandler+0x17c>

		    	 watering_prcess2.nev[4 - RTC_WKUP_i] = (char)((remaining_time2 / RTC_WKUP_divider) + ASCII_OFFSEET);
		    	 remaining_time2 -= (watering_prcess2.nev[4 - RTC_WKUP_i] - ASCII_OFFSEET) * RTC_WKUP_divider;
		       }

		     Cursor(0,0);
 8004886:	f04f 0000 	mov.w	r0, #0
 800488a:	f04f 0100 	mov.w	r1, #0
 800488e:	f7fb ff19 	bl	80006c4 <Cursor>
		     StrAlign(watering_prcess1.nev, temp, ALIGN_LEFT);
 8004892:	4b2b      	ldr	r3, [pc, #172]	; (8004940 <RTC_WKUP_IRQHandler+0x2d0>)
 8004894:	681b      	ldr	r3, [r3, #0]
 8004896:	4618      	mov	r0, r3
 8004898:	492d      	ldr	r1, [pc, #180]	; (8004950 <RTC_WKUP_IRQHandler+0x2e0>)
 800489a:	f04f 0201 	mov.w	r2, #1
 800489e:	f7fb ffdf 	bl	8000860 <StrAlign>
		     PrintStr(temp);
 80048a2:	482b      	ldr	r0, [pc, #172]	; (8004950 <RTC_WKUP_IRQHandler+0x2e0>)
 80048a4:	f7fc f91c 	bl	8000ae0 <PrintStr>
		     Cursor(1,0);
 80048a8:	f04f 0001 	mov.w	r0, #1
 80048ac:	f04f 0100 	mov.w	r1, #0
 80048b0:	f7fb ff08 	bl	80006c4 <Cursor>
		     StrAlign(watering_prcess2.nev, temp, ALIGN_LEFT);
 80048b4:	4b25      	ldr	r3, [pc, #148]	; (800494c <RTC_WKUP_IRQHandler+0x2dc>)
 80048b6:	681b      	ldr	r3, [r3, #0]
 80048b8:	4618      	mov	r0, r3
 80048ba:	4925      	ldr	r1, [pc, #148]	; (8004950 <RTC_WKUP_IRQHandler+0x2e0>)
 80048bc:	f04f 0201 	mov.w	r2, #1
 80048c0:	f7fb ffce 	bl	8000860 <StrAlign>
		     PrintStr(temp);
 80048c4:	4822      	ldr	r0, [pc, #136]	; (8004950 <RTC_WKUP_IRQHandler+0x2e0>)
 80048c6:	f7fc f90b 	bl	8000ae0 <PrintStr>
		  }

		     if(!(GPIO_ReadInputDataBit(INPUT_PORT, INPUT_6_PIN)))										//Ha  a végálláskapcsoló riaszt, letiltom a kimeneteket(STOP állapot)
 80048ca:	4822      	ldr	r0, [pc, #136]	; (8004954 <RTC_WKUP_IRQHandler+0x2e4>)
 80048cc:	f04f 0101 	mov.w	r1, #1
 80048d0:	f002 ff3e 	bl	8007750 <GPIO_ReadInputDataBit>
 80048d4:	4603      	mov	r3, r0
 80048d6:	2b00      	cmp	r3, #0
 80048d8:	d108      	bne.n	80048ec <RTC_WKUP_IRQHandler+0x27c>
		     {
		    	 Output_Off(Output_all);
 80048da:	f04f 000b 	mov.w	r0, #11
 80048de:	f7ff fc2d 	bl	800413c <Output_Off>
		    	 limit_swich_counter = LIMIT_SWITCH_COUNTER_WAIT;
 80048e2:	4b19      	ldr	r3, [pc, #100]	; (8004948 <RTC_WKUP_IRQHandler+0x2d8>)
 80048e4:	f04f 020a 	mov.w	r2, #10
 80048e8:	601a      	str	r2, [r3, #0]
 80048ea:	e06e      	b.n	80049ca <RTC_WKUP_IRQHandler+0x35a>
		     }
		     else if((GPIO_ReadInputDataBit(INPUT_PORT, INPUT_6_PIN)) && limit_swich_counter)			//Ha már van víz, de még várni kell a telítõdésig(még tiltva van a szivattyú) (WAIT állapot)
 80048ec:	4819      	ldr	r0, [pc, #100]	; (8004954 <RTC_WKUP_IRQHandler+0x2e4>)
 80048ee:	f04f 0101 	mov.w	r1, #1
 80048f2:	f002 ff2d 	bl	8007750 <GPIO_ReadInputDataBit>
 80048f6:	4603      	mov	r3, r0
 80048f8:	2b00      	cmp	r3, #0
 80048fa:	d00e      	beq.n	800491a <RTC_WKUP_IRQHandler+0x2aa>
 80048fc:	4b12      	ldr	r3, [pc, #72]	; (8004948 <RTC_WKUP_IRQHandler+0x2d8>)
 80048fe:	681b      	ldr	r3, [r3, #0]
 8004900:	2b00      	cmp	r3, #0
 8004902:	d00a      	beq.n	800491a <RTC_WKUP_IRQHandler+0x2aa>
		     {
		    	 Output_Off((Output_all));
 8004904:	f04f 000b 	mov.w	r0, #11
 8004908:	f7ff fc18 	bl	800413c <Output_Off>
		    	 limit_swich_counter--;
 800490c:	4b0e      	ldr	r3, [pc, #56]	; (8004948 <RTC_WKUP_IRQHandler+0x2d8>)
 800490e:	681b      	ldr	r3, [r3, #0]
 8004910:	f103 32ff 	add.w	r2, r3, #4294967295
 8004914:	4b0c      	ldr	r3, [pc, #48]	; (8004948 <RTC_WKUP_IRQHandler+0x2d8>)
 8004916:	601a      	str	r2, [r3, #0]
 8004918:	e057      	b.n	80049ca <RTC_WKUP_IRQHandler+0x35a>
		     }
		     else if((GPIO_ReadInputDataBit(INPUT_PORT, INPUT_6_PIN)) && (limit_swich_counter == 0))	//Ha a végálláskapcsoló van víz, illetve ha már letelt a szivattyú tiltásának ideje
 800491a:	480e      	ldr	r0, [pc, #56]	; (8004954 <RTC_WKUP_IRQHandler+0x2e4>)
 800491c:	f04f 0101 	mov.w	r1, #1
 8004920:	f002 ff16 	bl	8007750 <GPIO_ReadInputDataBit>
 8004924:	4603      	mov	r3, r0
 8004926:	2b00      	cmp	r3, #0
 8004928:	d04f      	beq.n	80049ca <RTC_WKUP_IRQHandler+0x35a>
 800492a:	4b07      	ldr	r3, [pc, #28]	; (8004948 <RTC_WKUP_IRQHandler+0x2d8>)
 800492c:	681b      	ldr	r3, [r3, #0]
 800492e:	2b00      	cmp	r3, #0
 8004930:	d14b      	bne.n	80049ca <RTC_WKUP_IRQHandler+0x35a>
		     {
		    	 RTC_WKUP_watering_temporary = &watering[1];
 8004932:	4b09      	ldr	r3, [pc, #36]	; (8004958 <RTC_WKUP_IRQHandler+0x2e8>)
 8004934:	607b      	str	r3, [r7, #4]

		         for(RTC_WKUP_i = 0; RTC_WKUP_i < 6; RTC_WKUP_i++)
 8004936:	f04f 0300 	mov.w	r3, #0
 800493a:	75fb      	strb	r3, [r7, #23]
 800493c:	e042      	b.n	80049c4 <RTC_WKUP_IRQHandler+0x354>
 800493e:	bf00      	nop
 8004940:	20001034 	.word	0x20001034
 8004944:	2000124c 	.word	0x2000124c
 8004948:	2000143c 	.word	0x2000143c
 800494c:	20000d10 	.word	0x20000d10
 8004950:	20000fac 	.word	0x20000fac
 8004954:	40020c00 	.word	0x40020c00
 8004958:	2000115c 	.word	0x2000115c
		         {
		         	if(!TimeCompare(RTC_WKUP_watering_temporary))		//Ha van egy aktív program. Ekkor ugyan a tömb része az új öntözés, mégsem fogjuk megnézni, hogy melyik a következõ program, hiszen ekkor már megy egy.
 800495c:	6878      	ldr	r0, [r7, #4]
 800495e:	f7fc faa1 	bl	8000ea4 <TimeCompare>
 8004962:	4603      	mov	r3, r0
 8004964:	2b00      	cmp	r3, #0
 8004966:	d126      	bne.n	80049b6 <RTC_WKUP_IRQHandler+0x346>
		         	{
		         		pump_counter++;
 8004968:	4b1e      	ldr	r3, [pc, #120]	; (80049e4 <RTC_WKUP_IRQHandler+0x374>)
 800496a:	681b      	ldr	r3, [r3, #0]
 800496c:	f103 0201 	add.w	r2, r3, #1
 8004970:	4b1c      	ldr	r3, [pc, #112]	; (80049e4 <RTC_WKUP_IRQHandler+0x374>)
 8004972:	601a      	str	r2, [r3, #0]

		         		if(pump_counter < PUMP_WAIT_1)
 8004974:	4b1b      	ldr	r3, [pc, #108]	; (80049e4 <RTC_WKUP_IRQHandler+0x374>)
 8004976:	681b      	ldr	r3, [r3, #0]
 8004978:	2b13      	cmp	r3, #19
 800497a:	dc0a      	bgt.n	8004992 <RTC_WKUP_IRQHandler+0x322>
		         		{
		         			Output_On((watering_current->Watering_channel) + 2);
 800497c:	4b1a      	ldr	r3, [pc, #104]	; (80049e8 <RTC_WKUP_IRQHandler+0x378>)
 800497e:	681b      	ldr	r3, [r3, #0]
 8004980:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
 8004984:	f103 0302 	add.w	r3, r3, #2
 8004988:	b2db      	uxtb	r3, r3
 800498a:	4618      	mov	r0, r3
 800498c:	f7ff fb70 	bl	8004070 <Output_On>
		         		else
		         		{
		         			pump_counter = 0;
		         		}

		         		break;
 8004990:	e01b      	b.n	80049ca <RTC_WKUP_IRQHandler+0x35a>

		         		if(pump_counter < PUMP_WAIT_1)
		         		{
		         			Output_On((watering_current->Watering_channel) + 2);
		         		}
		         		else if((pump_counter >= PUMP_WAIT_1) && (pump_counter < (PUMP_WAIT_1 + PUMP_WAIT_2)))
 8004992:	4b14      	ldr	r3, [pc, #80]	; (80049e4 <RTC_WKUP_IRQHandler+0x374>)
 8004994:	681b      	ldr	r3, [r3, #0]
 8004996:	2b13      	cmp	r3, #19
 8004998:	dd08      	ble.n	80049ac <RTC_WKUP_IRQHandler+0x33c>
 800499a:	4b12      	ldr	r3, [pc, #72]	; (80049e4 <RTC_WKUP_IRQHandler+0x374>)
 800499c:	681b      	ldr	r3, [r3, #0]
 800499e:	2b27      	cmp	r3, #39	; 0x27
 80049a0:	dc04      	bgt.n	80049ac <RTC_WKUP_IRQHandler+0x33c>
		         		{
		         			Output_Off(Output_all);
 80049a2:	f04f 000b 	mov.w	r0, #11
 80049a6:	f7ff fbc9 	bl	800413c <Output_Off>
		         		else
		         		{
		         			pump_counter = 0;
		         		}

		         		break;
 80049aa:	e00e      	b.n	80049ca <RTC_WKUP_IRQHandler+0x35a>
		         		{
		         			Output_Off(Output_all);
		         		}
		         		else
		         		{
		         			pump_counter = 0;
 80049ac:	4b0d      	ldr	r3, [pc, #52]	; (80049e4 <RTC_WKUP_IRQHandler+0x374>)
 80049ae:	f04f 0200 	mov.w	r2, #0
 80049b2:	601a      	str	r2, [r3, #0]
		         		}

		         		break;
 80049b4:	e009      	b.n	80049ca <RTC_WKUP_IRQHandler+0x35a>
		         	}

		         	RTC_WKUP_watering_temporary = RTC_WKUP_watering_temporary->next;
 80049b6:	687b      	ldr	r3, [r7, #4]
 80049b8:	68db      	ldr	r3, [r3, #12]
 80049ba:	607b      	str	r3, [r7, #4]
		     }
		     else if((GPIO_ReadInputDataBit(INPUT_PORT, INPUT_6_PIN)) && (limit_swich_counter == 0))	//Ha a végálláskapcsoló van víz, illetve ha már letelt a szivattyú tiltásának ideje
		     {
		    	 RTC_WKUP_watering_temporary = &watering[1];

		         for(RTC_WKUP_i = 0; RTC_WKUP_i < 6; RTC_WKUP_i++)
 80049bc:	7dfb      	ldrb	r3, [r7, #23]
 80049be:	f103 0301 	add.w	r3, r3, #1
 80049c2:	75fb      	strb	r3, [r7, #23]
 80049c4:	7dfb      	ldrb	r3, [r7, #23]
 80049c6:	2b05      	cmp	r3, #5
 80049c8:	d9c8      	bls.n	800495c <RTC_WKUP_IRQHandler+0x2ec>
		         	RTC_WKUP_watering_temporary = RTC_WKUP_watering_temporary->next;
		         }
		     }
	  }

    RTC_ClearITPendingBit(RTC_IT_WUT);
 80049ca:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 80049ce:	f005 f97f 	bl	8009cd0 <RTC_ClearITPendingBit>
    EXTI_ClearITPendingBit(EXTI_Line22);
 80049d2:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 80049d6:	f002 f929 	bl	8006c2c <EXTI_ClearITPendingBit>
  }
}
 80049da:	f107 0718 	add.w	r7, r7, #24
 80049de:	46bd      	mov	sp, r7
 80049e0:	bd80      	pop	{r7, pc}
 80049e2:	bf00      	nop
 80049e4:	20001440 	.word	0x20001440
 80049e8:	20001314 	.word	0x20001314

080049ec <RTC_Alarm_IRQHandler>:

/*	RTC_Alarm_IRQHandler
 * Ez a függvény kezeli le az ALARM  megszakításokat, azaz õ az, aki az öntözés kezdetét, végét lekezeli.
*/
void RTC_Alarm_IRQHandler(void)
{
 80049ec:	b5f0      	push	{r4, r5, r6, r7, lr}
 80049ee:	b08d      	sub	sp, #52	; 0x34
 80049f0:	af0a      	add	r7, sp, #40	; 0x28
	int RTC_Alarm_IRQH_a, RTC_Alarm_IRQH_b;

  if((RTC_GetITStatus(RTC_IT_ALRA) != RESET)/* && (!(day_counter % watering_current->nev[6]))*/)	//Öntözés kezdetét kezelõ rész
 80049f2:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80049f6:	f005 f92d 	bl	8009c54 <RTC_GetITStatus>
 80049fa:	4603      	mov	r3, r0
 80049fc:	2b00      	cmp	r3, #0
 80049fe:	f000 80ae 	beq.w	8004b5e <RTC_Alarm_IRQHandler+0x172>
  {
	  if((!(day_counter % (watering_current->nev[6] - ASCII_OFFSEET))))				//Megnézem, hogy aznap kell-e öntözni.
 8004a02:	4b96      	ldr	r3, [pc, #600]	; (8004c5c <RTC_Alarm_IRQHandler+0x270>)
 8004a04:	681b      	ldr	r3, [r3, #0]
 8004a06:	4a96      	ldr	r2, [pc, #600]	; (8004c60 <RTC_Alarm_IRQHandler+0x274>)
 8004a08:	6812      	ldr	r2, [r2, #0]
 8004a0a:	6812      	ldr	r2, [r2, #0]
 8004a0c:	f102 0206 	add.w	r2, r2, #6
 8004a10:	7812      	ldrb	r2, [r2, #0]
 8004a12:	f1a2 0230 	sub.w	r2, r2, #48	; 0x30
 8004a16:	fb93 f1f2 	sdiv	r1, r3, r2
 8004a1a:	fb02 f201 	mul.w	r2, r2, r1
 8004a1e:	1a9b      	subs	r3, r3, r2
 8004a20:	2b00      	cmp	r3, #0
 8004a22:	f040 8093 	bne.w	8004b4c <RTC_Alarm_IRQHandler+0x160>
	  {

		  Output_Off((Output_all));													//Biztonság kedvéért minden szelepet kikapcsolok
 8004a26:	f04f 000b 	mov.w	r0, #11
 8004a2a:	f7ff fb87 	bl	800413c <Output_Off>
		  Output_On((watering_current->Watering_channel) + 2);						//Megfelelõ szelep bekapcsolása
 8004a2e:	4b8c      	ldr	r3, [pc, #560]	; (8004c60 <RTC_Alarm_IRQHandler+0x274>)
 8004a30:	681b      	ldr	r3, [r3, #0]
 8004a32:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
 8004a36:	f103 0302 	add.w	r3, r3, #2
 8004a3a:	b2db      	uxtb	r3, r3
 8004a3c:	4618      	mov	r0, r3
 8004a3e:	f7ff fb17 	bl	8004070 <Output_On>
		  pump_counter = limit_swich_counter = 0;									//Nullázza a szivattyú kapcsolagatását(öntözéso programon belüli periódikus szünetek) vezérlõ változókat.
 8004a42:	4b88      	ldr	r3, [pc, #544]	; (8004c64 <RTC_Alarm_IRQHandler+0x278>)
 8004a44:	f04f 0200 	mov.w	r2, #0
 8004a48:	601a      	str	r2, [r3, #0]
 8004a4a:	4b86      	ldr	r3, [pc, #536]	; (8004c64 <RTC_Alarm_IRQHandler+0x278>)
 8004a4c:	681a      	ldr	r2, [r3, #0]
 8004a4e:	4b86      	ldr	r3, [pc, #536]	; (8004c68 <RTC_Alarm_IRQHandler+0x27c>)
 8004a50:	601a      	str	r2, [r3, #0]

		  menu_level_first[menu_level] = *menu_first;								//Elmenti az elõzõ képernyõ állását.
 8004a52:	4b86      	ldr	r3, [pc, #536]	; (8004c6c <RTC_Alarm_IRQHandler+0x280>)
 8004a54:	781b      	ldrb	r3, [r3, #0]
 8004a56:	461a      	mov	r2, r3
 8004a58:	4b85      	ldr	r3, [pc, #532]	; (8004c70 <RTC_Alarm_IRQHandler+0x284>)
 8004a5a:	6819      	ldr	r1, [r3, #0]
 8004a5c:	4885      	ldr	r0, [pc, #532]	; (8004c74 <RTC_Alarm_IRQHandler+0x288>)
 8004a5e:	4613      	mov	r3, r2
 8004a60:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8004a64:	1a9b      	subs	r3, r3, r2
 8004a66:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004a6a:	18c3      	adds	r3, r0, r3
 8004a6c:	461c      	mov	r4, r3
 8004a6e:	460d      	mov	r5, r1
 8004a70:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8004a72:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8004a74:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8004a78:	e884 0007 	stmia.w	r4, {r0, r1, r2}
		  menu_level_current[menu_level] = *menu_current;
 8004a7c:	4b7b      	ldr	r3, [pc, #492]	; (8004c6c <RTC_Alarm_IRQHandler+0x280>)
 8004a7e:	781b      	ldrb	r3, [r3, #0]
 8004a80:	461a      	mov	r2, r3
 8004a82:	4b7d      	ldr	r3, [pc, #500]	; (8004c78 <RTC_Alarm_IRQHandler+0x28c>)
 8004a84:	6819      	ldr	r1, [r3, #0]
 8004a86:	487d      	ldr	r0, [pc, #500]	; (8004c7c <RTC_Alarm_IRQHandler+0x290>)
 8004a88:	4613      	mov	r3, r2
 8004a8a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8004a8e:	1a9b      	subs	r3, r3, r2
 8004a90:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004a94:	18c3      	adds	r3, r0, r3
 8004a96:	461c      	mov	r4, r3
 8004a98:	460d      	mov	r5, r1
 8004a9a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8004a9c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8004a9e:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8004aa2:	e884 0007 	stmia.w	r4, {r0, r1, r2}
		  menu_first = menu_current = &watering_prcess1;     						//Az almenü elsõ pontjára állítom az almenü aktuálisan kiválasztott változóját.
 8004aa6:	4b74      	ldr	r3, [pc, #464]	; (8004c78 <RTC_Alarm_IRQHandler+0x28c>)
 8004aa8:	4a75      	ldr	r2, [pc, #468]	; (8004c80 <RTC_Alarm_IRQHandler+0x294>)
 8004aaa:	601a      	str	r2, [r3, #0]
 8004aac:	4b72      	ldr	r3, [pc, #456]	; (8004c78 <RTC_Alarm_IRQHandler+0x28c>)
 8004aae:	681a      	ldr	r2, [r3, #0]
 8004ab0:	4b6f      	ldr	r3, [pc, #444]	; (8004c70 <RTC_Alarm_IRQHandler+0x284>)
 8004ab2:	601a      	str	r2, [r3, #0]
		  menu_level++;
 8004ab4:	4b6d      	ldr	r3, [pc, #436]	; (8004c6c <RTC_Alarm_IRQHandler+0x280>)
 8004ab6:	781b      	ldrb	r3, [r3, #0]
 8004ab8:	f103 0301 	add.w	r3, r3, #1
 8004abc:	b2da      	uxtb	r2, r3
 8004abe:	4b6b      	ldr	r3, [pc, #428]	; (8004c6c <RTC_Alarm_IRQHandler+0x280>)
 8004ac0:	701a      	strb	r2, [r3, #0]

		  watering_prcess1.nev[0] = watering_temp[(watering_current->designator) - 1][14];
 8004ac2:	4b6f      	ldr	r3, [pc, #444]	; (8004c80 <RTC_Alarm_IRQHandler+0x294>)
 8004ac4:	6819      	ldr	r1, [r3, #0]
 8004ac6:	4b66      	ldr	r3, [pc, #408]	; (8004c60 <RTC_Alarm_IRQHandler+0x274>)
 8004ac8:	681b      	ldr	r3, [r3, #0]
 8004aca:	791b      	ldrb	r3, [r3, #4]
 8004acc:	f103 32ff 	add.w	r2, r3, #4294967295
 8004ad0:	486c      	ldr	r0, [pc, #432]	; (8004c84 <RTC_Alarm_IRQHandler+0x298>)
 8004ad2:	4613      	mov	r3, r2
 8004ad4:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8004ad8:	189b      	adds	r3, r3, r2
 8004ada:	18c3      	adds	r3, r0, r3
 8004adc:	f103 030e 	add.w	r3, r3, #14
 8004ae0:	781b      	ldrb	r3, [r3, #0]
 8004ae2:	700b      	strb	r3, [r1, #0]
		  watering_prcess1.nev[1] = watering_temp[(watering_current->designator) - 1][15];
 8004ae4:	4b66      	ldr	r3, [pc, #408]	; (8004c80 <RTC_Alarm_IRQHandler+0x294>)
 8004ae6:	681b      	ldr	r3, [r3, #0]
 8004ae8:	f103 0101 	add.w	r1, r3, #1
 8004aec:	4b5c      	ldr	r3, [pc, #368]	; (8004c60 <RTC_Alarm_IRQHandler+0x274>)
 8004aee:	681b      	ldr	r3, [r3, #0]
 8004af0:	791b      	ldrb	r3, [r3, #4]
 8004af2:	f103 32ff 	add.w	r2, r3, #4294967295
 8004af6:	4863      	ldr	r0, [pc, #396]	; (8004c84 <RTC_Alarm_IRQHandler+0x298>)
 8004af8:	4613      	mov	r3, r2
 8004afa:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8004afe:	189b      	adds	r3, r3, r2
 8004b00:	18c3      	adds	r3, r0, r3
 8004b02:	f103 030f 	add.w	r3, r3, #15
 8004b06:	781b      	ldrb	r3, [r3, #0]
 8004b08:	700b      	strb	r3, [r1, #0]
		  watering_prcess1.nev[3] = '0';
 8004b0a:	4b5d      	ldr	r3, [pc, #372]	; (8004c80 <RTC_Alarm_IRQHandler+0x294>)
 8004b0c:	681b      	ldr	r3, [r3, #0]
 8004b0e:	f103 0303 	add.w	r3, r3, #3
 8004b12:	f04f 0230 	mov.w	r2, #48	; 0x30
 8004b16:	701a      	strb	r2, [r3, #0]
		  watering_prcess1.nev[4] = '0';
 8004b18:	4b59      	ldr	r3, [pc, #356]	; (8004c80 <RTC_Alarm_IRQHandler+0x294>)
 8004b1a:	681b      	ldr	r3, [r3, #0]
 8004b1c:	f103 0304 	add.w	r3, r3, #4
 8004b20:	f04f 0230 	mov.w	r2, #48	; 0x30
 8004b24:	701a      	strb	r2, [r3, #0]

		  ClearLcmScreen();				//Beállítom az öntözõ képernyõt.
 8004b26:	f7fb fe05 	bl	8000734 <ClearLcmScreen>

		  Cursor(0,0);
 8004b2a:	f04f 0000 	mov.w	r0, #0
 8004b2e:	f04f 0100 	mov.w	r1, #0
 8004b32:	f7fb fdc7 	bl	80006c4 <Cursor>
		  StrAlign(watering_prcess1.nev, temp, ALIGN_LEFT);
 8004b36:	4b52      	ldr	r3, [pc, #328]	; (8004c80 <RTC_Alarm_IRQHandler+0x294>)
 8004b38:	681b      	ldr	r3, [r3, #0]
 8004b3a:	4618      	mov	r0, r3
 8004b3c:	4952      	ldr	r1, [pc, #328]	; (8004c88 <RTC_Alarm_IRQHandler+0x29c>)
 8004b3e:	f04f 0201 	mov.w	r2, #1
 8004b42:	f7fb fe8d 	bl	8000860 <StrAlign>
		  PrintStr(temp);
 8004b46:	4850      	ldr	r0, [pc, #320]	; (8004c88 <RTC_Alarm_IRQHandler+0x29c>)
 8004b48:	f7fb ffca 	bl	8000ae0 <PrintStr>
	  }

	  RTC_ClearITPendingBit(RTC_IT_ALRA);
 8004b4c:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8004b50:	f005 f8be 	bl	8009cd0 <RTC_ClearITPendingBit>
	  EXTI_ClearITPendingBit(EXTI_Line17);
 8004b54:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8004b58:	f002 f868 	bl	8006c2c <EXTI_ClearITPendingBit>
 8004b5c:	e115      	b.n	8004d8a <RTC_Alarm_IRQHandler+0x39e>
  }

  else if((RTC_GetITStatus(RTC_IT_ALRB) != RESET)/* && (!(day_counter % watering_current->nev[6]))*/)	//Öntözés program lejártakor lefutó kód
 8004b5e:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8004b62:	f005 f877 	bl	8009c54 <RTC_GetITStatus>
 8004b66:	4603      	mov	r3, r0
 8004b68:	2b00      	cmp	r3, #0
 8004b6a:	f000 810e 	beq.w	8004d8a <RTC_Alarm_IRQHandler+0x39e>
  {
	  RTC_Alarm_IRQH_a = ((((RTC->ALRMAR & RTC_ALRMAR_HT) >> 20) * 600) + (((RTC->ALRMAR & RTC_ALRMAR_HU) >> 16) * 60) + (((RTC->ALRMAR & RTC_ALRMAR_MNT) >> 12) * 10) + (((RTC->ALRMAR & RTC_ALRMAR_MNU) >> 8)));
 8004b6e:	4b47      	ldr	r3, [pc, #284]	; (8004c8c <RTC_Alarm_IRQHandler+0x2a0>)
 8004b70:	69db      	ldr	r3, [r3, #28]
 8004b72:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 8004b76:	ea4f 5313 	mov.w	r3, r3, lsr #20
 8004b7a:	f44f 7216 	mov.w	r2, #600	; 0x258
 8004b7e:	fb02 f103 	mul.w	r1, r2, r3
 8004b82:	4b42      	ldr	r3, [pc, #264]	; (8004c8c <RTC_Alarm_IRQHandler+0x2a0>)
 8004b84:	69db      	ldr	r3, [r3, #28]
 8004b86:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
 8004b8a:	ea4f 4213 	mov.w	r2, r3, lsr #16
 8004b8e:	4613      	mov	r3, r2
 8004b90:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8004b94:	1a9b      	subs	r3, r3, r2
 8004b96:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004b9a:	18c9      	adds	r1, r1, r3
 8004b9c:	4b3b      	ldr	r3, [pc, #236]	; (8004c8c <RTC_Alarm_IRQHandler+0x2a0>)
 8004b9e:	69db      	ldr	r3, [r3, #28]
 8004ba0:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
 8004ba4:	ea4f 3213 	mov.w	r2, r3, lsr #12
 8004ba8:	4613      	mov	r3, r2
 8004baa:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004bae:	189b      	adds	r3, r3, r2
 8004bb0:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8004bb4:	18ca      	adds	r2, r1, r3
 8004bb6:	4b35      	ldr	r3, [pc, #212]	; (8004c8c <RTC_Alarm_IRQHandler+0x2a0>)
 8004bb8:	69db      	ldr	r3, [r3, #28]
 8004bba:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 8004bbe:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8004bc2:	18d3      	adds	r3, r2, r3
 8004bc4:	607b      	str	r3, [r7, #4]
	  RTC_Alarm_IRQH_b = ((((RTC->ALRMBR & RTC_ALRMBR_HT) >> 20) * 600) + (((RTC->ALRMBR & RTC_ALRMBR_HU) >> 16) * 60) + (((RTC->ALRMBR & RTC_ALRMBR_MNT) >> 12) * 10) + (((RTC->ALRMBR & RTC_ALRMBR_MNU) >> 8)));
 8004bc6:	4b31      	ldr	r3, [pc, #196]	; (8004c8c <RTC_Alarm_IRQHandler+0x2a0>)
 8004bc8:	6a1b      	ldr	r3, [r3, #32]
 8004bca:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 8004bce:	ea4f 5313 	mov.w	r3, r3, lsr #20
 8004bd2:	f44f 7216 	mov.w	r2, #600	; 0x258
 8004bd6:	fb02 f103 	mul.w	r1, r2, r3
 8004bda:	4b2c      	ldr	r3, [pc, #176]	; (8004c8c <RTC_Alarm_IRQHandler+0x2a0>)
 8004bdc:	6a1b      	ldr	r3, [r3, #32]
 8004bde:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
 8004be2:	ea4f 4213 	mov.w	r2, r3, lsr #16
 8004be6:	4613      	mov	r3, r2
 8004be8:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8004bec:	1a9b      	subs	r3, r3, r2
 8004bee:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004bf2:	18c9      	adds	r1, r1, r3
 8004bf4:	4b25      	ldr	r3, [pc, #148]	; (8004c8c <RTC_Alarm_IRQHandler+0x2a0>)
 8004bf6:	6a1b      	ldr	r3, [r3, #32]
 8004bf8:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
 8004bfc:	ea4f 3213 	mov.w	r2, r3, lsr #12
 8004c00:	4613      	mov	r3, r2
 8004c02:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004c06:	189b      	adds	r3, r3, r2
 8004c08:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8004c0c:	18ca      	adds	r2, r1, r3
 8004c0e:	4b1f      	ldr	r3, [pc, #124]	; (8004c8c <RTC_Alarm_IRQHandler+0x2a0>)
 8004c10:	6a1b      	ldr	r3, [r3, #32]
 8004c12:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 8004c16:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8004c1a:	18d3      	adds	r3, r2, r3
 8004c1c:	603b      	str	r3, [r7, #0]

	  if((!(day_counter % (watering_current->nev[6] - ASCII_OFFSEET))) || ((RTC_Alarm_IRQH_a > RTC_Alarm_IRQH_b) && (!(((day_counter == 9) ? 1 : (day_counter - 1)) % (watering_current->nev[6] - ASCII_OFFSEET)))))
 8004c1e:	4b0f      	ldr	r3, [pc, #60]	; (8004c5c <RTC_Alarm_IRQHandler+0x270>)
 8004c20:	681b      	ldr	r3, [r3, #0]
 8004c22:	4a0f      	ldr	r2, [pc, #60]	; (8004c60 <RTC_Alarm_IRQHandler+0x274>)
 8004c24:	6812      	ldr	r2, [r2, #0]
 8004c26:	6812      	ldr	r2, [r2, #0]
 8004c28:	f102 0206 	add.w	r2, r2, #6
 8004c2c:	7812      	ldrb	r2, [r2, #0]
 8004c2e:	f1a2 0230 	sub.w	r2, r2, #48	; 0x30
 8004c32:	fb93 f1f2 	sdiv	r1, r3, r2
 8004c36:	fb02 f201 	mul.w	r2, r2, r1
 8004c3a:	1a9b      	subs	r3, r3, r2
 8004c3c:	2b00      	cmp	r3, #0
 8004c3e:	d038      	beq.n	8004cb2 <RTC_Alarm_IRQHandler+0x2c6>
 8004c40:	687a      	ldr	r2, [r7, #4]
 8004c42:	683b      	ldr	r3, [r7, #0]
 8004c44:	429a      	cmp	r2, r3
 8004c46:	f340 8098 	ble.w	8004d7a <RTC_Alarm_IRQHandler+0x38e>
 8004c4a:	4b04      	ldr	r3, [pc, #16]	; (8004c5c <RTC_Alarm_IRQHandler+0x270>)
 8004c4c:	681b      	ldr	r3, [r3, #0]
 8004c4e:	2b09      	cmp	r3, #9
 8004c50:	d01e      	beq.n	8004c90 <RTC_Alarm_IRQHandler+0x2a4>
 8004c52:	4b02      	ldr	r3, [pc, #8]	; (8004c5c <RTC_Alarm_IRQHandler+0x270>)
 8004c54:	681b      	ldr	r3, [r3, #0]
 8004c56:	f103 33ff 	add.w	r3, r3, #4294967295
 8004c5a:	e01b      	b.n	8004c94 <RTC_Alarm_IRQHandler+0x2a8>
 8004c5c:	20000e5c 	.word	0x20000e5c
 8004c60:	20001314 	.word	0x20001314
 8004c64:	2000143c 	.word	0x2000143c
 8004c68:	20001440 	.word	0x20001440
 8004c6c:	2000130e 	.word	0x2000130e
 8004c70:	20000d48 	.word	0x20000d48
 8004c74:	20000eb8 	.word	0x20000eb8
 8004c78:	2000124c 	.word	0x2000124c
 8004c7c:	20001054 	.word	0x20001054
 8004c80:	20001034 	.word	0x20001034
 8004c84:	20000dac 	.word	0x20000dac
 8004c88:	20000fac 	.word	0x20000fac
 8004c8c:	40002800 	.word	0x40002800
 8004c90:	f04f 0301 	mov.w	r3, #1
 8004c94:	4a3f      	ldr	r2, [pc, #252]	; (8004d94 <RTC_Alarm_IRQHandler+0x3a8>)
 8004c96:	6812      	ldr	r2, [r2, #0]
 8004c98:	6812      	ldr	r2, [r2, #0]
 8004c9a:	f102 0206 	add.w	r2, r2, #6
 8004c9e:	7812      	ldrb	r2, [r2, #0]
 8004ca0:	f1a2 0230 	sub.w	r2, r2, #48	; 0x30
 8004ca4:	fb93 f1f2 	sdiv	r1, r3, r2
 8004ca8:	fb02 f201 	mul.w	r2, r2, r1
 8004cac:	1a9b      	subs	r3, r3, r2
 8004cae:	2b00      	cmp	r3, #0
 8004cb0:	d163      	bne.n	8004d7a <RTC_Alarm_IRQHandler+0x38e>
	  {
		  Output_Off((Output_all));
 8004cb2:	f04f 000b 	mov.w	r0, #11
 8004cb6:	f7ff fa41 	bl	800413c <Output_Off>

		  watering_prcess1.nev[0] = '0';
 8004cba:	4b37      	ldr	r3, [pc, #220]	; (8004d98 <RTC_Alarm_IRQHandler+0x3ac>)
 8004cbc:	681b      	ldr	r3, [r3, #0]
 8004cbe:	f04f 0230 	mov.w	r2, #48	; 0x30
 8004cc2:	701a      	strb	r2, [r3, #0]
		  watering_prcess1.nev[1] = '0';
 8004cc4:	4b34      	ldr	r3, [pc, #208]	; (8004d98 <RTC_Alarm_IRQHandler+0x3ac>)
 8004cc6:	681b      	ldr	r3, [r3, #0]
 8004cc8:	f103 0301 	add.w	r3, r3, #1
 8004ccc:	f04f 0230 	mov.w	r2, #48	; 0x30
 8004cd0:	701a      	strb	r2, [r3, #0]
		  watering_prcess1.nev[3] = '0';
 8004cd2:	4b31      	ldr	r3, [pc, #196]	; (8004d98 <RTC_Alarm_IRQHandler+0x3ac>)
 8004cd4:	681b      	ldr	r3, [r3, #0]
 8004cd6:	f103 0303 	add.w	r3, r3, #3
 8004cda:	f04f 0230 	mov.w	r2, #48	; 0x30
 8004cde:	701a      	strb	r2, [r3, #0]
		  watering_prcess1.nev[4] = '0';
 8004ce0:	4b2d      	ldr	r3, [pc, #180]	; (8004d98 <RTC_Alarm_IRQHandler+0x3ac>)
 8004ce2:	681b      	ldr	r3, [r3, #0]
 8004ce4:	f103 0304 	add.w	r3, r3, #4
 8004ce8:	f04f 0230 	mov.w	r2, #48	; 0x30
 8004cec:	701a      	strb	r2, [r3, #0]

		  if(&(*menu_current) == &watering_prcess1)	//ha még mindig a Öntözés képernyõn van, a program lejártával visszamegy egy szintet.
 8004cee:	4b2b      	ldr	r3, [pc, #172]	; (8004d9c <RTC_Alarm_IRQHandler+0x3b0>)
 8004cf0:	681a      	ldr	r2, [r3, #0]
 8004cf2:	4b29      	ldr	r3, [pc, #164]	; (8004d98 <RTC_Alarm_IRQHandler+0x3ac>)
 8004cf4:	429a      	cmp	r2, r3
 8004cf6:	d138      	bne.n	8004d6a <RTC_Alarm_IRQHandler+0x37e>
		  {
			  ClearLcmScreen();
 8004cf8:	f7fb fd1c 	bl	8000734 <ClearLcmScreen>

			  menu_level--;
 8004cfc:	4b28      	ldr	r3, [pc, #160]	; (8004da0 <RTC_Alarm_IRQHandler+0x3b4>)
 8004cfe:	781b      	ldrb	r3, [r3, #0]
 8004d00:	f103 33ff 	add.w	r3, r3, #4294967295
 8004d04:	b2da      	uxtb	r2, r3
 8004d06:	4b26      	ldr	r3, [pc, #152]	; (8004da0 <RTC_Alarm_IRQHandler+0x3b4>)
 8004d08:	701a      	strb	r2, [r3, #0]
			  menu_current = &menu_level_current[menu_level];
 8004d0a:	4b25      	ldr	r3, [pc, #148]	; (8004da0 <RTC_Alarm_IRQHandler+0x3b4>)
 8004d0c:	781b      	ldrb	r3, [r3, #0]
 8004d0e:	461a      	mov	r2, r3
 8004d10:	4613      	mov	r3, r2
 8004d12:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8004d16:	1a9b      	subs	r3, r3, r2
 8004d18:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004d1c:	4a21      	ldr	r2, [pc, #132]	; (8004da4 <RTC_Alarm_IRQHandler+0x3b8>)
 8004d1e:	189a      	adds	r2, r3, r2
 8004d20:	4b1e      	ldr	r3, [pc, #120]	; (8004d9c <RTC_Alarm_IRQHandler+0x3b0>)
 8004d22:	601a      	str	r2, [r3, #0]
			  menu_first = &menu_level_first[menu_level];
 8004d24:	4b1e      	ldr	r3, [pc, #120]	; (8004da0 <RTC_Alarm_IRQHandler+0x3b4>)
 8004d26:	781b      	ldrb	r3, [r3, #0]
 8004d28:	461a      	mov	r2, r3
 8004d2a:	4613      	mov	r3, r2
 8004d2c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8004d30:	1a9b      	subs	r3, r3, r2
 8004d32:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004d36:	4a1c      	ldr	r2, [pc, #112]	; (8004da8 <RTC_Alarm_IRQHandler+0x3bc>)
 8004d38:	189a      	adds	r2, r3, r2
 8004d3a:	4b1c      	ldr	r3, [pc, #112]	; (8004dac <RTC_Alarm_IRQHandler+0x3c0>)
 8004d3c:	601a      	str	r2, [r3, #0]

			  DisplayFill(*menu_current, *menu_first);
 8004d3e:	4b17      	ldr	r3, [pc, #92]	; (8004d9c <RTC_Alarm_IRQHandler+0x3b0>)
 8004d40:	681e      	ldr	r6, [r3, #0]
 8004d42:	4b1a      	ldr	r3, [pc, #104]	; (8004dac <RTC_Alarm_IRQHandler+0x3c0>)
 8004d44:	681b      	ldr	r3, [r3, #0]
 8004d46:	ad03      	add	r5, sp, #12
 8004d48:	461c      	mov	r4, r3
 8004d4a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8004d4c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8004d4e:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8004d52:	e885 0007 	stmia.w	r5, {r0, r1, r2}
 8004d56:	466b      	mov	r3, sp
 8004d58:	f106 0210 	add.w	r2, r6, #16
 8004d5c:	ca07      	ldmia	r2, {r0, r1, r2}
 8004d5e:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 8004d62:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 8004d66:	f7fb ff3d 	bl	8000be4 <DisplayFill>
		  }

		  Watering_Next_Set();
 8004d6a:	f7fc fa79 	bl	8001260 <Watering_Next_Set>
		  RTC_WriteBackupRegister(RTC_BKP_DR0, 0x32F2);
 8004d6e:	f04f 0000 	mov.w	r0, #0
 8004d72:	f243 21f2 	movw	r1, #13042	; 0x32f2
 8004d76:	f004 fe13 	bl	80099a0 <RTC_WriteBackupRegister>
    RTC_WriteBackupRegister(RTC_BKP_DR0, 0x32F2);

*/
	  }

    RTC_ClearITPendingBit(RTC_IT_ALRB);
 8004d7a:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8004d7e:	f004 ffa7 	bl	8009cd0 <RTC_ClearITPendingBit>
    EXTI_ClearITPendingBit(EXTI_Line17);
 8004d82:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8004d86:	f001 ff51 	bl	8006c2c <EXTI_ClearITPendingBit>
  }
}
 8004d8a:	f107 070c 	add.w	r7, r7, #12
 8004d8e:	46bd      	mov	sp, r7
 8004d90:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004d92:	bf00      	nop
 8004d94:	20001314 	.word	0x20001314
 8004d98:	20001034 	.word	0x20001034
 8004d9c:	2000124c 	.word	0x2000124c
 8004da0:	2000130e 	.word	0x2000130e
 8004da4:	20001054 	.word	0x20001054
 8004da8:	20000eb8 	.word	0x20000eb8
 8004dac:	20000d48 	.word	0x20000d48

08004db0 <EXTI9_5_IRQHandler>:
 *  A fel és a lefele navigáló gombok megszakításkezelõi is ebbe az EXTI osztályba tartoznak
 */

char menu_current_position = 0;
void EXTI9_5_IRQHandler(void)
{
 8004db0:	b580      	push	{r7, lr}
 8004db2:	af00      	add	r7, sp, #0
//**************************************Input 1 interrupt kezelõ függvénye******************************************

if ( EXTI_GetITStatus(EXTI_Line6))              //Ez a megszakítás a menü kezelõ gombjához tartozik, amelyik a lefele léptetést csinálja
 8004db4:	f04f 0040 	mov.w	r0, #64	; 0x40
 8004db8:	f001 ff10 	bl	8006bdc <EXTI_GetITStatus>
 8004dbc:	4603      	mov	r3, r0
 8004dbe:	2b00      	cmp	r3, #0
 8004dc0:	f000 80b1 	beq.w	8004f26 <EXTI9_5_IRQHandler+0x176>
{
        if(menu_special_function)
 8004dc4:	4b93      	ldr	r3, [pc, #588]	; (8005014 <EXTI9_5_IRQHandler+0x264>)
 8004dc6:	781b      	ldrb	r3, [r3, #0]
 8004dc8:	2b00      	cmp	r3, #0
 8004dca:	d012      	beq.n	8004df2 <EXTI9_5_IRQHandler+0x42>
        {
            switch(menu_special_function)
 8004dcc:	4b91      	ldr	r3, [pc, #580]	; (8005014 <EXTI9_5_IRQHandler+0x264>)
 8004dce:	781b      	ldrb	r3, [r3, #0]
 8004dd0:	2b01      	cmp	r3, #1
 8004dd2:	d002      	beq.n	8004dda <EXTI9_5_IRQHandler+0x2a>
 8004dd4:	2b02      	cmp	r3, #2
 8004dd6:	d005      	beq.n	8004de4 <EXTI9_5_IRQHandler+0x34>
 8004dd8:	e00a      	b.n	8004df0 <EXTI9_5_IRQHandler+0x40>
            {
            case MENU_SPECIAL_FUNCTION_TIME_DATE:
                DateChanger(MENU_DOWN);
 8004dda:	f04f 0007 	mov.w	r0, #7
 8004dde:	f7fd f82f 	bl	8001e40 <DateChanger>
                break;
 8004de2:	e09c      	b.n	8004f1e <EXTI9_5_IRQHandler+0x16e>
            case MENU_SPECIAL_FUNCTION_ONTOZES:
                Watering(MENU_DOWN);
 8004de4:	f04f 0007 	mov.w	r0, #7
 8004de8:	f7fd fd38 	bl	800285c <Watering>
                break;
 8004dec:	bf00      	nop
 8004dee:	e096      	b.n	8004f1e <EXTI9_5_IRQHandler+0x16e>

            default:
                break;
 8004df0:	e095      	b.n	8004f1e <EXTI9_5_IRQHandler+0x16e>
            }
        }

        else if(menu_current->next)
 8004df2:	4b89      	ldr	r3, [pc, #548]	; (8005018 <EXTI9_5_IRQHandler+0x268>)
 8004df4:	681b      	ldr	r3, [r3, #0]
 8004df6:	68db      	ldr	r3, [r3, #12]
 8004df8:	2b00      	cmp	r3, #0
 8004dfa:	f000 8090 	beq.w	8004f1e <EXTI9_5_IRQHandler+0x16e>
        {
            menu_current = menu_current->next;
 8004dfe:	4b86      	ldr	r3, [pc, #536]	; (8005018 <EXTI9_5_IRQHandler+0x268>)
 8004e00:	681b      	ldr	r3, [r3, #0]
 8004e02:	68da      	ldr	r2, [r3, #12]
 8004e04:	4b84      	ldr	r3, [pc, #528]	; (8005018 <EXTI9_5_IRQHandler+0x268>)
 8004e06:	601a      	str	r2, [r3, #0]

            if(menu_current->designator >= ((menu_first->designator) + 3))
 8004e08:	4b83      	ldr	r3, [pc, #524]	; (8005018 <EXTI9_5_IRQHandler+0x268>)
 8004e0a:	681b      	ldr	r3, [r3, #0]
 8004e0c:	791b      	ldrb	r3, [r3, #4]
 8004e0e:	461a      	mov	r2, r3
 8004e10:	4b82      	ldr	r3, [pc, #520]	; (800501c <EXTI9_5_IRQHandler+0x26c>)
 8004e12:	681b      	ldr	r3, [r3, #0]
 8004e14:	791b      	ldrb	r3, [r3, #4]
 8004e16:	f103 0303 	add.w	r3, r3, #3
 8004e1a:	429a      	cmp	r2, r3
 8004e1c:	db45      	blt.n	8004eaa <EXTI9_5_IRQHandler+0xfa>
            {
                menu_temporary = menu_first->next;
 8004e1e:	4b7f      	ldr	r3, [pc, #508]	; (800501c <EXTI9_5_IRQHandler+0x26c>)
 8004e20:	681b      	ldr	r3, [r3, #0]
 8004e22:	68da      	ldr	r2, [r3, #12]
 8004e24:	4b7e      	ldr	r3, [pc, #504]	; (8005020 <EXTI9_5_IRQHandler+0x270>)
 8004e26:	601a      	str	r2, [r3, #0]
                Cursor(1,0);
 8004e28:	f04f 0001 	mov.w	r0, #1
 8004e2c:	f04f 0100 	mov.w	r1, #0
 8004e30:	f7fb fc48 	bl	80006c4 <Cursor>
                StrAlign(menu_temporary->nev, temp, ALIGN_LEFT);
 8004e34:	4b7a      	ldr	r3, [pc, #488]	; (8005020 <EXTI9_5_IRQHandler+0x270>)
 8004e36:	681b      	ldr	r3, [r3, #0]
 8004e38:	681b      	ldr	r3, [r3, #0]
 8004e3a:	4618      	mov	r0, r3
 8004e3c:	4979      	ldr	r1, [pc, #484]	; (8005024 <EXTI9_5_IRQHandler+0x274>)
 8004e3e:	f04f 0201 	mov.w	r2, #1
 8004e42:	f7fb fd0d 	bl	8000860 <StrAlign>
                PrintStr(temp);
 8004e46:	4877      	ldr	r0, [pc, #476]	; (8005024 <EXTI9_5_IRQHandler+0x274>)
 8004e48:	f7fb fe4a 	bl	8000ae0 <PrintStr>

                menu_temporary = menu_temporary->next;
 8004e4c:	4b74      	ldr	r3, [pc, #464]	; (8005020 <EXTI9_5_IRQHandler+0x270>)
 8004e4e:	681b      	ldr	r3, [r3, #0]
 8004e50:	68da      	ldr	r2, [r3, #12]
 8004e52:	4b73      	ldr	r3, [pc, #460]	; (8005020 <EXTI9_5_IRQHandler+0x270>)
 8004e54:	601a      	str	r2, [r3, #0]
                Cursor(2,0);
 8004e56:	f04f 0002 	mov.w	r0, #2
 8004e5a:	f04f 0100 	mov.w	r1, #0
 8004e5e:	f7fb fc31 	bl	80006c4 <Cursor>
                StrAlign(menu_temporary->nev, temp, ALIGN_LEFT);
 8004e62:	4b6f      	ldr	r3, [pc, #444]	; (8005020 <EXTI9_5_IRQHandler+0x270>)
 8004e64:	681b      	ldr	r3, [r3, #0]
 8004e66:	681b      	ldr	r3, [r3, #0]
 8004e68:	4618      	mov	r0, r3
 8004e6a:	496e      	ldr	r1, [pc, #440]	; (8005024 <EXTI9_5_IRQHandler+0x274>)
 8004e6c:	f04f 0201 	mov.w	r2, #1
 8004e70:	f7fb fcf6 	bl	8000860 <StrAlign>
                PrintStr(temp);
 8004e74:	486b      	ldr	r0, [pc, #428]	; (8005024 <EXTI9_5_IRQHandler+0x274>)
 8004e76:	f7fb fe33 	bl	8000ae0 <PrintStr>

                Cursor(3,0);
 8004e7a:	f04f 0003 	mov.w	r0, #3
 8004e7e:	f04f 0100 	mov.w	r1, #0
 8004e82:	f7fb fc1f 	bl	80006c4 <Cursor>
                StrAlign(menu_current->nev, temp, ALIGN_ARROW);
 8004e86:	4b64      	ldr	r3, [pc, #400]	; (8005018 <EXTI9_5_IRQHandler+0x268>)
 8004e88:	681b      	ldr	r3, [r3, #0]
 8004e8a:	681b      	ldr	r3, [r3, #0]
 8004e8c:	4618      	mov	r0, r3
 8004e8e:	4965      	ldr	r1, [pc, #404]	; (8005024 <EXTI9_5_IRQHandler+0x274>)
 8004e90:	f04f 0204 	mov.w	r2, #4
 8004e94:	f7fb fce4 	bl	8000860 <StrAlign>
                PrintStr(temp);
 8004e98:	4862      	ldr	r0, [pc, #392]	; (8005024 <EXTI9_5_IRQHandler+0x274>)
 8004e9a:	f7fb fe21 	bl	8000ae0 <PrintStr>

                menu_first = menu_first->next;
 8004e9e:	4b5f      	ldr	r3, [pc, #380]	; (800501c <EXTI9_5_IRQHandler+0x26c>)
 8004ea0:	681b      	ldr	r3, [r3, #0]
 8004ea2:	68da      	ldr	r2, [r3, #12]
 8004ea4:	4b5d      	ldr	r3, [pc, #372]	; (800501c <EXTI9_5_IRQHandler+0x26c>)
 8004ea6:	601a      	str	r2, [r3, #0]
 8004ea8:	e039      	b.n	8004f1e <EXTI9_5_IRQHandler+0x16e>
            }
            else
            {
                Cursor((menu_current->designator - menu_first->designator), 0);
 8004eaa:	4b5b      	ldr	r3, [pc, #364]	; (8005018 <EXTI9_5_IRQHandler+0x268>)
 8004eac:	681b      	ldr	r3, [r3, #0]
 8004eae:	791a      	ldrb	r2, [r3, #4]
 8004eb0:	4b5a      	ldr	r3, [pc, #360]	; (800501c <EXTI9_5_IRQHandler+0x26c>)
 8004eb2:	681b      	ldr	r3, [r3, #0]
 8004eb4:	791b      	ldrb	r3, [r3, #4]
 8004eb6:	1ad3      	subs	r3, r2, r3
 8004eb8:	b2db      	uxtb	r3, r3
 8004eba:	4618      	mov	r0, r3
 8004ebc:	f04f 0100 	mov.w	r1, #0
 8004ec0:	f7fb fc00 	bl	80006c4 <Cursor>
                menu_temporary = menu_current->previous;
 8004ec4:	4b54      	ldr	r3, [pc, #336]	; (8005018 <EXTI9_5_IRQHandler+0x268>)
 8004ec6:	681b      	ldr	r3, [r3, #0]
 8004ec8:	691a      	ldr	r2, [r3, #16]
 8004eca:	4b55      	ldr	r3, [pc, #340]	; (8005020 <EXTI9_5_IRQHandler+0x270>)
 8004ecc:	601a      	str	r2, [r3, #0]
                StrAlign(menu_temporary->nev, temp, ALIGN_LEFT);
 8004ece:	4b54      	ldr	r3, [pc, #336]	; (8005020 <EXTI9_5_IRQHandler+0x270>)
 8004ed0:	681b      	ldr	r3, [r3, #0]
 8004ed2:	681b      	ldr	r3, [r3, #0]
 8004ed4:	4618      	mov	r0, r3
 8004ed6:	4953      	ldr	r1, [pc, #332]	; (8005024 <EXTI9_5_IRQHandler+0x274>)
 8004ed8:	f04f 0201 	mov.w	r2, #1
 8004edc:	f7fb fcc0 	bl	8000860 <StrAlign>
                PrintStr(temp);
 8004ee0:	4850      	ldr	r0, [pc, #320]	; (8005024 <EXTI9_5_IRQHandler+0x274>)
 8004ee2:	f7fb fdfd 	bl	8000ae0 <PrintStr>

                Cursor(((menu_current->designator - menu_first->designator) + 1), 0);
 8004ee6:	4b4c      	ldr	r3, [pc, #304]	; (8005018 <EXTI9_5_IRQHandler+0x268>)
 8004ee8:	681b      	ldr	r3, [r3, #0]
 8004eea:	791a      	ldrb	r2, [r3, #4]
 8004eec:	4b4b      	ldr	r3, [pc, #300]	; (800501c <EXTI9_5_IRQHandler+0x26c>)
 8004eee:	681b      	ldr	r3, [r3, #0]
 8004ef0:	791b      	ldrb	r3, [r3, #4]
 8004ef2:	1ad3      	subs	r3, r2, r3
 8004ef4:	b2db      	uxtb	r3, r3
 8004ef6:	f103 0301 	add.w	r3, r3, #1
 8004efa:	b2db      	uxtb	r3, r3
 8004efc:	4618      	mov	r0, r3
 8004efe:	f04f 0100 	mov.w	r1, #0
 8004f02:	f7fb fbdf 	bl	80006c4 <Cursor>
                StrAlign(menu_current->nev, temp, ALIGN_ARROW);
 8004f06:	4b44      	ldr	r3, [pc, #272]	; (8005018 <EXTI9_5_IRQHandler+0x268>)
 8004f08:	681b      	ldr	r3, [r3, #0]
 8004f0a:	681b      	ldr	r3, [r3, #0]
 8004f0c:	4618      	mov	r0, r3
 8004f0e:	4945      	ldr	r1, [pc, #276]	; (8005024 <EXTI9_5_IRQHandler+0x274>)
 8004f10:	f04f 0204 	mov.w	r2, #4
 8004f14:	f7fb fca4 	bl	8000860 <StrAlign>
                PrintStr(temp);
 8004f18:	4842      	ldr	r0, [pc, #264]	; (8005024 <EXTI9_5_IRQHandler+0x274>)
 8004f1a:	f7fb fde1 	bl	8000ae0 <PrintStr>
            }
        }
    EXTI_ClearITPendingBit(EXTI_Line6);
 8004f1e:	f04f 0040 	mov.w	r0, #64	; 0x40
 8004f22:	f001 fe83 	bl	8006c2c <EXTI_ClearITPendingBit>
}

//**************************************Input 2 interrupt kezelõ függvénye******************************************
if ( EXTI_GetITStatus(EXTI_Line7))                      //Ez a megszakítás a menü kezelõ gombjához tartozik, amelyik a felfele léptetést csinálja
 8004f26:	f04f 0080 	mov.w	r0, #128	; 0x80
 8004f2a:	f001 fe57 	bl	8006bdc <EXTI_GetITStatus>
 8004f2e:	4603      	mov	r3, r0
 8004f30:	2b00      	cmp	r3, #0
 8004f32:	f000 80ba 	beq.w	80050aa <EXTI9_5_IRQHandler+0x2fa>
{
    if(menu_special_function)
 8004f36:	4b37      	ldr	r3, [pc, #220]	; (8005014 <EXTI9_5_IRQHandler+0x264>)
 8004f38:	781b      	ldrb	r3, [r3, #0]
 8004f3a:	2b00      	cmp	r3, #0
 8004f3c:	d012      	beq.n	8004f64 <EXTI9_5_IRQHandler+0x1b4>
    {
        switch(menu_special_function)
 8004f3e:	4b35      	ldr	r3, [pc, #212]	; (8005014 <EXTI9_5_IRQHandler+0x264>)
 8004f40:	781b      	ldrb	r3, [r3, #0]
 8004f42:	2b01      	cmp	r3, #1
 8004f44:	d002      	beq.n	8004f4c <EXTI9_5_IRQHandler+0x19c>
 8004f46:	2b02      	cmp	r3, #2
 8004f48:	d005      	beq.n	8004f56 <EXTI9_5_IRQHandler+0x1a6>
 8004f4a:	e00a      	b.n	8004f62 <EXTI9_5_IRQHandler+0x1b2>
        {
        case MENU_SPECIAL_FUNCTION_TIME_DATE:
            DateChanger(MENU_UP);
 8004f4c:	f04f 0008 	mov.w	r0, #8
 8004f50:	f7fc ff76 	bl	8001e40 <DateChanger>
            break;
 8004f54:	e0a5      	b.n	80050a2 <EXTI9_5_IRQHandler+0x2f2>
        case MENU_SPECIAL_FUNCTION_ONTOZES:
            Watering(MENU_UP);
 8004f56:	f04f 0008 	mov.w	r0, #8
 8004f5a:	f7fd fc7f 	bl	800285c <Watering>
            break;
 8004f5e:	bf00      	nop
 8004f60:	e09f      	b.n	80050a2 <EXTI9_5_IRQHandler+0x2f2>

        default:
            break;
 8004f62:	e09e      	b.n	80050a2 <EXTI9_5_IRQHandler+0x2f2>
        }
    }

    else if(menu_current->designator > 0)
 8004f64:	4b2c      	ldr	r3, [pc, #176]	; (8005018 <EXTI9_5_IRQHandler+0x268>)
 8004f66:	681b      	ldr	r3, [r3, #0]
 8004f68:	791b      	ldrb	r3, [r3, #4]
 8004f6a:	2b00      	cmp	r3, #0
 8004f6c:	f000 8099 	beq.w	80050a2 <EXTI9_5_IRQHandler+0x2f2>
        {
            menu_current = menu_current->previous;
 8004f70:	4b29      	ldr	r3, [pc, #164]	; (8005018 <EXTI9_5_IRQHandler+0x268>)
 8004f72:	681b      	ldr	r3, [r3, #0]
 8004f74:	691a      	ldr	r2, [r3, #16]
 8004f76:	4b28      	ldr	r3, [pc, #160]	; (8005018 <EXTI9_5_IRQHandler+0x268>)
 8004f78:	601a      	str	r2, [r3, #0]
            if(menu_current->designator < menu_first->designator)
 8004f7a:	4b27      	ldr	r3, [pc, #156]	; (8005018 <EXTI9_5_IRQHandler+0x268>)
 8004f7c:	681b      	ldr	r3, [r3, #0]
 8004f7e:	791a      	ldrb	r2, [r3, #4]
 8004f80:	4b26      	ldr	r3, [pc, #152]	; (800501c <EXTI9_5_IRQHandler+0x26c>)
 8004f82:	681b      	ldr	r3, [r3, #0]
 8004f84:	791b      	ldrb	r3, [r3, #4]
 8004f86:	429a      	cmp	r2, r3
 8004f88:	d24e      	bcs.n	8005028 <EXTI9_5_IRQHandler+0x278>
            {
                Cursor(1,0);
 8004f8a:	f04f 0001 	mov.w	r0, #1
 8004f8e:	f04f 0100 	mov.w	r1, #0
 8004f92:	f7fb fb97 	bl	80006c4 <Cursor>
                StrAlign(menu_current->nev, temp, ALIGN_ARROW);
 8004f96:	4b20      	ldr	r3, [pc, #128]	; (8005018 <EXTI9_5_IRQHandler+0x268>)
 8004f98:	681b      	ldr	r3, [r3, #0]
 8004f9a:	681b      	ldr	r3, [r3, #0]
 8004f9c:	4618      	mov	r0, r3
 8004f9e:	4921      	ldr	r1, [pc, #132]	; (8005024 <EXTI9_5_IRQHandler+0x274>)
 8004fa0:	f04f 0204 	mov.w	r2, #4
 8004fa4:	f7fb fc5c 	bl	8000860 <StrAlign>
                PrintStr(temp);
 8004fa8:	481e      	ldr	r0, [pc, #120]	; (8005024 <EXTI9_5_IRQHandler+0x274>)
 8004faa:	f7fb fd99 	bl	8000ae0 <PrintStr>

                menu_temporary = menu_current->next;
 8004fae:	4b1a      	ldr	r3, [pc, #104]	; (8005018 <EXTI9_5_IRQHandler+0x268>)
 8004fb0:	681b      	ldr	r3, [r3, #0]
 8004fb2:	68da      	ldr	r2, [r3, #12]
 8004fb4:	4b1a      	ldr	r3, [pc, #104]	; (8005020 <EXTI9_5_IRQHandler+0x270>)
 8004fb6:	601a      	str	r2, [r3, #0]
                Cursor(2,0);
 8004fb8:	f04f 0002 	mov.w	r0, #2
 8004fbc:	f04f 0100 	mov.w	r1, #0
 8004fc0:	f7fb fb80 	bl	80006c4 <Cursor>
                StrAlign(menu_temporary->nev, temp, ALIGN_LEFT);
 8004fc4:	4b16      	ldr	r3, [pc, #88]	; (8005020 <EXTI9_5_IRQHandler+0x270>)
 8004fc6:	681b      	ldr	r3, [r3, #0]
 8004fc8:	681b      	ldr	r3, [r3, #0]
 8004fca:	4618      	mov	r0, r3
 8004fcc:	4915      	ldr	r1, [pc, #84]	; (8005024 <EXTI9_5_IRQHandler+0x274>)
 8004fce:	f04f 0201 	mov.w	r2, #1
 8004fd2:	f7fb fc45 	bl	8000860 <StrAlign>
                PrintStr(temp);
 8004fd6:	4813      	ldr	r0, [pc, #76]	; (8005024 <EXTI9_5_IRQHandler+0x274>)
 8004fd8:	f7fb fd82 	bl	8000ae0 <PrintStr>

                menu_temporary = menu_temporary->next;
 8004fdc:	4b10      	ldr	r3, [pc, #64]	; (8005020 <EXTI9_5_IRQHandler+0x270>)
 8004fde:	681b      	ldr	r3, [r3, #0]
 8004fe0:	68da      	ldr	r2, [r3, #12]
 8004fe2:	4b0f      	ldr	r3, [pc, #60]	; (8005020 <EXTI9_5_IRQHandler+0x270>)
 8004fe4:	601a      	str	r2, [r3, #0]
                Cursor(3,0);
 8004fe6:	f04f 0003 	mov.w	r0, #3
 8004fea:	f04f 0100 	mov.w	r1, #0
 8004fee:	f7fb fb69 	bl	80006c4 <Cursor>
                StrAlign(menu_temporary->nev, temp, ALIGN_LEFT);
 8004ff2:	4b0b      	ldr	r3, [pc, #44]	; (8005020 <EXTI9_5_IRQHandler+0x270>)
 8004ff4:	681b      	ldr	r3, [r3, #0]
 8004ff6:	681b      	ldr	r3, [r3, #0]
 8004ff8:	4618      	mov	r0, r3
 8004ffa:	490a      	ldr	r1, [pc, #40]	; (8005024 <EXTI9_5_IRQHandler+0x274>)
 8004ffc:	f04f 0201 	mov.w	r2, #1
 8005000:	f7fb fc2e 	bl	8000860 <StrAlign>
                PrintStr(temp);
 8005004:	4807      	ldr	r0, [pc, #28]	; (8005024 <EXTI9_5_IRQHandler+0x274>)
 8005006:	f7fb fd6b 	bl	8000ae0 <PrintStr>
                menu_first = menu_current;
 800500a:	4b03      	ldr	r3, [pc, #12]	; (8005018 <EXTI9_5_IRQHandler+0x268>)
 800500c:	681a      	ldr	r2, [r3, #0]
 800500e:	4b03      	ldr	r3, [pc, #12]	; (800501c <EXTI9_5_IRQHandler+0x26c>)
 8005010:	601a      	str	r2, [r3, #0]
 8005012:	e046      	b.n	80050a2 <EXTI9_5_IRQHandler+0x2f2>
 8005014:	20000e12 	.word	0x20000e12
 8005018:	2000124c 	.word	0x2000124c
 800501c:	20000d48 	.word	0x20000d48
 8005020:	20001310 	.word	0x20001310
 8005024:	20000fac 	.word	0x20000fac
            }
            else
            {
                Cursor(((menu_current->designator - menu_first->designator) + 1), 0);
 8005028:	4b20      	ldr	r3, [pc, #128]	; (80050ac <EXTI9_5_IRQHandler+0x2fc>)
 800502a:	681b      	ldr	r3, [r3, #0]
 800502c:	791a      	ldrb	r2, [r3, #4]
 800502e:	4b20      	ldr	r3, [pc, #128]	; (80050b0 <EXTI9_5_IRQHandler+0x300>)
 8005030:	681b      	ldr	r3, [r3, #0]
 8005032:	791b      	ldrb	r3, [r3, #4]
 8005034:	1ad3      	subs	r3, r2, r3
 8005036:	b2db      	uxtb	r3, r3
 8005038:	f103 0301 	add.w	r3, r3, #1
 800503c:	b2db      	uxtb	r3, r3
 800503e:	4618      	mov	r0, r3
 8005040:	f04f 0100 	mov.w	r1, #0
 8005044:	f7fb fb3e 	bl	80006c4 <Cursor>
                StrAlign(menu_current->nev, temp, ALIGN_ARROW);
 8005048:	4b18      	ldr	r3, [pc, #96]	; (80050ac <EXTI9_5_IRQHandler+0x2fc>)
 800504a:	681b      	ldr	r3, [r3, #0]
 800504c:	681b      	ldr	r3, [r3, #0]
 800504e:	4618      	mov	r0, r3
 8005050:	4918      	ldr	r1, [pc, #96]	; (80050b4 <EXTI9_5_IRQHandler+0x304>)
 8005052:	f04f 0204 	mov.w	r2, #4
 8005056:	f7fb fc03 	bl	8000860 <StrAlign>
                PrintStr(temp);
 800505a:	4816      	ldr	r0, [pc, #88]	; (80050b4 <EXTI9_5_IRQHandler+0x304>)
 800505c:	f7fb fd40 	bl	8000ae0 <PrintStr>

                menu_temporary = menu_current->next;
 8005060:	4b12      	ldr	r3, [pc, #72]	; (80050ac <EXTI9_5_IRQHandler+0x2fc>)
 8005062:	681b      	ldr	r3, [r3, #0]
 8005064:	68da      	ldr	r2, [r3, #12]
 8005066:	4b14      	ldr	r3, [pc, #80]	; (80050b8 <EXTI9_5_IRQHandler+0x308>)
 8005068:	601a      	str	r2, [r3, #0]
                Cursor(((menu_current->designator - menu_first->designator) + 2), 0);
 800506a:	4b10      	ldr	r3, [pc, #64]	; (80050ac <EXTI9_5_IRQHandler+0x2fc>)
 800506c:	681b      	ldr	r3, [r3, #0]
 800506e:	791a      	ldrb	r2, [r3, #4]
 8005070:	4b0f      	ldr	r3, [pc, #60]	; (80050b0 <EXTI9_5_IRQHandler+0x300>)
 8005072:	681b      	ldr	r3, [r3, #0]
 8005074:	791b      	ldrb	r3, [r3, #4]
 8005076:	1ad3      	subs	r3, r2, r3
 8005078:	b2db      	uxtb	r3, r3
 800507a:	f103 0302 	add.w	r3, r3, #2
 800507e:	b2db      	uxtb	r3, r3
 8005080:	4618      	mov	r0, r3
 8005082:	f04f 0100 	mov.w	r1, #0
 8005086:	f7fb fb1d 	bl	80006c4 <Cursor>
                StrAlign(menu_temporary->nev, temp, ALIGN_LEFT);
 800508a:	4b0b      	ldr	r3, [pc, #44]	; (80050b8 <EXTI9_5_IRQHandler+0x308>)
 800508c:	681b      	ldr	r3, [r3, #0]
 800508e:	681b      	ldr	r3, [r3, #0]
 8005090:	4618      	mov	r0, r3
 8005092:	4908      	ldr	r1, [pc, #32]	; (80050b4 <EXTI9_5_IRQHandler+0x304>)
 8005094:	f04f 0201 	mov.w	r2, #1
 8005098:	f7fb fbe2 	bl	8000860 <StrAlign>
                PrintStr(temp);
 800509c:	4805      	ldr	r0, [pc, #20]	; (80050b4 <EXTI9_5_IRQHandler+0x304>)
 800509e:	f7fb fd1f 	bl	8000ae0 <PrintStr>
            }
        }
        EXTI_ClearITPendingBit(EXTI_Line7);
 80050a2:	f04f 0080 	mov.w	r0, #128	; 0x80
 80050a6:	f001 fdc1 	bl	8006c2c <EXTI_ClearITPendingBit>
}
}
 80050aa:	bd80      	pop	{r7, pc}
 80050ac:	2000124c 	.word	0x2000124c
 80050b0:	20000d48 	.word	0x20000d48
 80050b4:	20000fac 	.word	0x20000fac
 80050b8:	20001310 	.word	0x20001310

080050bc <EXTI3_IRQHandler>:


//******************************************RENOVÁLÁS ALATT!!**************************************************

void EXTI3_IRQHandler(void)
{
 80050bc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80050be:	b08b      	sub	sp, #44	; 0x2c
 80050c0:	af0a      	add	r7, sp, #40	; 0x28
    if ( EXTI_GetITStatus(EXTI_Line3))
 80050c2:	f04f 0008 	mov.w	r0, #8
 80050c6:	f001 fd89 	bl	8006bdc <EXTI_GetITStatus>
 80050ca:	4603      	mov	r3, r0
 80050cc:	2b00      	cmp	r3, #0
 80050ce:	f000 8104 	beq.w	80052da <EXTI3_IRQHandler+0x21e>
    {
        //*******************************RENOVÁLÁS ALATT******************
        if(menu_special_function)
 80050d2:	4b86      	ldr	r3, [pc, #536]	; (80052ec <EXTI3_IRQHandler+0x230>)
 80050d4:	781b      	ldrb	r3, [r3, #0]
 80050d6:	2b00      	cmp	r3, #0
 80050d8:	d012      	beq.n	8005100 <EXTI3_IRQHandler+0x44>
        {
            switch(menu_special_function)
 80050da:	4b84      	ldr	r3, [pc, #528]	; (80052ec <EXTI3_IRQHandler+0x230>)
 80050dc:	781b      	ldrb	r3, [r3, #0]
 80050de:	2b01      	cmp	r3, #1
 80050e0:	d002      	beq.n	80050e8 <EXTI3_IRQHandler+0x2c>
 80050e2:	2b02      	cmp	r3, #2
 80050e4:	d005      	beq.n	80050f2 <EXTI3_IRQHandler+0x36>
 80050e6:	e00a      	b.n	80050fe <EXTI3_IRQHandler+0x42>
            {
            case MENU_SPECIAL_FUNCTION_TIME_DATE:
                DateChanger(MENU_ENTER);
 80050e8:	f04f 0009 	mov.w	r0, #9
 80050ec:	f7fc fea8 	bl	8001e40 <DateChanger>
                break;
 80050f0:	e0f3      	b.n	80052da <EXTI3_IRQHandler+0x21e>
            case MENU_SPECIAL_FUNCTION_ONTOZES:
                Watering(MENU_ENTER);
 80050f2:	f04f 0009 	mov.w	r0, #9
 80050f6:	f7fd fbb1 	bl	800285c <Watering>
                break;
 80050fa:	bf00      	nop
 80050fc:	e0ed      	b.n	80052da <EXTI3_IRQHandler+0x21e>

            default:
                break;
 80050fe:	e0ec      	b.n	80052da <EXTI3_IRQHandler+0x21e>
            }
        }

        //*******************************RENOVÁLÁS ALATT******************

        else if(menu_current->down && (menu_level < MENU_LEVEL_MAX))                    //1. eset: Van az adott menüpontnak alpontja
 8005100:	4b7b      	ldr	r3, [pc, #492]	; (80052f0 <EXTI3_IRQHandler+0x234>)
 8005102:	681b      	ldr	r3, [r3, #0]
 8005104:	699b      	ldr	r3, [r3, #24]
 8005106:	2b00      	cmp	r3, #0
 8005108:	f000 8097 	beq.w	800523a <EXTI3_IRQHandler+0x17e>
 800510c:	4b79      	ldr	r3, [pc, #484]	; (80052f4 <EXTI3_IRQHandler+0x238>)
 800510e:	781b      	ldrb	r3, [r3, #0]
 8005110:	2b04      	cmp	r3, #4
 8005112:	f200 8092 	bhi.w	800523a <EXTI3_IRQHandler+0x17e>
        {
            ClearLcmScreen();
 8005116:	f7fb fb0d 	bl	8000734 <ClearLcmScreen>

            Cursor(0,0);
 800511a:	f04f 0000 	mov.w	r0, #0
 800511e:	f04f 0100 	mov.w	r1, #0
 8005122:	f7fb facf 	bl	80006c4 <Cursor>
            StrAlign(menu_current->nev, temp, ALIGN_CENTER);
 8005126:	4b72      	ldr	r3, [pc, #456]	; (80052f0 <EXTI3_IRQHandler+0x234>)
 8005128:	681b      	ldr	r3, [r3, #0]
 800512a:	681b      	ldr	r3, [r3, #0]
 800512c:	4618      	mov	r0, r3
 800512e:	4972      	ldr	r1, [pc, #456]	; (80052f8 <EXTI3_IRQHandler+0x23c>)
 8005130:	f04f 0203 	mov.w	r2, #3
 8005134:	f7fb fb94 	bl	8000860 <StrAlign>
            PrintStr(temp);
 8005138:	486f      	ldr	r0, [pc, #444]	; (80052f8 <EXTI3_IRQHandler+0x23c>)
 800513a:	f7fb fcd1 	bl	8000ae0 <PrintStr>

            menu_temporary = menu_current->down;
 800513e:	4b6c      	ldr	r3, [pc, #432]	; (80052f0 <EXTI3_IRQHandler+0x234>)
 8005140:	681b      	ldr	r3, [r3, #0]
 8005142:	699a      	ldr	r2, [r3, #24]
 8005144:	4b6d      	ldr	r3, [pc, #436]	; (80052fc <EXTI3_IRQHandler+0x240>)
 8005146:	601a      	str	r2, [r3, #0]
            Cursor(1,0);
 8005148:	f04f 0001 	mov.w	r0, #1
 800514c:	f04f 0100 	mov.w	r1, #0
 8005150:	f7fb fab8 	bl	80006c4 <Cursor>
            StrAlign(menu_temporary->nev, temp, ALIGN_ARROW);
 8005154:	4b69      	ldr	r3, [pc, #420]	; (80052fc <EXTI3_IRQHandler+0x240>)
 8005156:	681b      	ldr	r3, [r3, #0]
 8005158:	681b      	ldr	r3, [r3, #0]
 800515a:	4618      	mov	r0, r3
 800515c:	4966      	ldr	r1, [pc, #408]	; (80052f8 <EXTI3_IRQHandler+0x23c>)
 800515e:	f04f 0204 	mov.w	r2, #4
 8005162:	f7fb fb7d 	bl	8000860 <StrAlign>
            PrintStr(temp);
 8005166:	4864      	ldr	r0, [pc, #400]	; (80052f8 <EXTI3_IRQHandler+0x23c>)
 8005168:	f7fb fcba 	bl	8000ae0 <PrintStr>

            if(menu_temporary->next)
 800516c:	4b63      	ldr	r3, [pc, #396]	; (80052fc <EXTI3_IRQHandler+0x240>)
 800516e:	681b      	ldr	r3, [r3, #0]
 8005170:	68db      	ldr	r3, [r3, #12]
 8005172:	2b00      	cmp	r3, #0
 8005174:	d026      	beq.n	80051c4 <EXTI3_IRQHandler+0x108>
            {
                menu_temporary = menu_temporary->next;
 8005176:	4b61      	ldr	r3, [pc, #388]	; (80052fc <EXTI3_IRQHandler+0x240>)
 8005178:	681b      	ldr	r3, [r3, #0]
 800517a:	68da      	ldr	r2, [r3, #12]
 800517c:	4b5f      	ldr	r3, [pc, #380]	; (80052fc <EXTI3_IRQHandler+0x240>)
 800517e:	601a      	str	r2, [r3, #0]
                Cursor(2,0);
 8005180:	f04f 0002 	mov.w	r0, #2
 8005184:	f04f 0100 	mov.w	r1, #0
 8005188:	f7fb fa9c 	bl	80006c4 <Cursor>
                PrintStr(menu_temporary->nev);
 800518c:	4b5b      	ldr	r3, [pc, #364]	; (80052fc <EXTI3_IRQHandler+0x240>)
 800518e:	681b      	ldr	r3, [r3, #0]
 8005190:	681b      	ldr	r3, [r3, #0]
 8005192:	4618      	mov	r0, r3
 8005194:	f7fb fca4 	bl	8000ae0 <PrintStr>

                if(menu_temporary->next)
 8005198:	4b58      	ldr	r3, [pc, #352]	; (80052fc <EXTI3_IRQHandler+0x240>)
 800519a:	681b      	ldr	r3, [r3, #0]
 800519c:	68db      	ldr	r3, [r3, #12]
 800519e:	2b00      	cmp	r3, #0
 80051a0:	d010      	beq.n	80051c4 <EXTI3_IRQHandler+0x108>
                {
                    menu_temporary = menu_temporary->next;
 80051a2:	4b56      	ldr	r3, [pc, #344]	; (80052fc <EXTI3_IRQHandler+0x240>)
 80051a4:	681b      	ldr	r3, [r3, #0]
 80051a6:	68da      	ldr	r2, [r3, #12]
 80051a8:	4b54      	ldr	r3, [pc, #336]	; (80052fc <EXTI3_IRQHandler+0x240>)
 80051aa:	601a      	str	r2, [r3, #0]
                    Cursor(3,0);
 80051ac:	f04f 0003 	mov.w	r0, #3
 80051b0:	f04f 0100 	mov.w	r1, #0
 80051b4:	f7fb fa86 	bl	80006c4 <Cursor>
                    PrintStr(menu_temporary->nev);
 80051b8:	4b50      	ldr	r3, [pc, #320]	; (80052fc <EXTI3_IRQHandler+0x240>)
 80051ba:	681b      	ldr	r3, [r3, #0]
 80051bc:	681b      	ldr	r3, [r3, #0]
 80051be:	4618      	mov	r0, r3
 80051c0:	f7fb fc8e 	bl	8000ae0 <PrintStr>
                }
            }

            menu_level_first[menu_level] = *menu_first;
 80051c4:	4b4b      	ldr	r3, [pc, #300]	; (80052f4 <EXTI3_IRQHandler+0x238>)
 80051c6:	781b      	ldrb	r3, [r3, #0]
 80051c8:	461a      	mov	r2, r3
 80051ca:	4b4d      	ldr	r3, [pc, #308]	; (8005300 <EXTI3_IRQHandler+0x244>)
 80051cc:	6819      	ldr	r1, [r3, #0]
 80051ce:	484d      	ldr	r0, [pc, #308]	; (8005304 <EXTI3_IRQHandler+0x248>)
 80051d0:	4613      	mov	r3, r2
 80051d2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80051d6:	1a9b      	subs	r3, r3, r2
 80051d8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80051dc:	18c3      	adds	r3, r0, r3
 80051de:	461c      	mov	r4, r3
 80051e0:	460d      	mov	r5, r1
 80051e2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80051e4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80051e6:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 80051ea:	e884 0007 	stmia.w	r4, {r0, r1, r2}
            menu_level_current[menu_level] = *menu_current;
 80051ee:	4b41      	ldr	r3, [pc, #260]	; (80052f4 <EXTI3_IRQHandler+0x238>)
 80051f0:	781b      	ldrb	r3, [r3, #0]
 80051f2:	461a      	mov	r2, r3
 80051f4:	4b3e      	ldr	r3, [pc, #248]	; (80052f0 <EXTI3_IRQHandler+0x234>)
 80051f6:	6819      	ldr	r1, [r3, #0]
 80051f8:	4843      	ldr	r0, [pc, #268]	; (8005308 <EXTI3_IRQHandler+0x24c>)
 80051fa:	4613      	mov	r3, r2
 80051fc:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8005200:	1a9b      	subs	r3, r3, r2
 8005202:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005206:	18c3      	adds	r3, r0, r3
 8005208:	461c      	mov	r4, r3
 800520a:	460d      	mov	r5, r1
 800520c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800520e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8005210:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8005214:	e884 0007 	stmia.w	r4, {r0, r1, r2}
            menu_first = menu_current = menu_current->down;     //Az almenü elsõ pontjára állítom az almenü aktuálisan kiválasztott változóját.
 8005218:	4b35      	ldr	r3, [pc, #212]	; (80052f0 <EXTI3_IRQHandler+0x234>)
 800521a:	681b      	ldr	r3, [r3, #0]
 800521c:	699a      	ldr	r2, [r3, #24]
 800521e:	4b34      	ldr	r3, [pc, #208]	; (80052f0 <EXTI3_IRQHandler+0x234>)
 8005220:	601a      	str	r2, [r3, #0]
 8005222:	4b33      	ldr	r3, [pc, #204]	; (80052f0 <EXTI3_IRQHandler+0x234>)
 8005224:	681a      	ldr	r2, [r3, #0]
 8005226:	4b36      	ldr	r3, [pc, #216]	; (8005300 <EXTI3_IRQHandler+0x244>)
 8005228:	601a      	str	r2, [r3, #0]
            menu_level++;                                           //Egy jelzõ karakter, ami azt mutatja, hogy éppen egy almenüben vagyunk
 800522a:	4b32      	ldr	r3, [pc, #200]	; (80052f4 <EXTI3_IRQHandler+0x238>)
 800522c:	781b      	ldrb	r3, [r3, #0]
 800522e:	f103 0301 	add.w	r3, r3, #1
 8005232:	b2da      	uxtb	r2, r3
 8005234:	4b2f      	ldr	r3, [pc, #188]	; (80052f4 <EXTI3_IRQHandler+0x238>)
 8005236:	701a      	strb	r2, [r3, #0]
 8005238:	e04f      	b.n	80052da <EXTI3_IRQHandler+0x21e>
        }

        //********************************************************RENOVÁLÁS ALATT******************

        else if((menu_level != 0) && (menu_current->designator == 0))   //3. eset:  Ha vissza akarok lépni egy alpontból
 800523a:	4b2e      	ldr	r3, [pc, #184]	; (80052f4 <EXTI3_IRQHandler+0x238>)
 800523c:	781b      	ldrb	r3, [r3, #0]
 800523e:	2b00      	cmp	r3, #0
 8005240:	d03e      	beq.n	80052c0 <EXTI3_IRQHandler+0x204>
 8005242:	4b2b      	ldr	r3, [pc, #172]	; (80052f0 <EXTI3_IRQHandler+0x234>)
 8005244:	681b      	ldr	r3, [r3, #0]
 8005246:	791b      	ldrb	r3, [r3, #4]
 8005248:	2b00      	cmp	r3, #0
 800524a:	d139      	bne.n	80052c0 <EXTI3_IRQHandler+0x204>
        {
            /* Úgy látom, hogy kell egy új változót, egy chart bevezetni, ami arra szolgál, hogy elmentem az almenüpontba lépéskor, hogy az
            almenüpont hányadik sorban van a kijelzõn. Ezzel azt csinálom, hogy ahmikor vissza akarok lépni a fõmenübe, ugyan az lesz a fõmenû
            képernyõjének az állása, mint az almenübe lépéskor.*/
            ClearLcmScreen();
 800524c:	f7fb fa72 	bl	8000734 <ClearLcmScreen>

            menu_level--;
 8005250:	4b28      	ldr	r3, [pc, #160]	; (80052f4 <EXTI3_IRQHandler+0x238>)
 8005252:	781b      	ldrb	r3, [r3, #0]
 8005254:	f103 33ff 	add.w	r3, r3, #4294967295
 8005258:	b2da      	uxtb	r2, r3
 800525a:	4b26      	ldr	r3, [pc, #152]	; (80052f4 <EXTI3_IRQHandler+0x238>)
 800525c:	701a      	strb	r2, [r3, #0]
            menu_current = &menu_level_current[menu_level];
 800525e:	4b25      	ldr	r3, [pc, #148]	; (80052f4 <EXTI3_IRQHandler+0x238>)
 8005260:	781b      	ldrb	r3, [r3, #0]
 8005262:	461a      	mov	r2, r3
 8005264:	4613      	mov	r3, r2
 8005266:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800526a:	1a9b      	subs	r3, r3, r2
 800526c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005270:	4a25      	ldr	r2, [pc, #148]	; (8005308 <EXTI3_IRQHandler+0x24c>)
 8005272:	189a      	adds	r2, r3, r2
 8005274:	4b1e      	ldr	r3, [pc, #120]	; (80052f0 <EXTI3_IRQHandler+0x234>)
 8005276:	601a      	str	r2, [r3, #0]
            menu_first = &menu_level_first[menu_level];
 8005278:	4b1e      	ldr	r3, [pc, #120]	; (80052f4 <EXTI3_IRQHandler+0x238>)
 800527a:	781b      	ldrb	r3, [r3, #0]
 800527c:	461a      	mov	r2, r3
 800527e:	4613      	mov	r3, r2
 8005280:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8005284:	1a9b      	subs	r3, r3, r2
 8005286:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800528a:	4a1e      	ldr	r2, [pc, #120]	; (8005304 <EXTI3_IRQHandler+0x248>)
 800528c:	189a      	adds	r2, r3, r2
 800528e:	4b1c      	ldr	r3, [pc, #112]	; (8005300 <EXTI3_IRQHandler+0x244>)
 8005290:	601a      	str	r2, [r3, #0]

            DisplayFill(*menu_current, *menu_first);
 8005292:	4b17      	ldr	r3, [pc, #92]	; (80052f0 <EXTI3_IRQHandler+0x234>)
 8005294:	681e      	ldr	r6, [r3, #0]
 8005296:	4b1a      	ldr	r3, [pc, #104]	; (8005300 <EXTI3_IRQHandler+0x244>)
 8005298:	681b      	ldr	r3, [r3, #0]
 800529a:	ad03      	add	r5, sp, #12
 800529c:	461c      	mov	r4, r3
 800529e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80052a0:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80052a2:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 80052a6:	e885 0007 	stmia.w	r5, {r0, r1, r2}
 80052aa:	466b      	mov	r3, sp
 80052ac:	f106 0210 	add.w	r2, r6, #16
 80052b0:	ca07      	ldmia	r2, {r0, r1, r2}
 80052b2:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 80052b6:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 80052ba:	f7fb fc93 	bl	8000be4 <DisplayFill>
 80052be:	e00c      	b.n	80052da <EXTI3_IRQHandler+0x21e>
        }
        //***************************************************************************RENOVÁLÁS ALATT******************
        else if(menu_current->fgvnev != 0)                          //2. eset: Ha a menüpont kiválasztásával egy függvényt akarunk lefuttatni.
 80052c0:	4b0b      	ldr	r3, [pc, #44]	; (80052f0 <EXTI3_IRQHandler+0x234>)
 80052c2:	681b      	ldr	r3, [r3, #0]
 80052c4:	689b      	ldr	r3, [r3, #8]
 80052c6:	2b00      	cmp	r3, #0
 80052c8:	d007      	beq.n	80052da <EXTI3_IRQHandler+0x21e>
        {
            menu_current->fgvnev(menu_current->designator);
 80052ca:	4b09      	ldr	r3, [pc, #36]	; (80052f0 <EXTI3_IRQHandler+0x234>)
 80052cc:	681b      	ldr	r3, [r3, #0]
 80052ce:	689b      	ldr	r3, [r3, #8]
 80052d0:	4a07      	ldr	r2, [pc, #28]	; (80052f0 <EXTI3_IRQHandler+0x234>)
 80052d2:	6812      	ldr	r2, [r2, #0]
 80052d4:	7912      	ldrb	r2, [r2, #4]
 80052d6:	4610      	mov	r0, r2
 80052d8:	4798      	blx	r3
        }
    }

    EXTI_ClearITPendingBit(EXTI_Line3);
 80052da:	f04f 0008 	mov.w	r0, #8
 80052de:	f001 fca5 	bl	8006c2c <EXTI_ClearITPendingBit>
}
 80052e2:	f107 0704 	add.w	r7, r7, #4
 80052e6:	46bd      	mov	sp, r7
 80052e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80052ea:	bf00      	nop
 80052ec:	20000e12 	.word	0x20000e12
 80052f0:	2000124c 	.word	0x2000124c
 80052f4:	2000130e 	.word	0x2000130e
 80052f8:	20000fac 	.word	0x20000fac
 80052fc:	20001310 	.word	0x20001310
 8005300:	20000d48 	.word	0x20000d48
 8005304:	20000eb8 	.word	0x20000eb8
 8005308:	20001054 	.word	0x20001054

0800530c <EXTI2_IRQHandler>:


//                  Input 4 interrupt kezelõ függvénye

void EXTI2_IRQHandler(void)
{
 800530c:	b580      	push	{r7, lr}
 800530e:	af00      	add	r7, sp, #0
    if ( EXTI_GetITStatus(EXTI_Line2))
 8005310:	f04f 0004 	mov.w	r0, #4
 8005314:	f001 fc62 	bl	8006bdc <EXTI_GetITStatus>
    {

    }

    EXTI_ClearITPendingBit(EXTI_Line2);
 8005318:	f04f 0004 	mov.w	r0, #4
 800531c:	f001 fc86 	bl	8006c2c <EXTI_ClearITPendingBit>
}
 8005320:	bd80      	pop	{r7, pc}
 8005322:	bf00      	nop

08005324 <EXTI1_IRQHandler>:

//                  Input 5 interrupt kezelõ függvénye

void EXTI1_IRQHandler(void)
{
 8005324:	b580      	push	{r7, lr}
 8005326:	af00      	add	r7, sp, #0
    if ( EXTI_GetITStatus(EXTI_Line1))
 8005328:	f04f 0002 	mov.w	r0, #2
 800532c:	f001 fc56 	bl	8006bdc <EXTI_GetITStatus>
    {

    }

    EXTI_ClearITPendingBit(EXTI_Line1);
 8005330:	f04f 0002 	mov.w	r0, #2
 8005334:	f001 fc7a 	bl	8006c2c <EXTI_ClearITPendingBit>
}
 8005338:	bd80      	pop	{r7, pc}
 800533a:	bf00      	nop

0800533c <EXTI0_IRQHandler>:

//                  Input 6 interrupt kezelõ függvénye

void EXTI0_IRQHandler(void)
{
 800533c:	b580      	push	{r7, lr}
 800533e:	af00      	add	r7, sp, #0
    if ( EXTI_GetITStatus(EXTI_Line0))
 8005340:	f04f 0001 	mov.w	r0, #1
 8005344:	f001 fc4a 	bl	8006bdc <EXTI_GetITStatus>
    {

    }

    EXTI_ClearITPendingBit(EXTI_Line0);
 8005348:	f04f 0001 	mov.w	r0, #1
 800534c:	f001 fc6e 	bl	8006c2c <EXTI_ClearITPendingBit>
}
 8005350:	bd80      	pop	{r7, pc}
 8005352:	bf00      	nop

08005354 <SystemInit>:
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8005354:	b580      	push	{r7, lr}
 8005356:	af00      	add	r7, sp, #0
	SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8005358:	4b12      	ldr	r3, [pc, #72]	; (80053a4 <SystemInit+0x50>)
 800535a:	4a12      	ldr	r2, [pc, #72]	; (80053a4 <SystemInit+0x50>)
 800535c:	6812      	ldr	r2, [r2, #0]
 800535e:	f042 0201 	orr.w	r2, r2, #1
 8005362:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8005364:	4b0f      	ldr	r3, [pc, #60]	; (80053a4 <SystemInit+0x50>)
 8005366:	f04f 0200 	mov.w	r2, #0
 800536a:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 800536c:	4a0d      	ldr	r2, [pc, #52]	; (80053a4 <SystemInit+0x50>)
 800536e:	4b0d      	ldr	r3, [pc, #52]	; (80053a4 <SystemInit+0x50>)
 8005370:	681b      	ldr	r3, [r3, #0]
 8005372:	f023 7384 	bic.w	r3, r3, #17301504	; 0x1080000
 8005376:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800537a:	6013      	str	r3, [r2, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 800537c:	4b09      	ldr	r3, [pc, #36]	; (80053a4 <SystemInit+0x50>)
 800537e:	4a0a      	ldr	r2, [pc, #40]	; (80053a8 <SystemInit+0x54>)
 8005380:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8005382:	4b08      	ldr	r3, [pc, #32]	; (80053a4 <SystemInit+0x50>)
 8005384:	4a07      	ldr	r2, [pc, #28]	; (80053a4 <SystemInit+0x50>)
 8005386:	6812      	ldr	r2, [r2, #0]
 8005388:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800538c:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 800538e:	4b05      	ldr	r3, [pc, #20]	; (80053a4 <SystemInit+0x50>)
 8005390:	f04f 0200 	mov.w	r2, #0
 8005394:	60da      	str	r2, [r3, #12]
  SystemInit_ExtMemCtl(); 
#endif /* DATA_IN_ExtSRAM */
         
  /* Configure the System clock source, PLL Multiplier and Divider factors, 
     AHB/APBx prescalers and Flash settings ----------------------------------*/
  SetSysClock();
 8005396:	f000 f893 	bl	80054c0 <SetSysClock>

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800539a:	4b04      	ldr	r3, [pc, #16]	; (80053ac <SystemInit+0x58>)
 800539c:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80053a0:	609a      	str	r2, [r3, #8]
#endif
}
 80053a2:	bd80      	pop	{r7, pc}
 80053a4:	40023800 	.word	0x40023800
 80053a8:	24003010 	.word	0x24003010
 80053ac:	e000ed00 	.word	0xe000ed00

080053b0 <SystemCoreClockUpdate>:
  *     
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
 80053b0:	b480      	push	{r7}
 80053b2:	b087      	sub	sp, #28
 80053b4:	af00      	add	r7, sp, #0
  uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
 80053b6:	f04f 0300 	mov.w	r3, #0
 80053ba:	613b      	str	r3, [r7, #16]
 80053bc:	f04f 0300 	mov.w	r3, #0
 80053c0:	617b      	str	r3, [r7, #20]
 80053c2:	f04f 0302 	mov.w	r3, #2
 80053c6:	60fb      	str	r3, [r7, #12]
 80053c8:	f04f 0300 	mov.w	r3, #0
 80053cc:	60bb      	str	r3, [r7, #8]
 80053ce:	f04f 0302 	mov.w	r3, #2
 80053d2:	607b      	str	r3, [r7, #4]
  
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 80053d4:	4b35      	ldr	r3, [pc, #212]	; (80054ac <SystemCoreClockUpdate+0xfc>)
 80053d6:	689b      	ldr	r3, [r3, #8]
 80053d8:	f003 030c 	and.w	r3, r3, #12
 80053dc:	613b      	str	r3, [r7, #16]

  switch (tmp)
 80053de:	693b      	ldr	r3, [r7, #16]
 80053e0:	2b04      	cmp	r3, #4
 80053e2:	d007      	beq.n	80053f4 <SystemCoreClockUpdate+0x44>
 80053e4:	2b08      	cmp	r3, #8
 80053e6:	d009      	beq.n	80053fc <SystemCoreClockUpdate+0x4c>
 80053e8:	2b00      	cmp	r3, #0
 80053ea:	d145      	bne.n	8005478 <SystemCoreClockUpdate+0xc8>
  {
    case 0x00:  /* HSI used as system clock source */
      SystemCoreClock = HSI_VALUE;
 80053ec:	4b30      	ldr	r3, [pc, #192]	; (80054b0 <SystemCoreClockUpdate+0x100>)
 80053ee:	4a31      	ldr	r2, [pc, #196]	; (80054b4 <SystemCoreClockUpdate+0x104>)
 80053f0:	601a      	str	r2, [r3, #0]
      break;
 80053f2:	e045      	b.n	8005480 <SystemCoreClockUpdate+0xd0>
    case 0x04:  /* HSE used as system clock source */
      SystemCoreClock = HSE_VALUE;
 80053f4:	4b2e      	ldr	r3, [pc, #184]	; (80054b0 <SystemCoreClockUpdate+0x100>)
 80053f6:	4a30      	ldr	r2, [pc, #192]	; (80054b8 <SystemCoreClockUpdate+0x108>)
 80053f8:	601a      	str	r2, [r3, #0]
      break;
 80053fa:	e041      	b.n	8005480 <SystemCoreClockUpdate+0xd0>
    case 0x08:  /* PLL used as system clock source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
         SYSCLK = PLL_VCO / PLL_P
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 80053fc:	4b2b      	ldr	r3, [pc, #172]	; (80054ac <SystemCoreClockUpdate+0xfc>)
 80053fe:	685b      	ldr	r3, [r3, #4]
 8005400:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8005404:	ea4f 5393 	mov.w	r3, r3, lsr #22
 8005408:	60bb      	str	r3, [r7, #8]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800540a:	4b28      	ldr	r3, [pc, #160]	; (80054ac <SystemCoreClockUpdate+0xfc>)
 800540c:	685b      	ldr	r3, [r3, #4]
 800540e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8005412:	607b      	str	r3, [r7, #4]
      
      if (pllsource != 0)
 8005414:	68bb      	ldr	r3, [r7, #8]
 8005416:	2b00      	cmp	r3, #0
 8005418:	d00e      	beq.n	8005438 <SystemCoreClockUpdate+0x88>
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 800541a:	4a27      	ldr	r2, [pc, #156]	; (80054b8 <SystemCoreClockUpdate+0x108>)
 800541c:	687b      	ldr	r3, [r7, #4]
 800541e:	fbb2 f2f3 	udiv	r2, r2, r3
 8005422:	4b22      	ldr	r3, [pc, #136]	; (80054ac <SystemCoreClockUpdate+0xfc>)
 8005424:	6859      	ldr	r1, [r3, #4]
 8005426:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 800542a:	400b      	ands	r3, r1
 800542c:	ea4f 1393 	mov.w	r3, r3, lsr #6
 8005430:	fb03 f302 	mul.w	r3, r3, r2
 8005434:	617b      	str	r3, [r7, #20]
 8005436:	e00d      	b.n	8005454 <SystemCoreClockUpdate+0xa4>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 8005438:	4a1e      	ldr	r2, [pc, #120]	; (80054b4 <SystemCoreClockUpdate+0x104>)
 800543a:	687b      	ldr	r3, [r7, #4]
 800543c:	fbb2 f2f3 	udiv	r2, r2, r3
 8005440:	4b1a      	ldr	r3, [pc, #104]	; (80054ac <SystemCoreClockUpdate+0xfc>)
 8005442:	6859      	ldr	r1, [r3, #4]
 8005444:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8005448:	400b      	ands	r3, r1
 800544a:	ea4f 1393 	mov.w	r3, r3, lsr #6
 800544e:	fb03 f302 	mul.w	r3, r3, r2
 8005452:	617b      	str	r3, [r7, #20]
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8005454:	4b15      	ldr	r3, [pc, #84]	; (80054ac <SystemCoreClockUpdate+0xfc>)
 8005456:	685b      	ldr	r3, [r3, #4]
 8005458:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 800545c:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8005460:	f103 0301 	add.w	r3, r3, #1
 8005464:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8005468:	60fb      	str	r3, [r7, #12]
      SystemCoreClock = pllvco/pllp;
 800546a:	697a      	ldr	r2, [r7, #20]
 800546c:	68fb      	ldr	r3, [r7, #12]
 800546e:	fbb2 f2f3 	udiv	r2, r2, r3
 8005472:	4b0f      	ldr	r3, [pc, #60]	; (80054b0 <SystemCoreClockUpdate+0x100>)
 8005474:	601a      	str	r2, [r3, #0]
      break;
 8005476:	e003      	b.n	8005480 <SystemCoreClockUpdate+0xd0>
    default:
      SystemCoreClock = HSI_VALUE;
 8005478:	4b0d      	ldr	r3, [pc, #52]	; (80054b0 <SystemCoreClockUpdate+0x100>)
 800547a:	4a0e      	ldr	r2, [pc, #56]	; (80054b4 <SystemCoreClockUpdate+0x104>)
 800547c:	601a      	str	r2, [r3, #0]
      break;
 800547e:	bf00      	nop
  }
  /* Compute HCLK frequency --------------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 8005480:	4b0a      	ldr	r3, [pc, #40]	; (80054ac <SystemCoreClockUpdate+0xfc>)
 8005482:	689b      	ldr	r3, [r3, #8]
 8005484:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8005488:	ea4f 1313 	mov.w	r3, r3, lsr #4
 800548c:	4a0b      	ldr	r2, [pc, #44]	; (80054bc <SystemCoreClockUpdate+0x10c>)
 800548e:	5cd3      	ldrb	r3, [r2, r3]
 8005490:	b2db      	uxtb	r3, r3
 8005492:	613b      	str	r3, [r7, #16]
  /* HCLK frequency */
  SystemCoreClock >>= tmp;
 8005494:	4b06      	ldr	r3, [pc, #24]	; (80054b0 <SystemCoreClockUpdate+0x100>)
 8005496:	681a      	ldr	r2, [r3, #0]
 8005498:	693b      	ldr	r3, [r7, #16]
 800549a:	fa22 f203 	lsr.w	r2, r2, r3
 800549e:	4b04      	ldr	r3, [pc, #16]	; (80054b0 <SystemCoreClockUpdate+0x100>)
 80054a0:	601a      	str	r2, [r3, #0]
}
 80054a2:	f107 071c 	add.w	r7, r7, #28
 80054a6:	46bd      	mov	sp, r7
 80054a8:	bc80      	pop	{r7}
 80054aa:	4770      	bx	lr
 80054ac:	40023800 	.word	0x40023800
 80054b0:	20000014 	.word	0x20000014
 80054b4:	00f42400 	.word	0x00f42400
 80054b8:	017d7840 	.word	0x017d7840
 80054bc:	20000018 	.word	0x20000018

080054c0 <SetSysClock>:
  *         is reset to the default reset state (done in SystemInit() function).   
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
 80054c0:	b480      	push	{r7}
 80054c2:	b083      	sub	sp, #12
 80054c4:	af00      	add	r7, sp, #0
/******************************************************************************/
/*            PLL (clocked by HSE) used as System clock source                */
/******************************************************************************/
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 80054c6:	f04f 0300 	mov.w	r3, #0
 80054ca:	607b      	str	r3, [r7, #4]
 80054cc:	f04f 0300 	mov.w	r3, #0
 80054d0:	603b      	str	r3, [r7, #0]
  
  /* Enable HSE */
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 80054d2:	4b37      	ldr	r3, [pc, #220]	; (80055b0 <SetSysClock+0xf0>)
 80054d4:	4a36      	ldr	r2, [pc, #216]	; (80055b0 <SetSysClock+0xf0>)
 80054d6:	6812      	ldr	r2, [r2, #0]
 80054d8:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80054dc:	601a      	str	r2, [r3, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 80054de:	4b34      	ldr	r3, [pc, #208]	; (80055b0 <SetSysClock+0xf0>)
 80054e0:	681b      	ldr	r3, [r3, #0]
 80054e2:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80054e6:	603b      	str	r3, [r7, #0]
    StartUpCounter++;
 80054e8:	687b      	ldr	r3, [r7, #4]
 80054ea:	f103 0301 	add.w	r3, r3, #1
 80054ee:	607b      	str	r3, [r7, #4]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 80054f0:	683b      	ldr	r3, [r7, #0]
 80054f2:	2b00      	cmp	r3, #0
 80054f4:	d103      	bne.n	80054fe <SetSysClock+0x3e>
 80054f6:	687b      	ldr	r3, [r7, #4]
 80054f8:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 80054fc:	d1ef      	bne.n	80054de <SetSysClock+0x1e>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 80054fe:	4b2c      	ldr	r3, [pc, #176]	; (80055b0 <SetSysClock+0xf0>)
 8005500:	681b      	ldr	r3, [r3, #0]
 8005502:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8005506:	2b00      	cmp	r3, #0
 8005508:	d003      	beq.n	8005512 <SetSysClock+0x52>
  {
    HSEStatus = (uint32_t)0x01;
 800550a:	f04f 0301 	mov.w	r3, #1
 800550e:	603b      	str	r3, [r7, #0]
 8005510:	e002      	b.n	8005518 <SetSysClock+0x58>
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 8005512:	f04f 0300 	mov.w	r3, #0
 8005516:	603b      	str	r3, [r7, #0]
  }

  if (HSEStatus == (uint32_t)0x01)
 8005518:	683b      	ldr	r3, [r7, #0]
 800551a:	2b01      	cmp	r3, #1
 800551c:	d142      	bne.n	80055a4 <SetSysClock+0xe4>
  {
    /* Enable high performance mode, System frequency up to 168 MHz */
    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 800551e:	4b24      	ldr	r3, [pc, #144]	; (80055b0 <SetSysClock+0xf0>)
 8005520:	4a23      	ldr	r2, [pc, #140]	; (80055b0 <SetSysClock+0xf0>)
 8005522:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8005524:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8005528:	641a      	str	r2, [r3, #64]	; 0x40
    PWR->CR |= PWR_CR_PMODE;  
 800552a:	4b22      	ldr	r3, [pc, #136]	; (80055b4 <SetSysClock+0xf4>)
 800552c:	4a21      	ldr	r2, [pc, #132]	; (80055b4 <SetSysClock+0xf4>)
 800552e:	6812      	ldr	r2, [r2, #0]
 8005530:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8005534:	601a      	str	r2, [r3, #0]

    /* HCLK = SYSCLK / 1*/
    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 8005536:	4b1e      	ldr	r3, [pc, #120]	; (80055b0 <SetSysClock+0xf0>)
 8005538:	4a1d      	ldr	r2, [pc, #116]	; (80055b0 <SetSysClock+0xf0>)
 800553a:	6892      	ldr	r2, [r2, #8]
 800553c:	609a      	str	r2, [r3, #8]
      
    /* PCLK2 = HCLK / 2*/
    RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
 800553e:	4b1c      	ldr	r3, [pc, #112]	; (80055b0 <SetSysClock+0xf0>)
 8005540:	4a1b      	ldr	r2, [pc, #108]	; (80055b0 <SetSysClock+0xf0>)
 8005542:	6892      	ldr	r2, [r2, #8]
 8005544:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8005548:	609a      	str	r2, [r3, #8]
    
    /* PCLK1 = HCLK / 4*/
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
 800554a:	4b19      	ldr	r3, [pc, #100]	; (80055b0 <SetSysClock+0xf0>)
 800554c:	4a18      	ldr	r2, [pc, #96]	; (80055b0 <SetSysClock+0xf0>)
 800554e:	6892      	ldr	r2, [r2, #8]
 8005550:	f442 52a0 	orr.w	r2, r2, #5120	; 0x1400
 8005554:	609a      	str	r2, [r3, #8]

    /* Configure the main PLL */
    RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 8005556:	4b16      	ldr	r3, [pc, #88]	; (80055b0 <SetSysClock+0xf0>)
 8005558:	4a17      	ldr	r2, [pc, #92]	; (80055b8 <SetSysClock+0xf8>)
 800555a:	605a      	str	r2, [r3, #4]
                   (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);

    /* Enable the main PLL */
    RCC->CR |= RCC_CR_PLLON;
 800555c:	4b14      	ldr	r3, [pc, #80]	; (80055b0 <SetSysClock+0xf0>)
 800555e:	4a14      	ldr	r2, [pc, #80]	; (80055b0 <SetSysClock+0xf0>)
 8005560:	6812      	ldr	r2, [r2, #0]
 8005562:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8005566:	601a      	str	r2, [r3, #0]

    /* Wait till the main PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 8005568:	bf00      	nop
 800556a:	4b11      	ldr	r3, [pc, #68]	; (80055b0 <SetSysClock+0xf0>)
 800556c:	681b      	ldr	r3, [r3, #0]
 800556e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8005572:	2b00      	cmp	r3, #0
 8005574:	d0f9      	beq.n	800556a <SetSysClock+0xaa>
    {
    }
   
    /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
    FLASH->ACR = FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
 8005576:	4b11      	ldr	r3, [pc, #68]	; (80055bc <SetSysClock+0xfc>)
 8005578:	f240 6205 	movw	r2, #1541	; 0x605
 800557c:	601a      	str	r2, [r3, #0]

    /* Select the main PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 800557e:	4b0c      	ldr	r3, [pc, #48]	; (80055b0 <SetSysClock+0xf0>)
 8005580:	4a0b      	ldr	r2, [pc, #44]	; (80055b0 <SetSysClock+0xf0>)
 8005582:	6892      	ldr	r2, [r2, #8]
 8005584:	f022 0203 	bic.w	r2, r2, #3
 8005588:	609a      	str	r2, [r3, #8]
    RCC->CFGR |= RCC_CFGR_SW_PLL;
 800558a:	4b09      	ldr	r3, [pc, #36]	; (80055b0 <SetSysClock+0xf0>)
 800558c:	4a08      	ldr	r2, [pc, #32]	; (80055b0 <SetSysClock+0xf0>)
 800558e:	6892      	ldr	r2, [r2, #8]
 8005590:	f042 0202 	orr.w	r2, r2, #2
 8005594:	609a      	str	r2, [r3, #8]

    /* Wait till the main PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
 8005596:	bf00      	nop
 8005598:	4b05      	ldr	r3, [pc, #20]	; (80055b0 <SetSysClock+0xf0>)
 800559a:	689b      	ldr	r3, [r3, #8]
 800559c:	f003 030c 	and.w	r3, r3, #12
 80055a0:	2b08      	cmp	r3, #8
 80055a2:	d1f9      	bne.n	8005598 <SetSysClock+0xd8>
  else
  { /* If HSE fails to start-up, the application will have wrong clock
         configuration. User can add here some code to deal with this error */
  }

}
 80055a4:	f107 070c 	add.w	r7, r7, #12
 80055a8:	46bd      	mov	sp, r7
 80055aa:	bc80      	pop	{r7}
 80055ac:	4770      	bx	lr
 80055ae:	bf00      	nop
 80055b0:	40023800 	.word	0x40023800
 80055b4:	40007000 	.word	0x40007000
 80055b8:	07405408 	.word	0x07405408
 80055bc:	40023c00 	.word	0x40023c00

080055c0 <NVIC_PriorityGroupConfig>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)
{
 80055c0:	b480      	push	{r7}
 80055c2:	b083      	sub	sp, #12
 80055c4:	af00      	add	r7, sp, #0
 80055c6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 80055c8:	4a05      	ldr	r2, [pc, #20]	; (80055e0 <NVIC_PriorityGroupConfig+0x20>)
 80055ca:	687b      	ldr	r3, [r7, #4]
 80055cc:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80055d0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80055d4:	60d3      	str	r3, [r2, #12]
}
 80055d6:	f107 070c 	add.w	r7, r7, #12
 80055da:	46bd      	mov	sp, r7
 80055dc:	bc80      	pop	{r7}
 80055de:	4770      	bx	lr
 80055e0:	e000ed00 	.word	0xe000ed00

080055e4 <NVIC_Init>:
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 80055e4:	b480      	push	{r7}
 80055e6:	b085      	sub	sp, #20
 80055e8:	af00      	add	r7, sp, #0
 80055ea:	6078      	str	r0, [r7, #4]
  uint8_t tmppriority = 0x00, tmppre = 0x00, tmpsub = 0x0F;
 80055ec:	f04f 0300 	mov.w	r3, #0
 80055f0:	73fb      	strb	r3, [r7, #15]
 80055f2:	f04f 0300 	mov.w	r3, #0
 80055f6:	73bb      	strb	r3, [r7, #14]
 80055f8:	f04f 030f 	mov.w	r3, #15
 80055fc:	737b      	strb	r3, [r7, #13]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 80055fe:	687b      	ldr	r3, [r7, #4]
 8005600:	78db      	ldrb	r3, [r3, #3]
 8005602:	2b00      	cmp	r3, #0
 8005604:	d03c      	beq.n	8005680 <NVIC_Init+0x9c>
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8005606:	4b2a      	ldr	r3, [pc, #168]	; (80056b0 <NVIC_Init+0xcc>)
 8005608:	68db      	ldr	r3, [r3, #12]
 800560a:	ea6f 0303 	mvn.w	r3, r3
 800560e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8005612:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8005616:	73fb      	strb	r3, [r7, #15]
    tmppre = (0x4 - tmppriority);
 8005618:	7bfb      	ldrb	r3, [r7, #15]
 800561a:	f1c3 0304 	rsb	r3, r3, #4
 800561e:	73bb      	strb	r3, [r7, #14]
    tmpsub = tmpsub >> tmppriority;
 8005620:	7b7a      	ldrb	r2, [r7, #13]
 8005622:	7bfb      	ldrb	r3, [r7, #15]
 8005624:	fa42 f303 	asr.w	r3, r2, r3
 8005628:	737b      	strb	r3, [r7, #13]

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 800562a:	687b      	ldr	r3, [r7, #4]
 800562c:	785b      	ldrb	r3, [r3, #1]
 800562e:	461a      	mov	r2, r3
 8005630:	7bbb      	ldrb	r3, [r7, #14]
 8005632:	fa02 f303 	lsl.w	r3, r2, r3
 8005636:	73fb      	strb	r3, [r7, #15]
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 8005638:	687b      	ldr	r3, [r7, #4]
 800563a:	789a      	ldrb	r2, [r3, #2]
 800563c:	7b7b      	ldrb	r3, [r7, #13]
 800563e:	4013      	ands	r3, r2
 8005640:	b2da      	uxtb	r2, r3
 8005642:	7bfb      	ldrb	r3, [r7, #15]
 8005644:	4313      	orrs	r3, r2
 8005646:	73fb      	strb	r3, [r7, #15]
        
    tmppriority = tmppriority << 0x04;
 8005648:	7bfb      	ldrb	r3, [r7, #15]
 800564a:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800564e:	73fb      	strb	r3, [r7, #15]
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8005650:	4a18      	ldr	r2, [pc, #96]	; (80056b4 <NVIC_Init+0xd0>)
 8005652:	687b      	ldr	r3, [r7, #4]
 8005654:	781b      	ldrb	r3, [r3, #0]
 8005656:	18d3      	adds	r3, r2, r3
 8005658:	7bfa      	ldrb	r2, [r7, #15]
 800565a:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 800565e:	4b15      	ldr	r3, [pc, #84]	; (80056b4 <NVIC_Init+0xd0>)
 8005660:	687a      	ldr	r2, [r7, #4]
 8005662:	7812      	ldrb	r2, [r2, #0]
 8005664:	ea4f 1252 	mov.w	r2, r2, lsr #5
 8005668:	b2d2      	uxtb	r2, r2
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 800566a:	6879      	ldr	r1, [r7, #4]
 800566c:	7809      	ldrb	r1, [r1, #0]
 800566e:	f001 011f 	and.w	r1, r1, #31
 8005672:	f04f 0001 	mov.w	r0, #1
 8005676:	fa00 f101 	lsl.w	r1, r0, r1
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 800567a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 800567e:	e011      	b.n	80056a4 <NVIC_Init+0xc0>
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8005680:	4b0c      	ldr	r3, [pc, #48]	; (80056b4 <NVIC_Init+0xd0>)
 8005682:	687a      	ldr	r2, [r7, #4]
 8005684:	7812      	ldrb	r2, [r2, #0]
 8005686:	ea4f 1252 	mov.w	r2, r2, lsr #5
 800568a:	b2d2      	uxtb	r2, r2
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 800568c:	6879      	ldr	r1, [r7, #4]
 800568e:	7809      	ldrb	r1, [r1, #0]
 8005690:	f001 011f 	and.w	r1, r1, #31
 8005694:	f04f 0001 	mov.w	r0, #1
 8005698:	fa00 f101 	lsl.w	r1, r0, r1
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 800569c:	f102 0220 	add.w	r2, r2, #32
 80056a0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 80056a4:	f107 0714 	add.w	r7, r7, #20
 80056a8:	46bd      	mov	sp, r7
 80056aa:	bc80      	pop	{r7}
 80056ac:	4770      	bx	lr
 80056ae:	bf00      	nop
 80056b0:	e000ed00 	.word	0xe000ed00
 80056b4:	e000e100 	.word	0xe000e100

080056b8 <NVIC_SetVectorTable>:
  *     @arg NVIC_VectTab_FLASH: Vector Table in internal FLASH.
  * @param  Offset: Vector Table base offset field. This value must be a multiple of 0x200.
  * @retval None
  */
void NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset)
{ 
 80056b8:	b480      	push	{r7}
 80056ba:	b083      	sub	sp, #12
 80056bc:	af00      	add	r7, sp, #0
 80056be:	6078      	str	r0, [r7, #4]
 80056c0:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 80056c2:	4a07      	ldr	r2, [pc, #28]	; (80056e0 <NVIC_SetVectorTable+0x28>)
 80056c4:	683b      	ldr	r3, [r7, #0]
 80056c6:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 80056ca:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80056ce:	6879      	ldr	r1, [r7, #4]
 80056d0:	430b      	orrs	r3, r1
 80056d2:	6093      	str	r3, [r2, #8]
}
 80056d4:	f107 070c 	add.w	r7, r7, #12
 80056d8:	46bd      	mov	sp, r7
 80056da:	bc80      	pop	{r7}
 80056dc:	4770      	bx	lr
 80056de:	bf00      	nop
 80056e0:	e000ed00 	.word	0xe000ed00

080056e4 <NVIC_SystemLPConfig>:
  *     @arg NVIC_LP_SLEEPONEXIT: Low Power Sleep on Exit.
  * @param  NewState: new state of LP condition. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState)
{
 80056e4:	b480      	push	{r7}
 80056e6:	b083      	sub	sp, #12
 80056e8:	af00      	add	r7, sp, #0
 80056ea:	4602      	mov	r2, r0
 80056ec:	460b      	mov	r3, r1
 80056ee:	71fa      	strb	r2, [r7, #7]
 80056f0:	71bb      	strb	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
 80056f2:	79bb      	ldrb	r3, [r7, #6]
 80056f4:	2b00      	cmp	r3, #0
 80056f6:	d006      	beq.n	8005706 <NVIC_SystemLPConfig+0x22>
  {
    SCB->SCR |= LowPowerMode;
 80056f8:	4b09      	ldr	r3, [pc, #36]	; (8005720 <NVIC_SystemLPConfig+0x3c>)
 80056fa:	4a09      	ldr	r2, [pc, #36]	; (8005720 <NVIC_SystemLPConfig+0x3c>)
 80056fc:	6911      	ldr	r1, [r2, #16]
 80056fe:	79fa      	ldrb	r2, [r7, #7]
 8005700:	430a      	orrs	r2, r1
 8005702:	611a      	str	r2, [r3, #16]
 8005704:	e007      	b.n	8005716 <NVIC_SystemLPConfig+0x32>
  }
  else
  {
    SCB->SCR &= (uint32_t)(~(uint32_t)LowPowerMode);
 8005706:	4b06      	ldr	r3, [pc, #24]	; (8005720 <NVIC_SystemLPConfig+0x3c>)
 8005708:	4a05      	ldr	r2, [pc, #20]	; (8005720 <NVIC_SystemLPConfig+0x3c>)
 800570a:	6911      	ldr	r1, [r2, #16]
 800570c:	79fa      	ldrb	r2, [r7, #7]
 800570e:	ea6f 0202 	mvn.w	r2, r2
 8005712:	400a      	ands	r2, r1
 8005714:	611a      	str	r2, [r3, #16]
  }
}
 8005716:	f107 070c 	add.w	r7, r7, #12
 800571a:	46bd      	mov	sp, r7
 800571c:	bc80      	pop	{r7}
 800571e:	4770      	bx	lr
 8005720:	e000ed00 	.word	0xe000ed00

08005724 <SysTick_CLKSourceConfig>:
  *     @arg SysTick_CLKSource_HCLK_Div8: AHB clock divided by 8 selected as SysTick clock source.
  *     @arg SysTick_CLKSource_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
 8005724:	b480      	push	{r7}
 8005726:	b083      	sub	sp, #12
 8005728:	af00      	add	r7, sp, #0
 800572a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 800572c:	687b      	ldr	r3, [r7, #4]
 800572e:	2b04      	cmp	r3, #4
 8005730:	d106      	bne.n	8005740 <SysTick_CLKSourceConfig+0x1c>
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8005732:	4b09      	ldr	r3, [pc, #36]	; (8005758 <SysTick_CLKSourceConfig+0x34>)
 8005734:	4a08      	ldr	r2, [pc, #32]	; (8005758 <SysTick_CLKSourceConfig+0x34>)
 8005736:	6812      	ldr	r2, [r2, #0]
 8005738:	f042 0204 	orr.w	r2, r2, #4
 800573c:	601a      	str	r2, [r3, #0]
 800573e:	e005      	b.n	800574c <SysTick_CLKSourceConfig+0x28>
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 8005740:	4b05      	ldr	r3, [pc, #20]	; (8005758 <SysTick_CLKSourceConfig+0x34>)
 8005742:	4a05      	ldr	r2, [pc, #20]	; (8005758 <SysTick_CLKSourceConfig+0x34>)
 8005744:	6812      	ldr	r2, [r2, #0]
 8005746:	f022 0204 	bic.w	r2, r2, #4
 800574a:	601a      	str	r2, [r3, #0]
  }
}
 800574c:	f107 070c 	add.w	r7, r7, #12
 8005750:	46bd      	mov	sp, r7
 8005752:	bc80      	pop	{r7}
 8005754:	4770      	bx	lr
 8005756:	bf00      	nop
 8005758:	e000e010 	.word	0xe000e010

0800575c <ADC_DeInit>:
  *         values.
  * @param  None
  * @retval None
  */
void ADC_DeInit(void)
{
 800575c:	b580      	push	{r7, lr}
 800575e:	af00      	add	r7, sp, #0
  /* Enable all ADCs reset state */
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, ENABLE);
 8005760:	f44f 7080 	mov.w	r0, #256	; 0x100
 8005764:	f04f 0101 	mov.w	r1, #1
 8005768:	f002 fe42 	bl	80083f0 <RCC_APB2PeriphResetCmd>
  
  /* Release all ADCs from reset state */
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, DISABLE);
 800576c:	f44f 7080 	mov.w	r0, #256	; 0x100
 8005770:	f04f 0100 	mov.w	r1, #0
 8005774:	f002 fe3c 	bl	80083f0 <RCC_APB2PeriphResetCmd>
}
 8005778:	bd80      	pop	{r7, pc}
 800577a:	bf00      	nop

0800577c <ADC_Init>:
  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
  *         the configuration information for the specified ADC peripheral.
  * @retval None
  */
void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
{
 800577c:	b480      	push	{r7}
 800577e:	b085      	sub	sp, #20
 8005780:	af00      	add	r7, sp, #0
 8005782:	6078      	str	r0, [r7, #4]
 8005784:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg1 = 0;
 8005786:	f04f 0300 	mov.w	r3, #0
 800578a:	60fb      	str	r3, [r7, #12]
  uint8_t tmpreg2 = 0;
 800578c:	f04f 0300 	mov.w	r3, #0
 8005790:	72fb      	strb	r3, [r7, #11]
  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
  
  /*---------------------------- ADCx CR1 Configuration -----------------*/
  /* Get the ADCx CR1 value */
  tmpreg1 = ADCx->CR1;
 8005792:	687b      	ldr	r3, [r7, #4]
 8005794:	685b      	ldr	r3, [r3, #4]
 8005796:	60fb      	str	r3, [r7, #12]
  
  /* Clear RES and SCAN bits */
  tmpreg1 &= CR1_CLEAR_MASK;
 8005798:	68fb      	ldr	r3, [r7, #12]
 800579a:	f023 7340 	bic.w	r3, r3, #50331648	; 0x3000000
 800579e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80057a2:	60fb      	str	r3, [r7, #12]
  
  /* Configure ADCx: scan conversion mode and resolution */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  /* Set RES bit according to ADC_Resolution value */ 
  tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
 80057a4:	683b      	ldr	r3, [r7, #0]
 80057a6:	791b      	ldrb	r3, [r3, #4]
 80057a8:	ea4f 2203 	mov.w	r2, r3, lsl #8
                                   ADC_InitStruct->ADC_Resolution);
 80057ac:	683b      	ldr	r3, [r7, #0]
 80057ae:	681b      	ldr	r3, [r3, #0]
  tmpreg1 &= CR1_CLEAR_MASK;
  
  /* Configure ADCx: scan conversion mode and resolution */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  /* Set RES bit according to ADC_Resolution value */ 
  tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
 80057b0:	4313      	orrs	r3, r2
 80057b2:	68fa      	ldr	r2, [r7, #12]
 80057b4:	4313      	orrs	r3, r2
 80057b6:	60fb      	str	r3, [r7, #12]
                                   ADC_InitStruct->ADC_Resolution);
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;
 80057b8:	687b      	ldr	r3, [r7, #4]
 80057ba:	68fa      	ldr	r2, [r7, #12]
 80057bc:	605a      	str	r2, [r3, #4]
  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
 80057be:	687b      	ldr	r3, [r7, #4]
 80057c0:	689b      	ldr	r3, [r3, #8]
 80057c2:	60fb      	str	r3, [r7, #12]
  
  /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
  tmpreg1 &= CR2_CLEAR_MASK;
 80057c4:	68fa      	ldr	r2, [r7, #12]
 80057c6:	4b19      	ldr	r3, [pc, #100]	; (800582c <ADC_Init+0xb0>)
 80057c8:	4013      	ands	r3, r2
 80057ca:	60fb      	str	r3, [r7, #12]
     continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
 80057cc:	683b      	ldr	r3, [r7, #0]
 80057ce:	691a      	ldr	r2, [r3, #16]
                        ADC_InitStruct->ADC_ExternalTrigConv | 
 80057d0:	683b      	ldr	r3, [r7, #0]
 80057d2:	68db      	ldr	r3, [r3, #12]
     continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
 80057d4:	431a      	orrs	r2, r3
                        ADC_InitStruct->ADC_ExternalTrigConv | 
                        ADC_InitStruct->ADC_ExternalTrigConvEdge | \
 80057d6:	683b      	ldr	r3, [r7, #0]
 80057d8:	689b      	ldr	r3, [r3, #8]
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
                        ADC_InitStruct->ADC_ExternalTrigConv | 
 80057da:	431a      	orrs	r2, r3
                        ADC_InitStruct->ADC_ExternalTrigConvEdge | \
                        ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
 80057dc:	683b      	ldr	r3, [r7, #0]
 80057de:	795b      	ldrb	r3, [r3, #5]
 80057e0:	ea4f 0343 	mov.w	r3, r3, lsl #1
     continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
 80057e4:	4313      	orrs	r3, r2
 80057e6:	68fa      	ldr	r2, [r7, #12]
 80057e8:	4313      	orrs	r3, r2
 80057ea:	60fb      	str	r3, [r7, #12]
                        ADC_InitStruct->ADC_ExternalTrigConv | 
                        ADC_InitStruct->ADC_ExternalTrigConvEdge | \
                        ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
                        
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;
 80057ec:	687b      	ldr	r3, [r7, #4]
 80057ee:	68fa      	ldr	r2, [r7, #12]
 80057f0:	609a      	str	r2, [r3, #8]
  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
 80057f2:	687b      	ldr	r3, [r7, #4]
 80057f4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80057f6:	60fb      	str	r3, [r7, #12]
  
  /* Clear L bits */
  tmpreg1 &= SQR1_L_RESET;
 80057f8:	68fb      	ldr	r3, [r7, #12]
 80057fa:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 80057fe:	60fb      	str	r3, [r7, #12]
  
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfConversion value */
  tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
 8005800:	683b      	ldr	r3, [r7, #0]
 8005802:	7d1b      	ldrb	r3, [r3, #20]
 8005804:	f103 33ff 	add.w	r3, r3, #4294967295
 8005808:	b2da      	uxtb	r2, r3
 800580a:	7afb      	ldrb	r3, [r7, #11]
 800580c:	4313      	orrs	r3, r2
 800580e:	72fb      	strb	r3, [r7, #11]
  tmpreg1 |= ((uint32_t)tmpreg2 << 20);
 8005810:	7afb      	ldrb	r3, [r7, #11]
 8005812:	ea4f 5303 	mov.w	r3, r3, lsl #20
 8005816:	68fa      	ldr	r2, [r7, #12]
 8005818:	4313      	orrs	r3, r2
 800581a:	60fb      	str	r3, [r7, #12]
  
  /* Write to ADCx SQR1 */
  ADCx->SQR1 = tmpreg1;
 800581c:	687b      	ldr	r3, [r7, #4]
 800581e:	68fa      	ldr	r2, [r7, #12]
 8005820:	62da      	str	r2, [r3, #44]	; 0x2c
}
 8005822:	f107 0714 	add.w	r7, r7, #20
 8005826:	46bd      	mov	sp, r7
 8005828:	bc80      	pop	{r7}
 800582a:	4770      	bx	lr
 800582c:	c0fff7fd 	.word	0xc0fff7fd

08005830 <ADC_StructInit>:
  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure which will 
  *         be initialized.
  * @retval None
  */
void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
{
 8005830:	b480      	push	{r7}
 8005832:	b083      	sub	sp, #12
 8005834:	af00      	add	r7, sp, #0
 8005836:	6078      	str	r0, [r7, #4]
  /* Initialize the ADC_Mode member */
  ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
 8005838:	687b      	ldr	r3, [r7, #4]
 800583a:	f04f 0200 	mov.w	r2, #0
 800583e:	601a      	str	r2, [r3, #0]

  /* initialize the ADC_ScanConvMode member */
  ADC_InitStruct->ADC_ScanConvMode = DISABLE;
 8005840:	687b      	ldr	r3, [r7, #4]
 8005842:	f04f 0200 	mov.w	r2, #0
 8005846:	711a      	strb	r2, [r3, #4]

  /* Initialize the ADC_ContinuousConvMode member */
  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
 8005848:	687b      	ldr	r3, [r7, #4]
 800584a:	f04f 0200 	mov.w	r2, #0
 800584e:	715a      	strb	r2, [r3, #5]

  /* Initialize the ADC_ExternalTrigConvEdge member */
  ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
 8005850:	687b      	ldr	r3, [r7, #4]
 8005852:	f04f 0200 	mov.w	r2, #0
 8005856:	609a      	str	r2, [r3, #8]

  /* Initialize the ADC_ExternalTrigConv member */
  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
 8005858:	687b      	ldr	r3, [r7, #4]
 800585a:	f04f 0200 	mov.w	r2, #0
 800585e:	60da      	str	r2, [r3, #12]

  /* Initialize the ADC_DataAlign member */
  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
 8005860:	687b      	ldr	r3, [r7, #4]
 8005862:	f04f 0200 	mov.w	r2, #0
 8005866:	611a      	str	r2, [r3, #16]

  /* Initialize the ADC_NbrOfConversion member */
  ADC_InitStruct->ADC_NbrOfConversion = 1;
 8005868:	687b      	ldr	r3, [r7, #4]
 800586a:	f04f 0201 	mov.w	r2, #1
 800586e:	751a      	strb	r2, [r3, #20]
}
 8005870:	f107 070c 	add.w	r7, r7, #12
 8005874:	46bd      	mov	sp, r7
 8005876:	bc80      	pop	{r7}
 8005878:	4770      	bx	lr
 800587a:	bf00      	nop

0800587c <ADC_CommonInit>:
  * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure 
  *         that contains the configuration information for  All ADCs peripherals.
  * @retval None
  */
void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
{
 800587c:	b480      	push	{r7}
 800587e:	b085      	sub	sp, #20
 8005880:	af00      	add	r7, sp, #0
 8005882:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg1 = 0;
 8005884:	f04f 0300 	mov.w	r3, #0
 8005888:	60fb      	str	r3, [r7, #12]
  assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
  assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
  assert_param(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
  /*---------------------------- ADC CCR Configuration -----------------*/
  /* Get the ADC CCR value */
  tmpreg1 = ADC->CCR;
 800588a:	4b0e      	ldr	r3, [pc, #56]	; (80058c4 <ADC_CommonInit+0x48>)
 800588c:	685b      	ldr	r3, [r3, #4]
 800588e:	60fb      	str	r3, [r7, #12]
  
  /* Clear MULTI, DELAY, DMA and ADCPRE bits */
  tmpreg1 &= CR_CLEAR_MASK;
 8005890:	68fa      	ldr	r2, [r7, #12]
 8005892:	4b0d      	ldr	r3, [pc, #52]	; (80058c8 <ADC_CommonInit+0x4c>)
 8005894:	4013      	ands	r3, r2
 8005896:	60fb      	str	r3, [r7, #12]
     and DMA access mode for multimode */
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 8005898:	687b      	ldr	r3, [r7, #4]
 800589a:	681a      	ldr	r2, [r3, #0]
                        ADC_CommonInitStruct->ADC_Prescaler | 
 800589c:	687b      	ldr	r3, [r7, #4]
 800589e:	685b      	ldr	r3, [r3, #4]
     and DMA access mode for multimode */
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 80058a0:	431a      	orrs	r2, r3
                        ADC_CommonInitStruct->ADC_Prescaler | 
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
 80058a2:	687b      	ldr	r3, [r7, #4]
 80058a4:	689b      	ldr	r3, [r3, #8]
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
                        ADC_CommonInitStruct->ADC_Prescaler | 
 80058a6:	431a      	orrs	r2, r3
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
                        ADC_CommonInitStruct->ADC_TwoSamplingDelay);
 80058a8:	687b      	ldr	r3, [r7, #4]
 80058aa:	68db      	ldr	r3, [r3, #12]
     and DMA access mode for multimode */
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 80058ac:	4313      	orrs	r3, r2
 80058ae:	68fa      	ldr	r2, [r7, #12]
 80058b0:	4313      	orrs	r3, r2
 80058b2:	60fb      	str	r3, [r7, #12]
                        ADC_CommonInitStruct->ADC_Prescaler | 
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
                        ADC_CommonInitStruct->ADC_TwoSamplingDelay);
                        
  /* Write to ADC CCR */
  ADC->CCR = tmpreg1;
 80058b4:	4b03      	ldr	r3, [pc, #12]	; (80058c4 <ADC_CommonInit+0x48>)
 80058b6:	68fa      	ldr	r2, [r7, #12]
 80058b8:	605a      	str	r2, [r3, #4]
}
 80058ba:	f107 0714 	add.w	r7, r7, #20
 80058be:	46bd      	mov	sp, r7
 80058c0:	bc80      	pop	{r7}
 80058c2:	4770      	bx	lr
 80058c4:	40012300 	.word	0x40012300
 80058c8:	fffc30e0 	.word	0xfffc30e0

080058cc <ADC_CommonStructInit>:
  * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure
  *         which will be initialized.
  * @retval None
  */
void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
{
 80058cc:	b480      	push	{r7}
 80058ce:	b083      	sub	sp, #12
 80058d0:	af00      	add	r7, sp, #0
 80058d2:	6078      	str	r0, [r7, #4]
  /* Initialize the ADC_Mode member */
  ADC_CommonInitStruct->ADC_Mode = ADC_Mode_Independent;
 80058d4:	687b      	ldr	r3, [r7, #4]
 80058d6:	f04f 0200 	mov.w	r2, #0
 80058da:	601a      	str	r2, [r3, #0]

  /* initialize the ADC_Prescaler member */
  ADC_CommonInitStruct->ADC_Prescaler = ADC_Prescaler_Div2;
 80058dc:	687b      	ldr	r3, [r7, #4]
 80058de:	f04f 0200 	mov.w	r2, #0
 80058e2:	605a      	str	r2, [r3, #4]

  /* Initialize the ADC_DMAAccessMode member */
  ADC_CommonInitStruct->ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
 80058e4:	687b      	ldr	r3, [r7, #4]
 80058e6:	f04f 0200 	mov.w	r2, #0
 80058ea:	609a      	str	r2, [r3, #8]

  /* Initialize the ADC_TwoSamplingDelay member */
  ADC_CommonInitStruct->ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
 80058ec:	687b      	ldr	r3, [r7, #4]
 80058ee:	f04f 0200 	mov.w	r2, #0
 80058f2:	60da      	str	r2, [r3, #12]
}
 80058f4:	f107 070c 	add.w	r7, r7, #12
 80058f8:	46bd      	mov	sp, r7
 80058fa:	bc80      	pop	{r7}
 80058fc:	4770      	bx	lr
 80058fe:	bf00      	nop

08005900 <ADC_Cmd>:
  * @param  NewState: new state of the ADCx peripheral. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
 8005900:	b480      	push	{r7}
 8005902:	b083      	sub	sp, #12
 8005904:	af00      	add	r7, sp, #0
 8005906:	6078      	str	r0, [r7, #4]
 8005908:	460b      	mov	r3, r1
 800590a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800590c:	78fb      	ldrb	r3, [r7, #3]
 800590e:	2b00      	cmp	r3, #0
 8005910:	d006      	beq.n	8005920 <ADC_Cmd+0x20>
  {
    /* Set the ADON bit to wake up the ADC from power down mode */
    ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
 8005912:	687b      	ldr	r3, [r7, #4]
 8005914:	689b      	ldr	r3, [r3, #8]
 8005916:	f043 0201 	orr.w	r2, r3, #1
 800591a:	687b      	ldr	r3, [r7, #4]
 800591c:	609a      	str	r2, [r3, #8]
 800591e:	e005      	b.n	800592c <ADC_Cmd+0x2c>
  }
  else
  {
    /* Disable the selected ADC peripheral */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
 8005920:	687b      	ldr	r3, [r7, #4]
 8005922:	689b      	ldr	r3, [r3, #8]
 8005924:	f023 0201 	bic.w	r2, r3, #1
 8005928:	687b      	ldr	r3, [r7, #4]
 800592a:	609a      	str	r2, [r3, #8]
  }
}
 800592c:	f107 070c 	add.w	r7, r7, #12
 8005930:	46bd      	mov	sp, r7
 8005932:	bc80      	pop	{r7}
 8005934:	4770      	bx	lr
 8005936:	bf00      	nop

08005938 <ADC_AnalogWatchdogCmd>:
  *            @arg ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog on all regular and injected channels
  *            @arg ADC_AnalogWatchdog_None: No channel guarded by the analog watchdog
  * @retval None	  
  */
void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
{
 8005938:	b480      	push	{r7}
 800593a:	b085      	sub	sp, #20
 800593c:	af00      	add	r7, sp, #0
 800593e:	6078      	str	r0, [r7, #4]
 8005940:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8005942:	f04f 0300 	mov.w	r3, #0
 8005946:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
  
  /* Get the old register value */
  tmpreg = ADCx->CR1;
 8005948:	687b      	ldr	r3, [r7, #4]
 800594a:	685b      	ldr	r3, [r3, #4]
 800594c:	60fb      	str	r3, [r7, #12]
  
  /* Clear AWDEN, JAWDEN and AWDSGL bits */
  tmpreg &= CR1_AWDMode_RESET;
 800594e:	68fb      	ldr	r3, [r7, #12]
 8005950:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
 8005954:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8005958:	60fb      	str	r3, [r7, #12]
  
  /* Set the analog watchdog enable mode */
  tmpreg |= ADC_AnalogWatchdog;
 800595a:	68fa      	ldr	r2, [r7, #12]
 800595c:	683b      	ldr	r3, [r7, #0]
 800595e:	4313      	orrs	r3, r2
 8005960:	60fb      	str	r3, [r7, #12]
  
  /* Store the new register value */
  ADCx->CR1 = tmpreg;
 8005962:	687b      	ldr	r3, [r7, #4]
 8005964:	68fa      	ldr	r2, [r7, #12]
 8005966:	605a      	str	r2, [r3, #4]
}
 8005968:	f107 0714 	add.w	r7, r7, #20
 800596c:	46bd      	mov	sp, r7
 800596e:	bc80      	pop	{r7}
 8005970:	4770      	bx	lr
 8005972:	bf00      	nop

08005974 <ADC_AnalogWatchdogThresholdsConfig>:
  *          This parameter must be a 12-bit value.
  * @retval None
  */
void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
                                        uint16_t LowThreshold)
{
 8005974:	b480      	push	{r7}
 8005976:	b083      	sub	sp, #12
 8005978:	af00      	add	r7, sp, #0
 800597a:	6078      	str	r0, [r7, #4]
 800597c:	4613      	mov	r3, r2
 800597e:	460a      	mov	r2, r1
 8005980:	807a      	strh	r2, [r7, #2]
 8005982:	803b      	strh	r3, [r7, #0]
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_THRESHOLD(HighThreshold));
  assert_param(IS_ADC_THRESHOLD(LowThreshold));
  
  /* Set the ADCx high threshold */
  ADCx->HTR = HighThreshold;
 8005984:	887a      	ldrh	r2, [r7, #2]
 8005986:	687b      	ldr	r3, [r7, #4]
 8005988:	625a      	str	r2, [r3, #36]	; 0x24
  
  /* Set the ADCx low threshold */
  ADCx->LTR = LowThreshold;
 800598a:	883a      	ldrh	r2, [r7, #0]
 800598c:	687b      	ldr	r3, [r7, #4]
 800598e:	629a      	str	r2, [r3, #40]	; 0x28
}
 8005990:	f107 070c 	add.w	r7, r7, #12
 8005994:	46bd      	mov	sp, r7
 8005996:	bc80      	pop	{r7}
 8005998:	4770      	bx	lr
 800599a:	bf00      	nop

0800599c <ADC_AnalogWatchdogSingleChannelConfig>:
  *            @arg ADC_Channel_17: ADC Channel17 selected
  *            @arg ADC_Channel_18: ADC Channel18 selected
  * @retval None
  */
void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
{
 800599c:	b480      	push	{r7}
 800599e:	b085      	sub	sp, #20
 80059a0:	af00      	add	r7, sp, #0
 80059a2:	6078      	str	r0, [r7, #4]
 80059a4:	460b      	mov	r3, r1
 80059a6:	70fb      	strb	r3, [r7, #3]
  uint32_t tmpreg = 0;
 80059a8:	f04f 0300 	mov.w	r3, #0
 80059ac:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  
  /* Get the old register value */
  tmpreg = ADCx->CR1;
 80059ae:	687b      	ldr	r3, [r7, #4]
 80059b0:	685b      	ldr	r3, [r3, #4]
 80059b2:	60fb      	str	r3, [r7, #12]
  
  /* Clear the Analog watchdog channel select bits */
  tmpreg &= CR1_AWDCH_RESET;
 80059b4:	68fb      	ldr	r3, [r7, #12]
 80059b6:	f023 031f 	bic.w	r3, r3, #31
 80059ba:	60fb      	str	r3, [r7, #12]
  
  /* Set the Analog watchdog channel */
  tmpreg |= ADC_Channel;
 80059bc:	78fb      	ldrb	r3, [r7, #3]
 80059be:	68fa      	ldr	r2, [r7, #12]
 80059c0:	4313      	orrs	r3, r2
 80059c2:	60fb      	str	r3, [r7, #12]
  
  /* Store the new register value */
  ADCx->CR1 = tmpreg;
 80059c4:	687b      	ldr	r3, [r7, #4]
 80059c6:	68fa      	ldr	r2, [r7, #12]
 80059c8:	605a      	str	r2, [r3, #4]
}
 80059ca:	f107 0714 	add.w	r7, r7, #20
 80059ce:	46bd      	mov	sp, r7
 80059d0:	bc80      	pop	{r7}
 80059d2:	4770      	bx	lr

080059d4 <ADC_TempSensorVrefintCmd>:
  * @param  NewState: new state of the temperature sensor and Vrefint channels.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_TempSensorVrefintCmd(FunctionalState NewState)                
{
 80059d4:	b480      	push	{r7}
 80059d6:	b083      	sub	sp, #12
 80059d8:	af00      	add	r7, sp, #0
 80059da:	4603      	mov	r3, r0
 80059dc:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80059de:	79fb      	ldrb	r3, [r7, #7]
 80059e0:	2b00      	cmp	r3, #0
 80059e2:	d006      	beq.n	80059f2 <ADC_TempSensorVrefintCmd+0x1e>
  {
    /* Enable the temperature sensor and Vrefint channel*/
    ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
 80059e4:	4b08      	ldr	r3, [pc, #32]	; (8005a08 <ADC_TempSensorVrefintCmd+0x34>)
 80059e6:	4a08      	ldr	r2, [pc, #32]	; (8005a08 <ADC_TempSensorVrefintCmd+0x34>)
 80059e8:	6852      	ldr	r2, [r2, #4]
 80059ea:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 80059ee:	605a      	str	r2, [r3, #4]
 80059f0:	e005      	b.n	80059fe <ADC_TempSensorVrefintCmd+0x2a>
  }
  else
  {
    /* Disable the temperature sensor and Vrefint channel*/
    ADC->CCR &= (uint32_t)(~ADC_CCR_TSVREFE);
 80059f2:	4b05      	ldr	r3, [pc, #20]	; (8005a08 <ADC_TempSensorVrefintCmd+0x34>)
 80059f4:	4a04      	ldr	r2, [pc, #16]	; (8005a08 <ADC_TempSensorVrefintCmd+0x34>)
 80059f6:	6852      	ldr	r2, [r2, #4]
 80059f8:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 80059fc:	605a      	str	r2, [r3, #4]
  }
}
 80059fe:	f107 070c 	add.w	r7, r7, #12
 8005a02:	46bd      	mov	sp, r7
 8005a04:	bc80      	pop	{r7}
 8005a06:	4770      	bx	lr
 8005a08:	40012300 	.word	0x40012300

08005a0c <ADC_VBATCmd>:
  * @param  NewState: new state of the VBAT channel.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_VBATCmd(FunctionalState NewState)                             
{
 8005a0c:	b480      	push	{r7}
 8005a0e:	b083      	sub	sp, #12
 8005a10:	af00      	add	r7, sp, #0
 8005a12:	4603      	mov	r3, r0
 8005a14:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8005a16:	79fb      	ldrb	r3, [r7, #7]
 8005a18:	2b00      	cmp	r3, #0
 8005a1a:	d006      	beq.n	8005a2a <ADC_VBATCmd+0x1e>
  {
    /* Enable the VBAT channel*/
    ADC->CCR |= (uint32_t)ADC_CCR_VBATE;
 8005a1c:	4b08      	ldr	r3, [pc, #32]	; (8005a40 <ADC_VBATCmd+0x34>)
 8005a1e:	4a08      	ldr	r2, [pc, #32]	; (8005a40 <ADC_VBATCmd+0x34>)
 8005a20:	6852      	ldr	r2, [r2, #4]
 8005a22:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8005a26:	605a      	str	r2, [r3, #4]
 8005a28:	e005      	b.n	8005a36 <ADC_VBATCmd+0x2a>
  }
  else
  {
    /* Disable the VBAT channel*/
    ADC->CCR &= (uint32_t)(~ADC_CCR_VBATE);
 8005a2a:	4b05      	ldr	r3, [pc, #20]	; (8005a40 <ADC_VBATCmd+0x34>)
 8005a2c:	4a04      	ldr	r2, [pc, #16]	; (8005a40 <ADC_VBATCmd+0x34>)
 8005a2e:	6852      	ldr	r2, [r2, #4]
 8005a30:	f422 0280 	bic.w	r2, r2, #4194304	; 0x400000
 8005a34:	605a      	str	r2, [r3, #4]
  }
}
 8005a36:	f107 070c 	add.w	r7, r7, #12
 8005a3a:	46bd      	mov	sp, r7
 8005a3c:	bc80      	pop	{r7}
 8005a3e:	4770      	bx	lr
 8005a40:	40012300 	.word	0x40012300

08005a44 <ADC_RegularChannelConfig>:
  *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
  *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
  * @retval None
  */
void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
 8005a44:	b480      	push	{r7}
 8005a46:	b085      	sub	sp, #20
 8005a48:	af00      	add	r7, sp, #0
 8005a4a:	6078      	str	r0, [r7, #4]
 8005a4c:	70f9      	strb	r1, [r7, #3]
 8005a4e:	70ba      	strb	r2, [r7, #2]
 8005a50:	707b      	strb	r3, [r7, #1]
  uint32_t tmpreg1 = 0, tmpreg2 = 0;
 8005a52:	f04f 0300 	mov.w	r3, #0
 8005a56:	60fb      	str	r3, [r7, #12]
 8005a58:	f04f 0300 	mov.w	r3, #0
 8005a5c:	60bb      	str	r3, [r7, #8]
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
 8005a5e:	78fb      	ldrb	r3, [r7, #3]
 8005a60:	2b09      	cmp	r3, #9
 8005a62:	d927      	bls.n	8005ab4 <ADC_RegularChannelConfig+0x70>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
 8005a64:	687b      	ldr	r3, [r7, #4]
 8005a66:	68db      	ldr	r3, [r3, #12]
 8005a68:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
 8005a6a:	78fa      	ldrb	r2, [r7, #3]
 8005a6c:	4613      	mov	r3, r2
 8005a6e:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8005a72:	189b      	adds	r3, r3, r2
 8005a74:	f1a3 031e 	sub.w	r3, r3, #30
 8005a78:	f04f 0207 	mov.w	r2, #7
 8005a7c:	fa02 f303 	lsl.w	r3, r2, r3
 8005a80:	60bb      	str	r3, [r7, #8]
    
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 8005a82:	68bb      	ldr	r3, [r7, #8]
 8005a84:	ea6f 0303 	mvn.w	r3, r3
 8005a88:	68fa      	ldr	r2, [r7, #12]
 8005a8a:	4013      	ands	r3, r2
 8005a8c:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
 8005a8e:	7879      	ldrb	r1, [r7, #1]
 8005a90:	78fa      	ldrb	r2, [r7, #3]
 8005a92:	4613      	mov	r3, r2
 8005a94:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8005a98:	189b      	adds	r3, r3, r2
 8005a9a:	f1a3 031e 	sub.w	r3, r3, #30
 8005a9e:	fa01 f303 	lsl.w	r3, r1, r3
 8005aa2:	60bb      	str	r3, [r7, #8]
    
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 8005aa4:	68fa      	ldr	r2, [r7, #12]
 8005aa6:	68bb      	ldr	r3, [r7, #8]
 8005aa8:	4313      	orrs	r3, r2
 8005aaa:	60fb      	str	r3, [r7, #12]
    
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
 8005aac:	687b      	ldr	r3, [r7, #4]
 8005aae:	68fa      	ldr	r2, [r7, #12]
 8005ab0:	60da      	str	r2, [r3, #12]
 8005ab2:	e022      	b.n	8005afa <ADC_RegularChannelConfig+0xb6>
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
 8005ab4:	687b      	ldr	r3, [r7, #4]
 8005ab6:	691b      	ldr	r3, [r3, #16]
 8005ab8:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
 8005aba:	78fa      	ldrb	r2, [r7, #3]
 8005abc:	4613      	mov	r3, r2
 8005abe:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8005ac2:	189b      	adds	r3, r3, r2
 8005ac4:	f04f 0207 	mov.w	r2, #7
 8005ac8:	fa02 f303 	lsl.w	r3, r2, r3
 8005acc:	60bb      	str	r3, [r7, #8]
    
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 8005ace:	68bb      	ldr	r3, [r7, #8]
 8005ad0:	ea6f 0303 	mvn.w	r3, r3
 8005ad4:	68fa      	ldr	r2, [r7, #12]
 8005ad6:	4013      	ands	r3, r2
 8005ad8:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
 8005ada:	7879      	ldrb	r1, [r7, #1]
 8005adc:	78fa      	ldrb	r2, [r7, #3]
 8005ade:	4613      	mov	r3, r2
 8005ae0:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8005ae4:	189b      	adds	r3, r3, r2
 8005ae6:	fa01 f303 	lsl.w	r3, r1, r3
 8005aea:	60bb      	str	r3, [r7, #8]
    
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 8005aec:	68fa      	ldr	r2, [r7, #12]
 8005aee:	68bb      	ldr	r3, [r7, #8]
 8005af0:	4313      	orrs	r3, r2
 8005af2:	60fb      	str	r3, [r7, #12]
    
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
 8005af4:	687b      	ldr	r3, [r7, #4]
 8005af6:	68fa      	ldr	r2, [r7, #12]
 8005af8:	611a      	str	r2, [r3, #16]
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
 8005afa:	78bb      	ldrb	r3, [r7, #2]
 8005afc:	2b06      	cmp	r3, #6
 8005afe:	d827      	bhi.n	8005b50 <ADC_RegularChannelConfig+0x10c>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
 8005b00:	687b      	ldr	r3, [r7, #4]
 8005b02:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005b04:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
 8005b06:	78bb      	ldrb	r3, [r7, #2]
 8005b08:	f103 32ff 	add.w	r2, r3, #4294967295
 8005b0c:	4613      	mov	r3, r2
 8005b0e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005b12:	189b      	adds	r3, r3, r2
 8005b14:	f04f 021f 	mov.w	r2, #31
 8005b18:	fa02 f303 	lsl.w	r3, r2, r3
 8005b1c:	60bb      	str	r3, [r7, #8]
    
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8005b1e:	68bb      	ldr	r3, [r7, #8]
 8005b20:	ea6f 0303 	mvn.w	r3, r3
 8005b24:	68fa      	ldr	r2, [r7, #12]
 8005b26:	4013      	ands	r3, r2
 8005b28:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
 8005b2a:	78f9      	ldrb	r1, [r7, #3]
 8005b2c:	78bb      	ldrb	r3, [r7, #2]
 8005b2e:	f103 32ff 	add.w	r2, r3, #4294967295
 8005b32:	4613      	mov	r3, r2
 8005b34:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005b38:	189b      	adds	r3, r3, r2
 8005b3a:	fa01 f303 	lsl.w	r3, r1, r3
 8005b3e:	60bb      	str	r3, [r7, #8]
    
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8005b40:	68fa      	ldr	r2, [r7, #12]
 8005b42:	68bb      	ldr	r3, [r7, #8]
 8005b44:	4313      	orrs	r3, r2
 8005b46:	60fb      	str	r3, [r7, #12]
    
    /* Store the new register value */
    ADCx->SQR3 = tmpreg1;
 8005b48:	687b      	ldr	r3, [r7, #4]
 8005b4a:	68fa      	ldr	r2, [r7, #12]
 8005b4c:	635a      	str	r2, [r3, #52]	; 0x34
 8005b4e:	e051      	b.n	8005bf4 <ADC_RegularChannelConfig+0x1b0>
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
 8005b50:	78bb      	ldrb	r3, [r7, #2]
 8005b52:	2b0c      	cmp	r3, #12
 8005b54:	d827      	bhi.n	8005ba6 <ADC_RegularChannelConfig+0x162>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
 8005b56:	687b      	ldr	r3, [r7, #4]
 8005b58:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005b5a:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
 8005b5c:	78ba      	ldrb	r2, [r7, #2]
 8005b5e:	4613      	mov	r3, r2
 8005b60:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005b64:	189b      	adds	r3, r3, r2
 8005b66:	f1a3 0323 	sub.w	r3, r3, #35	; 0x23
 8005b6a:	f04f 021f 	mov.w	r2, #31
 8005b6e:	fa02 f303 	lsl.w	r3, r2, r3
 8005b72:	60bb      	str	r3, [r7, #8]
    
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8005b74:	68bb      	ldr	r3, [r7, #8]
 8005b76:	ea6f 0303 	mvn.w	r3, r3
 8005b7a:	68fa      	ldr	r2, [r7, #12]
 8005b7c:	4013      	ands	r3, r2
 8005b7e:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
 8005b80:	78f9      	ldrb	r1, [r7, #3]
 8005b82:	78ba      	ldrb	r2, [r7, #2]
 8005b84:	4613      	mov	r3, r2
 8005b86:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005b8a:	189b      	adds	r3, r3, r2
 8005b8c:	f1a3 0323 	sub.w	r3, r3, #35	; 0x23
 8005b90:	fa01 f303 	lsl.w	r3, r1, r3
 8005b94:	60bb      	str	r3, [r7, #8]
    
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8005b96:	68fa      	ldr	r2, [r7, #12]
 8005b98:	68bb      	ldr	r3, [r7, #8]
 8005b9a:	4313      	orrs	r3, r2
 8005b9c:	60fb      	str	r3, [r7, #12]
    
    /* Store the new register value */
    ADCx->SQR2 = tmpreg1;
 8005b9e:	687b      	ldr	r3, [r7, #4]
 8005ba0:	68fa      	ldr	r2, [r7, #12]
 8005ba2:	631a      	str	r2, [r3, #48]	; 0x30
 8005ba4:	e026      	b.n	8005bf4 <ADC_RegularChannelConfig+0x1b0>
  }
  /* For Rank 13 to 16 */
  else
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
 8005ba6:	687b      	ldr	r3, [r7, #4]
 8005ba8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005baa:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
 8005bac:	78ba      	ldrb	r2, [r7, #2]
 8005bae:	4613      	mov	r3, r2
 8005bb0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005bb4:	189b      	adds	r3, r3, r2
 8005bb6:	f1a3 0341 	sub.w	r3, r3, #65	; 0x41
 8005bba:	f04f 021f 	mov.w	r2, #31
 8005bbe:	fa02 f303 	lsl.w	r3, r2, r3
 8005bc2:	60bb      	str	r3, [r7, #8]
    
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8005bc4:	68bb      	ldr	r3, [r7, #8]
 8005bc6:	ea6f 0303 	mvn.w	r3, r3
 8005bca:	68fa      	ldr	r2, [r7, #12]
 8005bcc:	4013      	ands	r3, r2
 8005bce:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
 8005bd0:	78f9      	ldrb	r1, [r7, #3]
 8005bd2:	78ba      	ldrb	r2, [r7, #2]
 8005bd4:	4613      	mov	r3, r2
 8005bd6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005bda:	189b      	adds	r3, r3, r2
 8005bdc:	f1a3 0341 	sub.w	r3, r3, #65	; 0x41
 8005be0:	fa01 f303 	lsl.w	r3, r1, r3
 8005be4:	60bb      	str	r3, [r7, #8]
    
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8005be6:	68fa      	ldr	r2, [r7, #12]
 8005be8:	68bb      	ldr	r3, [r7, #8]
 8005bea:	4313      	orrs	r3, r2
 8005bec:	60fb      	str	r3, [r7, #12]
    
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
 8005bee:	687b      	ldr	r3, [r7, #4]
 8005bf0:	68fa      	ldr	r2, [r7, #12]
 8005bf2:	62da      	str	r2, [r3, #44]	; 0x2c
  }
}
 8005bf4:	f107 0714 	add.w	r7, r7, #20
 8005bf8:	46bd      	mov	sp, r7
 8005bfa:	bc80      	pop	{r7}
 8005bfc:	4770      	bx	lr
 8005bfe:	bf00      	nop

08005c00 <ADC_SoftwareStartConv>:
  * @brief  Enables the selected ADC software start conversion of the regular channels.
  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
  * @retval None
  */
void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
{
 8005c00:	b480      	push	{r7}
 8005c02:	b083      	sub	sp, #12
 8005c04:	af00      	add	r7, sp, #0
 8005c06:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Enable the selected ADC conversion for regular group */
  ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 8005c08:	687b      	ldr	r3, [r7, #4]
 8005c0a:	689b      	ldr	r3, [r3, #8]
 8005c0c:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
 8005c10:	687b      	ldr	r3, [r7, #4]
 8005c12:	609a      	str	r2, [r3, #8]
}
 8005c14:	f107 070c 	add.w	r7, r7, #12
 8005c18:	46bd      	mov	sp, r7
 8005c1a:	bc80      	pop	{r7}
 8005c1c:	4770      	bx	lr
 8005c1e:	bf00      	nop

08005c20 <ADC_GetSoftwareStartConvStatus>:
  * @brief  Gets the selected ADC Software start regular conversion Status.
  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
  * @retval The new state of ADC software start conversion (SET or RESET).
  */
FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
{
 8005c20:	b480      	push	{r7}
 8005c22:	b085      	sub	sp, #20
 8005c24:	af00      	add	r7, sp, #0
 8005c26:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
 8005c28:	f04f 0300 	mov.w	r3, #0
 8005c2c:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Check the status of SWSTART bit */
  if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
 8005c2e:	687b      	ldr	r3, [r7, #4]
 8005c30:	689b      	ldr	r3, [r3, #8]
 8005c32:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8005c36:	2b00      	cmp	r3, #0
 8005c38:	d003      	beq.n	8005c42 <ADC_GetSoftwareStartConvStatus+0x22>
  {
    /* SWSTART bit is set */
    bitstatus = SET;
 8005c3a:	f04f 0301 	mov.w	r3, #1
 8005c3e:	73fb      	strb	r3, [r7, #15]
 8005c40:	e002      	b.n	8005c48 <ADC_GetSoftwareStartConvStatus+0x28>
  }
  else
  {
    /* SWSTART bit is reset */
    bitstatus = RESET;
 8005c42:	f04f 0300 	mov.w	r3, #0
 8005c46:	73fb      	strb	r3, [r7, #15]
  }
  
  /* Return the SWSTART bit status */
  return  bitstatus;
 8005c48:	7bfb      	ldrb	r3, [r7, #15]
}
 8005c4a:	4618      	mov	r0, r3
 8005c4c:	f107 0714 	add.w	r7, r7, #20
 8005c50:	46bd      	mov	sp, r7
 8005c52:	bc80      	pop	{r7}
 8005c54:	4770      	bx	lr
 8005c56:	bf00      	nop

08005c58 <ADC_EOCOnEachRegularChannelCmd>:
  * @param  NewState: new state of the selected ADC EOC flag rising
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_EOCOnEachRegularChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
 8005c58:	b480      	push	{r7}
 8005c5a:	b083      	sub	sp, #12
 8005c5c:	af00      	add	r7, sp, #0
 8005c5e:	6078      	str	r0, [r7, #4]
 8005c60:	460b      	mov	r3, r1
 8005c62:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8005c64:	78fb      	ldrb	r3, [r7, #3]
 8005c66:	2b00      	cmp	r3, #0
 8005c68:	d006      	beq.n	8005c78 <ADC_EOCOnEachRegularChannelCmd+0x20>
  {
    /* Enable the selected ADC EOC rising on each regular channel conversion */
    ADCx->CR2 |= (uint32_t)ADC_CR2_EOCS;
 8005c6a:	687b      	ldr	r3, [r7, #4]
 8005c6c:	689b      	ldr	r3, [r3, #8]
 8005c6e:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
 8005c72:	687b      	ldr	r3, [r7, #4]
 8005c74:	609a      	str	r2, [r3, #8]
 8005c76:	e005      	b.n	8005c84 <ADC_EOCOnEachRegularChannelCmd+0x2c>
  }
  else
  {
    /* Disable the selected ADC EOC rising on each regular channel conversion */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_EOCS);
 8005c78:	687b      	ldr	r3, [r7, #4]
 8005c7a:	689b      	ldr	r3, [r3, #8]
 8005c7c:	f423 6280 	bic.w	r2, r3, #1024	; 0x400
 8005c80:	687b      	ldr	r3, [r7, #4]
 8005c82:	609a      	str	r2, [r3, #8]
  }
}
 8005c84:	f107 070c 	add.w	r7, r7, #12
 8005c88:	46bd      	mov	sp, r7
 8005c8a:	bc80      	pop	{r7}
 8005c8c:	4770      	bx	lr
 8005c8e:	bf00      	nop

08005c90 <ADC_ContinuousModeCmd>:
  * @param  NewState: new state of the selected ADC continuous conversion mode
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
 8005c90:	b480      	push	{r7}
 8005c92:	b083      	sub	sp, #12
 8005c94:	af00      	add	r7, sp, #0
 8005c96:	6078      	str	r0, [r7, #4]
 8005c98:	460b      	mov	r3, r1
 8005c9a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8005c9c:	78fb      	ldrb	r3, [r7, #3]
 8005c9e:	2b00      	cmp	r3, #0
 8005ca0:	d006      	beq.n	8005cb0 <ADC_ContinuousModeCmd+0x20>
  {
    /* Enable the selected ADC continuous conversion mode */
    ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;
 8005ca2:	687b      	ldr	r3, [r7, #4]
 8005ca4:	689b      	ldr	r3, [r3, #8]
 8005ca6:	f043 0202 	orr.w	r2, r3, #2
 8005caa:	687b      	ldr	r3, [r7, #4]
 8005cac:	609a      	str	r2, [r3, #8]
 8005cae:	e005      	b.n	8005cbc <ADC_ContinuousModeCmd+0x2c>
  }
  else
  {
    /* Disable the selected ADC continuous conversion mode */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_CONT);
 8005cb0:	687b      	ldr	r3, [r7, #4]
 8005cb2:	689b      	ldr	r3, [r3, #8]
 8005cb4:	f023 0202 	bic.w	r2, r3, #2
 8005cb8:	687b      	ldr	r3, [r7, #4]
 8005cba:	609a      	str	r2, [r3, #8]
  }
}
 8005cbc:	f107 070c 	add.w	r7, r7, #12
 8005cc0:	46bd      	mov	sp, r7
 8005cc2:	bc80      	pop	{r7}
 8005cc4:	4770      	bx	lr
 8005cc6:	bf00      	nop

08005cc8 <ADC_DiscModeChannelCountConfig>:
  * @param  Number: specifies the discontinuous mode regular channel count value.
  *          This number must be between 1 and 8.
  * @retval None
  */
void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
{
 8005cc8:	b480      	push	{r7}
 8005cca:	b085      	sub	sp, #20
 8005ccc:	af00      	add	r7, sp, #0
 8005cce:	6078      	str	r0, [r7, #4]
 8005cd0:	460b      	mov	r3, r1
 8005cd2:	70fb      	strb	r3, [r7, #3]
  uint32_t tmpreg1 = 0;
 8005cd4:	f04f 0300 	mov.w	r3, #0
 8005cd8:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg2 = 0;
 8005cda:	f04f 0300 	mov.w	r3, #0
 8005cde:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
  
  /* Get the old register value */
  tmpreg1 = ADCx->CR1;
 8005ce0:	687b      	ldr	r3, [r7, #4]
 8005ce2:	685b      	ldr	r3, [r3, #4]
 8005ce4:	60fb      	str	r3, [r7, #12]
  
  /* Clear the old discontinuous mode channel count */
  tmpreg1 &= CR1_DISCNUM_RESET;
 8005ce6:	68fb      	ldr	r3, [r7, #12]
 8005ce8:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8005cec:	60fb      	str	r3, [r7, #12]
  
  /* Set the discontinuous mode channel count */
  tmpreg2 = Number - 1;
 8005cee:	78fb      	ldrb	r3, [r7, #3]
 8005cf0:	f103 33ff 	add.w	r3, r3, #4294967295
 8005cf4:	60bb      	str	r3, [r7, #8]
  tmpreg1 |= tmpreg2 << 13;
 8005cf6:	68bb      	ldr	r3, [r7, #8]
 8005cf8:	ea4f 3343 	mov.w	r3, r3, lsl #13
 8005cfc:	68fa      	ldr	r2, [r7, #12]
 8005cfe:	4313      	orrs	r3, r2
 8005d00:	60fb      	str	r3, [r7, #12]
  
  /* Store the new register value */
  ADCx->CR1 = tmpreg1;
 8005d02:	687b      	ldr	r3, [r7, #4]
 8005d04:	68fa      	ldr	r2, [r7, #12]
 8005d06:	605a      	str	r2, [r3, #4]
}
 8005d08:	f107 0714 	add.w	r7, r7, #20
 8005d0c:	46bd      	mov	sp, r7
 8005d0e:	bc80      	pop	{r7}
 8005d10:	4770      	bx	lr
 8005d12:	bf00      	nop

08005d14 <ADC_DiscModeCmd>:
  *         regular group channel.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
 8005d14:	b480      	push	{r7}
 8005d16:	b083      	sub	sp, #12
 8005d18:	af00      	add	r7, sp, #0
 8005d1a:	6078      	str	r0, [r7, #4]
 8005d1c:	460b      	mov	r3, r1
 8005d1e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8005d20:	78fb      	ldrb	r3, [r7, #3]
 8005d22:	2b00      	cmp	r3, #0
 8005d24:	d006      	beq.n	8005d34 <ADC_DiscModeCmd+0x20>
  {
    /* Enable the selected ADC regular discontinuous mode */
    ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 8005d26:	687b      	ldr	r3, [r7, #4]
 8005d28:	685b      	ldr	r3, [r3, #4]
 8005d2a:	f443 6200 	orr.w	r2, r3, #2048	; 0x800
 8005d2e:	687b      	ldr	r3, [r7, #4]
 8005d30:	605a      	str	r2, [r3, #4]
 8005d32:	e005      	b.n	8005d40 <ADC_DiscModeCmd+0x2c>
  }
  else
  {
    /* Disable the selected ADC regular discontinuous mode */
    ADCx->CR1 &= (uint32_t)(~ADC_CR1_DISCEN);
 8005d34:	687b      	ldr	r3, [r7, #4]
 8005d36:	685b      	ldr	r3, [r3, #4]
 8005d38:	f423 6200 	bic.w	r2, r3, #2048	; 0x800
 8005d3c:	687b      	ldr	r3, [r7, #4]
 8005d3e:	605a      	str	r2, [r3, #4]
  }
}
 8005d40:	f107 070c 	add.w	r7, r7, #12
 8005d44:	46bd      	mov	sp, r7
 8005d46:	bc80      	pop	{r7}
 8005d48:	4770      	bx	lr
 8005d4a:	bf00      	nop

08005d4c <ADC_GetConversionValue>:
  * @brief  Returns the last ADCx conversion result data for regular channel.
  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
  * @retval The Data conversion value.
  */
uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
{
 8005d4c:	b480      	push	{r7}
 8005d4e:	b083      	sub	sp, #12
 8005d50:	af00      	add	r7, sp, #0
 8005d52:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Return the selected ADC conversion value */
  return (uint16_t) ADCx->DR;
 8005d54:	687b      	ldr	r3, [r7, #4]
 8005d56:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8005d58:	b29b      	uxth	r3, r3
}
 8005d5a:	4618      	mov	r0, r3
 8005d5c:	f107 070c 	add.w	r7, r7, #12
 8005d60:	46bd      	mov	sp, r7
 8005d62:	bc80      	pop	{r7}
 8005d64:	4770      	bx	lr
 8005d66:	bf00      	nop

08005d68 <ADC_GetMultiModeConversionValue>:
  * @note   In triple mode, the value returned by this function is as following
  *           Data[15:0] : these bits contain alternatively the regular data of ADC1, ADC3 and ADC2.
  *           Data[31:16]: these bits contain alternatively the regular data of ADC2, ADC1 and ADC3.           
  */
uint32_t ADC_GetMultiModeConversionValue(void)
{
 8005d68:	b480      	push	{r7}
 8005d6a:	af00      	add	r7, sp, #0
  /* Return the multi mode conversion value */
  return (*(__IO uint32_t *) CDR_ADDRESS);
 8005d6c:	4b02      	ldr	r3, [pc, #8]	; (8005d78 <ADC_GetMultiModeConversionValue+0x10>)
 8005d6e:	681b      	ldr	r3, [r3, #0]
}
 8005d70:	4618      	mov	r0, r3
 8005d72:	46bd      	mov	sp, r7
 8005d74:	bc80      	pop	{r7}
 8005d76:	4770      	bx	lr
 8005d78:	40012308 	.word	0x40012308

08005d7c <ADC_DMACmd>:
  * @param  NewState: new state of the selected ADC DMA transfer.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
 8005d7c:	b480      	push	{r7}
 8005d7e:	b083      	sub	sp, #12
 8005d80:	af00      	add	r7, sp, #0
 8005d82:	6078      	str	r0, [r7, #4]
 8005d84:	460b      	mov	r3, r1
 8005d86:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8005d88:	78fb      	ldrb	r3, [r7, #3]
 8005d8a:	2b00      	cmp	r3, #0
 8005d8c:	d006      	beq.n	8005d9c <ADC_DMACmd+0x20>
  {
    /* Enable the selected ADC DMA request */
    ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
 8005d8e:	687b      	ldr	r3, [r7, #4]
 8005d90:	689b      	ldr	r3, [r3, #8]
 8005d92:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 8005d96:	687b      	ldr	r3, [r7, #4]
 8005d98:	609a      	str	r2, [r3, #8]
 8005d9a:	e005      	b.n	8005da8 <ADC_DMACmd+0x2c>
  }
  else
  {
    /* Disable the selected ADC DMA request */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_DMA);
 8005d9c:	687b      	ldr	r3, [r7, #4]
 8005d9e:	689b      	ldr	r3, [r3, #8]
 8005da0:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 8005da4:	687b      	ldr	r3, [r7, #4]
 8005da6:	609a      	str	r2, [r3, #8]
  }
}
 8005da8:	f107 070c 	add.w	r7, r7, #12
 8005dac:	46bd      	mov	sp, r7
 8005dae:	bc80      	pop	{r7}
 8005db0:	4770      	bx	lr
 8005db2:	bf00      	nop

08005db4 <ADC_DMARequestAfterLastTransferCmd>:
  * @param  NewState: new state of the selected ADC DMA request after last transfer.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
 8005db4:	b480      	push	{r7}
 8005db6:	b083      	sub	sp, #12
 8005db8:	af00      	add	r7, sp, #0
 8005dba:	6078      	str	r0, [r7, #4]
 8005dbc:	460b      	mov	r3, r1
 8005dbe:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8005dc0:	78fb      	ldrb	r3, [r7, #3]
 8005dc2:	2b00      	cmp	r3, #0
 8005dc4:	d006      	beq.n	8005dd4 <ADC_DMARequestAfterLastTransferCmd+0x20>
  {
    /* Enable the selected ADC DMA request after last transfer */
    ADCx->CR2 |= (uint32_t)ADC_CR2_DDS;
 8005dc6:	687b      	ldr	r3, [r7, #4]
 8005dc8:	689b      	ldr	r3, [r3, #8]
 8005dca:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 8005dce:	687b      	ldr	r3, [r7, #4]
 8005dd0:	609a      	str	r2, [r3, #8]
 8005dd2:	e005      	b.n	8005de0 <ADC_DMARequestAfterLastTransferCmd+0x2c>
  }
  else
  {
    /* Disable the selected ADC DMA request after last transfer */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_DDS);
 8005dd4:	687b      	ldr	r3, [r7, #4]
 8005dd6:	689b      	ldr	r3, [r3, #8]
 8005dd8:	f423 7200 	bic.w	r2, r3, #512	; 0x200
 8005ddc:	687b      	ldr	r3, [r7, #4]
 8005dde:	609a      	str	r2, [r3, #8]
  }
}
 8005de0:	f107 070c 	add.w	r7, r7, #12
 8005de4:	46bd      	mov	sp, r7
 8005de6:	bc80      	pop	{r7}
 8005de8:	4770      	bx	lr
 8005dea:	bf00      	nop

08005dec <ADC_MultiModeDMARequestAfterLastTransferCmd>:
  *         by ADC_CommonInitStruct.ADC_DMAAccessMode structure member) is 
  *          ADC_DMAAccessMode_1, ADC_DMAAccessMode_2 or ADC_DMAAccessMode_3.     
  * @retval None
  */
void ADC_MultiModeDMARequestAfterLastTransferCmd(FunctionalState NewState)
{
 8005dec:	b480      	push	{r7}
 8005dee:	b083      	sub	sp, #12
 8005df0:	af00      	add	r7, sp, #0
 8005df2:	4603      	mov	r3, r0
 8005df4:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8005df6:	79fb      	ldrb	r3, [r7, #7]
 8005df8:	2b00      	cmp	r3, #0
 8005dfa:	d006      	beq.n	8005e0a <ADC_MultiModeDMARequestAfterLastTransferCmd+0x1e>
  {
    /* Enable the selected ADC DMA request after last transfer */
    ADC->CCR |= (uint32_t)ADC_CCR_DDS;
 8005dfc:	4b08      	ldr	r3, [pc, #32]	; (8005e20 <ADC_MultiModeDMARequestAfterLastTransferCmd+0x34>)
 8005dfe:	4a08      	ldr	r2, [pc, #32]	; (8005e20 <ADC_MultiModeDMARequestAfterLastTransferCmd+0x34>)
 8005e00:	6852      	ldr	r2, [r2, #4]
 8005e02:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8005e06:	605a      	str	r2, [r3, #4]
 8005e08:	e005      	b.n	8005e16 <ADC_MultiModeDMARequestAfterLastTransferCmd+0x2a>
  }
  else
  {
    /* Disable the selected ADC DMA request after last transfer */
    ADC->CCR &= (uint32_t)(~ADC_CCR_DDS);
 8005e0a:	4b05      	ldr	r3, [pc, #20]	; (8005e20 <ADC_MultiModeDMARequestAfterLastTransferCmd+0x34>)
 8005e0c:	4a04      	ldr	r2, [pc, #16]	; (8005e20 <ADC_MultiModeDMARequestAfterLastTransferCmd+0x34>)
 8005e0e:	6852      	ldr	r2, [r2, #4]
 8005e10:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8005e14:	605a      	str	r2, [r3, #4]
  }
}
 8005e16:	f107 070c 	add.w	r7, r7, #12
 8005e1a:	46bd      	mov	sp, r7
 8005e1c:	bc80      	pop	{r7}
 8005e1e:	4770      	bx	lr
 8005e20:	40012300 	.word	0x40012300

08005e24 <ADC_InjectedChannelConfig>:
  *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
  *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
  * @retval None
  */
void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
 8005e24:	b480      	push	{r7}
 8005e26:	b087      	sub	sp, #28
 8005e28:	af00      	add	r7, sp, #0
 8005e2a:	6078      	str	r0, [r7, #4]
 8005e2c:	70f9      	strb	r1, [r7, #3]
 8005e2e:	70ba      	strb	r2, [r7, #2]
 8005e30:	707b      	strb	r3, [r7, #1]
  uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
 8005e32:	f04f 0300 	mov.w	r3, #0
 8005e36:	617b      	str	r3, [r7, #20]
 8005e38:	f04f 0300 	mov.w	r3, #0
 8005e3c:	613b      	str	r3, [r7, #16]
 8005e3e:	f04f 0300 	mov.w	r3, #0
 8005e42:	60fb      	str	r3, [r7, #12]
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_INJECTED_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
 8005e44:	78fb      	ldrb	r3, [r7, #3]
 8005e46:	2b09      	cmp	r3, #9
 8005e48:	d927      	bls.n	8005e9a <ADC_InjectedChannelConfig+0x76>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
 8005e4a:	687b      	ldr	r3, [r7, #4]
 8005e4c:	68db      	ldr	r3, [r3, #12]
 8005e4e:	617b      	str	r3, [r7, #20]
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_SET << (3*(ADC_Channel - 10));
 8005e50:	78fa      	ldrb	r2, [r7, #3]
 8005e52:	4613      	mov	r3, r2
 8005e54:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8005e58:	189b      	adds	r3, r3, r2
 8005e5a:	f1a3 031e 	sub.w	r3, r3, #30
 8005e5e:	f04f 0207 	mov.w	r2, #7
 8005e62:	fa02 f303 	lsl.w	r3, r2, r3
 8005e66:	613b      	str	r3, [r7, #16]
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 8005e68:	693b      	ldr	r3, [r7, #16]
 8005e6a:	ea6f 0303 	mvn.w	r3, r3
 8005e6e:	697a      	ldr	r2, [r7, #20]
 8005e70:	4013      	ands	r3, r2
 8005e72:	617b      	str	r3, [r7, #20]
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
 8005e74:	7879      	ldrb	r1, [r7, #1]
 8005e76:	78fa      	ldrb	r2, [r7, #3]
 8005e78:	4613      	mov	r3, r2
 8005e7a:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8005e7e:	189b      	adds	r3, r3, r2
 8005e80:	f1a3 031e 	sub.w	r3, r3, #30
 8005e84:	fa01 f303 	lsl.w	r3, r1, r3
 8005e88:	613b      	str	r3, [r7, #16]
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 8005e8a:	697a      	ldr	r2, [r7, #20]
 8005e8c:	693b      	ldr	r3, [r7, #16]
 8005e8e:	4313      	orrs	r3, r2
 8005e90:	617b      	str	r3, [r7, #20]
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
 8005e92:	687b      	ldr	r3, [r7, #4]
 8005e94:	697a      	ldr	r2, [r7, #20]
 8005e96:	60da      	str	r2, [r3, #12]
 8005e98:	e022      	b.n	8005ee0 <ADC_InjectedChannelConfig+0xbc>
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
 8005e9a:	687b      	ldr	r3, [r7, #4]
 8005e9c:	691b      	ldr	r3, [r3, #16]
 8005e9e:	617b      	str	r3, [r7, #20]
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
 8005ea0:	78fa      	ldrb	r2, [r7, #3]
 8005ea2:	4613      	mov	r3, r2
 8005ea4:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8005ea8:	189b      	adds	r3, r3, r2
 8005eaa:	f04f 0207 	mov.w	r2, #7
 8005eae:	fa02 f303 	lsl.w	r3, r2, r3
 8005eb2:	613b      	str	r3, [r7, #16]
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 8005eb4:	693b      	ldr	r3, [r7, #16]
 8005eb6:	ea6f 0303 	mvn.w	r3, r3
 8005eba:	697a      	ldr	r2, [r7, #20]
 8005ebc:	4013      	ands	r3, r2
 8005ebe:	617b      	str	r3, [r7, #20]
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
 8005ec0:	7879      	ldrb	r1, [r7, #1]
 8005ec2:	78fa      	ldrb	r2, [r7, #3]
 8005ec4:	4613      	mov	r3, r2
 8005ec6:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8005eca:	189b      	adds	r3, r3, r2
 8005ecc:	fa01 f303 	lsl.w	r3, r1, r3
 8005ed0:	613b      	str	r3, [r7, #16]
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 8005ed2:	697a      	ldr	r2, [r7, #20]
 8005ed4:	693b      	ldr	r3, [r7, #16]
 8005ed6:	4313      	orrs	r3, r2
 8005ed8:	617b      	str	r3, [r7, #20]
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
 8005eda:	687b      	ldr	r3, [r7, #4]
 8005edc:	697a      	ldr	r2, [r7, #20]
 8005ede:	611a      	str	r2, [r3, #16]
  }
  /* Rank configuration */
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
 8005ee0:	687b      	ldr	r3, [r7, #4]
 8005ee2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005ee4:	617b      	str	r3, [r7, #20]
  /* Get JL value: Number = JL+1 */
  tmpreg3 =  (tmpreg1 & JSQR_JL_SET)>> 20;
 8005ee6:	697b      	ldr	r3, [r7, #20]
 8005ee8:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 8005eec:	ea4f 5313 	mov.w	r3, r3, lsr #20
 8005ef0:	60fb      	str	r3, [r7, #12]
  /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = JSQR_JSQ_SET << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
 8005ef2:	68fb      	ldr	r3, [r7, #12]
 8005ef4:	b2db      	uxtb	r3, r3
 8005ef6:	ea6f 0303 	mvn.w	r3, r3
 8005efa:	b2da      	uxtb	r2, r3
 8005efc:	78bb      	ldrb	r3, [r7, #2]
 8005efe:	18d3      	adds	r3, r2, r3
 8005f00:	b2db      	uxtb	r3, r3
 8005f02:	f103 0303 	add.w	r3, r3, #3
 8005f06:	b2db      	uxtb	r3, r3
 8005f08:	461a      	mov	r2, r3
 8005f0a:	4613      	mov	r3, r2
 8005f0c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005f10:	189b      	adds	r3, r3, r2
 8005f12:	f04f 021f 	mov.w	r2, #31
 8005f16:	fa02 f303 	lsl.w	r3, r2, r3
 8005f1a:	613b      	str	r3, [r7, #16]
  /* Clear the old JSQx bits for the selected rank */
  tmpreg1 &= ~tmpreg2;
 8005f1c:	693b      	ldr	r3, [r7, #16]
 8005f1e:	ea6f 0303 	mvn.w	r3, r3
 8005f22:	697a      	ldr	r2, [r7, #20]
 8005f24:	4013      	ands	r3, r2
 8005f26:	617b      	str	r3, [r7, #20]
  /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
 8005f28:	78f9      	ldrb	r1, [r7, #3]
 8005f2a:	68fb      	ldr	r3, [r7, #12]
 8005f2c:	b2db      	uxtb	r3, r3
 8005f2e:	ea6f 0303 	mvn.w	r3, r3
 8005f32:	b2da      	uxtb	r2, r3
 8005f34:	78bb      	ldrb	r3, [r7, #2]
 8005f36:	18d3      	adds	r3, r2, r3
 8005f38:	b2db      	uxtb	r3, r3
 8005f3a:	f103 0303 	add.w	r3, r3, #3
 8005f3e:	b2db      	uxtb	r3, r3
 8005f40:	461a      	mov	r2, r3
 8005f42:	4613      	mov	r3, r2
 8005f44:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005f48:	189b      	adds	r3, r3, r2
 8005f4a:	fa01 f303 	lsl.w	r3, r1, r3
 8005f4e:	613b      	str	r3, [r7, #16]
  /* Set the JSQx bits for the selected rank */
  tmpreg1 |= tmpreg2;
 8005f50:	697a      	ldr	r2, [r7, #20]
 8005f52:	693b      	ldr	r3, [r7, #16]
 8005f54:	4313      	orrs	r3, r2
 8005f56:	617b      	str	r3, [r7, #20]
  /* Store the new register value */
  ADCx->JSQR = tmpreg1;
 8005f58:	687b      	ldr	r3, [r7, #4]
 8005f5a:	697a      	ldr	r2, [r7, #20]
 8005f5c:	639a      	str	r2, [r3, #56]	; 0x38
}
 8005f5e:	f107 071c 	add.w	r7, r7, #28
 8005f62:	46bd      	mov	sp, r7
 8005f64:	bc80      	pop	{r7}
 8005f66:	4770      	bx	lr

08005f68 <ADC_InjectedSequencerLengthConfig>:
  * @param  Length: The sequencer length. 
  *          This parameter must be a number between 1 to 4.
  * @retval None
  */
void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
{
 8005f68:	b480      	push	{r7}
 8005f6a:	b085      	sub	sp, #20
 8005f6c:	af00      	add	r7, sp, #0
 8005f6e:	6078      	str	r0, [r7, #4]
 8005f70:	460b      	mov	r3, r1
 8005f72:	70fb      	strb	r3, [r7, #3]
  uint32_t tmpreg1 = 0;
 8005f74:	f04f 0300 	mov.w	r3, #0
 8005f78:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg2 = 0;
 8005f7a:	f04f 0300 	mov.w	r3, #0
 8005f7e:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_LENGTH(Length));
  
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
 8005f80:	687b      	ldr	r3, [r7, #4]
 8005f82:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005f84:	60fb      	str	r3, [r7, #12]
  
  /* Clear the old injected sequence length JL bits */
  tmpreg1 &= JSQR_JL_RESET;
 8005f86:	68fb      	ldr	r3, [r7, #12]
 8005f88:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8005f8c:	60fb      	str	r3, [r7, #12]
  
  /* Set the injected sequence length JL bits */
  tmpreg2 = Length - 1; 
 8005f8e:	78fb      	ldrb	r3, [r7, #3]
 8005f90:	f103 33ff 	add.w	r3, r3, #4294967295
 8005f94:	60bb      	str	r3, [r7, #8]
  tmpreg1 |= tmpreg2 << 20;
 8005f96:	68bb      	ldr	r3, [r7, #8]
 8005f98:	ea4f 5303 	mov.w	r3, r3, lsl #20
 8005f9c:	68fa      	ldr	r2, [r7, #12]
 8005f9e:	4313      	orrs	r3, r2
 8005fa0:	60fb      	str	r3, [r7, #12]
  
  /* Store the new register value */
  ADCx->JSQR = tmpreg1;
 8005fa2:	687b      	ldr	r3, [r7, #4]
 8005fa4:	68fa      	ldr	r2, [r7, #12]
 8005fa6:	639a      	str	r2, [r3, #56]	; 0x38
}
 8005fa8:	f107 0714 	add.w	r7, r7, #20
 8005fac:	46bd      	mov	sp, r7
 8005fae:	bc80      	pop	{r7}
 8005fb0:	4770      	bx	lr
 8005fb2:	bf00      	nop

08005fb4 <ADC_SetInjectedOffset>:
  * @param  Offset: the offset value for the selected ADC injected channel
  *          This parameter must be a 12bit value.
  * @retval None
  */
void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
{
 8005fb4:	b480      	push	{r7}
 8005fb6:	b085      	sub	sp, #20
 8005fb8:	af00      	add	r7, sp, #0
 8005fba:	6078      	str	r0, [r7, #4]
 8005fbc:	4613      	mov	r3, r2
 8005fbe:	460a      	mov	r2, r1
 8005fc0:	70fa      	strb	r2, [r7, #3]
 8005fc2:	803b      	strh	r3, [r7, #0]
    __IO uint32_t tmp = 0;
 8005fc4:	f04f 0300 	mov.w	r3, #0
 8005fc8:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
  assert_param(IS_ADC_OFFSET(Offset));
  
  tmp = (uint32_t)ADCx;
 8005fca:	687b      	ldr	r3, [r7, #4]
 8005fcc:	60fb      	str	r3, [r7, #12]
  tmp += ADC_InjectedChannel;
 8005fce:	78fa      	ldrb	r2, [r7, #3]
 8005fd0:	68fb      	ldr	r3, [r7, #12]
 8005fd2:	18d3      	adds	r3, r2, r3
 8005fd4:	60fb      	str	r3, [r7, #12]
  
  /* Set the selected injected channel data offset */
 *(__IO uint32_t *) tmp = (uint32_t)Offset;
 8005fd6:	68fb      	ldr	r3, [r7, #12]
 8005fd8:	883a      	ldrh	r2, [r7, #0]
 8005fda:	601a      	str	r2, [r3, #0]
}
 8005fdc:	f107 0714 	add.w	r7, r7, #20
 8005fe0:	46bd      	mov	sp, r7
 8005fe2:	bc80      	pop	{r7}
 8005fe4:	4770      	bx	lr
 8005fe6:	bf00      	nop

08005fe8 <ADC_ExternalTrigInjectedConvConfig>:
  *            @arg ADC_ExternalTrigInjecConv_T8_CC4: Timer8 capture compare4 selected 
  *            @arg ADC_ExternalTrigInjecConv_Ext_IT15: External interrupt line 15 event selected                          
  * @retval None
  */
void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
{
 8005fe8:	b480      	push	{r7}
 8005fea:	b085      	sub	sp, #20
 8005fec:	af00      	add	r7, sp, #0
 8005fee:	6078      	str	r0, [r7, #4]
 8005ff0:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8005ff2:	f04f 0300 	mov.w	r3, #0
 8005ff6:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
  
  /* Get the old register value */
  tmpreg = ADCx->CR2;
 8005ff8:	687b      	ldr	r3, [r7, #4]
 8005ffa:	689b      	ldr	r3, [r3, #8]
 8005ffc:	60fb      	str	r3, [r7, #12]
  
  /* Clear the old external event selection for injected group */
  tmpreg &= CR2_JEXTSEL_RESET;
 8005ffe:	68fb      	ldr	r3, [r7, #12]
 8006000:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
 8006004:	60fb      	str	r3, [r7, #12]
  
  /* Set the external event selection for injected group */
  tmpreg |= ADC_ExternalTrigInjecConv;
 8006006:	68fa      	ldr	r2, [r7, #12]
 8006008:	683b      	ldr	r3, [r7, #0]
 800600a:	4313      	orrs	r3, r2
 800600c:	60fb      	str	r3, [r7, #12]
  
  /* Store the new register value */
  ADCx->CR2 = tmpreg;
 800600e:	687b      	ldr	r3, [r7, #4]
 8006010:	68fa      	ldr	r2, [r7, #12]
 8006012:	609a      	str	r2, [r3, #8]
}
 8006014:	f107 0714 	add.w	r7, r7, #20
 8006018:	46bd      	mov	sp, r7
 800601a:	bc80      	pop	{r7}
 800601c:	4770      	bx	lr
 800601e:	bf00      	nop

08006020 <ADC_ExternalTrigInjectedConvEdgeConfig>:
  *            @arg ADC_ExternalTrigInjecConvEdge_RisingFalling: detection on both rising 
  *                                                               and falling edge
  * @retval None
  */
void ADC_ExternalTrigInjectedConvEdgeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConvEdge)
{
 8006020:	b480      	push	{r7}
 8006022:	b085      	sub	sp, #20
 8006024:	af00      	add	r7, sp, #0
 8006026:	6078      	str	r0, [r7, #4]
 8006028:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 800602a:	f04f 0300 	mov.w	r3, #0
 800602e:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(ADC_ExternalTrigInjecConvEdge));
  /* Get the old register value */
  tmpreg = ADCx->CR2;
 8006030:	687b      	ldr	r3, [r7, #4]
 8006032:	689b      	ldr	r3, [r3, #8]
 8006034:	60fb      	str	r3, [r7, #12]
  /* Clear the old external trigger edge for injected group */
  tmpreg &= CR2_JEXTEN_RESET;
 8006036:	68fb      	ldr	r3, [r7, #12]
 8006038:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 800603c:	60fb      	str	r3, [r7, #12]
  /* Set the new external trigger edge for injected group */
  tmpreg |= ADC_ExternalTrigInjecConvEdge;
 800603e:	68fa      	ldr	r2, [r7, #12]
 8006040:	683b      	ldr	r3, [r7, #0]
 8006042:	4313      	orrs	r3, r2
 8006044:	60fb      	str	r3, [r7, #12]
  /* Store the new register value */
  ADCx->CR2 = tmpreg;
 8006046:	687b      	ldr	r3, [r7, #4]
 8006048:	68fa      	ldr	r2, [r7, #12]
 800604a:	609a      	str	r2, [r3, #8]
}
 800604c:	f107 0714 	add.w	r7, r7, #20
 8006050:	46bd      	mov	sp, r7
 8006052:	bc80      	pop	{r7}
 8006054:	4770      	bx	lr
 8006056:	bf00      	nop

08006058 <ADC_SoftwareStartInjectedConv>:
  * @brief  Enables the selected ADC software start conversion of the injected channels.
  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
  * @retval None
  */
void ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx)
{
 8006058:	b480      	push	{r7}
 800605a:	b083      	sub	sp, #12
 800605c:	af00      	add	r7, sp, #0
 800605e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Enable the selected ADC conversion for injected group */
  ADCx->CR2 |= (uint32_t)ADC_CR2_JSWSTART;
 8006060:	687b      	ldr	r3, [r7, #4]
 8006062:	689b      	ldr	r3, [r3, #8]
 8006064:	f443 0280 	orr.w	r2, r3, #4194304	; 0x400000
 8006068:	687b      	ldr	r3, [r7, #4]
 800606a:	609a      	str	r2, [r3, #8]
}
 800606c:	f107 070c 	add.w	r7, r7, #12
 8006070:	46bd      	mov	sp, r7
 8006072:	bc80      	pop	{r7}
 8006074:	4770      	bx	lr
 8006076:	bf00      	nop

08006078 <ADC_GetSoftwareStartInjectedConvCmdStatus>:
  * @brief  Gets the selected ADC Software start injected conversion Status.
  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
  * @retval The new state of ADC software start injected conversion (SET or RESET).
  */
FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
{
 8006078:	b480      	push	{r7}
 800607a:	b085      	sub	sp, #20
 800607c:	af00      	add	r7, sp, #0
 800607e:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
 8006080:	f04f 0300 	mov.w	r3, #0
 8006084:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Check the status of JSWSTART bit */
  if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
 8006086:	687b      	ldr	r3, [r7, #4]
 8006088:	689b      	ldr	r3, [r3, #8]
 800608a:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800608e:	2b00      	cmp	r3, #0
 8006090:	d003      	beq.n	800609a <ADC_GetSoftwareStartInjectedConvCmdStatus+0x22>
  {
    /* JSWSTART bit is set */
    bitstatus = SET;
 8006092:	f04f 0301 	mov.w	r3, #1
 8006096:	73fb      	strb	r3, [r7, #15]
 8006098:	e002      	b.n	80060a0 <ADC_GetSoftwareStartInjectedConvCmdStatus+0x28>
  }
  else
  {
    /* JSWSTART bit is reset */
    bitstatus = RESET;
 800609a:	f04f 0300 	mov.w	r3, #0
 800609e:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the JSWSTART bit status */
  return  bitstatus;
 80060a0:	7bfb      	ldrb	r3, [r7, #15]
}
 80060a2:	4618      	mov	r0, r3
 80060a4:	f107 0714 	add.w	r7, r7, #20
 80060a8:	46bd      	mov	sp, r7
 80060aa:	bc80      	pop	{r7}
 80060ac:	4770      	bx	lr
 80060ae:	bf00      	nop

080060b0 <ADC_AutoInjectedConvCmd>:
  * @param  NewState: new state of the selected ADC auto injected conversion
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
 80060b0:	b480      	push	{r7}
 80060b2:	b083      	sub	sp, #12
 80060b4:	af00      	add	r7, sp, #0
 80060b6:	6078      	str	r0, [r7, #4]
 80060b8:	460b      	mov	r3, r1
 80060ba:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80060bc:	78fb      	ldrb	r3, [r7, #3]
 80060be:	2b00      	cmp	r3, #0
 80060c0:	d006      	beq.n	80060d0 <ADC_AutoInjectedConvCmd+0x20>
  {
    /* Enable the selected ADC automatic injected group conversion */
    ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;
 80060c2:	687b      	ldr	r3, [r7, #4]
 80060c4:	685b      	ldr	r3, [r3, #4]
 80060c6:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
 80060ca:	687b      	ldr	r3, [r7, #4]
 80060cc:	605a      	str	r2, [r3, #4]
 80060ce:	e005      	b.n	80060dc <ADC_AutoInjectedConvCmd+0x2c>
  }
  else
  {
    /* Disable the selected ADC automatic injected group conversion */
    ADCx->CR1 &= (uint32_t)(~ADC_CR1_JAUTO);
 80060d0:	687b      	ldr	r3, [r7, #4]
 80060d2:	685b      	ldr	r3, [r3, #4]
 80060d4:	f423 6280 	bic.w	r2, r3, #1024	; 0x400
 80060d8:	687b      	ldr	r3, [r7, #4]
 80060da:	605a      	str	r2, [r3, #4]
  }
}
 80060dc:	f107 070c 	add.w	r7, r7, #12
 80060e0:	46bd      	mov	sp, r7
 80060e2:	bc80      	pop	{r7}
 80060e4:	4770      	bx	lr
 80060e6:	bf00      	nop

080060e8 <ADC_InjectedDiscModeCmd>:
  *         group channel.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
 80060e8:	b480      	push	{r7}
 80060ea:	b083      	sub	sp, #12
 80060ec:	af00      	add	r7, sp, #0
 80060ee:	6078      	str	r0, [r7, #4]
 80060f0:	460b      	mov	r3, r1
 80060f2:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80060f4:	78fb      	ldrb	r3, [r7, #3]
 80060f6:	2b00      	cmp	r3, #0
 80060f8:	d006      	beq.n	8006108 <ADC_InjectedDiscModeCmd+0x20>
  {
    /* Enable the selected ADC injected discontinuous mode */
    ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;
 80060fa:	687b      	ldr	r3, [r7, #4]
 80060fc:	685b      	ldr	r3, [r3, #4]
 80060fe:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
 8006102:	687b      	ldr	r3, [r7, #4]
 8006104:	605a      	str	r2, [r3, #4]
 8006106:	e005      	b.n	8006114 <ADC_InjectedDiscModeCmd+0x2c>
  }
  else
  {
    /* Disable the selected ADC injected discontinuous mode */
    ADCx->CR1 &= (uint32_t)(~ADC_CR1_JDISCEN);
 8006108:	687b      	ldr	r3, [r7, #4]
 800610a:	685b      	ldr	r3, [r3, #4]
 800610c:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 8006110:	687b      	ldr	r3, [r7, #4]
 8006112:	605a      	str	r2, [r3, #4]
  }
}
 8006114:	f107 070c 	add.w	r7, r7, #12
 8006118:	46bd      	mov	sp, r7
 800611a:	bc80      	pop	{r7}
 800611c:	4770      	bx	lr
 800611e:	bf00      	nop

08006120 <ADC_GetInjectedConversionValue>:
  *            @arg ADC_InjectedChannel_3: Injected Channel3 selected
  *            @arg ADC_InjectedChannel_4: Injected Channel4 selected
  * @retval The Data conversion value.
  */
uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
{
 8006120:	b480      	push	{r7}
 8006122:	b085      	sub	sp, #20
 8006124:	af00      	add	r7, sp, #0
 8006126:	6078      	str	r0, [r7, #4]
 8006128:	460b      	mov	r3, r1
 800612a:	70fb      	strb	r3, [r7, #3]
  __IO uint32_t tmp = 0;
 800612c:	f04f 0300 	mov.w	r3, #0
 8006130:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));

  tmp = (uint32_t)ADCx;
 8006132:	687b      	ldr	r3, [r7, #4]
 8006134:	60fb      	str	r3, [r7, #12]
  tmp += ADC_InjectedChannel + JDR_OFFSET;
 8006136:	78fa      	ldrb	r2, [r7, #3]
 8006138:	68fb      	ldr	r3, [r7, #12]
 800613a:	18d3      	adds	r3, r2, r3
 800613c:	f103 0328 	add.w	r3, r3, #40	; 0x28
 8006140:	60fb      	str	r3, [r7, #12]
  
  /* Returns the selected injected channel conversion data value */
  return (uint16_t) (*(__IO uint32_t*)  tmp); 
 8006142:	68fb      	ldr	r3, [r7, #12]
 8006144:	681b      	ldr	r3, [r3, #0]
 8006146:	b29b      	uxth	r3, r3
}
 8006148:	4618      	mov	r0, r3
 800614a:	f107 0714 	add.w	r7, r7, #20
 800614e:	46bd      	mov	sp, r7
 8006150:	bc80      	pop	{r7}
 8006152:	4770      	bx	lr

08006154 <ADC_ITConfig>:
  * @param  NewState: new state of the specified ADC interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)  
{
 8006154:	b480      	push	{r7}
 8006156:	b085      	sub	sp, #20
 8006158:	af00      	add	r7, sp, #0
 800615a:	6078      	str	r0, [r7, #4]
 800615c:	4613      	mov	r3, r2
 800615e:	460a      	mov	r2, r1
 8006160:	807a      	strh	r2, [r7, #2]
 8006162:	707b      	strb	r3, [r7, #1]
  uint32_t itmask = 0;
 8006164:	f04f 0300 	mov.w	r3, #0
 8006168:	60fb      	str	r3, [r7, #12]
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_ADC_IT(ADC_IT)); 

  /* Get the ADC IT index */
  itmask = (uint8_t)ADC_IT;
 800616a:	887b      	ldrh	r3, [r7, #2]
 800616c:	b2db      	uxtb	r3, r3
 800616e:	60fb      	str	r3, [r7, #12]
  itmask = (uint32_t)0x01 << itmask;    
 8006170:	68fb      	ldr	r3, [r7, #12]
 8006172:	f04f 0201 	mov.w	r2, #1
 8006176:	fa02 f303 	lsl.w	r3, r2, r3
 800617a:	60fb      	str	r3, [r7, #12]

  if (NewState != DISABLE)
 800617c:	787b      	ldrb	r3, [r7, #1]
 800617e:	2b00      	cmp	r3, #0
 8006180:	d006      	beq.n	8006190 <ADC_ITConfig+0x3c>
  {
    /* Enable the selected ADC interrupts */
    ADCx->CR1 |= itmask;
 8006182:	687b      	ldr	r3, [r7, #4]
 8006184:	685a      	ldr	r2, [r3, #4]
 8006186:	68fb      	ldr	r3, [r7, #12]
 8006188:	431a      	orrs	r2, r3
 800618a:	687b      	ldr	r3, [r7, #4]
 800618c:	605a      	str	r2, [r3, #4]
 800618e:	e007      	b.n	80061a0 <ADC_ITConfig+0x4c>
  }
  else
  {
    /* Disable the selected ADC interrupts */
    ADCx->CR1 &= (~(uint32_t)itmask);
 8006190:	687b      	ldr	r3, [r7, #4]
 8006192:	685a      	ldr	r2, [r3, #4]
 8006194:	68fb      	ldr	r3, [r7, #12]
 8006196:	ea6f 0303 	mvn.w	r3, r3
 800619a:	401a      	ands	r2, r3
 800619c:	687b      	ldr	r3, [r7, #4]
 800619e:	605a      	str	r2, [r3, #4]
  }
}
 80061a0:	f107 0714 	add.w	r7, r7, #20
 80061a4:	46bd      	mov	sp, r7
 80061a6:	bc80      	pop	{r7}
 80061a8:	4770      	bx	lr
 80061aa:	bf00      	nop

080061ac <ADC_GetFlagStatus>:
  *            @arg ADC_FLAG_STRT: Start of regular group conversion flag
  *            @arg ADC_FLAG_OVR: Overrun flag                                                 
  * @retval The new state of ADC_FLAG (SET or RESET).
  */
FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
{
 80061ac:	b480      	push	{r7}
 80061ae:	b085      	sub	sp, #20
 80061b0:	af00      	add	r7, sp, #0
 80061b2:	6078      	str	r0, [r7, #4]
 80061b4:	460b      	mov	r3, r1
 80061b6:	70fb      	strb	r3, [r7, #3]
  FlagStatus bitstatus = RESET;
 80061b8:	f04f 0300 	mov.w	r3, #0
 80061bc:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_GET_FLAG(ADC_FLAG));

  /* Check the status of the specified ADC flag */
  if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
 80061be:	687b      	ldr	r3, [r7, #4]
 80061c0:	681a      	ldr	r2, [r3, #0]
 80061c2:	78fb      	ldrb	r3, [r7, #3]
 80061c4:	4013      	ands	r3, r2
 80061c6:	2b00      	cmp	r3, #0
 80061c8:	d003      	beq.n	80061d2 <ADC_GetFlagStatus+0x26>
  {
    /* ADC_FLAG is set */
    bitstatus = SET;
 80061ca:	f04f 0301 	mov.w	r3, #1
 80061ce:	73fb      	strb	r3, [r7, #15]
 80061d0:	e002      	b.n	80061d8 <ADC_GetFlagStatus+0x2c>
  }
  else
  {
    /* ADC_FLAG is reset */
    bitstatus = RESET;
 80061d2:	f04f 0300 	mov.w	r3, #0
 80061d6:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the ADC_FLAG status */
  return  bitstatus;
 80061d8:	7bfb      	ldrb	r3, [r7, #15]
}
 80061da:	4618      	mov	r0, r3
 80061dc:	f107 0714 	add.w	r7, r7, #20
 80061e0:	46bd      	mov	sp, r7
 80061e2:	bc80      	pop	{r7}
 80061e4:	4770      	bx	lr
 80061e6:	bf00      	nop

080061e8 <ADC_ClearFlag>:
  *            @arg ADC_FLAG_STRT: Start of regular group conversion flag
  *            @arg ADC_FLAG_OVR: Overrun flag                          
  * @retval None
  */
void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
{
 80061e8:	b480      	push	{r7}
 80061ea:	b083      	sub	sp, #12
 80061ec:	af00      	add	r7, sp, #0
 80061ee:	6078      	str	r0, [r7, #4]
 80061f0:	460b      	mov	r3, r1
 80061f2:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));

  /* Clear the selected ADC flags */
  ADCx->SR = ~(uint32_t)ADC_FLAG;
 80061f4:	78fb      	ldrb	r3, [r7, #3]
 80061f6:	ea6f 0203 	mvn.w	r2, r3
 80061fa:	687b      	ldr	r3, [r7, #4]
 80061fc:	601a      	str	r2, [r3, #0]
}
 80061fe:	f107 070c 	add.w	r7, r7, #12
 8006202:	46bd      	mov	sp, r7
 8006204:	bc80      	pop	{r7}
 8006206:	4770      	bx	lr

08006208 <ADC_GetITStatus>:
  *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
  *            @arg ADC_IT_OVR: Overrun interrupt mask                        
  * @retval The new state of ADC_IT (SET or RESET).
  */
ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
{
 8006208:	b480      	push	{r7}
 800620a:	b087      	sub	sp, #28
 800620c:	af00      	add	r7, sp, #0
 800620e:	6078      	str	r0, [r7, #4]
 8006210:	460b      	mov	r3, r1
 8006212:	807b      	strh	r3, [r7, #2]
  ITStatus bitstatus = RESET;
 8006214:	f04f 0300 	mov.w	r3, #0
 8006218:	75fb      	strb	r3, [r7, #23]
  uint32_t itmask = 0, enablestatus = 0;
 800621a:	f04f 0300 	mov.w	r3, #0
 800621e:	613b      	str	r3, [r7, #16]
 8006220:	f04f 0300 	mov.w	r3, #0
 8006224:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_IT(ADC_IT));

  /* Get the ADC IT index */
  itmask = ADC_IT >> 8;
 8006226:	887b      	ldrh	r3, [r7, #2]
 8006228:	ea4f 2313 	mov.w	r3, r3, lsr #8
 800622c:	b29b      	uxth	r3, r3
 800622e:	613b      	str	r3, [r7, #16]

  /* Get the ADC_IT enable bit status */
  enablestatus = (ADCx->CR1 & ((uint32_t)0x01 << (uint8_t)ADC_IT)) ;
 8006230:	687b      	ldr	r3, [r7, #4]
 8006232:	685a      	ldr	r2, [r3, #4]
 8006234:	887b      	ldrh	r3, [r7, #2]
 8006236:	b2db      	uxtb	r3, r3
 8006238:	f04f 0101 	mov.w	r1, #1
 800623c:	fa01 f303 	lsl.w	r3, r1, r3
 8006240:	4013      	ands	r3, r2
 8006242:	60fb      	str	r3, [r7, #12]

  /* Check the status of the specified ADC interrupt */
  if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
 8006244:	687b      	ldr	r3, [r7, #4]
 8006246:	681a      	ldr	r2, [r3, #0]
 8006248:	693b      	ldr	r3, [r7, #16]
 800624a:	4013      	ands	r3, r2
 800624c:	2b00      	cmp	r3, #0
 800624e:	d006      	beq.n	800625e <ADC_GetITStatus+0x56>
 8006250:	68fb      	ldr	r3, [r7, #12]
 8006252:	2b00      	cmp	r3, #0
 8006254:	d003      	beq.n	800625e <ADC_GetITStatus+0x56>
  {
    /* ADC_IT is set */
    bitstatus = SET;
 8006256:	f04f 0301 	mov.w	r3, #1
 800625a:	75fb      	strb	r3, [r7, #23]
 800625c:	e002      	b.n	8006264 <ADC_GetITStatus+0x5c>
  }
  else
  {
    /* ADC_IT is reset */
    bitstatus = RESET;
 800625e:	f04f 0300 	mov.w	r3, #0
 8006262:	75fb      	strb	r3, [r7, #23]
  }
  /* Return the ADC_IT status */
  return  bitstatus;
 8006264:	7dfb      	ldrb	r3, [r7, #23]
}
 8006266:	4618      	mov	r0, r3
 8006268:	f107 071c 	add.w	r7, r7, #28
 800626c:	46bd      	mov	sp, r7
 800626e:	bc80      	pop	{r7}
 8006270:	4770      	bx	lr
 8006272:	bf00      	nop

08006274 <ADC_ClearITPendingBit>:
  *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
  *            @arg ADC_IT_OVR: Overrun interrupt mask                         
  * @retval None
  */
void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
{
 8006274:	b480      	push	{r7}
 8006276:	b085      	sub	sp, #20
 8006278:	af00      	add	r7, sp, #0
 800627a:	6078      	str	r0, [r7, #4]
 800627c:	460b      	mov	r3, r1
 800627e:	807b      	strh	r3, [r7, #2]
  uint8_t itmask = 0;
 8006280:	f04f 0300 	mov.w	r3, #0
 8006284:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_IT(ADC_IT)); 
  /* Get the ADC IT index */
  itmask = (uint8_t)(ADC_IT >> 8);
 8006286:	887b      	ldrh	r3, [r7, #2]
 8006288:	ea4f 2313 	mov.w	r3, r3, lsr #8
 800628c:	b29b      	uxth	r3, r3
 800628e:	73fb      	strb	r3, [r7, #15]
  /* Clear the selected ADC interrupt pending bits */
  ADCx->SR = ~(uint32_t)itmask;
 8006290:	7bfb      	ldrb	r3, [r7, #15]
 8006292:	ea6f 0203 	mvn.w	r2, r3
 8006296:	687b      	ldr	r3, [r7, #4]
 8006298:	601a      	str	r2, [r3, #0]
}                    
 800629a:	f107 0714 	add.w	r7, r7, #20
 800629e:	46bd      	mov	sp, r7
 80062a0:	bc80      	pop	{r7}
 80062a2:	4770      	bx	lr

080062a4 <DMA_DeInit>:
  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
  *         to 7 to select the DMA Stream.
  * @retval None
  */
void DMA_DeInit(DMA_Stream_TypeDef* DMAy_Streamx)
{
 80062a4:	b480      	push	{r7}
 80062a6:	b083      	sub	sp, #12
 80062a8:	af00      	add	r7, sp, #0
 80062aa:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Disable the selected DMAy Streamx */
  DMAy_Streamx->CR &= ~((uint32_t)DMA_SxCR_EN);
 80062ac:	687b      	ldr	r3, [r7, #4]
 80062ae:	681b      	ldr	r3, [r3, #0]
 80062b0:	f023 0201 	bic.w	r2, r3, #1
 80062b4:	687b      	ldr	r3, [r7, #4]
 80062b6:	601a      	str	r2, [r3, #0]

  /* Reset DMAy Streamx control register */
  DMAy_Streamx->CR  = 0;
 80062b8:	687b      	ldr	r3, [r7, #4]
 80062ba:	f04f 0200 	mov.w	r2, #0
 80062be:	601a      	str	r2, [r3, #0]
  
  /* Reset DMAy Streamx Number of Data to Transfer register */
  DMAy_Streamx->NDTR = 0;
 80062c0:	687b      	ldr	r3, [r7, #4]
 80062c2:	f04f 0200 	mov.w	r2, #0
 80062c6:	605a      	str	r2, [r3, #4]
  
  /* Reset DMAy Streamx peripheral address register */
  DMAy_Streamx->PAR  = 0;
 80062c8:	687b      	ldr	r3, [r7, #4]
 80062ca:	f04f 0200 	mov.w	r2, #0
 80062ce:	609a      	str	r2, [r3, #8]
  
  /* Reset DMAy Streamx memory 0 address register */
  DMAy_Streamx->M0AR = 0;
 80062d0:	687b      	ldr	r3, [r7, #4]
 80062d2:	f04f 0200 	mov.w	r2, #0
 80062d6:	60da      	str	r2, [r3, #12]

  /* Reset DMAy Streamx memory 1 address register */
  DMAy_Streamx->M1AR = 0;
 80062d8:	687b      	ldr	r3, [r7, #4]
 80062da:	f04f 0200 	mov.w	r2, #0
 80062de:	611a      	str	r2, [r3, #16]

  /* Reset DMAy Streamx FIFO control register */
  DMAy_Streamx->FCR = (uint32_t)0x00000021; 
 80062e0:	687b      	ldr	r3, [r7, #4]
 80062e2:	f04f 0221 	mov.w	r2, #33	; 0x21
 80062e6:	615a      	str	r2, [r3, #20]

  /* Reset interrupt pending bits for the selected stream */
  if (DMAy_Streamx == DMA1_Stream0)
 80062e8:	687a      	ldr	r2, [r7, #4]
 80062ea:	4b46      	ldr	r3, [pc, #280]	; (8006404 <DMA_DeInit+0x160>)
 80062ec:	429a      	cmp	r2, r3
 80062ee:	d104      	bne.n	80062fa <DMA_DeInit+0x56>
  {
    /* Reset interrupt pending bits for DMA1 Stream0 */
    DMA1->LIFCR = DMA_Stream0_IT_MASK;
 80062f0:	4b45      	ldr	r3, [pc, #276]	; (8006408 <DMA_DeInit+0x164>)
 80062f2:	f04f 023d 	mov.w	r2, #61	; 0x3d
 80062f6:	609a      	str	r2, [r3, #8]
 80062f8:	e07f      	b.n	80063fa <DMA_DeInit+0x156>
  }
  else if (DMAy_Streamx == DMA1_Stream1)
 80062fa:	687a      	ldr	r2, [r7, #4]
 80062fc:	4b43      	ldr	r3, [pc, #268]	; (800640c <DMA_DeInit+0x168>)
 80062fe:	429a      	cmp	r2, r3
 8006300:	d104      	bne.n	800630c <DMA_DeInit+0x68>
  {
    /* Reset interrupt pending bits for DMA1 Stream1 */
    DMA1->LIFCR = DMA_Stream1_IT_MASK;
 8006302:	4b41      	ldr	r3, [pc, #260]	; (8006408 <DMA_DeInit+0x164>)
 8006304:	f44f 6274 	mov.w	r2, #3904	; 0xf40
 8006308:	609a      	str	r2, [r3, #8]
 800630a:	e076      	b.n	80063fa <DMA_DeInit+0x156>
  }
  else if (DMAy_Streamx == DMA1_Stream2)
 800630c:	687a      	ldr	r2, [r7, #4]
 800630e:	4b40      	ldr	r3, [pc, #256]	; (8006410 <DMA_DeInit+0x16c>)
 8006310:	429a      	cmp	r2, r3
 8006312:	d104      	bne.n	800631e <DMA_DeInit+0x7a>
  {
    /* Reset interrupt pending bits for DMA1 Stream2 */
    DMA1->LIFCR = DMA_Stream2_IT_MASK;
 8006314:	4b3c      	ldr	r3, [pc, #240]	; (8006408 <DMA_DeInit+0x164>)
 8006316:	f44f 1274 	mov.w	r2, #3997696	; 0x3d0000
 800631a:	609a      	str	r2, [r3, #8]
 800631c:	e06d      	b.n	80063fa <DMA_DeInit+0x156>
  }
  else if (DMAy_Streamx == DMA1_Stream3)
 800631e:	687a      	ldr	r2, [r7, #4]
 8006320:	4b3c      	ldr	r3, [pc, #240]	; (8006414 <DMA_DeInit+0x170>)
 8006322:	429a      	cmp	r2, r3
 8006324:	d104      	bne.n	8006330 <DMA_DeInit+0x8c>
  {
    /* Reset interrupt pending bits for DMA1 Stream3 */
    DMA1->LIFCR = DMA_Stream3_IT_MASK;
 8006326:	4b38      	ldr	r3, [pc, #224]	; (8006408 <DMA_DeInit+0x164>)
 8006328:	f04f 6274 	mov.w	r2, #255852544	; 0xf400000
 800632c:	609a      	str	r2, [r3, #8]
 800632e:	e064      	b.n	80063fa <DMA_DeInit+0x156>
  }
  else if (DMAy_Streamx == DMA1_Stream4)
 8006330:	687a      	ldr	r2, [r7, #4]
 8006332:	4b39      	ldr	r3, [pc, #228]	; (8006418 <DMA_DeInit+0x174>)
 8006334:	429a      	cmp	r2, r3
 8006336:	d103      	bne.n	8006340 <DMA_DeInit+0x9c>
  {
    /* Reset interrupt pending bits for DMA1 Stream4 */
    DMA1->HIFCR = DMA_Stream4_IT_MASK;
 8006338:	4b33      	ldr	r3, [pc, #204]	; (8006408 <DMA_DeInit+0x164>)
 800633a:	4a38      	ldr	r2, [pc, #224]	; (800641c <DMA_DeInit+0x178>)
 800633c:	60da      	str	r2, [r3, #12]
 800633e:	e05c      	b.n	80063fa <DMA_DeInit+0x156>
  }
  else if (DMAy_Streamx == DMA1_Stream5)
 8006340:	687a      	ldr	r2, [r7, #4]
 8006342:	4b37      	ldr	r3, [pc, #220]	; (8006420 <DMA_DeInit+0x17c>)
 8006344:	429a      	cmp	r2, r3
 8006346:	d103      	bne.n	8006350 <DMA_DeInit+0xac>
  {
    /* Reset interrupt pending bits for DMA1 Stream5 */
    DMA1->HIFCR = DMA_Stream5_IT_MASK;
 8006348:	4b2f      	ldr	r3, [pc, #188]	; (8006408 <DMA_DeInit+0x164>)
 800634a:	4a36      	ldr	r2, [pc, #216]	; (8006424 <DMA_DeInit+0x180>)
 800634c:	60da      	str	r2, [r3, #12]
 800634e:	e054      	b.n	80063fa <DMA_DeInit+0x156>
  }
  else if (DMAy_Streamx == DMA1_Stream6)
 8006350:	687a      	ldr	r2, [r7, #4]
 8006352:	4b35      	ldr	r3, [pc, #212]	; (8006428 <DMA_DeInit+0x184>)
 8006354:	429a      	cmp	r2, r3
 8006356:	d103      	bne.n	8006360 <DMA_DeInit+0xbc>
  {
    /* Reset interrupt pending bits for DMA1 Stream6 */
    DMA1->HIFCR = (uint32_t)DMA_Stream6_IT_MASK;
 8006358:	4b2b      	ldr	r3, [pc, #172]	; (8006408 <DMA_DeInit+0x164>)
 800635a:	4a34      	ldr	r2, [pc, #208]	; (800642c <DMA_DeInit+0x188>)
 800635c:	60da      	str	r2, [r3, #12]
 800635e:	e04c      	b.n	80063fa <DMA_DeInit+0x156>
  }
  else if (DMAy_Streamx == DMA1_Stream7)
 8006360:	687a      	ldr	r2, [r7, #4]
 8006362:	4b33      	ldr	r3, [pc, #204]	; (8006430 <DMA_DeInit+0x18c>)
 8006364:	429a      	cmp	r2, r3
 8006366:	d104      	bne.n	8006372 <DMA_DeInit+0xce>
  {
    /* Reset interrupt pending bits for DMA1 Stream7 */
    DMA1->HIFCR = DMA_Stream7_IT_MASK;
 8006368:	4b27      	ldr	r3, [pc, #156]	; (8006408 <DMA_DeInit+0x164>)
 800636a:	f04f 523d 	mov.w	r2, #792723456	; 0x2f400000
 800636e:	60da      	str	r2, [r3, #12]
 8006370:	e043      	b.n	80063fa <DMA_DeInit+0x156>
  }
  else if (DMAy_Streamx == DMA2_Stream0)
 8006372:	687a      	ldr	r2, [r7, #4]
 8006374:	4b2f      	ldr	r3, [pc, #188]	; (8006434 <DMA_DeInit+0x190>)
 8006376:	429a      	cmp	r2, r3
 8006378:	d104      	bne.n	8006384 <DMA_DeInit+0xe0>
  {
    /* Reset interrupt pending bits for DMA2 Stream0 */
    DMA2->LIFCR = DMA_Stream0_IT_MASK;
 800637a:	4b2f      	ldr	r3, [pc, #188]	; (8006438 <DMA_DeInit+0x194>)
 800637c:	f04f 023d 	mov.w	r2, #61	; 0x3d
 8006380:	609a      	str	r2, [r3, #8]
 8006382:	e03a      	b.n	80063fa <DMA_DeInit+0x156>
  }
  else if (DMAy_Streamx == DMA2_Stream1)
 8006384:	687a      	ldr	r2, [r7, #4]
 8006386:	4b2d      	ldr	r3, [pc, #180]	; (800643c <DMA_DeInit+0x198>)
 8006388:	429a      	cmp	r2, r3
 800638a:	d104      	bne.n	8006396 <DMA_DeInit+0xf2>
  {
    /* Reset interrupt pending bits for DMA2 Stream1 */
    DMA2->LIFCR = DMA_Stream1_IT_MASK;
 800638c:	4b2a      	ldr	r3, [pc, #168]	; (8006438 <DMA_DeInit+0x194>)
 800638e:	f44f 6274 	mov.w	r2, #3904	; 0xf40
 8006392:	609a      	str	r2, [r3, #8]
 8006394:	e031      	b.n	80063fa <DMA_DeInit+0x156>
  }
  else if (DMAy_Streamx == DMA2_Stream2)
 8006396:	687a      	ldr	r2, [r7, #4]
 8006398:	4b29      	ldr	r3, [pc, #164]	; (8006440 <DMA_DeInit+0x19c>)
 800639a:	429a      	cmp	r2, r3
 800639c:	d104      	bne.n	80063a8 <DMA_DeInit+0x104>
  {
    /* Reset interrupt pending bits for DMA2 Stream2 */
    DMA2->LIFCR = DMA_Stream2_IT_MASK;
 800639e:	4b26      	ldr	r3, [pc, #152]	; (8006438 <DMA_DeInit+0x194>)
 80063a0:	f44f 1274 	mov.w	r2, #3997696	; 0x3d0000
 80063a4:	609a      	str	r2, [r3, #8]
 80063a6:	e028      	b.n	80063fa <DMA_DeInit+0x156>
  }
  else if (DMAy_Streamx == DMA2_Stream3)
 80063a8:	687a      	ldr	r2, [r7, #4]
 80063aa:	4b26      	ldr	r3, [pc, #152]	; (8006444 <DMA_DeInit+0x1a0>)
 80063ac:	429a      	cmp	r2, r3
 80063ae:	d104      	bne.n	80063ba <DMA_DeInit+0x116>
  {
    /* Reset interrupt pending bits for DMA2 Stream3 */
    DMA2->LIFCR = DMA_Stream3_IT_MASK;
 80063b0:	4b21      	ldr	r3, [pc, #132]	; (8006438 <DMA_DeInit+0x194>)
 80063b2:	f04f 6274 	mov.w	r2, #255852544	; 0xf400000
 80063b6:	609a      	str	r2, [r3, #8]
 80063b8:	e01f      	b.n	80063fa <DMA_DeInit+0x156>
  }
  else if (DMAy_Streamx == DMA2_Stream4)
 80063ba:	687a      	ldr	r2, [r7, #4]
 80063bc:	4b22      	ldr	r3, [pc, #136]	; (8006448 <DMA_DeInit+0x1a4>)
 80063be:	429a      	cmp	r2, r3
 80063c0:	d103      	bne.n	80063ca <DMA_DeInit+0x126>
  {
    /* Reset interrupt pending bits for DMA2 Stream4 */
    DMA2->HIFCR = DMA_Stream4_IT_MASK;
 80063c2:	4b1d      	ldr	r3, [pc, #116]	; (8006438 <DMA_DeInit+0x194>)
 80063c4:	4a15      	ldr	r2, [pc, #84]	; (800641c <DMA_DeInit+0x178>)
 80063c6:	60da      	str	r2, [r3, #12]
 80063c8:	e017      	b.n	80063fa <DMA_DeInit+0x156>
  }
  else if (DMAy_Streamx == DMA2_Stream5)
 80063ca:	687a      	ldr	r2, [r7, #4]
 80063cc:	4b1f      	ldr	r3, [pc, #124]	; (800644c <DMA_DeInit+0x1a8>)
 80063ce:	429a      	cmp	r2, r3
 80063d0:	d103      	bne.n	80063da <DMA_DeInit+0x136>
  {
    /* Reset interrupt pending bits for DMA2 Stream5 */
    DMA2->HIFCR = DMA_Stream5_IT_MASK;
 80063d2:	4b19      	ldr	r3, [pc, #100]	; (8006438 <DMA_DeInit+0x194>)
 80063d4:	4a13      	ldr	r2, [pc, #76]	; (8006424 <DMA_DeInit+0x180>)
 80063d6:	60da      	str	r2, [r3, #12]
 80063d8:	e00f      	b.n	80063fa <DMA_DeInit+0x156>
  }
  else if (DMAy_Streamx == DMA2_Stream6)
 80063da:	687a      	ldr	r2, [r7, #4]
 80063dc:	4b1c      	ldr	r3, [pc, #112]	; (8006450 <DMA_DeInit+0x1ac>)
 80063de:	429a      	cmp	r2, r3
 80063e0:	d103      	bne.n	80063ea <DMA_DeInit+0x146>
  {
    /* Reset interrupt pending bits for DMA2 Stream6 */
    DMA2->HIFCR = DMA_Stream6_IT_MASK;
 80063e2:	4b15      	ldr	r3, [pc, #84]	; (8006438 <DMA_DeInit+0x194>)
 80063e4:	4a11      	ldr	r2, [pc, #68]	; (800642c <DMA_DeInit+0x188>)
 80063e6:	60da      	str	r2, [r3, #12]
 80063e8:	e007      	b.n	80063fa <DMA_DeInit+0x156>
  }
  else 
  {
    if (DMAy_Streamx == DMA2_Stream7)
 80063ea:	687a      	ldr	r2, [r7, #4]
 80063ec:	4b19      	ldr	r3, [pc, #100]	; (8006454 <DMA_DeInit+0x1b0>)
 80063ee:	429a      	cmp	r2, r3
 80063f0:	d103      	bne.n	80063fa <DMA_DeInit+0x156>
    {
      /* Reset interrupt pending bits for DMA2 Stream7 */
      DMA2->HIFCR = DMA_Stream7_IT_MASK;
 80063f2:	4b11      	ldr	r3, [pc, #68]	; (8006438 <DMA_DeInit+0x194>)
 80063f4:	f04f 523d 	mov.w	r2, #792723456	; 0x2f400000
 80063f8:	60da      	str	r2, [r3, #12]
    }
  }
}
 80063fa:	f107 070c 	add.w	r7, r7, #12
 80063fe:	46bd      	mov	sp, r7
 8006400:	bc80      	pop	{r7}
 8006402:	4770      	bx	lr
 8006404:	40026010 	.word	0x40026010
 8006408:	40026000 	.word	0x40026000
 800640c:	40026028 	.word	0x40026028
 8006410:	40026040 	.word	0x40026040
 8006414:	40026058 	.word	0x40026058
 8006418:	40026070 	.word	0x40026070
 800641c:	2000003d 	.word	0x2000003d
 8006420:	40026088 	.word	0x40026088
 8006424:	20000f40 	.word	0x20000f40
 8006428:	400260a0 	.word	0x400260a0
 800642c:	203d0000 	.word	0x203d0000
 8006430:	400260b8 	.word	0x400260b8
 8006434:	40026410 	.word	0x40026410
 8006438:	40026400 	.word	0x40026400
 800643c:	40026428 	.word	0x40026428
 8006440:	40026440 	.word	0x40026440
 8006444:	40026458 	.word	0x40026458
 8006448:	40026470 	.word	0x40026470
 800644c:	40026488 	.word	0x40026488
 8006450:	400264a0 	.word	0x400264a0
 8006454:	400264b8 	.word	0x400264b8

08006458 <DMA_Init>:
  * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that contains
  *         the configuration information for the specified DMA Stream.  
  * @retval None
  */
void DMA_Init(DMA_Stream_TypeDef* DMAy_Streamx, DMA_InitTypeDef* DMA_InitStruct)
{
 8006458:	b480      	push	{r7}
 800645a:	b085      	sub	sp, #20
 800645c:	af00      	add	r7, sp, #0
 800645e:	6078      	str	r0, [r7, #4]
 8006460:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8006462:	f04f 0300 	mov.w	r3, #0
 8006466:	60fb      	str	r3, [r7, #12]
  assert_param(IS_DMA_MEMORY_BURST(DMA_InitStruct->DMA_MemoryBurst));
  assert_param(IS_DMA_PERIPHERAL_BURST(DMA_InitStruct->DMA_PeripheralBurst));

  /*------------------------- DMAy Streamx CR Configuration ------------------*/
  /* Get the DMAy_Streamx CR value */
  tmpreg = DMAy_Streamx->CR;
 8006468:	687b      	ldr	r3, [r7, #4]
 800646a:	681b      	ldr	r3, [r3, #0]
 800646c:	60fb      	str	r3, [r7, #12]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 800646e:	68fa      	ldr	r2, [r7, #12]
 8006470:	4b24      	ldr	r3, [pc, #144]	; (8006504 <DMA_Init+0xac>)
 8006472:	4013      	ands	r3, r2
 8006474:	60fb      	str	r3, [r7, #12]
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set CIRC bit according to DMA_Mode value */
  /* Set PL bits according to DMA_Priority value */
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 8006476:	683b      	ldr	r3, [r7, #0]
 8006478:	681a      	ldr	r2, [r3, #0]
 800647a:	683b      	ldr	r3, [r7, #0]
 800647c:	68db      	ldr	r3, [r3, #12]
 800647e:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8006480:	683b      	ldr	r3, [r7, #0]
 8006482:	695b      	ldr	r3, [r3, #20]
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set CIRC bit according to DMA_Mode value */
  /* Set PL bits according to DMA_Priority value */
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 8006484:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8006486:	683b      	ldr	r3, [r7, #0]
 8006488:	699b      	ldr	r3, [r3, #24]
 800648a:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 800648c:	683b      	ldr	r3, [r7, #0]
 800648e:	69db      	ldr	r3, [r3, #28]
  /* Set CIRC bit according to DMA_Mode value */
  /* Set PL bits according to DMA_Priority value */
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8006490:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 8006492:	683b      	ldr	r3, [r7, #0]
 8006494:	6a1b      	ldr	r3, [r3, #32]
 8006496:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
 8006498:	683b      	ldr	r3, [r7, #0]
 800649a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  /* Set PL bits according to DMA_Priority value */
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 800649c:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
 800649e:	683b      	ldr	r3, [r7, #0]
 80064a0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80064a2:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;
 80064a4:	683b      	ldr	r3, [r7, #0]
 80064a6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
 80064a8:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;
 80064aa:	683b      	ldr	r3, [r7, #0]
 80064ac:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80064ae:	4313      	orrs	r3, r2
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set CIRC bit according to DMA_Mode value */
  /* Set PL bits according to DMA_Priority value */
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 80064b0:	68fa      	ldr	r2, [r7, #12]
 80064b2:	4313      	orrs	r3, r2
 80064b4:	60fb      	str	r3, [r7, #12]
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
            DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;

  /* Write to DMAy Streamx CR register */
  DMAy_Streamx->CR = tmpreg;
 80064b6:	687b      	ldr	r3, [r7, #4]
 80064b8:	68fa      	ldr	r2, [r7, #12]
 80064ba:	601a      	str	r2, [r3, #0]

  /*------------------------- DMAy Streamx FCR Configuration -----------------*/
  /* Get the DMAy_Streamx FCR value */
  tmpreg = DMAy_Streamx->FCR;
 80064bc:	687b      	ldr	r3, [r7, #4]
 80064be:	695b      	ldr	r3, [r3, #20]
 80064c0:	60fb      	str	r3, [r7, #12]

  /* Clear DMDIS and FTH bits */
  tmpreg &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 80064c2:	68fb      	ldr	r3, [r7, #12]
 80064c4:	f023 0307 	bic.w	r3, r3, #7
 80064c8:	60fb      	str	r3, [r7, #12]

  /* Configure DMAy Streamx FIFO: 
    Set DMDIS bits according to DMA_FIFOMode value 
    Set FTH bits according to DMA_FIFOThreshold value */
  tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
 80064ca:	683b      	ldr	r3, [r7, #0]
 80064cc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80064ce:	683b      	ldr	r3, [r7, #0]
 80064d0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80064d2:	4313      	orrs	r3, r2
 80064d4:	68fa      	ldr	r2, [r7, #12]
 80064d6:	4313      	orrs	r3, r2
 80064d8:	60fb      	str	r3, [r7, #12]

  /* Write to DMAy Streamx CR */
  DMAy_Streamx->FCR = tmpreg;
 80064da:	687b      	ldr	r3, [r7, #4]
 80064dc:	68fa      	ldr	r2, [r7, #12]
 80064de:	615a      	str	r2, [r3, #20]

  /*------------------------- DMAy Streamx NDTR Configuration ----------------*/
  /* Write to DMAy Streamx NDTR register */
  DMAy_Streamx->NDTR = DMA_InitStruct->DMA_BufferSize;
 80064e0:	683b      	ldr	r3, [r7, #0]
 80064e2:	691a      	ldr	r2, [r3, #16]
 80064e4:	687b      	ldr	r3, [r7, #4]
 80064e6:	605a      	str	r2, [r3, #4]

  /*------------------------- DMAy Streamx PAR Configuration -----------------*/
  /* Write to DMAy Streamx PAR */
  DMAy_Streamx->PAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 80064e8:	683b      	ldr	r3, [r7, #0]
 80064ea:	685a      	ldr	r2, [r3, #4]
 80064ec:	687b      	ldr	r3, [r7, #4]
 80064ee:	609a      	str	r2, [r3, #8]

  /*------------------------- DMAy Streamx M0AR Configuration ----------------*/
  /* Write to DMAy Streamx M0AR */
  DMAy_Streamx->M0AR = DMA_InitStruct->DMA_Memory0BaseAddr;
 80064f0:	683b      	ldr	r3, [r7, #0]
 80064f2:	689a      	ldr	r2, [r3, #8]
 80064f4:	687b      	ldr	r3, [r7, #4]
 80064f6:	60da      	str	r2, [r3, #12]
}
 80064f8:	f107 0714 	add.w	r7, r7, #20
 80064fc:	46bd      	mov	sp, r7
 80064fe:	bc80      	pop	{r7}
 8006500:	4770      	bx	lr
 8006502:	bf00      	nop
 8006504:	f01c803f 	.word	0xf01c803f

08006508 <DMA_StructInit>:
  * @param  DMA_InitStruct : pointer to a DMA_InitTypeDef structure which will 
  *         be initialized.
  * @retval None
  */
void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
{
 8006508:	b480      	push	{r7}
 800650a:	b083      	sub	sp, #12
 800650c:	af00      	add	r7, sp, #0
 800650e:	6078      	str	r0, [r7, #4]
  /*-------------- Reset DMA init structure parameters values ----------------*/
  /* Initialize the DMA_Channel member */
  DMA_InitStruct->DMA_Channel = 0;
 8006510:	687b      	ldr	r3, [r7, #4]
 8006512:	f04f 0200 	mov.w	r2, #0
 8006516:	601a      	str	r2, [r3, #0]

  /* Initialize the DMA_PeripheralBaseAddr member */
  DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
 8006518:	687b      	ldr	r3, [r7, #4]
 800651a:	f04f 0200 	mov.w	r2, #0
 800651e:	605a      	str	r2, [r3, #4]

  /* Initialize the DMA_Memory0BaseAddr member */
  DMA_InitStruct->DMA_Memory0BaseAddr = 0;
 8006520:	687b      	ldr	r3, [r7, #4]
 8006522:	f04f 0200 	mov.w	r2, #0
 8006526:	609a      	str	r2, [r3, #8]

  /* Initialize the DMA_DIR member */
  DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralToMemory;
 8006528:	687b      	ldr	r3, [r7, #4]
 800652a:	f04f 0200 	mov.w	r2, #0
 800652e:	60da      	str	r2, [r3, #12]

  /* Initialize the DMA_BufferSize member */
  DMA_InitStruct->DMA_BufferSize = 0;
 8006530:	687b      	ldr	r3, [r7, #4]
 8006532:	f04f 0200 	mov.w	r2, #0
 8006536:	611a      	str	r2, [r3, #16]

  /* Initialize the DMA_PeripheralInc member */
  DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8006538:	687b      	ldr	r3, [r7, #4]
 800653a:	f04f 0200 	mov.w	r2, #0
 800653e:	615a      	str	r2, [r3, #20]

  /* Initialize the DMA_MemoryInc member */
  DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
 8006540:	687b      	ldr	r3, [r7, #4]
 8006542:	f04f 0200 	mov.w	r2, #0
 8006546:	619a      	str	r2, [r3, #24]

  /* Initialize the DMA_PeripheralDataSize member */
  DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8006548:	687b      	ldr	r3, [r7, #4]
 800654a:	f04f 0200 	mov.w	r2, #0
 800654e:	61da      	str	r2, [r3, #28]

  /* Initialize the DMA_MemoryDataSize member */
  DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 8006550:	687b      	ldr	r3, [r7, #4]
 8006552:	f04f 0200 	mov.w	r2, #0
 8006556:	621a      	str	r2, [r3, #32]

  /* Initialize the DMA_Mode member */
  DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
 8006558:	687b      	ldr	r3, [r7, #4]
 800655a:	f04f 0200 	mov.w	r2, #0
 800655e:	625a      	str	r2, [r3, #36]	; 0x24

  /* Initialize the DMA_Priority member */
  DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
 8006560:	687b      	ldr	r3, [r7, #4]
 8006562:	f04f 0200 	mov.w	r2, #0
 8006566:	629a      	str	r2, [r3, #40]	; 0x28

  /* Initialize the DMA_FIFOMode member */
  DMA_InitStruct->DMA_FIFOMode = DMA_FIFOMode_Disable;
 8006568:	687b      	ldr	r3, [r7, #4]
 800656a:	f04f 0200 	mov.w	r2, #0
 800656e:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Initialize the DMA_FIFOThreshold member */
  DMA_InitStruct->DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
 8006570:	687b      	ldr	r3, [r7, #4]
 8006572:	f04f 0200 	mov.w	r2, #0
 8006576:	631a      	str	r2, [r3, #48]	; 0x30

  /* Initialize the DMA_MemoryBurst member */
  DMA_InitStruct->DMA_MemoryBurst = DMA_MemoryBurst_Single;
 8006578:	687b      	ldr	r3, [r7, #4]
 800657a:	f04f 0200 	mov.w	r2, #0
 800657e:	635a      	str	r2, [r3, #52]	; 0x34

  /* Initialize the DMA_PeripheralBurst member */
  DMA_InitStruct->DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
 8006580:	687b      	ldr	r3, [r7, #4]
 8006582:	f04f 0200 	mov.w	r2, #0
 8006586:	639a      	str	r2, [r3, #56]	; 0x38
}
 8006588:	f107 070c 	add.w	r7, r7, #12
 800658c:	46bd      	mov	sp, r7
 800658e:	bc80      	pop	{r7}
 8006590:	4770      	bx	lr
 8006592:	bf00      	nop

08006594 <DMA_Cmd>:
  *        this single data is finished.            
  *    
  * @retval None
  */
void DMA_Cmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
{
 8006594:	b480      	push	{r7}
 8006596:	b083      	sub	sp, #12
 8006598:	af00      	add	r7, sp, #0
 800659a:	6078      	str	r0, [r7, #4]
 800659c:	460b      	mov	r3, r1
 800659e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80065a0:	78fb      	ldrb	r3, [r7, #3]
 80065a2:	2b00      	cmp	r3, #0
 80065a4:	d006      	beq.n	80065b4 <DMA_Cmd+0x20>
  {
    /* Enable the selected DMAy Streamx by setting EN bit */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
 80065a6:	687b      	ldr	r3, [r7, #4]
 80065a8:	681b      	ldr	r3, [r3, #0]
 80065aa:	f043 0201 	orr.w	r2, r3, #1
 80065ae:	687b      	ldr	r3, [r7, #4]
 80065b0:	601a      	str	r2, [r3, #0]
 80065b2:	e005      	b.n	80065c0 <DMA_Cmd+0x2c>
  }
  else
  {
    /* Disable the selected DMAy Streamx by clearing EN bit */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_EN;
 80065b4:	687b      	ldr	r3, [r7, #4]
 80065b6:	681b      	ldr	r3, [r3, #0]
 80065b8:	f023 0201 	bic.w	r2, r3, #1
 80065bc:	687b      	ldr	r3, [r7, #4]
 80065be:	601a      	str	r2, [r3, #0]
  }
}
 80065c0:	f107 070c 	add.w	r7, r7, #12
 80065c4:	46bd      	mov	sp, r7
 80065c6:	bc80      	pop	{r7}
 80065c8:	4770      	bx	lr
 80065ca:	bf00      	nop

080065cc <DMA_PeriphIncOffsetSizeConfig>:
  *            @arg DMA_PINCOS_WordAligned: Peripheral address increment offset is 
  *                                         fixed to 4 (32-bit aligned addresses). 
  * @retval None
  */
void DMA_PeriphIncOffsetSizeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_Pincos)
{
 80065cc:	b480      	push	{r7}
 80065ce:	b083      	sub	sp, #12
 80065d0:	af00      	add	r7, sp, #0
 80065d2:	6078      	str	r0, [r7, #4]
 80065d4:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_PINCOS_SIZE(DMA_Pincos));

  /* Check the needed Peripheral increment offset */
  if(DMA_Pincos != DMA_PINCOS_Psize)
 80065d6:	683b      	ldr	r3, [r7, #0]
 80065d8:	2b00      	cmp	r3, #0
 80065da:	d006      	beq.n	80065ea <DMA_PeriphIncOffsetSizeConfig+0x1e>
  {
    /* Configure DMA_SxCR_PINCOS bit with the input parameter */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PINCOS;     
 80065dc:	687b      	ldr	r3, [r7, #4]
 80065de:	681b      	ldr	r3, [r3, #0]
 80065e0:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
 80065e4:	687b      	ldr	r3, [r7, #4]
 80065e6:	601a      	str	r2, [r3, #0]
 80065e8:	e005      	b.n	80065f6 <DMA_PeriphIncOffsetSizeConfig+0x2a>
  }
  else
  {
    /* Clear the PINCOS bit: Peripheral address incremented according to PSIZE */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PINCOS;    
 80065ea:	687b      	ldr	r3, [r7, #4]
 80065ec:	681b      	ldr	r3, [r3, #0]
 80065ee:	f423 4200 	bic.w	r2, r3, #32768	; 0x8000
 80065f2:	687b      	ldr	r3, [r7, #4]
 80065f4:	601a      	str	r2, [r3, #0]
  }
}
 80065f6:	f107 070c 	add.w	r7, r7, #12
 80065fa:	46bd      	mov	sp, r7
 80065fc:	bc80      	pop	{r7}
 80065fe:	4770      	bx	lr

08006600 <DMA_FlowControllerConfig>:
  *            @arg DMA_FlowCtrl_Peripheral: DMAy_Streamx transactions flow controller 
  *                                          is the peripheral.    
  * @retval None
  */
void DMA_FlowControllerConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FlowCtrl)
{
 8006600:	b480      	push	{r7}
 8006602:	b083      	sub	sp, #12
 8006604:	af00      	add	r7, sp, #0
 8006606:	6078      	str	r0, [r7, #4]
 8006608:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_FLOW_CTRL(DMA_FlowCtrl));

  /* Check the needed flow controller  */
  if(DMA_FlowCtrl != DMA_FlowCtrl_Memory)
 800660a:	683b      	ldr	r3, [r7, #0]
 800660c:	2b00      	cmp	r3, #0
 800660e:	d006      	beq.n	800661e <DMA_FlowControllerConfig+0x1e>
  {
    /* Configure DMA_SxCR_PFCTRL bit with the input parameter */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PFCTRL;   
 8006610:	687b      	ldr	r3, [r7, #4]
 8006612:	681b      	ldr	r3, [r3, #0]
 8006614:	f043 0220 	orr.w	r2, r3, #32
 8006618:	687b      	ldr	r3, [r7, #4]
 800661a:	601a      	str	r2, [r3, #0]
 800661c:	e005      	b.n	800662a <DMA_FlowControllerConfig+0x2a>
  }
  else
  {
    /* Clear the PFCTRL bit: Memory is the flow controller */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PFCTRL;    
 800661e:	687b      	ldr	r3, [r7, #4]
 8006620:	681b      	ldr	r3, [r3, #0]
 8006622:	f023 0220 	bic.w	r2, r3, #32
 8006626:	687b      	ldr	r3, [r7, #4]
 8006628:	601a      	str	r2, [r3, #0]
  }
}
 800662a:	f107 070c 	add.w	r7, r7, #12
 800662e:	46bd      	mov	sp, r7
 8006630:	bc80      	pop	{r7}
 8006632:	4770      	bx	lr

08006634 <DMA_SetCurrDataCounter>:
  *         DMAy_SxPAR register is considered as Peripheral.
  *      
  * @retval The number of remaining data units in the current DMAy Streamx transfer.
  */
void DMA_SetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx, uint16_t Counter)
{
 8006634:	b480      	push	{r7}
 8006636:	b083      	sub	sp, #12
 8006638:	af00      	add	r7, sp, #0
 800663a:	6078      	str	r0, [r7, #4]
 800663c:	460b      	mov	r3, r1
 800663e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Write the number of data units to be transferred */
  DMAy_Streamx->NDTR = (uint16_t)Counter;
 8006640:	887a      	ldrh	r2, [r7, #2]
 8006642:	687b      	ldr	r3, [r7, #4]
 8006644:	605a      	str	r2, [r3, #4]
}
 8006646:	f107 070c 	add.w	r7, r7, #12
 800664a:	46bd      	mov	sp, r7
 800664c:	bc80      	pop	{r7}
 800664e:	4770      	bx	lr

08006650 <DMA_GetCurrDataCounter>:
  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
  *          to 7 to select the DMA Stream.
  * @retval The number of remaining data units in the current DMAy Streamx transfer.
  */
uint16_t DMA_GetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx)
{
 8006650:	b480      	push	{r7}
 8006652:	b083      	sub	sp, #12
 8006654:	af00      	add	r7, sp, #0
 8006656:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Return the number of remaining data units for DMAy Streamx */
  return ((uint16_t)(DMAy_Streamx->NDTR));
 8006658:	687b      	ldr	r3, [r7, #4]
 800665a:	685b      	ldr	r3, [r3, #4]
 800665c:	b29b      	uxth	r3, r3
}
 800665e:	4618      	mov	r0, r3
 8006660:	f107 070c 	add.w	r7, r7, #12
 8006664:	46bd      	mov	sp, r7
 8006666:	bc80      	pop	{r7}
 8006668:	4770      	bx	lr
 800666a:	bf00      	nop

0800666c <DMA_DoubleBufferModeConfig>:
  *   
  * @retval None
  */
void DMA_DoubleBufferModeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t Memory1BaseAddr,
                                uint32_t DMA_CurrentMemory)
{  
 800666c:	b480      	push	{r7}
 800666e:	b085      	sub	sp, #20
 8006670:	af00      	add	r7, sp, #0
 8006672:	60f8      	str	r0, [r7, #12]
 8006674:	60b9      	str	r1, [r7, #8]
 8006676:	607a      	str	r2, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CURRENT_MEM(DMA_CurrentMemory));

  if (DMA_CurrentMemory != DMA_Memory_0)
 8006678:	687b      	ldr	r3, [r7, #4]
 800667a:	2b00      	cmp	r3, #0
 800667c:	d006      	beq.n	800668c <DMA_DoubleBufferModeConfig+0x20>
  {
    /* Set Memory 1 as current memory address */
    DMAy_Streamx->CR |= (uint32_t)(DMA_SxCR_CT);    
 800667e:	68fb      	ldr	r3, [r7, #12]
 8006680:	681b      	ldr	r3, [r3, #0]
 8006682:	f443 2200 	orr.w	r2, r3, #524288	; 0x80000
 8006686:	68fb      	ldr	r3, [r7, #12]
 8006688:	601a      	str	r2, [r3, #0]
 800668a:	e005      	b.n	8006698 <DMA_DoubleBufferModeConfig+0x2c>
  }
  else
  {
    /* Set Memory 0 as current memory address */
    DMAy_Streamx->CR &= ~(uint32_t)(DMA_SxCR_CT);    
 800668c:	68fb      	ldr	r3, [r7, #12]
 800668e:	681b      	ldr	r3, [r3, #0]
 8006690:	f423 2200 	bic.w	r2, r3, #524288	; 0x80000
 8006694:	68fb      	ldr	r3, [r7, #12]
 8006696:	601a      	str	r2, [r3, #0]
  }

  /* Write to DMAy Streamx M1AR */
  DMAy_Streamx->M1AR = Memory1BaseAddr;
 8006698:	68fb      	ldr	r3, [r7, #12]
 800669a:	68ba      	ldr	r2, [r7, #8]
 800669c:	611a      	str	r2, [r3, #16]
}
 800669e:	f107 0714 	add.w	r7, r7, #20
 80066a2:	46bd      	mov	sp, r7
 80066a4:	bc80      	pop	{r7}
 80066a6:	4770      	bx	lr

080066a8 <DMA_DoubleBufferModeCmd>:
  * @param  NewState: new state of the DMAy Streamx double buffer mode. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DMA_DoubleBufferModeCmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
{  
 80066a8:	b480      	push	{r7}
 80066aa:	b083      	sub	sp, #12
 80066ac:	af00      	add	r7, sp, #0
 80066ae:	6078      	str	r0, [r7, #4]
 80066b0:	460b      	mov	r3, r1
 80066b2:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Configure the Double Buffer mode */
  if (NewState != DISABLE)
 80066b4:	78fb      	ldrb	r3, [r7, #3]
 80066b6:	2b00      	cmp	r3, #0
 80066b8:	d006      	beq.n	80066c8 <DMA_DoubleBufferModeCmd+0x20>
  {
    /* Enable the Double buffer mode */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_DBM;
 80066ba:	687b      	ldr	r3, [r7, #4]
 80066bc:	681b      	ldr	r3, [r3, #0]
 80066be:	f443 2280 	orr.w	r2, r3, #262144	; 0x40000
 80066c2:	687b      	ldr	r3, [r7, #4]
 80066c4:	601a      	str	r2, [r3, #0]
 80066c6:	e005      	b.n	80066d4 <DMA_DoubleBufferModeCmd+0x2c>
  }
  else
  {
    /* Disable the Double buffer mode */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_DBM;
 80066c8:	687b      	ldr	r3, [r7, #4]
 80066ca:	681b      	ldr	r3, [r3, #0]
 80066cc:	f423 2280 	bic.w	r2, r3, #262144	; 0x40000
 80066d0:	687b      	ldr	r3, [r7, #4]
 80066d2:	601a      	str	r2, [r3, #0]
  }
}
 80066d4:	f107 070c 	add.w	r7, r7, #12
 80066d8:	46bd      	mov	sp, r7
 80066da:	bc80      	pop	{r7}
 80066dc:	4770      	bx	lr
 80066de:	bf00      	nop

080066e0 <DMA_MemoryTargetConfig>:
  *  
  * @retval None
  */
void DMA_MemoryTargetConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t MemoryBaseAddr,
                           uint32_t DMA_MemoryTarget)
{
 80066e0:	b480      	push	{r7}
 80066e2:	b085      	sub	sp, #20
 80066e4:	af00      	add	r7, sp, #0
 80066e6:	60f8      	str	r0, [r7, #12]
 80066e8:	60b9      	str	r1, [r7, #8]
 80066ea:	607a      	str	r2, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CURRENT_MEM(DMA_MemoryTarget));
    
  /* Check the Memory target to be configured */
  if (DMA_MemoryTarget != DMA_Memory_0)
 80066ec:	687b      	ldr	r3, [r7, #4]
 80066ee:	2b00      	cmp	r3, #0
 80066f0:	d003      	beq.n	80066fa <DMA_MemoryTargetConfig+0x1a>
  {
    /* Write to DMAy Streamx M1AR */
    DMAy_Streamx->M1AR = MemoryBaseAddr;    
 80066f2:	68fb      	ldr	r3, [r7, #12]
 80066f4:	68ba      	ldr	r2, [r7, #8]
 80066f6:	611a      	str	r2, [r3, #16]
 80066f8:	e002      	b.n	8006700 <DMA_MemoryTargetConfig+0x20>
  }  
  else
  {
    /* Write to DMAy Streamx M0AR */
    DMAy_Streamx->M0AR = MemoryBaseAddr;  
 80066fa:	68fb      	ldr	r3, [r7, #12]
 80066fc:	68ba      	ldr	r2, [r7, #8]
 80066fe:	60da      	str	r2, [r3, #12]
  }
}
 8006700:	f107 0714 	add.w	r7, r7, #20
 8006704:	46bd      	mov	sp, r7
 8006706:	bc80      	pop	{r7}
 8006708:	4770      	bx	lr
 800670a:	bf00      	nop

0800670c <DMA_GetCurrentMemoryTarget>:
  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
  *          to 7 to select the DMA Stream.
  * @retval The memory target number: 0 for Memory0 or 1 for Memory1. 
  */
uint32_t DMA_GetCurrentMemoryTarget(DMA_Stream_TypeDef* DMAy_Streamx)
{
 800670c:	b480      	push	{r7}
 800670e:	b085      	sub	sp, #20
 8006710:	af00      	add	r7, sp, #0
 8006712:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0;
 8006714:	f04f 0300 	mov.w	r3, #0
 8006718:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Get the current memory target */
  if ((DMAy_Streamx->CR & DMA_SxCR_CT) != 0)
 800671a:	687b      	ldr	r3, [r7, #4]
 800671c:	681b      	ldr	r3, [r3, #0]
 800671e:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8006722:	2b00      	cmp	r3, #0
 8006724:	d003      	beq.n	800672e <DMA_GetCurrentMemoryTarget+0x22>
  {
    /* Current memory buffer used is Memory 1 */
    tmp = 1;
 8006726:	f04f 0301 	mov.w	r3, #1
 800672a:	60fb      	str	r3, [r7, #12]
 800672c:	e002      	b.n	8006734 <DMA_GetCurrentMemoryTarget+0x28>
  }  
  else
  {
    /* Current memory buffer used is Memory 0 */
    tmp = 0;    
 800672e:	f04f 0300 	mov.w	r3, #0
 8006732:	60fb      	str	r3, [r7, #12]
  }
  return tmp;
 8006734:	68fb      	ldr	r3, [r7, #12]
}
 8006736:	4618      	mov	r0, r3
 8006738:	f107 0714 	add.w	r7, r7, #20
 800673c:	46bd      	mov	sp, r7
 800673e:	bc80      	pop	{r7}
 8006740:	4770      	bx	lr
 8006742:	bf00      	nop

08006744 <DMA_GetCmdStatus>:
  *          of this single data is finished.  
  *      
  * @retval Current state of the DMAy Streamx (ENABLE or DISABLE).
  */
FunctionalState DMA_GetCmdStatus(DMA_Stream_TypeDef* DMAy_Streamx)
{
 8006744:	b480      	push	{r7}
 8006746:	b085      	sub	sp, #20
 8006748:	af00      	add	r7, sp, #0
 800674a:	6078      	str	r0, [r7, #4]
  FunctionalState state = DISABLE;
 800674c:	f04f 0300 	mov.w	r3, #0
 8006750:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  if ((DMAy_Streamx->CR & (uint32_t)DMA_SxCR_EN) != 0)
 8006752:	687b      	ldr	r3, [r7, #4]
 8006754:	681b      	ldr	r3, [r3, #0]
 8006756:	f003 0301 	and.w	r3, r3, #1
 800675a:	2b00      	cmp	r3, #0
 800675c:	d003      	beq.n	8006766 <DMA_GetCmdStatus+0x22>
  {
    /* The selected DMAy Streamx EN bit is set (DMA is still transferring) */
    state = ENABLE;
 800675e:	f04f 0301 	mov.w	r3, #1
 8006762:	73fb      	strb	r3, [r7, #15]
 8006764:	e002      	b.n	800676c <DMA_GetCmdStatus+0x28>
  }
  else
  {
    /* The selected DMAy Streamx EN bit is cleared (DMA is disabled and 
        all transfers are complete) */
    state = DISABLE;
 8006766:	f04f 0300 	mov.w	r3, #0
 800676a:	73fb      	strb	r3, [r7, #15]
  }
  return state;
 800676c:	7bfb      	ldrb	r3, [r7, #15]
}
 800676e:	4618      	mov	r0, r3
 8006770:	f107 0714 	add.w	r7, r7, #20
 8006774:	46bd      	mov	sp, r7
 8006776:	bc80      	pop	{r7}
 8006778:	4770      	bx	lr
 800677a:	bf00      	nop

0800677c <DMA_GetFIFOStatus>:
  *           - DMA_FIFOStatus_3QuartersFull: if more than 3 quarters-full.
  *           - DMA_FIFOStatus_Empty: when FIFO is empty
  *           - DMA_FIFOStatus_Full: when FIFO is full
  */
uint32_t DMA_GetFIFOStatus(DMA_Stream_TypeDef* DMAy_Streamx)
{
 800677c:	b480      	push	{r7}
 800677e:	b085      	sub	sp, #20
 8006780:	af00      	add	r7, sp, #0
 8006782:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8006784:	f04f 0300 	mov.w	r3, #0
 8006788:	60fb      	str	r3, [r7, #12]
 
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  
  /* Get the FIFO level bits */
  tmpreg = (uint32_t)((DMAy_Streamx->FCR & DMA_SxFCR_FS));
 800678a:	687b      	ldr	r3, [r7, #4]
 800678c:	695b      	ldr	r3, [r3, #20]
 800678e:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8006792:	60fb      	str	r3, [r7, #12]
  
  return tmpreg;
 8006794:	68fb      	ldr	r3, [r7, #12]
}
 8006796:	4618      	mov	r0, r3
 8006798:	f107 0714 	add.w	r7, r7, #20
 800679c:	46bd      	mov	sp, r7
 800679e:	bc80      	pop	{r7}
 80067a0:	4770      	bx	lr
 80067a2:	bf00      	nop

080067a4 <DMA_GetFlagStatus>:
  *            @arg DMA_FLAG_FEIFx:  Streamx FIFO error flag
  *         Where x can be 0 to 7 to select the DMA Stream.
  * @retval The new state of DMA_FLAG (SET or RESET).
  */
FlagStatus DMA_GetFlagStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
{
 80067a4:	b480      	push	{r7}
 80067a6:	b087      	sub	sp, #28
 80067a8:	af00      	add	r7, sp, #0
 80067aa:	6078      	str	r0, [r7, #4]
 80067ac:	6039      	str	r1, [r7, #0]
  FlagStatus bitstatus = RESET;
 80067ae:	f04f 0300 	mov.w	r3, #0
 80067b2:	75fb      	strb	r3, [r7, #23]
  DMA_TypeDef* DMAy;
  uint32_t tmpreg = 0;
 80067b4:	f04f 0300 	mov.w	r3, #0
 80067b8:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_GET_FLAG(DMA_FLAG));

  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
 80067ba:	687a      	ldr	r2, [r7, #4]
 80067bc:	4b16      	ldr	r3, [pc, #88]	; (8006818 <DMA_GetFlagStatus+0x74>)
 80067be:	429a      	cmp	r2, r3
 80067c0:	d802      	bhi.n	80067c8 <DMA_GetFlagStatus+0x24>
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 80067c2:	4b16      	ldr	r3, [pc, #88]	; (800681c <DMA_GetFlagStatus+0x78>)
 80067c4:	613b      	str	r3, [r7, #16]
 80067c6:	e001      	b.n	80067cc <DMA_GetFlagStatus+0x28>
  } 
  else 
  {
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
 80067c8:	4b15      	ldr	r3, [pc, #84]	; (8006820 <DMA_GetFlagStatus+0x7c>)
 80067ca:	613b      	str	r3, [r7, #16]
  }

  /* Check if the flag is in HISR or LISR */
  if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
 80067cc:	683b      	ldr	r3, [r7, #0]
 80067ce:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 80067d2:	2b00      	cmp	r3, #0
 80067d4:	d003      	beq.n	80067de <DMA_GetFlagStatus+0x3a>
  {
    /* Get DMAy HISR register value */
    tmpreg = DMAy->HISR;
 80067d6:	693b      	ldr	r3, [r7, #16]
 80067d8:	685b      	ldr	r3, [r3, #4]
 80067da:	60fb      	str	r3, [r7, #12]
 80067dc:	e002      	b.n	80067e4 <DMA_GetFlagStatus+0x40>
  }
  else
  {
    /* Get DMAy LISR register value */
    tmpreg = DMAy->LISR;
 80067de:	693b      	ldr	r3, [r7, #16]
 80067e0:	681b      	ldr	r3, [r3, #0]
 80067e2:	60fb      	str	r3, [r7, #12]
  }   
 
  /* Mask the reserved bits */
  tmpreg &= (uint32_t)RESERVED_MASK;
 80067e4:	68fb      	ldr	r3, [r7, #12]
 80067e6:	f023 23f0 	bic.w	r3, r3, #4026593280	; 0xf000f000
 80067ea:	f023 1382 	bic.w	r3, r3, #8519810	; 0x820082
 80067ee:	60fb      	str	r3, [r7, #12]

  /* Check the status of the specified DMA flag */
  if ((tmpreg & DMA_FLAG) != (uint32_t)RESET)
 80067f0:	68fa      	ldr	r2, [r7, #12]
 80067f2:	683b      	ldr	r3, [r7, #0]
 80067f4:	4013      	ands	r3, r2
 80067f6:	2b00      	cmp	r3, #0
 80067f8:	d003      	beq.n	8006802 <DMA_GetFlagStatus+0x5e>
  {
    /* DMA_FLAG is set */
    bitstatus = SET;
 80067fa:	f04f 0301 	mov.w	r3, #1
 80067fe:	75fb      	strb	r3, [r7, #23]
 8006800:	e002      	b.n	8006808 <DMA_GetFlagStatus+0x64>
  }
  else
  {
    /* DMA_FLAG is reset */
    bitstatus = RESET;
 8006802:	f04f 0300 	mov.w	r3, #0
 8006806:	75fb      	strb	r3, [r7, #23]
  }

  /* Return the DMA_FLAG status */
  return  bitstatus;
 8006808:	7dfb      	ldrb	r3, [r7, #23]
}
 800680a:	4618      	mov	r0, r3
 800680c:	f107 071c 	add.w	r7, r7, #28
 8006810:	46bd      	mov	sp, r7
 8006812:	bc80      	pop	{r7}
 8006814:	4770      	bx	lr
 8006816:	bf00      	nop
 8006818:	4002640f 	.word	0x4002640f
 800681c:	40026000 	.word	0x40026000
 8006820:	40026400 	.word	0x40026400

08006824 <DMA_ClearFlag>:
  *            @arg DMA_FLAG_FEIFx:  Streamx FIFO error flag
  *         Where x can be 0 to 7 to select the DMA Stream.   
  * @retval None
  */
void DMA_ClearFlag(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
{
 8006824:	b480      	push	{r7}
 8006826:	b085      	sub	sp, #20
 8006828:	af00      	add	r7, sp, #0
 800682a:	6078      	str	r0, [r7, #4]
 800682c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));

  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
 800682e:	687a      	ldr	r2, [r7, #4]
 8006830:	4b10      	ldr	r3, [pc, #64]	; (8006874 <DMA_ClearFlag+0x50>)
 8006832:	429a      	cmp	r2, r3
 8006834:	d802      	bhi.n	800683c <DMA_ClearFlag+0x18>
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 8006836:	4b10      	ldr	r3, [pc, #64]	; (8006878 <DMA_ClearFlag+0x54>)
 8006838:	60fb      	str	r3, [r7, #12]
 800683a:	e001      	b.n	8006840 <DMA_ClearFlag+0x1c>
  } 
  else 
  {
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
 800683c:	4b0f      	ldr	r3, [pc, #60]	; (800687c <DMA_ClearFlag+0x58>)
 800683e:	60fb      	str	r3, [r7, #12]
  }

  /* Check if LIFCR or HIFCR register is targeted */
  if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
 8006840:	683b      	ldr	r3, [r7, #0]
 8006842:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8006846:	2b00      	cmp	r3, #0
 8006848:	d007      	beq.n	800685a <DMA_ClearFlag+0x36>
  {
    /* Set DMAy HIFCR register clear flag bits */
    DMAy->HIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
 800684a:	683b      	ldr	r3, [r7, #0]
 800684c:	f023 23f0 	bic.w	r3, r3, #4026593280	; 0xf000f000
 8006850:	f023 1382 	bic.w	r3, r3, #8519810	; 0x820082
 8006854:	68fa      	ldr	r2, [r7, #12]
 8006856:	60d3      	str	r3, [r2, #12]
 8006858:	e006      	b.n	8006868 <DMA_ClearFlag+0x44>
  }
  else 
  {
    /* Set DMAy LIFCR register clear flag bits */
    DMAy->LIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
 800685a:	683b      	ldr	r3, [r7, #0]
 800685c:	f023 23f0 	bic.w	r3, r3, #4026593280	; 0xf000f000
 8006860:	f023 1382 	bic.w	r3, r3, #8519810	; 0x820082
 8006864:	68fa      	ldr	r2, [r7, #12]
 8006866:	6093      	str	r3, [r2, #8]
  }    
}
 8006868:	f107 0714 	add.w	r7, r7, #20
 800686c:	46bd      	mov	sp, r7
 800686e:	bc80      	pop	{r7}
 8006870:	4770      	bx	lr
 8006872:	bf00      	nop
 8006874:	4002640f 	.word	0x4002640f
 8006878:	40026000 	.word	0x40026000
 800687c:	40026400 	.word	0x40026400

08006880 <DMA_ITConfig>:
  * @param  NewState: new state of the specified DMA interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DMA_ITConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT, FunctionalState NewState)
{
 8006880:	b480      	push	{r7}
 8006882:	b085      	sub	sp, #20
 8006884:	af00      	add	r7, sp, #0
 8006886:	60f8      	str	r0, [r7, #12]
 8006888:	60b9      	str	r1, [r7, #8]
 800688a:	4613      	mov	r3, r2
 800688c:	71fb      	strb	r3, [r7, #7]
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Check if the DMA_IT parameter contains a FIFO interrupt */
  if ((DMA_IT & DMA_IT_FE) != 0)
 800688e:	68bb      	ldr	r3, [r7, #8]
 8006890:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8006894:	2b00      	cmp	r3, #0
 8006896:	d00f      	beq.n	80068b8 <DMA_ITConfig+0x38>
  {
    if (NewState != DISABLE)
 8006898:	79fb      	ldrb	r3, [r7, #7]
 800689a:	2b00      	cmp	r3, #0
 800689c:	d006      	beq.n	80068ac <DMA_ITConfig+0x2c>
    {
      /* Enable the selected DMA FIFO interrupts */
      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
 800689e:	68fb      	ldr	r3, [r7, #12]
 80068a0:	695b      	ldr	r3, [r3, #20]
 80068a2:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 80068a6:	68fb      	ldr	r3, [r7, #12]
 80068a8:	615a      	str	r2, [r3, #20]
 80068aa:	e005      	b.n	80068b8 <DMA_ITConfig+0x38>
    }    
    else 
    {
      /* Disable the selected DMA FIFO interrupts */
      DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
 80068ac:	68fb      	ldr	r3, [r7, #12]
 80068ae:	695b      	ldr	r3, [r3, #20]
 80068b0:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 80068b4:	68fb      	ldr	r3, [r7, #12]
 80068b6:	615a      	str	r2, [r3, #20]
    }
  }

  /* Check if the DMA_IT parameter contains a Transfer interrupt */
  if (DMA_IT != DMA_IT_FE)
 80068b8:	68bb      	ldr	r3, [r7, #8]
 80068ba:	2b80      	cmp	r3, #128	; 0x80
 80068bc:	d015      	beq.n	80068ea <DMA_ITConfig+0x6a>
  {
    if (NewState != DISABLE)
 80068be:	79fb      	ldrb	r3, [r7, #7]
 80068c0:	2b00      	cmp	r3, #0
 80068c2:	d008      	beq.n	80068d6 <DMA_ITConfig+0x56>
    {
      /* Enable the selected DMA transfer interrupts */
      DMAy_Streamx->CR |= (uint32_t)(DMA_IT  & TRANSFER_IT_ENABLE_MASK);
 80068c4:	68fb      	ldr	r3, [r7, #12]
 80068c6:	681a      	ldr	r2, [r3, #0]
 80068c8:	68bb      	ldr	r3, [r7, #8]
 80068ca:	f003 031e 	and.w	r3, r3, #30
 80068ce:	431a      	orrs	r2, r3
 80068d0:	68fb      	ldr	r3, [r7, #12]
 80068d2:	601a      	str	r2, [r3, #0]
 80068d4:	e009      	b.n	80068ea <DMA_ITConfig+0x6a>
    }
    else
    {
      /* Disable the selected DMA transfer interrupts */
      DMAy_Streamx->CR &= ~(uint32_t)(DMA_IT & TRANSFER_IT_ENABLE_MASK);
 80068d6:	68fb      	ldr	r3, [r7, #12]
 80068d8:	681a      	ldr	r2, [r3, #0]
 80068da:	68bb      	ldr	r3, [r7, #8]
 80068dc:	f003 031e 	and.w	r3, r3, #30
 80068e0:	ea6f 0303 	mvn.w	r3, r3
 80068e4:	401a      	ands	r2, r3
 80068e6:	68fb      	ldr	r3, [r7, #12]
 80068e8:	601a      	str	r2, [r3, #0]
    }    
  }
}
 80068ea:	f107 0714 	add.w	r7, r7, #20
 80068ee:	46bd      	mov	sp, r7
 80068f0:	bc80      	pop	{r7}
 80068f2:	4770      	bx	lr

080068f4 <DMA_GetITStatus>:
  *            @arg DMA_IT_FEIFx:  Streamx FIFO error interrupt
  *         Where x can be 0 to 7 to select the DMA Stream.
  * @retval The new state of DMA_IT (SET or RESET).
  */
ITStatus DMA_GetITStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
{
 80068f4:	b480      	push	{r7}
 80068f6:	b087      	sub	sp, #28
 80068f8:	af00      	add	r7, sp, #0
 80068fa:	6078      	str	r0, [r7, #4]
 80068fc:	6039      	str	r1, [r7, #0]
  ITStatus bitstatus = RESET;
 80068fe:	f04f 0300 	mov.w	r3, #0
 8006902:	75fb      	strb	r3, [r7, #23]
  DMA_TypeDef* DMAy;
  uint32_t tmpreg = 0, enablestatus = 0;
 8006904:	f04f 0300 	mov.w	r3, #0
 8006908:	60fb      	str	r3, [r7, #12]
 800690a:	f04f 0300 	mov.w	r3, #0
 800690e:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_GET_IT(DMA_IT));
 
  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
 8006910:	687a      	ldr	r2, [r7, #4]
 8006912:	4b24      	ldr	r3, [pc, #144]	; (80069a4 <DMA_GetITStatus+0xb0>)
 8006914:	429a      	cmp	r2, r3
 8006916:	d802      	bhi.n	800691e <DMA_GetITStatus+0x2a>
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 8006918:	4b23      	ldr	r3, [pc, #140]	; (80069a8 <DMA_GetITStatus+0xb4>)
 800691a:	613b      	str	r3, [r7, #16]
 800691c:	e001      	b.n	8006922 <DMA_GetITStatus+0x2e>
  } 
  else 
  {
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
 800691e:	4b23      	ldr	r3, [pc, #140]	; (80069ac <DMA_GetITStatus+0xb8>)
 8006920:	613b      	str	r3, [r7, #16]
  }

  /* Check if the interrupt enable bit is in the CR or FCR register */
  if ((DMA_IT & TRANSFER_IT_MASK) != (uint32_t)RESET)
 8006922:	683b      	ldr	r3, [r7, #0]
 8006924:	f023 23f0 	bic.w	r3, r3, #4026593280	; 0xf000f000
 8006928:	f023 13c3 	bic.w	r3, r3, #12779715	; 0xc300c3
 800692c:	2b00      	cmp	r3, #0
 800692e:	d00b      	beq.n	8006948 <DMA_GetITStatus+0x54>
  {
    /* Get the interrupt enable position mask in CR register */
    tmpreg = (uint32_t)((DMA_IT >> 11) & TRANSFER_IT_ENABLE_MASK);   
 8006930:	683b      	ldr	r3, [r7, #0]
 8006932:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8006936:	f003 031e 	and.w	r3, r3, #30
 800693a:	60fb      	str	r3, [r7, #12]
    
    /* Check the enable bit in CR register */
    enablestatus = (uint32_t)(DMAy_Streamx->CR & tmpreg);
 800693c:	687b      	ldr	r3, [r7, #4]
 800693e:	681a      	ldr	r2, [r3, #0]
 8006940:	68fb      	ldr	r3, [r7, #12]
 8006942:	4013      	ands	r3, r2
 8006944:	60bb      	str	r3, [r7, #8]
 8006946:	e004      	b.n	8006952 <DMA_GetITStatus+0x5e>
  }
  else 
  {
    /* Check the enable bit in FCR register */
    enablestatus = (uint32_t)(DMAy_Streamx->FCR & DMA_IT_FE); 
 8006948:	687b      	ldr	r3, [r7, #4]
 800694a:	695b      	ldr	r3, [r3, #20]
 800694c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8006950:	60bb      	str	r3, [r7, #8]
  }
 
  /* Check if the interrupt pending flag is in LISR or HISR */
  if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
 8006952:	683b      	ldr	r3, [r7, #0]
 8006954:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8006958:	2b00      	cmp	r3, #0
 800695a:	d003      	beq.n	8006964 <DMA_GetITStatus+0x70>
  {
    /* Get DMAy HISR register value */
    tmpreg = DMAy->HISR ;
 800695c:	693b      	ldr	r3, [r7, #16]
 800695e:	685b      	ldr	r3, [r3, #4]
 8006960:	60fb      	str	r3, [r7, #12]
 8006962:	e002      	b.n	800696a <DMA_GetITStatus+0x76>
  }
  else
  {
    /* Get DMAy LISR register value */
    tmpreg = DMAy->LISR ;
 8006964:	693b      	ldr	r3, [r7, #16]
 8006966:	681b      	ldr	r3, [r3, #0]
 8006968:	60fb      	str	r3, [r7, #12]
  } 

  /* mask all reserved bits */
  tmpreg &= (uint32_t)RESERVED_MASK;
 800696a:	68fb      	ldr	r3, [r7, #12]
 800696c:	f023 23f0 	bic.w	r3, r3, #4026593280	; 0xf000f000
 8006970:	f023 1382 	bic.w	r3, r3, #8519810	; 0x820082
 8006974:	60fb      	str	r3, [r7, #12]

  /* Check the status of the specified DMA interrupt */
  if (((tmpreg & DMA_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 8006976:	68fa      	ldr	r2, [r7, #12]
 8006978:	683b      	ldr	r3, [r7, #0]
 800697a:	4013      	ands	r3, r2
 800697c:	2b00      	cmp	r3, #0
 800697e:	d006      	beq.n	800698e <DMA_GetITStatus+0x9a>
 8006980:	68bb      	ldr	r3, [r7, #8]
 8006982:	2b00      	cmp	r3, #0
 8006984:	d003      	beq.n	800698e <DMA_GetITStatus+0x9a>
  {
    /* DMA_IT is set */
    bitstatus = SET;
 8006986:	f04f 0301 	mov.w	r3, #1
 800698a:	75fb      	strb	r3, [r7, #23]
 800698c:	e002      	b.n	8006994 <DMA_GetITStatus+0xa0>
  }
  else
  {
    /* DMA_IT is reset */
    bitstatus = RESET;
 800698e:	f04f 0300 	mov.w	r3, #0
 8006992:	75fb      	strb	r3, [r7, #23]
  }

  /* Return the DMA_IT status */
  return  bitstatus;
 8006994:	7dfb      	ldrb	r3, [r7, #23]
}
 8006996:	4618      	mov	r0, r3
 8006998:	f107 071c 	add.w	r7, r7, #28
 800699c:	46bd      	mov	sp, r7
 800699e:	bc80      	pop	{r7}
 80069a0:	4770      	bx	lr
 80069a2:	bf00      	nop
 80069a4:	4002640f 	.word	0x4002640f
 80069a8:	40026000 	.word	0x40026000
 80069ac:	40026400 	.word	0x40026400

080069b0 <DMA_ClearITPendingBit>:
  *            @arg DMA_IT_FEIFx:  Streamx FIFO error interrupt
  *         Where x can be 0 to 7 to select the DMA Stream.
  * @retval None
  */
void DMA_ClearITPendingBit(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
{
 80069b0:	b480      	push	{r7}
 80069b2:	b085      	sub	sp, #20
 80069b4:	af00      	add	r7, sp, #0
 80069b6:	6078      	str	r0, [r7, #4]
 80069b8:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CLEAR_IT(DMA_IT));

  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
 80069ba:	687a      	ldr	r2, [r7, #4]
 80069bc:	4b10      	ldr	r3, [pc, #64]	; (8006a00 <DMA_ClearITPendingBit+0x50>)
 80069be:	429a      	cmp	r2, r3
 80069c0:	d802      	bhi.n	80069c8 <DMA_ClearITPendingBit+0x18>
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 80069c2:	4b10      	ldr	r3, [pc, #64]	; (8006a04 <DMA_ClearITPendingBit+0x54>)
 80069c4:	60fb      	str	r3, [r7, #12]
 80069c6:	e001      	b.n	80069cc <DMA_ClearITPendingBit+0x1c>
  } 
  else 
  {
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
 80069c8:	4b0f      	ldr	r3, [pc, #60]	; (8006a08 <DMA_ClearITPendingBit+0x58>)
 80069ca:	60fb      	str	r3, [r7, #12]
  }

  /* Check if LIFCR or HIFCR register is targeted */
  if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
 80069cc:	683b      	ldr	r3, [r7, #0]
 80069ce:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 80069d2:	2b00      	cmp	r3, #0
 80069d4:	d007      	beq.n	80069e6 <DMA_ClearITPendingBit+0x36>
  {
    /* Set DMAy HIFCR register clear interrupt bits */
    DMAy->HIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
 80069d6:	683b      	ldr	r3, [r7, #0]
 80069d8:	f023 23f0 	bic.w	r3, r3, #4026593280	; 0xf000f000
 80069dc:	f023 1382 	bic.w	r3, r3, #8519810	; 0x820082
 80069e0:	68fa      	ldr	r2, [r7, #12]
 80069e2:	60d3      	str	r3, [r2, #12]
 80069e4:	e006      	b.n	80069f4 <DMA_ClearITPendingBit+0x44>
  }
  else 
  {
    /* Set DMAy LIFCR register clear interrupt bits */
    DMAy->LIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
 80069e6:	683b      	ldr	r3, [r7, #0]
 80069e8:	f023 23f0 	bic.w	r3, r3, #4026593280	; 0xf000f000
 80069ec:	f023 1382 	bic.w	r3, r3, #8519810	; 0x820082
 80069f0:	68fa      	ldr	r2, [r7, #12]
 80069f2:	6093      	str	r3, [r2, #8]
  }   
}
 80069f4:	f107 0714 	add.w	r7, r7, #20
 80069f8:	46bd      	mov	sp, r7
 80069fa:	bc80      	pop	{r7}
 80069fc:	4770      	bx	lr
 80069fe:	bf00      	nop
 8006a00:	4002640f 	.word	0x4002640f
 8006a04:	40026000 	.word	0x40026000
 8006a08:	40026400 	.word	0x40026400

08006a0c <EXTI_DeInit>:
  * @brief  Deinitializes the EXTI peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void EXTI_DeInit(void)
{
 8006a0c:	b480      	push	{r7}
 8006a0e:	af00      	add	r7, sp, #0
  EXTI->IMR = 0x00000000;
 8006a10:	4b0a      	ldr	r3, [pc, #40]	; (8006a3c <EXTI_DeInit+0x30>)
 8006a12:	f04f 0200 	mov.w	r2, #0
 8006a16:	601a      	str	r2, [r3, #0]
  EXTI->EMR = 0x00000000;
 8006a18:	4b08      	ldr	r3, [pc, #32]	; (8006a3c <EXTI_DeInit+0x30>)
 8006a1a:	f04f 0200 	mov.w	r2, #0
 8006a1e:	605a      	str	r2, [r3, #4]
  EXTI->RTSR = 0x00000000;
 8006a20:	4b06      	ldr	r3, [pc, #24]	; (8006a3c <EXTI_DeInit+0x30>)
 8006a22:	f04f 0200 	mov.w	r2, #0
 8006a26:	609a      	str	r2, [r3, #8]
  EXTI->FTSR = 0x00000000;
 8006a28:	4b04      	ldr	r3, [pc, #16]	; (8006a3c <EXTI_DeInit+0x30>)
 8006a2a:	f04f 0200 	mov.w	r2, #0
 8006a2e:	60da      	str	r2, [r3, #12]
  EXTI->PR = 0x007FFFFF;
 8006a30:	4b02      	ldr	r3, [pc, #8]	; (8006a3c <EXTI_DeInit+0x30>)
 8006a32:	4a03      	ldr	r2, [pc, #12]	; (8006a40 <EXTI_DeInit+0x34>)
 8006a34:	615a      	str	r2, [r3, #20]
}
 8006a36:	46bd      	mov	sp, r7
 8006a38:	bc80      	pop	{r7}
 8006a3a:	4770      	bx	lr
 8006a3c:	40013c00 	.word	0x40013c00
 8006a40:	007fffff 	.word	0x007fffff

08006a44 <EXTI_Init>:
  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
  *         that contains the configuration information for the EXTI peripheral.
  * @retval None
  */
void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
{
 8006a44:	b480      	push	{r7}
 8006a46:	b085      	sub	sp, #20
 8006a48:	af00      	add	r7, sp, #0
 8006a4a:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0;
 8006a4c:	f04f 0300 	mov.w	r3, #0
 8006a50:	60fb      	str	r3, [r7, #12]
  assert_param(IS_EXTI_MODE(EXTI_InitStruct->EXTI_Mode));
  assert_param(IS_EXTI_TRIGGER(EXTI_InitStruct->EXTI_Trigger));
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
 8006a52:	4b35      	ldr	r3, [pc, #212]	; (8006b28 <EXTI_Init+0xe4>)
 8006a54:	60fb      	str	r3, [r7, #12]
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8006a56:	687b      	ldr	r3, [r7, #4]
 8006a58:	799b      	ldrb	r3, [r3, #6]
 8006a5a:	2b00      	cmp	r3, #0
 8006a5c:	d051      	beq.n	8006b02 <EXTI_Init+0xbe>
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 8006a5e:	4b32      	ldr	r3, [pc, #200]	; (8006b28 <EXTI_Init+0xe4>)
 8006a60:	4a31      	ldr	r2, [pc, #196]	; (8006b28 <EXTI_Init+0xe4>)
 8006a62:	6811      	ldr	r1, [r2, #0]
 8006a64:	687a      	ldr	r2, [r7, #4]
 8006a66:	6812      	ldr	r2, [r2, #0]
 8006a68:	ea6f 0202 	mvn.w	r2, r2
 8006a6c:	400a      	ands	r2, r1
 8006a6e:	601a      	str	r2, [r3, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 8006a70:	4b2d      	ldr	r3, [pc, #180]	; (8006b28 <EXTI_Init+0xe4>)
 8006a72:	4a2d      	ldr	r2, [pc, #180]	; (8006b28 <EXTI_Init+0xe4>)
 8006a74:	6851      	ldr	r1, [r2, #4]
 8006a76:	687a      	ldr	r2, [r7, #4]
 8006a78:	6812      	ldr	r2, [r2, #0]
 8006a7a:	ea6f 0202 	mvn.w	r2, r2
 8006a7e:	400a      	ands	r2, r1
 8006a80:	605a      	str	r2, [r3, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;
 8006a82:	687b      	ldr	r3, [r7, #4]
 8006a84:	791b      	ldrb	r3, [r3, #4]
 8006a86:	68fa      	ldr	r2, [r7, #12]
 8006a88:	18d3      	adds	r3, r2, r3
 8006a8a:	60fb      	str	r3, [r7, #12]

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 8006a8c:	68fb      	ldr	r3, [r7, #12]
 8006a8e:	68fa      	ldr	r2, [r7, #12]
 8006a90:	6811      	ldr	r1, [r2, #0]
 8006a92:	687a      	ldr	r2, [r7, #4]
 8006a94:	6812      	ldr	r2, [r2, #0]
 8006a96:	430a      	orrs	r2, r1
 8006a98:	601a      	str	r2, [r3, #0]

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
 8006a9a:	4b23      	ldr	r3, [pc, #140]	; (8006b28 <EXTI_Init+0xe4>)
 8006a9c:	4a22      	ldr	r2, [pc, #136]	; (8006b28 <EXTI_Init+0xe4>)
 8006a9e:	6891      	ldr	r1, [r2, #8]
 8006aa0:	687a      	ldr	r2, [r7, #4]
 8006aa2:	6812      	ldr	r2, [r2, #0]
 8006aa4:	ea6f 0202 	mvn.w	r2, r2
 8006aa8:	400a      	ands	r2, r1
 8006aaa:	609a      	str	r2, [r3, #8]
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 8006aac:	4b1e      	ldr	r3, [pc, #120]	; (8006b28 <EXTI_Init+0xe4>)
 8006aae:	4a1e      	ldr	r2, [pc, #120]	; (8006b28 <EXTI_Init+0xe4>)
 8006ab0:	68d1      	ldr	r1, [r2, #12]
 8006ab2:	687a      	ldr	r2, [r7, #4]
 8006ab4:	6812      	ldr	r2, [r2, #0]
 8006ab6:	ea6f 0202 	mvn.w	r2, r2
 8006aba:	400a      	ands	r2, r1
 8006abc:	60da      	str	r2, [r3, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 8006abe:	687b      	ldr	r3, [r7, #4]
 8006ac0:	795b      	ldrb	r3, [r3, #5]
 8006ac2:	2b10      	cmp	r3, #16
 8006ac4:	d10e      	bne.n	8006ae4 <EXTI_Init+0xa0>
    {
      /* Rising Falling edge */
      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
 8006ac6:	4b18      	ldr	r3, [pc, #96]	; (8006b28 <EXTI_Init+0xe4>)
 8006ac8:	4a17      	ldr	r2, [pc, #92]	; (8006b28 <EXTI_Init+0xe4>)
 8006aca:	6891      	ldr	r1, [r2, #8]
 8006acc:	687a      	ldr	r2, [r7, #4]
 8006ace:	6812      	ldr	r2, [r2, #0]
 8006ad0:	430a      	orrs	r2, r1
 8006ad2:	609a      	str	r2, [r3, #8]
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
 8006ad4:	4b14      	ldr	r3, [pc, #80]	; (8006b28 <EXTI_Init+0xe4>)
 8006ad6:	4a14      	ldr	r2, [pc, #80]	; (8006b28 <EXTI_Init+0xe4>)
 8006ad8:	68d1      	ldr	r1, [r2, #12]
 8006ada:	687a      	ldr	r2, [r7, #4]
 8006adc:	6812      	ldr	r2, [r2, #0]
 8006ade:	430a      	orrs	r2, r1
 8006ae0:	60da      	str	r2, [r3, #12]
 8006ae2:	e01c      	b.n	8006b1e <EXTI_Init+0xda>
    }
    else
    {
      tmp = (uint32_t)EXTI_BASE;
 8006ae4:	4b10      	ldr	r3, [pc, #64]	; (8006b28 <EXTI_Init+0xe4>)
 8006ae6:	60fb      	str	r3, [r7, #12]
      tmp += EXTI_InitStruct->EXTI_Trigger;
 8006ae8:	687b      	ldr	r3, [r7, #4]
 8006aea:	795b      	ldrb	r3, [r3, #5]
 8006aec:	68fa      	ldr	r2, [r7, #12]
 8006aee:	18d3      	adds	r3, r2, r3
 8006af0:	60fb      	str	r3, [r7, #12]

      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 8006af2:	68fb      	ldr	r3, [r7, #12]
 8006af4:	68fa      	ldr	r2, [r7, #12]
 8006af6:	6811      	ldr	r1, [r2, #0]
 8006af8:	687a      	ldr	r2, [r7, #4]
 8006afa:	6812      	ldr	r2, [r2, #0]
 8006afc:	430a      	orrs	r2, r1
 8006afe:	601a      	str	r2, [r3, #0]
 8006b00:	e00d      	b.n	8006b1e <EXTI_Init+0xda>
    }
  }
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;
 8006b02:	687b      	ldr	r3, [r7, #4]
 8006b04:	791b      	ldrb	r3, [r3, #4]
 8006b06:	68fa      	ldr	r2, [r7, #12]
 8006b08:	18d3      	adds	r3, r2, r3
 8006b0a:	60fb      	str	r3, [r7, #12]

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 8006b0c:	68fb      	ldr	r3, [r7, #12]
 8006b0e:	68fa      	ldr	r2, [r7, #12]
 8006b10:	6811      	ldr	r1, [r2, #0]
 8006b12:	687a      	ldr	r2, [r7, #4]
 8006b14:	6812      	ldr	r2, [r2, #0]
 8006b16:	ea6f 0202 	mvn.w	r2, r2
 8006b1a:	400a      	ands	r2, r1
 8006b1c:	601a      	str	r2, [r3, #0]
  }
}
 8006b1e:	f107 0714 	add.w	r7, r7, #20
 8006b22:	46bd      	mov	sp, r7
 8006b24:	bc80      	pop	{r7}
 8006b26:	4770      	bx	lr
 8006b28:	40013c00 	.word	0x40013c00

08006b2c <EXTI_StructInit>:
  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure which will
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
 8006b2c:	b480      	push	{r7}
 8006b2e:	b083      	sub	sp, #12
 8006b30:	af00      	add	r7, sp, #0
 8006b32:	6078      	str	r0, [r7, #4]
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 8006b34:	687b      	ldr	r3, [r7, #4]
 8006b36:	f04f 0200 	mov.w	r2, #0
 8006b3a:	601a      	str	r2, [r3, #0]
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
 8006b3c:	687b      	ldr	r3, [r7, #4]
 8006b3e:	f04f 0200 	mov.w	r2, #0
 8006b42:	711a      	strb	r2, [r3, #4]
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;
 8006b44:	687b      	ldr	r3, [r7, #4]
 8006b46:	f04f 020c 	mov.w	r2, #12
 8006b4a:	715a      	strb	r2, [r3, #5]
  EXTI_InitStruct->EXTI_LineCmd = DISABLE;
 8006b4c:	687b      	ldr	r3, [r7, #4]
 8006b4e:	f04f 0200 	mov.w	r2, #0
 8006b52:	719a      	strb	r2, [r3, #6]
}
 8006b54:	f107 070c 	add.w	r7, r7, #12
 8006b58:	46bd      	mov	sp, r7
 8006b5a:	bc80      	pop	{r7}
 8006b5c:	4770      	bx	lr
 8006b5e:	bf00      	nop

08006b60 <EXTI_GenerateSWInterrupt>:
  *         will be generated.
  *         This parameter can be any combination of EXTI_Linex where x can be (0..22)
  * @retval None
  */
void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
{
 8006b60:	b480      	push	{r7}
 8006b62:	b083      	sub	sp, #12
 8006b64:	af00      	add	r7, sp, #0
 8006b66:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->SWIER |= EXTI_Line;
 8006b68:	4b05      	ldr	r3, [pc, #20]	; (8006b80 <EXTI_GenerateSWInterrupt+0x20>)
 8006b6a:	4a05      	ldr	r2, [pc, #20]	; (8006b80 <EXTI_GenerateSWInterrupt+0x20>)
 8006b6c:	6911      	ldr	r1, [r2, #16]
 8006b6e:	687a      	ldr	r2, [r7, #4]
 8006b70:	430a      	orrs	r2, r1
 8006b72:	611a      	str	r2, [r3, #16]
}
 8006b74:	f107 070c 	add.w	r7, r7, #12
 8006b78:	46bd      	mov	sp, r7
 8006b7a:	bc80      	pop	{r7}
 8006b7c:	4770      	bx	lr
 8006b7e:	bf00      	nop
 8006b80:	40013c00 	.word	0x40013c00

08006b84 <EXTI_GetFlagStatus>:
  * @param  EXTI_Line: specifies the EXTI line flag to check.
  *          This parameter can be EXTI_Linex where x can be(0..22)
  * @retval The new state of EXTI_Line (SET or RESET).
  */
FlagStatus EXTI_GetFlagStatus(uint32_t EXTI_Line)
{
 8006b84:	b480      	push	{r7}
 8006b86:	b085      	sub	sp, #20
 8006b88:	af00      	add	r7, sp, #0
 8006b8a:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
 8006b8c:	f04f 0300 	mov.w	r3, #0
 8006b90:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  if ((EXTI->PR & EXTI_Line) != (uint32_t)RESET)
 8006b92:	4b0a      	ldr	r3, [pc, #40]	; (8006bbc <EXTI_GetFlagStatus+0x38>)
 8006b94:	695a      	ldr	r2, [r3, #20]
 8006b96:	687b      	ldr	r3, [r7, #4]
 8006b98:	4013      	ands	r3, r2
 8006b9a:	2b00      	cmp	r3, #0
 8006b9c:	d003      	beq.n	8006ba6 <EXTI_GetFlagStatus+0x22>
  {
    bitstatus = SET;
 8006b9e:	f04f 0301 	mov.w	r3, #1
 8006ba2:	73fb      	strb	r3, [r7, #15]
 8006ba4:	e002      	b.n	8006bac <EXTI_GetFlagStatus+0x28>
  }
  else
  {
    bitstatus = RESET;
 8006ba6:	f04f 0300 	mov.w	r3, #0
 8006baa:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 8006bac:	7bfb      	ldrb	r3, [r7, #15]
}
 8006bae:	4618      	mov	r0, r3
 8006bb0:	f107 0714 	add.w	r7, r7, #20
 8006bb4:	46bd      	mov	sp, r7
 8006bb6:	bc80      	pop	{r7}
 8006bb8:	4770      	bx	lr
 8006bba:	bf00      	nop
 8006bbc:	40013c00 	.word	0x40013c00

08006bc0 <EXTI_ClearFlag>:
  * @param  EXTI_Line: specifies the EXTI lines flags to clear.
  *          This parameter can be any combination of EXTI_Linex where x can be (0..22)
  * @retval None
  */
void EXTI_ClearFlag(uint32_t EXTI_Line)
{
 8006bc0:	b480      	push	{r7}
 8006bc2:	b083      	sub	sp, #12
 8006bc4:	af00      	add	r7, sp, #0
 8006bc6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 8006bc8:	4b03      	ldr	r3, [pc, #12]	; (8006bd8 <EXTI_ClearFlag+0x18>)
 8006bca:	687a      	ldr	r2, [r7, #4]
 8006bcc:	615a      	str	r2, [r3, #20]
}
 8006bce:	f107 070c 	add.w	r7, r7, #12
 8006bd2:	46bd      	mov	sp, r7
 8006bd4:	bc80      	pop	{r7}
 8006bd6:	4770      	bx	lr
 8006bd8:	40013c00 	.word	0x40013c00

08006bdc <EXTI_GetITStatus>:
  * @param  EXTI_Line: specifies the EXTI line to check.
  *          This parameter can be EXTI_Linex where x can be(0..22)
  * @retval The new state of EXTI_Line (SET or RESET).
  */
ITStatus EXTI_GetITStatus(uint32_t EXTI_Line)
{
 8006bdc:	b480      	push	{r7}
 8006bde:	b085      	sub	sp, #20
 8006be0:	af00      	add	r7, sp, #0
 8006be2:	6078      	str	r0, [r7, #4]
  ITStatus bitstatus = RESET;
 8006be4:	f04f 0300 	mov.w	r3, #0
 8006be8:	73fb      	strb	r3, [r7, #15]
  uint32_t enablestatus = 0;
 8006bea:	f04f 0300 	mov.w	r3, #0
 8006bee:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  enablestatus =  EXTI->IMR & EXTI_Line;
 8006bf0:	4b0d      	ldr	r3, [pc, #52]	; (8006c28 <EXTI_GetITStatus+0x4c>)
 8006bf2:	681a      	ldr	r2, [r3, #0]
 8006bf4:	687b      	ldr	r3, [r7, #4]
 8006bf6:	4013      	ands	r3, r2
 8006bf8:	60bb      	str	r3, [r7, #8]
  if (((EXTI->PR & EXTI_Line) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 8006bfa:	4b0b      	ldr	r3, [pc, #44]	; (8006c28 <EXTI_GetITStatus+0x4c>)
 8006bfc:	695a      	ldr	r2, [r3, #20]
 8006bfe:	687b      	ldr	r3, [r7, #4]
 8006c00:	4013      	ands	r3, r2
 8006c02:	2b00      	cmp	r3, #0
 8006c04:	d006      	beq.n	8006c14 <EXTI_GetITStatus+0x38>
 8006c06:	68bb      	ldr	r3, [r7, #8]
 8006c08:	2b00      	cmp	r3, #0
 8006c0a:	d003      	beq.n	8006c14 <EXTI_GetITStatus+0x38>
  {
    bitstatus = SET;
 8006c0c:	f04f 0301 	mov.w	r3, #1
 8006c10:	73fb      	strb	r3, [r7, #15]
 8006c12:	e002      	b.n	8006c1a <EXTI_GetITStatus+0x3e>
  }
  else
  {
    bitstatus = RESET;
 8006c14:	f04f 0300 	mov.w	r3, #0
 8006c18:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 8006c1a:	7bfb      	ldrb	r3, [r7, #15]
}
 8006c1c:	4618      	mov	r0, r3
 8006c1e:	f107 0714 	add.w	r7, r7, #20
 8006c22:	46bd      	mov	sp, r7
 8006c24:	bc80      	pop	{r7}
 8006c26:	4770      	bx	lr
 8006c28:	40013c00 	.word	0x40013c00

08006c2c <EXTI_ClearITPendingBit>:
  * @param  EXTI_Line: specifies the EXTI lines to clear.
  *          This parameter can be any combination of EXTI_Linex where x can be (0..22)
  * @retval None
  */
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
 8006c2c:	b480      	push	{r7}
 8006c2e:	b083      	sub	sp, #12
 8006c30:	af00      	add	r7, sp, #0
 8006c32:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 8006c34:	4b03      	ldr	r3, [pc, #12]	; (8006c44 <EXTI_ClearITPendingBit+0x18>)
 8006c36:	687a      	ldr	r2, [r7, #4]
 8006c38:	615a      	str	r2, [r3, #20]
}
 8006c3a:	f107 070c 	add.w	r7, r7, #12
 8006c3e:	46bd      	mov	sp, r7
 8006c40:	bc80      	pop	{r7}
 8006c42:	4770      	bx	lr
 8006c44:	40013c00 	.word	0x40013c00

08006c48 <FLASH_SetLatency>:
  *            @arg FLASH_Latency_6: FLASH Six Latency cycles
  *            @arg FLASH_Latency_7: FLASH Seven Latency cycles      
  * @retval None
  */
void FLASH_SetLatency(uint32_t FLASH_Latency)
{
 8006c48:	b480      	push	{r7}
 8006c4a:	b083      	sub	sp, #12
 8006c4c:	af00      	add	r7, sp, #0
 8006c4e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_FLASH_LATENCY(FLASH_Latency));
  
  /* Perform Byte access to FLASH_ACR[8:0] to set the Latency value */
  *(__IO uint8_t *)ACR_BYTE0_ADDRESS = (uint8_t)FLASH_Latency;
 8006c50:	4b04      	ldr	r3, [pc, #16]	; (8006c64 <FLASH_SetLatency+0x1c>)
 8006c52:	687a      	ldr	r2, [r7, #4]
 8006c54:	b2d2      	uxtb	r2, r2
 8006c56:	701a      	strb	r2, [r3, #0]
}
 8006c58:	f107 070c 	add.w	r7, r7, #12
 8006c5c:	46bd      	mov	sp, r7
 8006c5e:	bc80      	pop	{r7}
 8006c60:	4770      	bx	lr
 8006c62:	bf00      	nop
 8006c64:	40023c00 	.word	0x40023c00

08006c68 <FLASH_PrefetchBufferCmd>:
  * @param  NewState: new state of the Prefetch Buffer.
  *          This parameter  can be: ENABLE or DISABLE.
  * @retval None
  */
void FLASH_PrefetchBufferCmd(FunctionalState NewState)
{
 8006c68:	b480      	push	{r7}
 8006c6a:	b083      	sub	sp, #12
 8006c6c:	af00      	add	r7, sp, #0
 8006c6e:	4603      	mov	r3, r0
 8006c70:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  /* Enable or disable the Prefetch Buffer */
  if(NewState != DISABLE)
 8006c72:	79fb      	ldrb	r3, [r7, #7]
 8006c74:	2b00      	cmp	r3, #0
 8006c76:	d006      	beq.n	8006c86 <FLASH_PrefetchBufferCmd+0x1e>
  {
    FLASH->ACR |= FLASH_ACR_PRFTEN;
 8006c78:	4b08      	ldr	r3, [pc, #32]	; (8006c9c <FLASH_PrefetchBufferCmd+0x34>)
 8006c7a:	4a08      	ldr	r2, [pc, #32]	; (8006c9c <FLASH_PrefetchBufferCmd+0x34>)
 8006c7c:	6812      	ldr	r2, [r2, #0]
 8006c7e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8006c82:	601a      	str	r2, [r3, #0]
 8006c84:	e005      	b.n	8006c92 <FLASH_PrefetchBufferCmd+0x2a>
  }
  else
  {
    FLASH->ACR &= (~FLASH_ACR_PRFTEN);
 8006c86:	4b05      	ldr	r3, [pc, #20]	; (8006c9c <FLASH_PrefetchBufferCmd+0x34>)
 8006c88:	4a04      	ldr	r2, [pc, #16]	; (8006c9c <FLASH_PrefetchBufferCmd+0x34>)
 8006c8a:	6812      	ldr	r2, [r2, #0]
 8006c8c:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8006c90:	601a      	str	r2, [r3, #0]
  }
}
 8006c92:	f107 070c 	add.w	r7, r7, #12
 8006c96:	46bd      	mov	sp, r7
 8006c98:	bc80      	pop	{r7}
 8006c9a:	4770      	bx	lr
 8006c9c:	40023c00 	.word	0x40023c00

08006ca0 <FLASH_InstructionCacheCmd>:
  * @param  NewState: new state of the Instruction Cache.
  *          This parameter  can be: ENABLE or DISABLE.
  * @retval None
  */
void FLASH_InstructionCacheCmd(FunctionalState NewState)
{
 8006ca0:	b480      	push	{r7}
 8006ca2:	b083      	sub	sp, #12
 8006ca4:	af00      	add	r7, sp, #0
 8006ca6:	4603      	mov	r3, r0
 8006ca8:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if(NewState != DISABLE)
 8006caa:	79fb      	ldrb	r3, [r7, #7]
 8006cac:	2b00      	cmp	r3, #0
 8006cae:	d006      	beq.n	8006cbe <FLASH_InstructionCacheCmd+0x1e>
  {
    FLASH->ACR |= FLASH_ACR_ICEN;
 8006cb0:	4b08      	ldr	r3, [pc, #32]	; (8006cd4 <FLASH_InstructionCacheCmd+0x34>)
 8006cb2:	4a08      	ldr	r2, [pc, #32]	; (8006cd4 <FLASH_InstructionCacheCmd+0x34>)
 8006cb4:	6812      	ldr	r2, [r2, #0]
 8006cb6:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8006cba:	601a      	str	r2, [r3, #0]
 8006cbc:	e005      	b.n	8006cca <FLASH_InstructionCacheCmd+0x2a>
  }
  else
  {
    FLASH->ACR &= (~FLASH_ACR_ICEN);
 8006cbe:	4b05      	ldr	r3, [pc, #20]	; (8006cd4 <FLASH_InstructionCacheCmd+0x34>)
 8006cc0:	4a04      	ldr	r2, [pc, #16]	; (8006cd4 <FLASH_InstructionCacheCmd+0x34>)
 8006cc2:	6812      	ldr	r2, [r2, #0]
 8006cc4:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8006cc8:	601a      	str	r2, [r3, #0]
  }
}
 8006cca:	f107 070c 	add.w	r7, r7, #12
 8006cce:	46bd      	mov	sp, r7
 8006cd0:	bc80      	pop	{r7}
 8006cd2:	4770      	bx	lr
 8006cd4:	40023c00 	.word	0x40023c00

08006cd8 <FLASH_DataCacheCmd>:
  * @param  NewState: new state of the Data Cache.
  *          This parameter  can be: ENABLE or DISABLE.
  * @retval None
  */
void FLASH_DataCacheCmd(FunctionalState NewState)
{
 8006cd8:	b480      	push	{r7}
 8006cda:	b083      	sub	sp, #12
 8006cdc:	af00      	add	r7, sp, #0
 8006cde:	4603      	mov	r3, r0
 8006ce0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if(NewState != DISABLE)
 8006ce2:	79fb      	ldrb	r3, [r7, #7]
 8006ce4:	2b00      	cmp	r3, #0
 8006ce6:	d006      	beq.n	8006cf6 <FLASH_DataCacheCmd+0x1e>
  {
    FLASH->ACR |= FLASH_ACR_DCEN;
 8006ce8:	4b08      	ldr	r3, [pc, #32]	; (8006d0c <FLASH_DataCacheCmd+0x34>)
 8006cea:	4a08      	ldr	r2, [pc, #32]	; (8006d0c <FLASH_DataCacheCmd+0x34>)
 8006cec:	6812      	ldr	r2, [r2, #0]
 8006cee:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8006cf2:	601a      	str	r2, [r3, #0]
 8006cf4:	e005      	b.n	8006d02 <FLASH_DataCacheCmd+0x2a>
  }
  else
  {
    FLASH->ACR &= (~FLASH_ACR_DCEN);
 8006cf6:	4b05      	ldr	r3, [pc, #20]	; (8006d0c <FLASH_DataCacheCmd+0x34>)
 8006cf8:	4a04      	ldr	r2, [pc, #16]	; (8006d0c <FLASH_DataCacheCmd+0x34>)
 8006cfa:	6812      	ldr	r2, [r2, #0]
 8006cfc:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8006d00:	601a      	str	r2, [r3, #0]
  }
}
 8006d02:	f107 070c 	add.w	r7, r7, #12
 8006d06:	46bd      	mov	sp, r7
 8006d08:	bc80      	pop	{r7}
 8006d0a:	4770      	bx	lr
 8006d0c:	40023c00 	.word	0x40023c00

08006d10 <FLASH_InstructionCacheReset>:
  * @note   This function must be used only when the Instruction Cache is disabled.  
  * @param  None
  * @retval None
  */
void FLASH_InstructionCacheReset(void)
{
 8006d10:	b480      	push	{r7}
 8006d12:	af00      	add	r7, sp, #0
  FLASH->ACR |= FLASH_ACR_ICRST;
 8006d14:	4b04      	ldr	r3, [pc, #16]	; (8006d28 <FLASH_InstructionCacheReset+0x18>)
 8006d16:	4a04      	ldr	r2, [pc, #16]	; (8006d28 <FLASH_InstructionCacheReset+0x18>)
 8006d18:	6812      	ldr	r2, [r2, #0]
 8006d1a:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8006d1e:	601a      	str	r2, [r3, #0]
}
 8006d20:	46bd      	mov	sp, r7
 8006d22:	bc80      	pop	{r7}
 8006d24:	4770      	bx	lr
 8006d26:	bf00      	nop
 8006d28:	40023c00 	.word	0x40023c00

08006d2c <FLASH_DataCacheReset>:
  * @note   This function must be used only when the Data Cache is disabled.  
  * @param  None
  * @retval None
  */
void FLASH_DataCacheReset(void)
{
 8006d2c:	b480      	push	{r7}
 8006d2e:	af00      	add	r7, sp, #0
  FLASH->ACR |= FLASH_ACR_DCRST;
 8006d30:	4b04      	ldr	r3, [pc, #16]	; (8006d44 <FLASH_DataCacheReset+0x18>)
 8006d32:	4a04      	ldr	r2, [pc, #16]	; (8006d44 <FLASH_DataCacheReset+0x18>)
 8006d34:	6812      	ldr	r2, [r2, #0]
 8006d36:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8006d3a:	601a      	str	r2, [r3, #0]
}
 8006d3c:	46bd      	mov	sp, r7
 8006d3e:	bc80      	pop	{r7}
 8006d40:	4770      	bx	lr
 8006d42:	bf00      	nop
 8006d44:	40023c00 	.word	0x40023c00

08006d48 <FLASH_Unlock>:
  * @brief  Unlocks the FLASH control register access
  * @param  None
  * @retval None
  */
void FLASH_Unlock(void)
{
 8006d48:	b480      	push	{r7}
 8006d4a:	af00      	add	r7, sp, #0
  if((FLASH->CR & FLASH_CR_LOCK) != RESET)
 8006d4c:	4b06      	ldr	r3, [pc, #24]	; (8006d68 <FLASH_Unlock+0x20>)
 8006d4e:	691b      	ldr	r3, [r3, #16]
 8006d50:	2b00      	cmp	r3, #0
 8006d52:	da05      	bge.n	8006d60 <FLASH_Unlock+0x18>
  {
    /* Authorize the FLASH Registers access */
    FLASH->KEYR = FLASH_KEY1;
 8006d54:	4b04      	ldr	r3, [pc, #16]	; (8006d68 <FLASH_Unlock+0x20>)
 8006d56:	4a05      	ldr	r2, [pc, #20]	; (8006d6c <FLASH_Unlock+0x24>)
 8006d58:	605a      	str	r2, [r3, #4]
    FLASH->KEYR = FLASH_KEY2;
 8006d5a:	4b03      	ldr	r3, [pc, #12]	; (8006d68 <FLASH_Unlock+0x20>)
 8006d5c:	4a04      	ldr	r2, [pc, #16]	; (8006d70 <FLASH_Unlock+0x28>)
 8006d5e:	605a      	str	r2, [r3, #4]
  }  
}
 8006d60:	46bd      	mov	sp, r7
 8006d62:	bc80      	pop	{r7}
 8006d64:	4770      	bx	lr
 8006d66:	bf00      	nop
 8006d68:	40023c00 	.word	0x40023c00
 8006d6c:	45670123 	.word	0x45670123
 8006d70:	cdef89ab 	.word	0xcdef89ab

08006d74 <FLASH_Lock>:
  * @brief  Locks the FLASH control register access
  * @param  None
  * @retval None
  */
void FLASH_Lock(void)
{
 8006d74:	b480      	push	{r7}
 8006d76:	af00      	add	r7, sp, #0
  /* Set the LOCK Bit to lock the FLASH Registers access */
  FLASH->CR |= FLASH_CR_LOCK;
 8006d78:	4b04      	ldr	r3, [pc, #16]	; (8006d8c <FLASH_Lock+0x18>)
 8006d7a:	4a04      	ldr	r2, [pc, #16]	; (8006d8c <FLASH_Lock+0x18>)
 8006d7c:	6912      	ldr	r2, [r2, #16]
 8006d7e:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8006d82:	611a      	str	r2, [r3, #16]
}
 8006d84:	46bd      	mov	sp, r7
 8006d86:	bc80      	pop	{r7}
 8006d88:	4770      	bx	lr
 8006d8a:	bf00      	nop
 8006d8c:	40023c00 	.word	0x40023c00

08006d90 <FLASH_EraseSector>:
  *       
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
{
 8006d90:	b580      	push	{r7, lr}
 8006d92:	b084      	sub	sp, #16
 8006d94:	af00      	add	r7, sp, #0
 8006d96:	6078      	str	r0, [r7, #4]
 8006d98:	460b      	mov	r3, r1
 8006d9a:	70fb      	strb	r3, [r7, #3]
  uint32_t tmp_psize = 0x0;
 8006d9c:	f04f 0300 	mov.w	r3, #0
 8006da0:	60fb      	str	r3, [r7, #12]
  FLASH_Status status = FLASH_COMPLETE;
 8006da2:	f04f 0308 	mov.w	r3, #8
 8006da6:	72fb      	strb	r3, [r7, #11]

  /* Check the parameters */
  assert_param(IS_FLASH_SECTOR(FLASH_Sector));
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  
  if(VoltageRange == VoltageRange_1)
 8006da8:	78fb      	ldrb	r3, [r7, #3]
 8006daa:	2b00      	cmp	r3, #0
 8006dac:	d103      	bne.n	8006db6 <FLASH_EraseSector+0x26>
  {
     tmp_psize = FLASH_PSIZE_BYTE;
 8006dae:	f04f 0300 	mov.w	r3, #0
 8006db2:	60fb      	str	r3, [r7, #12]
 8006db4:	e010      	b.n	8006dd8 <FLASH_EraseSector+0x48>
  }
  else if(VoltageRange == VoltageRange_2)
 8006db6:	78fb      	ldrb	r3, [r7, #3]
 8006db8:	2b01      	cmp	r3, #1
 8006dba:	d103      	bne.n	8006dc4 <FLASH_EraseSector+0x34>
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
 8006dbc:	f44f 7380 	mov.w	r3, #256	; 0x100
 8006dc0:	60fb      	str	r3, [r7, #12]
 8006dc2:	e009      	b.n	8006dd8 <FLASH_EraseSector+0x48>
  }
  else if(VoltageRange == VoltageRange_3)
 8006dc4:	78fb      	ldrb	r3, [r7, #3]
 8006dc6:	2b02      	cmp	r3, #2
 8006dc8:	d103      	bne.n	8006dd2 <FLASH_EraseSector+0x42>
  {
    tmp_psize = FLASH_PSIZE_WORD;
 8006dca:	f44f 7300 	mov.w	r3, #512	; 0x200
 8006dce:	60fb      	str	r3, [r7, #12]
 8006dd0:	e002      	b.n	8006dd8 <FLASH_EraseSector+0x48>
  }
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
 8006dd2:	f44f 7340 	mov.w	r3, #768	; 0x300
 8006dd6:	60fb      	str	r3, [r7, #12]
  }
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 8006dd8:	f000 fb0c 	bl	80073f4 <FLASH_WaitForLastOperation>
 8006ddc:	4603      	mov	r3, r0
 8006dde:	72fb      	strb	r3, [r7, #11]
  
  if(status == FLASH_COMPLETE)
 8006de0:	7afb      	ldrb	r3, [r7, #11]
 8006de2:	2b08      	cmp	r3, #8
 8006de4:	d12f      	bne.n	8006e46 <FLASH_EraseSector+0xb6>
  { 
    /* if the previous operation is completed, proceed to erase the sector */
    FLASH->CR &= CR_PSIZE_MASK;
 8006de6:	4b1b      	ldr	r3, [pc, #108]	; (8006e54 <FLASH_EraseSector+0xc4>)
 8006de8:	4a1a      	ldr	r2, [pc, #104]	; (8006e54 <FLASH_EraseSector+0xc4>)
 8006dea:	6912      	ldr	r2, [r2, #16]
 8006dec:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8006df0:	611a      	str	r2, [r3, #16]
    FLASH->CR |= tmp_psize;
 8006df2:	4b18      	ldr	r3, [pc, #96]	; (8006e54 <FLASH_EraseSector+0xc4>)
 8006df4:	4a17      	ldr	r2, [pc, #92]	; (8006e54 <FLASH_EraseSector+0xc4>)
 8006df6:	6911      	ldr	r1, [r2, #16]
 8006df8:	68fa      	ldr	r2, [r7, #12]
 8006dfa:	430a      	orrs	r2, r1
 8006dfc:	611a      	str	r2, [r3, #16]
    FLASH->CR &= SECTOR_MASK;
 8006dfe:	4b15      	ldr	r3, [pc, #84]	; (8006e54 <FLASH_EraseSector+0xc4>)
 8006e00:	4a14      	ldr	r2, [pc, #80]	; (8006e54 <FLASH_EraseSector+0xc4>)
 8006e02:	6912      	ldr	r2, [r2, #16]
 8006e04:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 8006e08:	611a      	str	r2, [r3, #16]
    FLASH->CR |= FLASH_CR_SER | FLASH_Sector;
 8006e0a:	4b12      	ldr	r3, [pc, #72]	; (8006e54 <FLASH_EraseSector+0xc4>)
 8006e0c:	4a11      	ldr	r2, [pc, #68]	; (8006e54 <FLASH_EraseSector+0xc4>)
 8006e0e:	6911      	ldr	r1, [r2, #16]
 8006e10:	687a      	ldr	r2, [r7, #4]
 8006e12:	430a      	orrs	r2, r1
 8006e14:	f042 0202 	orr.w	r2, r2, #2
 8006e18:	611a      	str	r2, [r3, #16]
    FLASH->CR |= FLASH_CR_STRT;
 8006e1a:	4b0e      	ldr	r3, [pc, #56]	; (8006e54 <FLASH_EraseSector+0xc4>)
 8006e1c:	4a0d      	ldr	r2, [pc, #52]	; (8006e54 <FLASH_EraseSector+0xc4>)
 8006e1e:	6912      	ldr	r2, [r2, #16]
 8006e20:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8006e24:	611a      	str	r2, [r3, #16]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 8006e26:	f000 fae5 	bl	80073f4 <FLASH_WaitForLastOperation>
 8006e2a:	4603      	mov	r3, r0
 8006e2c:	72fb      	strb	r3, [r7, #11]
    
    /* if the erase operation is completed, disable the SER Bit */
    FLASH->CR &= (~FLASH_CR_SER);
 8006e2e:	4b09      	ldr	r3, [pc, #36]	; (8006e54 <FLASH_EraseSector+0xc4>)
 8006e30:	4a08      	ldr	r2, [pc, #32]	; (8006e54 <FLASH_EraseSector+0xc4>)
 8006e32:	6912      	ldr	r2, [r2, #16]
 8006e34:	f022 0202 	bic.w	r2, r2, #2
 8006e38:	611a      	str	r2, [r3, #16]
    FLASH->CR &= SECTOR_MASK; 
 8006e3a:	4b06      	ldr	r3, [pc, #24]	; (8006e54 <FLASH_EraseSector+0xc4>)
 8006e3c:	4a05      	ldr	r2, [pc, #20]	; (8006e54 <FLASH_EraseSector+0xc4>)
 8006e3e:	6912      	ldr	r2, [r2, #16]
 8006e40:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 8006e44:	611a      	str	r2, [r3, #16]
  }
  /* Return the Erase Status */
  return status;
 8006e46:	7afb      	ldrb	r3, [r7, #11]
}
 8006e48:	4618      	mov	r0, r3
 8006e4a:	f107 0710 	add.w	r7, r7, #16
 8006e4e:	46bd      	mov	sp, r7
 8006e50:	bd80      	pop	{r7, pc}
 8006e52:	bf00      	nop
 8006e54:	40023c00 	.word	0x40023c00

08006e58 <FLASH_EraseAllSectors>:
  *       
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)
{
 8006e58:	b580      	push	{r7, lr}
 8006e5a:	b084      	sub	sp, #16
 8006e5c:	af00      	add	r7, sp, #0
 8006e5e:	4603      	mov	r3, r0
 8006e60:	71fb      	strb	r3, [r7, #7]
  uint32_t tmp_psize = 0x0;
 8006e62:	f04f 0300 	mov.w	r3, #0
 8006e66:	60fb      	str	r3, [r7, #12]
  FLASH_Status status = FLASH_COMPLETE;
 8006e68:	f04f 0308 	mov.w	r3, #8
 8006e6c:	72fb      	strb	r3, [r7, #11]
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 8006e6e:	f000 fac1 	bl	80073f4 <FLASH_WaitForLastOperation>
 8006e72:	4603      	mov	r3, r0
 8006e74:	72fb      	strb	r3, [r7, #11]
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  
  if(VoltageRange == VoltageRange_1)
 8006e76:	79fb      	ldrb	r3, [r7, #7]
 8006e78:	2b00      	cmp	r3, #0
 8006e7a:	d103      	bne.n	8006e84 <FLASH_EraseAllSectors+0x2c>
  {
     tmp_psize = FLASH_PSIZE_BYTE;
 8006e7c:	f04f 0300 	mov.w	r3, #0
 8006e80:	60fb      	str	r3, [r7, #12]
 8006e82:	e010      	b.n	8006ea6 <FLASH_EraseAllSectors+0x4e>
  }
  else if(VoltageRange == VoltageRange_2)
 8006e84:	79fb      	ldrb	r3, [r7, #7]
 8006e86:	2b01      	cmp	r3, #1
 8006e88:	d103      	bne.n	8006e92 <FLASH_EraseAllSectors+0x3a>
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
 8006e8a:	f44f 7380 	mov.w	r3, #256	; 0x100
 8006e8e:	60fb      	str	r3, [r7, #12]
 8006e90:	e009      	b.n	8006ea6 <FLASH_EraseAllSectors+0x4e>
  }
  else if(VoltageRange == VoltageRange_3)
 8006e92:	79fb      	ldrb	r3, [r7, #7]
 8006e94:	2b02      	cmp	r3, #2
 8006e96:	d103      	bne.n	8006ea0 <FLASH_EraseAllSectors+0x48>
  {
    tmp_psize = FLASH_PSIZE_WORD;
 8006e98:	f44f 7300 	mov.w	r3, #512	; 0x200
 8006e9c:	60fb      	str	r3, [r7, #12]
 8006e9e:	e002      	b.n	8006ea6 <FLASH_EraseAllSectors+0x4e>
  }
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
 8006ea0:	f44f 7340 	mov.w	r3, #768	; 0x300
 8006ea4:	60fb      	str	r3, [r7, #12]
  }  
  if(status == FLASH_COMPLETE)
 8006ea6:	7afb      	ldrb	r3, [r7, #11]
 8006ea8:	2b08      	cmp	r3, #8
 8006eaa:	d121      	bne.n	8006ef0 <FLASH_EraseAllSectors+0x98>
  {
    /* if the previous operation is completed, proceed to erase all sectors */
     FLASH->CR &= CR_PSIZE_MASK;
 8006eac:	4b13      	ldr	r3, [pc, #76]	; (8006efc <FLASH_EraseAllSectors+0xa4>)
 8006eae:	4a13      	ldr	r2, [pc, #76]	; (8006efc <FLASH_EraseAllSectors+0xa4>)
 8006eb0:	6912      	ldr	r2, [r2, #16]
 8006eb2:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8006eb6:	611a      	str	r2, [r3, #16]
     FLASH->CR |= tmp_psize;
 8006eb8:	4b10      	ldr	r3, [pc, #64]	; (8006efc <FLASH_EraseAllSectors+0xa4>)
 8006eba:	4a10      	ldr	r2, [pc, #64]	; (8006efc <FLASH_EraseAllSectors+0xa4>)
 8006ebc:	6911      	ldr	r1, [r2, #16]
 8006ebe:	68fa      	ldr	r2, [r7, #12]
 8006ec0:	430a      	orrs	r2, r1
 8006ec2:	611a      	str	r2, [r3, #16]
     FLASH->CR |= FLASH_CR_MER;
 8006ec4:	4b0d      	ldr	r3, [pc, #52]	; (8006efc <FLASH_EraseAllSectors+0xa4>)
 8006ec6:	4a0d      	ldr	r2, [pc, #52]	; (8006efc <FLASH_EraseAllSectors+0xa4>)
 8006ec8:	6912      	ldr	r2, [r2, #16]
 8006eca:	f042 0204 	orr.w	r2, r2, #4
 8006ece:	611a      	str	r2, [r3, #16]
     FLASH->CR |= FLASH_CR_STRT;
 8006ed0:	4b0a      	ldr	r3, [pc, #40]	; (8006efc <FLASH_EraseAllSectors+0xa4>)
 8006ed2:	4a0a      	ldr	r2, [pc, #40]	; (8006efc <FLASH_EraseAllSectors+0xa4>)
 8006ed4:	6912      	ldr	r2, [r2, #16]
 8006ed6:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8006eda:	611a      	str	r2, [r3, #16]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 8006edc:	f000 fa8a 	bl	80073f4 <FLASH_WaitForLastOperation>
 8006ee0:	4603      	mov	r3, r0
 8006ee2:	72fb      	strb	r3, [r7, #11]

    /* if the erase operation is completed, disable the MER Bit */
    FLASH->CR &= (~FLASH_CR_MER);
 8006ee4:	4b05      	ldr	r3, [pc, #20]	; (8006efc <FLASH_EraseAllSectors+0xa4>)
 8006ee6:	4a05      	ldr	r2, [pc, #20]	; (8006efc <FLASH_EraseAllSectors+0xa4>)
 8006ee8:	6912      	ldr	r2, [r2, #16]
 8006eea:	f022 0204 	bic.w	r2, r2, #4
 8006eee:	611a      	str	r2, [r3, #16]

  }   
  /* Return the Erase Status */
  return status;
 8006ef0:	7afb      	ldrb	r3, [r7, #11]
}
 8006ef2:	4618      	mov	r0, r3
 8006ef4:	f107 0710 	add.w	r7, r7, #16
 8006ef8:	46bd      	mov	sp, r7
 8006efa:	bd80      	pop	{r7, pc}
 8006efc:	40023c00 	.word	0x40023c00

08006f00 <FLASH_ProgramDoubleWord>:
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
{
 8006f00:	b580      	push	{r7, lr}
 8006f02:	b086      	sub	sp, #24
 8006f04:	af00      	add	r7, sp, #0
 8006f06:	60f8      	str	r0, [r7, #12]
 8006f08:	e9c7 2300 	strd	r2, r3, [r7]
  FLASH_Status status = FLASH_COMPLETE;
 8006f0c:	f04f 0308 	mov.w	r3, #8
 8006f10:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 8006f12:	f000 fa6f 	bl	80073f4 <FLASH_WaitForLastOperation>
 8006f16:	4603      	mov	r3, r0
 8006f18:	75fb      	strb	r3, [r7, #23]
  
  if(status == FLASH_COMPLETE)
 8006f1a:	7dfb      	ldrb	r3, [r7, #23]
 8006f1c:	2b08      	cmp	r3, #8
 8006f1e:	d120      	bne.n	8006f62 <FLASH_ProgramDoubleWord+0x62>
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR &= CR_PSIZE_MASK;
 8006f20:	4b13      	ldr	r3, [pc, #76]	; (8006f70 <FLASH_ProgramDoubleWord+0x70>)
 8006f22:	4a13      	ldr	r2, [pc, #76]	; (8006f70 <FLASH_ProgramDoubleWord+0x70>)
 8006f24:	6912      	ldr	r2, [r2, #16]
 8006f26:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8006f2a:	611a      	str	r2, [r3, #16]
    FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
 8006f2c:	4b10      	ldr	r3, [pc, #64]	; (8006f70 <FLASH_ProgramDoubleWord+0x70>)
 8006f2e:	4a10      	ldr	r2, [pc, #64]	; (8006f70 <FLASH_ProgramDoubleWord+0x70>)
 8006f30:	6912      	ldr	r2, [r2, #16]
 8006f32:	f442 7240 	orr.w	r2, r2, #768	; 0x300
 8006f36:	611a      	str	r2, [r3, #16]
    FLASH->CR |= FLASH_CR_PG;
 8006f38:	4b0d      	ldr	r3, [pc, #52]	; (8006f70 <FLASH_ProgramDoubleWord+0x70>)
 8006f3a:	4a0d      	ldr	r2, [pc, #52]	; (8006f70 <FLASH_ProgramDoubleWord+0x70>)
 8006f3c:	6912      	ldr	r2, [r2, #16]
 8006f3e:	f042 0201 	orr.w	r2, r2, #1
 8006f42:	611a      	str	r2, [r3, #16]
  
    *(__IO uint64_t*)Address = Data;
 8006f44:	68f9      	ldr	r1, [r7, #12]
 8006f46:	e9d7 2300 	ldrd	r2, r3, [r7]
 8006f4a:	e9c1 2300 	strd	r2, r3, [r1]
        
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 8006f4e:	f000 fa51 	bl	80073f4 <FLASH_WaitForLastOperation>
 8006f52:	4603      	mov	r3, r0
 8006f54:	75fb      	strb	r3, [r7, #23]

    /* if the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);
 8006f56:	4b06      	ldr	r3, [pc, #24]	; (8006f70 <FLASH_ProgramDoubleWord+0x70>)
 8006f58:	4a05      	ldr	r2, [pc, #20]	; (8006f70 <FLASH_ProgramDoubleWord+0x70>)
 8006f5a:	6912      	ldr	r2, [r2, #16]
 8006f5c:	f022 0201 	bic.w	r2, r2, #1
 8006f60:	611a      	str	r2, [r3, #16]
  } 
  /* Return the Program Status */
  return status;
 8006f62:	7dfb      	ldrb	r3, [r7, #23]
}
 8006f64:	4618      	mov	r0, r3
 8006f66:	f107 0718 	add.w	r7, r7, #24
 8006f6a:	46bd      	mov	sp, r7
 8006f6c:	bd80      	pop	{r7, pc}
 8006f6e:	bf00      	nop
 8006f70:	40023c00 	.word	0x40023c00

08006f74 <FLASH_ProgramWord>:
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
{
 8006f74:	b580      	push	{r7, lr}
 8006f76:	b084      	sub	sp, #16
 8006f78:	af00      	add	r7, sp, #0
 8006f7a:	6078      	str	r0, [r7, #4]
 8006f7c:	6039      	str	r1, [r7, #0]
  FLASH_Status status = FLASH_COMPLETE;
 8006f7e:	f04f 0308 	mov.w	r3, #8
 8006f82:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 8006f84:	f000 fa36 	bl	80073f4 <FLASH_WaitForLastOperation>
 8006f88:	4603      	mov	r3, r0
 8006f8a:	73fb      	strb	r3, [r7, #15]
  
  if(status == FLASH_COMPLETE)
 8006f8c:	7bfb      	ldrb	r3, [r7, #15]
 8006f8e:	2b08      	cmp	r3, #8
 8006f90:	d11e      	bne.n	8006fd0 <FLASH_ProgramWord+0x5c>
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR &= CR_PSIZE_MASK;
 8006f92:	4b12      	ldr	r3, [pc, #72]	; (8006fdc <FLASH_ProgramWord+0x68>)
 8006f94:	4a11      	ldr	r2, [pc, #68]	; (8006fdc <FLASH_ProgramWord+0x68>)
 8006f96:	6912      	ldr	r2, [r2, #16]
 8006f98:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8006f9c:	611a      	str	r2, [r3, #16]
    FLASH->CR |= FLASH_PSIZE_WORD;
 8006f9e:	4b0f      	ldr	r3, [pc, #60]	; (8006fdc <FLASH_ProgramWord+0x68>)
 8006fa0:	4a0e      	ldr	r2, [pc, #56]	; (8006fdc <FLASH_ProgramWord+0x68>)
 8006fa2:	6912      	ldr	r2, [r2, #16]
 8006fa4:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8006fa8:	611a      	str	r2, [r3, #16]
    FLASH->CR |= FLASH_CR_PG;
 8006faa:	4b0c      	ldr	r3, [pc, #48]	; (8006fdc <FLASH_ProgramWord+0x68>)
 8006fac:	4a0b      	ldr	r2, [pc, #44]	; (8006fdc <FLASH_ProgramWord+0x68>)
 8006fae:	6912      	ldr	r2, [r2, #16]
 8006fb0:	f042 0201 	orr.w	r2, r2, #1
 8006fb4:	611a      	str	r2, [r3, #16]
  
    *(__IO uint32_t*)Address = Data;
 8006fb6:	687b      	ldr	r3, [r7, #4]
 8006fb8:	683a      	ldr	r2, [r7, #0]
 8006fba:	601a      	str	r2, [r3, #0]
        
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 8006fbc:	f000 fa1a 	bl	80073f4 <FLASH_WaitForLastOperation>
 8006fc0:	4603      	mov	r3, r0
 8006fc2:	73fb      	strb	r3, [r7, #15]

    /* if the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);
 8006fc4:	4b05      	ldr	r3, [pc, #20]	; (8006fdc <FLASH_ProgramWord+0x68>)
 8006fc6:	4a05      	ldr	r2, [pc, #20]	; (8006fdc <FLASH_ProgramWord+0x68>)
 8006fc8:	6912      	ldr	r2, [r2, #16]
 8006fca:	f022 0201 	bic.w	r2, r2, #1
 8006fce:	611a      	str	r2, [r3, #16]
  } 
  /* Return the Program Status */
  return status;
 8006fd0:	7bfb      	ldrb	r3, [r7, #15]
}
 8006fd2:	4618      	mov	r0, r3
 8006fd4:	f107 0710 	add.w	r7, r7, #16
 8006fd8:	46bd      	mov	sp, r7
 8006fda:	bd80      	pop	{r7, pc}
 8006fdc:	40023c00 	.word	0x40023c00

08006fe0 <FLASH_ProgramHalfWord>:
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
{
 8006fe0:	b580      	push	{r7, lr}
 8006fe2:	b084      	sub	sp, #16
 8006fe4:	af00      	add	r7, sp, #0
 8006fe6:	6078      	str	r0, [r7, #4]
 8006fe8:	460b      	mov	r3, r1
 8006fea:	807b      	strh	r3, [r7, #2]
  FLASH_Status status = FLASH_COMPLETE;
 8006fec:	f04f 0308 	mov.w	r3, #8
 8006ff0:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 8006ff2:	f000 f9ff 	bl	80073f4 <FLASH_WaitForLastOperation>
 8006ff6:	4603      	mov	r3, r0
 8006ff8:	73fb      	strb	r3, [r7, #15]
  
  if(status == FLASH_COMPLETE)
 8006ffa:	7bfb      	ldrb	r3, [r7, #15]
 8006ffc:	2b08      	cmp	r3, #8
 8006ffe:	d11e      	bne.n	800703e <FLASH_ProgramHalfWord+0x5e>
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR &= CR_PSIZE_MASK;
 8007000:	4b12      	ldr	r3, [pc, #72]	; (800704c <FLASH_ProgramHalfWord+0x6c>)
 8007002:	4a12      	ldr	r2, [pc, #72]	; (800704c <FLASH_ProgramHalfWord+0x6c>)
 8007004:	6912      	ldr	r2, [r2, #16]
 8007006:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 800700a:	611a      	str	r2, [r3, #16]
    FLASH->CR |= FLASH_PSIZE_HALF_WORD;
 800700c:	4b0f      	ldr	r3, [pc, #60]	; (800704c <FLASH_ProgramHalfWord+0x6c>)
 800700e:	4a0f      	ldr	r2, [pc, #60]	; (800704c <FLASH_ProgramHalfWord+0x6c>)
 8007010:	6912      	ldr	r2, [r2, #16]
 8007012:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8007016:	611a      	str	r2, [r3, #16]
    FLASH->CR |= FLASH_CR_PG;
 8007018:	4b0c      	ldr	r3, [pc, #48]	; (800704c <FLASH_ProgramHalfWord+0x6c>)
 800701a:	4a0c      	ldr	r2, [pc, #48]	; (800704c <FLASH_ProgramHalfWord+0x6c>)
 800701c:	6912      	ldr	r2, [r2, #16]
 800701e:	f042 0201 	orr.w	r2, r2, #1
 8007022:	611a      	str	r2, [r3, #16]
  
    *(__IO uint16_t*)Address = Data;
 8007024:	687b      	ldr	r3, [r7, #4]
 8007026:	887a      	ldrh	r2, [r7, #2]
 8007028:	801a      	strh	r2, [r3, #0]
        
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 800702a:	f000 f9e3 	bl	80073f4 <FLASH_WaitForLastOperation>
 800702e:	4603      	mov	r3, r0
 8007030:	73fb      	strb	r3, [r7, #15]

    /* if the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);
 8007032:	4b06      	ldr	r3, [pc, #24]	; (800704c <FLASH_ProgramHalfWord+0x6c>)
 8007034:	4a05      	ldr	r2, [pc, #20]	; (800704c <FLASH_ProgramHalfWord+0x6c>)
 8007036:	6912      	ldr	r2, [r2, #16]
 8007038:	f022 0201 	bic.w	r2, r2, #1
 800703c:	611a      	str	r2, [r3, #16]
  } 
  /* Return the Program Status */
  return status;
 800703e:	7bfb      	ldrb	r3, [r7, #15]
}
 8007040:	4618      	mov	r0, r3
 8007042:	f107 0710 	add.w	r7, r7, #16
 8007046:	46bd      	mov	sp, r7
 8007048:	bd80      	pop	{r7, pc}
 800704a:	bf00      	nop
 800704c:	40023c00 	.word	0x40023c00

08007050 <FLASH_ProgramByte>:
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
{
 8007050:	b580      	push	{r7, lr}
 8007052:	b084      	sub	sp, #16
 8007054:	af00      	add	r7, sp, #0
 8007056:	6078      	str	r0, [r7, #4]
 8007058:	460b      	mov	r3, r1
 800705a:	70fb      	strb	r3, [r7, #3]
  FLASH_Status status = FLASH_COMPLETE;
 800705c:	f04f 0308 	mov.w	r3, #8
 8007060:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 8007062:	f000 f9c7 	bl	80073f4 <FLASH_WaitForLastOperation>
 8007066:	4603      	mov	r3, r0
 8007068:	73fb      	strb	r3, [r7, #15]
  
  if(status == FLASH_COMPLETE)
 800706a:	7bfb      	ldrb	r3, [r7, #15]
 800706c:	2b08      	cmp	r3, #8
 800706e:	d11c      	bne.n	80070aa <FLASH_ProgramByte+0x5a>
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR &= CR_PSIZE_MASK;
 8007070:	4b11      	ldr	r3, [pc, #68]	; (80070b8 <FLASH_ProgramByte+0x68>)
 8007072:	4a11      	ldr	r2, [pc, #68]	; (80070b8 <FLASH_ProgramByte+0x68>)
 8007074:	6912      	ldr	r2, [r2, #16]
 8007076:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 800707a:	611a      	str	r2, [r3, #16]
    FLASH->CR |= FLASH_PSIZE_BYTE;
 800707c:	4b0e      	ldr	r3, [pc, #56]	; (80070b8 <FLASH_ProgramByte+0x68>)
 800707e:	4a0e      	ldr	r2, [pc, #56]	; (80070b8 <FLASH_ProgramByte+0x68>)
 8007080:	6912      	ldr	r2, [r2, #16]
 8007082:	611a      	str	r2, [r3, #16]
    FLASH->CR |= FLASH_CR_PG;
 8007084:	4b0c      	ldr	r3, [pc, #48]	; (80070b8 <FLASH_ProgramByte+0x68>)
 8007086:	4a0c      	ldr	r2, [pc, #48]	; (80070b8 <FLASH_ProgramByte+0x68>)
 8007088:	6912      	ldr	r2, [r2, #16]
 800708a:	f042 0201 	orr.w	r2, r2, #1
 800708e:	611a      	str	r2, [r3, #16]
  
    *(__IO uint8_t*)Address = Data;
 8007090:	687b      	ldr	r3, [r7, #4]
 8007092:	78fa      	ldrb	r2, [r7, #3]
 8007094:	701a      	strb	r2, [r3, #0]
        
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 8007096:	f000 f9ad 	bl	80073f4 <FLASH_WaitForLastOperation>
 800709a:	4603      	mov	r3, r0
 800709c:	73fb      	strb	r3, [r7, #15]

    /* if the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);
 800709e:	4b06      	ldr	r3, [pc, #24]	; (80070b8 <FLASH_ProgramByte+0x68>)
 80070a0:	4a05      	ldr	r2, [pc, #20]	; (80070b8 <FLASH_ProgramByte+0x68>)
 80070a2:	6912      	ldr	r2, [r2, #16]
 80070a4:	f022 0201 	bic.w	r2, r2, #1
 80070a8:	611a      	str	r2, [r3, #16]
  } 

  /* Return the Program Status */
  return status;
 80070aa:	7bfb      	ldrb	r3, [r7, #15]
}
 80070ac:	4618      	mov	r0, r3
 80070ae:	f107 0710 	add.w	r7, r7, #16
 80070b2:	46bd      	mov	sp, r7
 80070b4:	bd80      	pop	{r7, pc}
 80070b6:	bf00      	nop
 80070b8:	40023c00 	.word	0x40023c00

080070bc <FLASH_OB_Unlock>:
  * @brief  Unlocks the FLASH Option Control Registers access.
  * @param  None
  * @retval None
  */
void FLASH_OB_Unlock(void)
{
 80070bc:	b480      	push	{r7}
 80070be:	af00      	add	r7, sp, #0
  if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
 80070c0:	4b07      	ldr	r3, [pc, #28]	; (80070e0 <FLASH_OB_Unlock+0x24>)
 80070c2:	695b      	ldr	r3, [r3, #20]
 80070c4:	f003 0301 	and.w	r3, r3, #1
 80070c8:	2b00      	cmp	r3, #0
 80070ca:	d005      	beq.n	80070d8 <FLASH_OB_Unlock+0x1c>
  {
    /* Authorizes the Option Byte register programming */
    FLASH->OPTKEYR = FLASH_OPT_KEY1;
 80070cc:	4b04      	ldr	r3, [pc, #16]	; (80070e0 <FLASH_OB_Unlock+0x24>)
 80070ce:	4a05      	ldr	r2, [pc, #20]	; (80070e4 <FLASH_OB_Unlock+0x28>)
 80070d0:	609a      	str	r2, [r3, #8]
    FLASH->OPTKEYR = FLASH_OPT_KEY2;
 80070d2:	4b03      	ldr	r3, [pc, #12]	; (80070e0 <FLASH_OB_Unlock+0x24>)
 80070d4:	4a04      	ldr	r2, [pc, #16]	; (80070e8 <FLASH_OB_Unlock+0x2c>)
 80070d6:	609a      	str	r2, [r3, #8]
  }  
}
 80070d8:	46bd      	mov	sp, r7
 80070da:	bc80      	pop	{r7}
 80070dc:	4770      	bx	lr
 80070de:	bf00      	nop
 80070e0:	40023c00 	.word	0x40023c00
 80070e4:	08192a3b 	.word	0x08192a3b
 80070e8:	4c5d6e7f 	.word	0x4c5d6e7f

080070ec <FLASH_OB_Lock>:
  * @brief  Locks the FLASH Option Control Registers access.
  * @param  None
  * @retval None
  */
void FLASH_OB_Lock(void)
{
 80070ec:	b480      	push	{r7}
 80070ee:	af00      	add	r7, sp, #0
  /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
  FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
 80070f0:	4b04      	ldr	r3, [pc, #16]	; (8007104 <FLASH_OB_Lock+0x18>)
 80070f2:	4a04      	ldr	r2, [pc, #16]	; (8007104 <FLASH_OB_Lock+0x18>)
 80070f4:	6952      	ldr	r2, [r2, #20]
 80070f6:	f042 0201 	orr.w	r2, r2, #1
 80070fa:	615a      	str	r2, [r3, #20]
}
 80070fc:	46bd      	mov	sp, r7
 80070fe:	bc80      	pop	{r7}
 8007100:	4770      	bx	lr
 8007102:	bf00      	nop
 8007104:	40023c00 	.word	0x40023c00

08007108 <FLASH_OB_WRPConfig>:
  * @param  Newstate: new state of the Write Protection.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None  
  */
void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
{ 
 8007108:	b580      	push	{r7, lr}
 800710a:	b084      	sub	sp, #16
 800710c:	af00      	add	r7, sp, #0
 800710e:	6078      	str	r0, [r7, #4]
 8007110:	460b      	mov	r3, r1
 8007112:	70fb      	strb	r3, [r7, #3]
  FLASH_Status status = FLASH_COMPLETE;
 8007114:	f04f 0308 	mov.w	r3, #8
 8007118:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_OB_WRP(OB_WRP));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  status = FLASH_WaitForLastOperation();
 800711a:	f000 f96b 	bl	80073f4 <FLASH_WaitForLastOperation>
 800711e:	4603      	mov	r3, r0
 8007120:	73fb      	strb	r3, [r7, #15]

  if(status == FLASH_COMPLETE)
 8007122:	7bfb      	ldrb	r3, [r7, #15]
 8007124:	2b08      	cmp	r3, #8
 8007126:	d118      	bne.n	800715a <FLASH_OB_WRPConfig+0x52>
  { 
    if(NewState != DISABLE)
 8007128:	78fb      	ldrb	r3, [r7, #3]
 800712a:	2b00      	cmp	r3, #0
 800712c:	d00c      	beq.n	8007148 <FLASH_OB_WRPConfig+0x40>
    {
      *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_WRP);
 800712e:	4b0d      	ldr	r3, [pc, #52]	; (8007164 <FLASH_OB_WRPConfig+0x5c>)
 8007130:	4a0c      	ldr	r2, [pc, #48]	; (8007164 <FLASH_OB_WRPConfig+0x5c>)
 8007132:	8812      	ldrh	r2, [r2, #0]
 8007134:	b291      	uxth	r1, r2
 8007136:	687a      	ldr	r2, [r7, #4]
 8007138:	b292      	uxth	r2, r2
 800713a:	ea6f 0202 	mvn.w	r2, r2
 800713e:	b292      	uxth	r2, r2
 8007140:	400a      	ands	r2, r1
 8007142:	b292      	uxth	r2, r2
 8007144:	801a      	strh	r2, [r3, #0]
 8007146:	e008      	b.n	800715a <FLASH_OB_WRPConfig+0x52>
    }
    else
    {
      *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
 8007148:	4b06      	ldr	r3, [pc, #24]	; (8007164 <FLASH_OB_WRPConfig+0x5c>)
 800714a:	4a06      	ldr	r2, [pc, #24]	; (8007164 <FLASH_OB_WRPConfig+0x5c>)
 800714c:	8812      	ldrh	r2, [r2, #0]
 800714e:	b291      	uxth	r1, r2
 8007150:	687a      	ldr	r2, [r7, #4]
 8007152:	b292      	uxth	r2, r2
 8007154:	430a      	orrs	r2, r1
 8007156:	b292      	uxth	r2, r2
 8007158:	801a      	strh	r2, [r3, #0]
    }
  }
}
 800715a:	f107 0710 	add.w	r7, r7, #16
 800715e:	46bd      	mov	sp, r7
 8007160:	bd80      	pop	{r7, pc}
 8007162:	bf00      	nop
 8007164:	40023c16 	.word	0x40023c16

08007168 <FLASH_OB_RDPConfig>:
  * !!!Warning!!! When enabling OB_RDP level 2 it's no more possible to go back to level 1 or 0
  *    
  * @retval None
  */
void FLASH_OB_RDPConfig(uint8_t OB_RDP)
{
 8007168:	b580      	push	{r7, lr}
 800716a:	b084      	sub	sp, #16
 800716c:	af00      	add	r7, sp, #0
 800716e:	4603      	mov	r3, r0
 8007170:	71fb      	strb	r3, [r7, #7]
  FLASH_Status status = FLASH_COMPLETE;
 8007172:	f04f 0308 	mov.w	r3, #8
 8007176:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_OB_RDP(OB_RDP));

  status = FLASH_WaitForLastOperation();
 8007178:	f000 f93c 	bl	80073f4 <FLASH_WaitForLastOperation>
 800717c:	4603      	mov	r3, r0
 800717e:	73fb      	strb	r3, [r7, #15]

  if(status == FLASH_COMPLETE)
 8007180:	7bfb      	ldrb	r3, [r7, #15]
 8007182:	2b08      	cmp	r3, #8
 8007184:	d102      	bne.n	800718c <FLASH_OB_RDPConfig+0x24>
  {
    *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = OB_RDP;
 8007186:	4b03      	ldr	r3, [pc, #12]	; (8007194 <FLASH_OB_RDPConfig+0x2c>)
 8007188:	79fa      	ldrb	r2, [r7, #7]
 800718a:	701a      	strb	r2, [r3, #0]

  }
}
 800718c:	f107 0710 	add.w	r7, r7, #16
 8007190:	46bd      	mov	sp, r7
 8007192:	bd80      	pop	{r7, pc}
 8007194:	40023c15 	.word	0x40023c15

08007198 <FLASH_OB_UserConfig>:
  *            @arg OB_STDBY_NoRST: No reset generated when entering in STANDBY
  *            @arg OB_STDBY_RST: Reset generated when entering in STANDBY
  * @retval None
  */
void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
{
 8007198:	b580      	push	{r7, lr}
 800719a:	b084      	sub	sp, #16
 800719c:	af00      	add	r7, sp, #0
 800719e:	4613      	mov	r3, r2
 80071a0:	4602      	mov	r2, r0
 80071a2:	71fa      	strb	r2, [r7, #7]
 80071a4:	460a      	mov	r2, r1
 80071a6:	71ba      	strb	r2, [r7, #6]
 80071a8:	717b      	strb	r3, [r7, #5]
  uint8_t optiontmp = 0xFF;
 80071aa:	f04f 03ff 	mov.w	r3, #255	; 0xff
 80071ae:	73fb      	strb	r3, [r7, #15]
  FLASH_Status status = FLASH_COMPLETE; 
 80071b0:	f04f 0308 	mov.w	r3, #8
 80071b4:	73bb      	strb	r3, [r7, #14]
  assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
  assert_param(IS_OB_STOP_SOURCE(OB_STOP));
  assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 80071b6:	f000 f91d 	bl	80073f4 <FLASH_WaitForLastOperation>
 80071ba:	4603      	mov	r3, r0
 80071bc:	73bb      	strb	r3, [r7, #14]
  
  if(status == FLASH_COMPLETE)
 80071be:	7bbb      	ldrb	r3, [r7, #14]
 80071c0:	2b08      	cmp	r3, #8
 80071c2:	d111      	bne.n	80071e8 <FLASH_OB_UserConfig+0x50>
  { 
    /* Mask OPTLOCK, OPTSTRT and BOR_LEV bits */
    optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0F); 
 80071c4:	4b0a      	ldr	r3, [pc, #40]	; (80071f0 <FLASH_OB_UserConfig+0x58>)
 80071c6:	781b      	ldrb	r3, [r3, #0]
 80071c8:	b2db      	uxtb	r3, r3
 80071ca:	f003 030f 	and.w	r3, r3, #15
 80071ce:	73fb      	strb	r3, [r7, #15]

    /* Update User Option Byte */
    *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS = OB_IWDG | (uint8_t)(OB_STDBY | (uint8_t)(OB_STOP | ((uint8_t)optiontmp))); 
 80071d0:	4b07      	ldr	r3, [pc, #28]	; (80071f0 <FLASH_OB_UserConfig+0x58>)
 80071d2:	79b9      	ldrb	r1, [r7, #6]
 80071d4:	7bfa      	ldrb	r2, [r7, #15]
 80071d6:	430a      	orrs	r2, r1
 80071d8:	b2d1      	uxtb	r1, r2
 80071da:	797a      	ldrb	r2, [r7, #5]
 80071dc:	430a      	orrs	r2, r1
 80071de:	b2d1      	uxtb	r1, r2
 80071e0:	79fa      	ldrb	r2, [r7, #7]
 80071e2:	430a      	orrs	r2, r1
 80071e4:	b2d2      	uxtb	r2, r2
 80071e6:	701a      	strb	r2, [r3, #0]
  }  
}
 80071e8:	f107 0710 	add.w	r7, r7, #16
 80071ec:	46bd      	mov	sp, r7
 80071ee:	bd80      	pop	{r7, pc}
 80071f0:	40023c14 	.word	0x40023c14

080071f4 <FLASH_OB_BORConfig>:
  *            @arg OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
  *            @arg OB_BOR_OFF: Supply voltage ranges from 1.62 to 2.1 V
  * @retval None
  */
void FLASH_OB_BORConfig(uint8_t OB_BOR)
{
 80071f4:	b480      	push	{r7}
 80071f6:	b083      	sub	sp, #12
 80071f8:	af00      	add	r7, sp, #0
 80071fa:	4603      	mov	r3, r0
 80071fc:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_OB_BOR(OB_BOR));

  /* Set the BOR Level */
  *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BOR_LEV);
 80071fe:	4b0a      	ldr	r3, [pc, #40]	; (8007228 <FLASH_OB_BORConfig+0x34>)
 8007200:	4a09      	ldr	r2, [pc, #36]	; (8007228 <FLASH_OB_BORConfig+0x34>)
 8007202:	7812      	ldrb	r2, [r2, #0]
 8007204:	b2d2      	uxtb	r2, r2
 8007206:	f022 020c 	bic.w	r2, r2, #12
 800720a:	b2d2      	uxtb	r2, r2
 800720c:	701a      	strb	r2, [r3, #0]
  *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOR;
 800720e:	4b06      	ldr	r3, [pc, #24]	; (8007228 <FLASH_OB_BORConfig+0x34>)
 8007210:	4a05      	ldr	r2, [pc, #20]	; (8007228 <FLASH_OB_BORConfig+0x34>)
 8007212:	7812      	ldrb	r2, [r2, #0]
 8007214:	b2d1      	uxtb	r1, r2
 8007216:	79fa      	ldrb	r2, [r7, #7]
 8007218:	430a      	orrs	r2, r1
 800721a:	b2d2      	uxtb	r2, r2
 800721c:	701a      	strb	r2, [r3, #0]

}
 800721e:	f107 070c 	add.w	r7, r7, #12
 8007222:	46bd      	mov	sp, r7
 8007224:	bc80      	pop	{r7}
 8007226:	4770      	bx	lr
 8007228:	40023c14 	.word	0x40023c14

0800722c <FLASH_OB_Launch>:
  * @param  None
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_OB_Launch(void)
{
 800722c:	b580      	push	{r7, lr}
 800722e:	b082      	sub	sp, #8
 8007230:	af00      	add	r7, sp, #0
  FLASH_Status status = FLASH_COMPLETE;
 8007232:	f04f 0308 	mov.w	r3, #8
 8007236:	71fb      	strb	r3, [r7, #7]

  /* Set the OPTSTRT bit in OPTCR register */
  *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= FLASH_OPTCR_OPTSTRT;
 8007238:	4b08      	ldr	r3, [pc, #32]	; (800725c <FLASH_OB_Launch+0x30>)
 800723a:	4a08      	ldr	r2, [pc, #32]	; (800725c <FLASH_OB_Launch+0x30>)
 800723c:	7812      	ldrb	r2, [r2, #0]
 800723e:	b2d2      	uxtb	r2, r2
 8007240:	f042 0202 	orr.w	r2, r2, #2
 8007244:	b2d2      	uxtb	r2, r2
 8007246:	701a      	strb	r2, [r3, #0]

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 8007248:	f000 f8d4 	bl	80073f4 <FLASH_WaitForLastOperation>
 800724c:	4603      	mov	r3, r0
 800724e:	71fb      	strb	r3, [r7, #7]

  return status;
 8007250:	79fb      	ldrb	r3, [r7, #7]
}
 8007252:	4618      	mov	r0, r3
 8007254:	f107 0708 	add.w	r7, r7, #8
 8007258:	46bd      	mov	sp, r7
 800725a:	bd80      	pop	{r7, pc}
 800725c:	40023c14 	.word	0x40023c14

08007260 <FLASH_OB_GetUser>:
  * @param  None
  * @retval The FLASH User Option Bytes values: IWDG_SW(Bit0), RST_STOP(Bit1)
  *         and RST_STDBY(Bit2).
  */
uint8_t FLASH_OB_GetUser(void)
{
 8007260:	b480      	push	{r7}
 8007262:	af00      	add	r7, sp, #0
  /* Return the User Option Byte */
  return (uint8_t)(FLASH->OPTCR >> 5);
 8007264:	4b04      	ldr	r3, [pc, #16]	; (8007278 <FLASH_OB_GetUser+0x18>)
 8007266:	695b      	ldr	r3, [r3, #20]
 8007268:	ea4f 1353 	mov.w	r3, r3, lsr #5
 800726c:	b2db      	uxtb	r3, r3
}
 800726e:	4618      	mov	r0, r3
 8007270:	46bd      	mov	sp, r7
 8007272:	bc80      	pop	{r7}
 8007274:	4770      	bx	lr
 8007276:	bf00      	nop
 8007278:	40023c00 	.word	0x40023c00

0800727c <FLASH_OB_GetWRP>:
  * @brief  Returns the FLASH Write Protection Option Bytes value.
  * @param  None
  * @retval The FLASH Write Protection  Option Bytes value
  */
uint16_t FLASH_OB_GetWRP(void)
{
 800727c:	b480      	push	{r7}
 800727e:	af00      	add	r7, sp, #0
  /* Return the FLASH write protection Register value */
  return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
 8007280:	4b03      	ldr	r3, [pc, #12]	; (8007290 <FLASH_OB_GetWRP+0x14>)
 8007282:	881b      	ldrh	r3, [r3, #0]
 8007284:	b29b      	uxth	r3, r3
}
 8007286:	4618      	mov	r0, r3
 8007288:	46bd      	mov	sp, r7
 800728a:	bc80      	pop	{r7}
 800728c:	4770      	bx	lr
 800728e:	bf00      	nop
 8007290:	40023c16 	.word	0x40023c16

08007294 <FLASH_OB_GetRDP>:
  * @retval FLASH ReadOut Protection Status:
  *           - SET, when OB_RDP_Level_1 or OB_RDP_Level_2 is set
  *           - RESET, when OB_RDP_Level_0 is set
  */
FlagStatus FLASH_OB_GetRDP(void)
{
 8007294:	b480      	push	{r7}
 8007296:	b083      	sub	sp, #12
 8007298:	af00      	add	r7, sp, #0
  FlagStatus readstatus = RESET;
 800729a:	f04f 0300 	mov.w	r3, #0
 800729e:	71fb      	strb	r3, [r7, #7]

  if ((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) != (uint8_t)OB_RDP_Level_0))
 80072a0:	4b09      	ldr	r3, [pc, #36]	; (80072c8 <FLASH_OB_GetRDP+0x34>)
 80072a2:	781b      	ldrb	r3, [r3, #0]
 80072a4:	b2db      	uxtb	r3, r3
 80072a6:	2baa      	cmp	r3, #170	; 0xaa
 80072a8:	d003      	beq.n	80072b2 <FLASH_OB_GetRDP+0x1e>
  {
    readstatus = SET;
 80072aa:	f04f 0301 	mov.w	r3, #1
 80072ae:	71fb      	strb	r3, [r7, #7]
 80072b0:	e002      	b.n	80072b8 <FLASH_OB_GetRDP+0x24>
  }
  else
  {
    readstatus = RESET;
 80072b2:	f04f 0300 	mov.w	r3, #0
 80072b6:	71fb      	strb	r3, [r7, #7]
  }
  return readstatus;
 80072b8:	79fb      	ldrb	r3, [r7, #7]
}
 80072ba:	4618      	mov	r0, r3
 80072bc:	f107 070c 	add.w	r7, r7, #12
 80072c0:	46bd      	mov	sp, r7
 80072c2:	bc80      	pop	{r7}
 80072c4:	4770      	bx	lr
 80072c6:	bf00      	nop
 80072c8:	40023c15 	.word	0x40023c15

080072cc <FLASH_OB_GetBOR>:
  *           - OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
  *           - OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
  *           - OB_BOR_OFF   : Supply voltage ranges from 1.62 to 2.1 V  
  */
uint8_t FLASH_OB_GetBOR(void)
{
 80072cc:	b480      	push	{r7}
 80072ce:	af00      	add	r7, sp, #0
  /* Return the FLASH BOR level */
  return (uint8_t)(*(__IO uint8_t *)(OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0C);
 80072d0:	4b04      	ldr	r3, [pc, #16]	; (80072e4 <FLASH_OB_GetBOR+0x18>)
 80072d2:	781b      	ldrb	r3, [r3, #0]
 80072d4:	b2db      	uxtb	r3, r3
 80072d6:	f003 030c 	and.w	r3, r3, #12
 80072da:	b2db      	uxtb	r3, r3
}
 80072dc:	4618      	mov	r0, r3
 80072de:	46bd      	mov	sp, r7
 80072e0:	bc80      	pop	{r7}
 80072e2:	4770      	bx	lr
 80072e4:	40023c14 	.word	0x40023c14

080072e8 <FLASH_ITConfig>:
  *            @arg FLASH_IT_ERR: FLASH Error Interrupt
  *            @arg FLASH_IT_EOP: FLASH end of operation Interrupt
  * @retval None 
  */
void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
{
 80072e8:	b480      	push	{r7}
 80072ea:	b083      	sub	sp, #12
 80072ec:	af00      	add	r7, sp, #0
 80072ee:	6078      	str	r0, [r7, #4]
 80072f0:	460b      	mov	r3, r1
 80072f2:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_FLASH_IT(FLASH_IT)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if(NewState != DISABLE)
 80072f4:	78fb      	ldrb	r3, [r7, #3]
 80072f6:	2b00      	cmp	r3, #0
 80072f8:	d006      	beq.n	8007308 <FLASH_ITConfig+0x20>
  {
    /* Enable the interrupt sources */
    FLASH->CR |= FLASH_IT;
 80072fa:	4b0a      	ldr	r3, [pc, #40]	; (8007324 <FLASH_ITConfig+0x3c>)
 80072fc:	4a09      	ldr	r2, [pc, #36]	; (8007324 <FLASH_ITConfig+0x3c>)
 80072fe:	6911      	ldr	r1, [r2, #16]
 8007300:	687a      	ldr	r2, [r7, #4]
 8007302:	430a      	orrs	r2, r1
 8007304:	611a      	str	r2, [r3, #16]
 8007306:	e007      	b.n	8007318 <FLASH_ITConfig+0x30>
  }
  else
  {
    /* Disable the interrupt sources */
    FLASH->CR &= ~(uint32_t)FLASH_IT;
 8007308:	4b06      	ldr	r3, [pc, #24]	; (8007324 <FLASH_ITConfig+0x3c>)
 800730a:	4a06      	ldr	r2, [pc, #24]	; (8007324 <FLASH_ITConfig+0x3c>)
 800730c:	6911      	ldr	r1, [r2, #16]
 800730e:	687a      	ldr	r2, [r7, #4]
 8007310:	ea6f 0202 	mvn.w	r2, r2
 8007314:	400a      	ands	r2, r1
 8007316:	611a      	str	r2, [r3, #16]
  }
}
 8007318:	f107 070c 	add.w	r7, r7, #12
 800731c:	46bd      	mov	sp, r7
 800731e:	bc80      	pop	{r7}
 8007320:	4770      	bx	lr
 8007322:	bf00      	nop
 8007324:	40023c00 	.word	0x40023c00

08007328 <FLASH_GetFlagStatus>:
  *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
  *            @arg FLASH_FLAG_BSY: FLASH Busy flag
  * @retval The new state of FLASH_FLAG (SET or RESET).
  */
FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
{
 8007328:	b480      	push	{r7}
 800732a:	b085      	sub	sp, #20
 800732c:	af00      	add	r7, sp, #0
 800732e:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
 8007330:	f04f 0300 	mov.w	r3, #0
 8007334:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG));

  if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
 8007336:	4b0a      	ldr	r3, [pc, #40]	; (8007360 <FLASH_GetFlagStatus+0x38>)
 8007338:	68da      	ldr	r2, [r3, #12]
 800733a:	687b      	ldr	r3, [r7, #4]
 800733c:	4013      	ands	r3, r2
 800733e:	2b00      	cmp	r3, #0
 8007340:	d003      	beq.n	800734a <FLASH_GetFlagStatus+0x22>
  {
    bitstatus = SET;
 8007342:	f04f 0301 	mov.w	r3, #1
 8007346:	73fb      	strb	r3, [r7, #15]
 8007348:	e002      	b.n	8007350 <FLASH_GetFlagStatus+0x28>
  }
  else
  {
    bitstatus = RESET;
 800734a:	f04f 0300 	mov.w	r3, #0
 800734e:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the new state of FLASH_FLAG (SET or RESET) */
  return bitstatus; 
 8007350:	7bfb      	ldrb	r3, [r7, #15]
}
 8007352:	4618      	mov	r0, r3
 8007354:	f107 0714 	add.w	r7, r7, #20
 8007358:	46bd      	mov	sp, r7
 800735a:	bc80      	pop	{r7}
 800735c:	4770      	bx	lr
 800735e:	bf00      	nop
 8007360:	40023c00 	.word	0x40023c00

08007364 <FLASH_ClearFlag>:
  *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
  *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
  * @retval None
  */
void FLASH_ClearFlag(uint32_t FLASH_FLAG)
{
 8007364:	b480      	push	{r7}
 8007366:	b083      	sub	sp, #12
 8007368:	af00      	add	r7, sp, #0
 800736a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
  
  /* Clear the flags */
  FLASH->SR = FLASH_FLAG;
 800736c:	4b03      	ldr	r3, [pc, #12]	; (800737c <FLASH_ClearFlag+0x18>)
 800736e:	687a      	ldr	r2, [r7, #4]
 8007370:	60da      	str	r2, [r3, #12]
}
 8007372:	f107 070c 	add.w	r7, r7, #12
 8007376:	46bd      	mov	sp, r7
 8007378:	bc80      	pop	{r7}
 800737a:	4770      	bx	lr
 800737c:	40023c00 	.word	0x40023c00

08007380 <FLASH_GetStatus>:
  * @param  None
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_GetStatus(void)
{
 8007380:	b480      	push	{r7}
 8007382:	b083      	sub	sp, #12
 8007384:	af00      	add	r7, sp, #0
  FLASH_Status flashstatus = FLASH_COMPLETE;
 8007386:	f04f 0308 	mov.w	r3, #8
 800738a:	71fb      	strb	r3, [r7, #7]
  
  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
 800738c:	4b18      	ldr	r3, [pc, #96]	; (80073f0 <FLASH_GetStatus+0x70>)
 800738e:	68db      	ldr	r3, [r3, #12]
 8007390:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8007394:	2b00      	cmp	r3, #0
 8007396:	d003      	beq.n	80073a0 <FLASH_GetStatus+0x20>
  {
    flashstatus = FLASH_BUSY;
 8007398:	f04f 0301 	mov.w	r3, #1
 800739c:	71fb      	strb	r3, [r7, #7]
 800739e:	e020      	b.n	80073e2 <FLASH_GetStatus+0x62>
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_WRPERR) != (uint32_t)0x00)
 80073a0:	4b13      	ldr	r3, [pc, #76]	; (80073f0 <FLASH_GetStatus+0x70>)
 80073a2:	68db      	ldr	r3, [r3, #12]
 80073a4:	f003 0310 	and.w	r3, r3, #16
 80073a8:	2b00      	cmp	r3, #0
 80073aa:	d003      	beq.n	80073b4 <FLASH_GetStatus+0x34>
    { 
      flashstatus = FLASH_ERROR_WRP;
 80073ac:	f04f 0305 	mov.w	r3, #5
 80073b0:	71fb      	strb	r3, [r7, #7]
 80073b2:	e016      	b.n	80073e2 <FLASH_GetStatus+0x62>
    }
    else 
    {
      if((FLASH->SR & (uint32_t)0xEF) != (uint32_t)0x00)
 80073b4:	4b0e      	ldr	r3, [pc, #56]	; (80073f0 <FLASH_GetStatus+0x70>)
 80073b6:	68db      	ldr	r3, [r3, #12]
 80073b8:	f003 03ef 	and.w	r3, r3, #239	; 0xef
 80073bc:	2b00      	cmp	r3, #0
 80073be:	d003      	beq.n	80073c8 <FLASH_GetStatus+0x48>
      {
        flashstatus = FLASH_ERROR_PROGRAM; 
 80073c0:	f04f 0306 	mov.w	r3, #6
 80073c4:	71fb      	strb	r3, [r7, #7]
 80073c6:	e00c      	b.n	80073e2 <FLASH_GetStatus+0x62>
      }
      else
      {
        if((FLASH->SR & FLASH_FLAG_OPERR) != (uint32_t)0x00)
 80073c8:	4b09      	ldr	r3, [pc, #36]	; (80073f0 <FLASH_GetStatus+0x70>)
 80073ca:	68db      	ldr	r3, [r3, #12]
 80073cc:	f003 0302 	and.w	r3, r3, #2
 80073d0:	2b00      	cmp	r3, #0
 80073d2:	d003      	beq.n	80073dc <FLASH_GetStatus+0x5c>
        {
          flashstatus = FLASH_ERROR_OPERATION;
 80073d4:	f04f 0307 	mov.w	r3, #7
 80073d8:	71fb      	strb	r3, [r7, #7]
 80073da:	e002      	b.n	80073e2 <FLASH_GetStatus+0x62>
        }
        else
        {
          flashstatus = FLASH_COMPLETE;
 80073dc:	f04f 0308 	mov.w	r3, #8
 80073e0:	71fb      	strb	r3, [r7, #7]
        }
      }
    }
  }
  /* Return the FLASH Status */
  return flashstatus;
 80073e2:	79fb      	ldrb	r3, [r7, #7]
}
 80073e4:	4618      	mov	r0, r3
 80073e6:	f107 070c 	add.w	r7, r7, #12
 80073ea:	46bd      	mov	sp, r7
 80073ec:	bc80      	pop	{r7}
 80073ee:	4770      	bx	lr
 80073f0:	40023c00 	.word	0x40023c00

080073f4 <FLASH_WaitForLastOperation>:
  * @param  None
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_WaitForLastOperation(void)
{ 
 80073f4:	b580      	push	{r7, lr}
 80073f6:	b082      	sub	sp, #8
 80073f8:	af00      	add	r7, sp, #0
  __IO FLASH_Status status = FLASH_COMPLETE;
 80073fa:	f04f 0308 	mov.w	r3, #8
 80073fe:	71fb      	strb	r3, [r7, #7]
   
  /* Check for the FLASH Status */
  status = FLASH_GetStatus();
 8007400:	f7ff ffbe 	bl	8007380 <FLASH_GetStatus>
 8007404:	4603      	mov	r3, r0
 8007406:	71fb      	strb	r3, [r7, #7]

  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
  while(status == FLASH_BUSY)
 8007408:	e003      	b.n	8007412 <FLASH_WaitForLastOperation+0x1e>
  {
    status = FLASH_GetStatus();
 800740a:	f7ff ffb9 	bl	8007380 <FLASH_GetStatus>
 800740e:	4603      	mov	r3, r0
 8007410:	71fb      	strb	r3, [r7, #7]
  status = FLASH_GetStatus();

  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
  while(status == FLASH_BUSY)
 8007412:	79fb      	ldrb	r3, [r7, #7]
 8007414:	b2db      	uxtb	r3, r3
 8007416:	2b01      	cmp	r3, #1
 8007418:	d0f7      	beq.n	800740a <FLASH_WaitForLastOperation+0x16>
  {
    status = FLASH_GetStatus();
  }
  /* Return the operation status */
  return status;
 800741a:	79fb      	ldrb	r3, [r7, #7]
 800741c:	b2db      	uxtb	r3, r3
}
 800741e:	4618      	mov	r0, r3
 8007420:	f107 0708 	add.w	r7, r7, #8
 8007424:	46bd      	mov	sp, r7
 8007426:	bd80      	pop	{r7, pc}

08007428 <GPIO_DeInit>:
  * @note   By default, The GPIO pins are configured in input floating mode (except JTAG pins).
  * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
  * @retval None
  */
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
 8007428:	b580      	push	{r7, lr}
 800742a:	b082      	sub	sp, #8
 800742c:	af00      	add	r7, sp, #0
 800742e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
 8007430:	687a      	ldr	r2, [r7, #4]
 8007432:	4b4d      	ldr	r3, [pc, #308]	; (8007568 <GPIO_DeInit+0x140>)
 8007434:	429a      	cmp	r2, r3
 8007436:	d10c      	bne.n	8007452 <GPIO_DeInit+0x2a>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 8007438:	f04f 0001 	mov.w	r0, #1
 800743c:	f04f 0101 	mov.w	r1, #1
 8007440:	f000 ff56 	bl	80082f0 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
 8007444:	f04f 0001 	mov.w	r0, #1
 8007448:	f04f 0100 	mov.w	r1, #0
 800744c:	f000 ff50 	bl	80082f0 <RCC_AHB1PeriphResetCmd>
 8007450:	e086      	b.n	8007560 <GPIO_DeInit+0x138>
  }
  else if (GPIOx == GPIOB)
 8007452:	687a      	ldr	r2, [r7, #4]
 8007454:	4b45      	ldr	r3, [pc, #276]	; (800756c <GPIO_DeInit+0x144>)
 8007456:	429a      	cmp	r2, r3
 8007458:	d10c      	bne.n	8007474 <GPIO_DeInit+0x4c>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
 800745a:	f04f 0002 	mov.w	r0, #2
 800745e:	f04f 0101 	mov.w	r1, #1
 8007462:	f000 ff45 	bl	80082f0 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
 8007466:	f04f 0002 	mov.w	r0, #2
 800746a:	f04f 0100 	mov.w	r1, #0
 800746e:	f000 ff3f 	bl	80082f0 <RCC_AHB1PeriphResetCmd>
 8007472:	e075      	b.n	8007560 <GPIO_DeInit+0x138>
  }
  else if (GPIOx == GPIOC)
 8007474:	687a      	ldr	r2, [r7, #4]
 8007476:	4b3e      	ldr	r3, [pc, #248]	; (8007570 <GPIO_DeInit+0x148>)
 8007478:	429a      	cmp	r2, r3
 800747a:	d10c      	bne.n	8007496 <GPIO_DeInit+0x6e>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
 800747c:	f04f 0004 	mov.w	r0, #4
 8007480:	f04f 0101 	mov.w	r1, #1
 8007484:	f000 ff34 	bl	80082f0 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
 8007488:	f04f 0004 	mov.w	r0, #4
 800748c:	f04f 0100 	mov.w	r1, #0
 8007490:	f000 ff2e 	bl	80082f0 <RCC_AHB1PeriphResetCmd>
 8007494:	e064      	b.n	8007560 <GPIO_DeInit+0x138>
  }
  else if (GPIOx == GPIOD)
 8007496:	687a      	ldr	r2, [r7, #4]
 8007498:	4b36      	ldr	r3, [pc, #216]	; (8007574 <GPIO_DeInit+0x14c>)
 800749a:	429a      	cmp	r2, r3
 800749c:	d10c      	bne.n	80074b8 <GPIO_DeInit+0x90>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
 800749e:	f04f 0008 	mov.w	r0, #8
 80074a2:	f04f 0101 	mov.w	r1, #1
 80074a6:	f000 ff23 	bl	80082f0 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
 80074aa:	f04f 0008 	mov.w	r0, #8
 80074ae:	f04f 0100 	mov.w	r1, #0
 80074b2:	f000 ff1d 	bl	80082f0 <RCC_AHB1PeriphResetCmd>
 80074b6:	e053      	b.n	8007560 <GPIO_DeInit+0x138>
  }
  else if (GPIOx == GPIOE)
 80074b8:	687a      	ldr	r2, [r7, #4]
 80074ba:	4b2f      	ldr	r3, [pc, #188]	; (8007578 <GPIO_DeInit+0x150>)
 80074bc:	429a      	cmp	r2, r3
 80074be:	d10c      	bne.n	80074da <GPIO_DeInit+0xb2>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
 80074c0:	f04f 0010 	mov.w	r0, #16
 80074c4:	f04f 0101 	mov.w	r1, #1
 80074c8:	f000 ff12 	bl	80082f0 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
 80074cc:	f04f 0010 	mov.w	r0, #16
 80074d0:	f04f 0100 	mov.w	r1, #0
 80074d4:	f000 ff0c 	bl	80082f0 <RCC_AHB1PeriphResetCmd>
 80074d8:	e042      	b.n	8007560 <GPIO_DeInit+0x138>
  }
  else if (GPIOx == GPIOF)
 80074da:	687a      	ldr	r2, [r7, #4]
 80074dc:	4b27      	ldr	r3, [pc, #156]	; (800757c <GPIO_DeInit+0x154>)
 80074de:	429a      	cmp	r2, r3
 80074e0:	d10c      	bne.n	80074fc <GPIO_DeInit+0xd4>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
 80074e2:	f04f 0020 	mov.w	r0, #32
 80074e6:	f04f 0101 	mov.w	r1, #1
 80074ea:	f000 ff01 	bl	80082f0 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
 80074ee:	f04f 0020 	mov.w	r0, #32
 80074f2:	f04f 0100 	mov.w	r1, #0
 80074f6:	f000 fefb 	bl	80082f0 <RCC_AHB1PeriphResetCmd>
 80074fa:	e031      	b.n	8007560 <GPIO_DeInit+0x138>
  }
  else if (GPIOx == GPIOG)
 80074fc:	687a      	ldr	r2, [r7, #4]
 80074fe:	4b20      	ldr	r3, [pc, #128]	; (8007580 <GPIO_DeInit+0x158>)
 8007500:	429a      	cmp	r2, r3
 8007502:	d10c      	bne.n	800751e <GPIO_DeInit+0xf6>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
 8007504:	f04f 0040 	mov.w	r0, #64	; 0x40
 8007508:	f04f 0101 	mov.w	r1, #1
 800750c:	f000 fef0 	bl	80082f0 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
 8007510:	f04f 0040 	mov.w	r0, #64	; 0x40
 8007514:	f04f 0100 	mov.w	r1, #0
 8007518:	f000 feea 	bl	80082f0 <RCC_AHB1PeriphResetCmd>
 800751c:	e020      	b.n	8007560 <GPIO_DeInit+0x138>
  }
  else if (GPIOx == GPIOH)
 800751e:	687a      	ldr	r2, [r7, #4]
 8007520:	4b18      	ldr	r3, [pc, #96]	; (8007584 <GPIO_DeInit+0x15c>)
 8007522:	429a      	cmp	r2, r3
 8007524:	d10c      	bne.n	8007540 <GPIO_DeInit+0x118>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
 8007526:	f04f 0080 	mov.w	r0, #128	; 0x80
 800752a:	f04f 0101 	mov.w	r1, #1
 800752e:	f000 fedf 	bl	80082f0 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
 8007532:	f04f 0080 	mov.w	r0, #128	; 0x80
 8007536:	f04f 0100 	mov.w	r1, #0
 800753a:	f000 fed9 	bl	80082f0 <RCC_AHB1PeriphResetCmd>
 800753e:	e00f      	b.n	8007560 <GPIO_DeInit+0x138>
  }
  else
  {
    if (GPIOx == GPIOI)
 8007540:	687a      	ldr	r2, [r7, #4]
 8007542:	4b11      	ldr	r3, [pc, #68]	; (8007588 <GPIO_DeInit+0x160>)
 8007544:	429a      	cmp	r2, r3
 8007546:	d10b      	bne.n	8007560 <GPIO_DeInit+0x138>
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
 8007548:	f44f 7080 	mov.w	r0, #256	; 0x100
 800754c:	f04f 0101 	mov.w	r1, #1
 8007550:	f000 fece 	bl	80082f0 <RCC_AHB1PeriphResetCmd>
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
 8007554:	f44f 7080 	mov.w	r0, #256	; 0x100
 8007558:	f04f 0100 	mov.w	r1, #0
 800755c:	f000 fec8 	bl	80082f0 <RCC_AHB1PeriphResetCmd>
    }
  }
}
 8007560:	f107 0708 	add.w	r7, r7, #8
 8007564:	46bd      	mov	sp, r7
 8007566:	bd80      	pop	{r7, pc}
 8007568:	40020000 	.word	0x40020000
 800756c:	40020400 	.word	0x40020400
 8007570:	40020800 	.word	0x40020800
 8007574:	40020c00 	.word	0x40020c00
 8007578:	40021000 	.word	0x40021000
 800757c:	40021400 	.word	0x40021400
 8007580:	40021800 	.word	0x40021800
 8007584:	40021c00 	.word	0x40021c00
 8007588:	40022000 	.word	0x40022000

0800758c <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 800758c:	b480      	push	{r7}
 800758e:	b087      	sub	sp, #28
 8007590:	af00      	add	r7, sp, #0
 8007592:	6078      	str	r0, [r7, #4]
 8007594:	6039      	str	r1, [r7, #0]
  uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
 8007596:	f04f 0300 	mov.w	r3, #0
 800759a:	617b      	str	r3, [r7, #20]
 800759c:	f04f 0300 	mov.w	r3, #0
 80075a0:	613b      	str	r3, [r7, #16]
 80075a2:	f04f 0300 	mov.w	r3, #0
 80075a6:	60fb      	str	r3, [r7, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80075a8:	f04f 0300 	mov.w	r3, #0
 80075ac:	617b      	str	r3, [r7, #20]
 80075ae:	e086      	b.n	80076be <GPIO_Init+0x132>
  {
    pos = ((uint32_t)0x01) << pinpos;
 80075b0:	697b      	ldr	r3, [r7, #20]
 80075b2:	f04f 0201 	mov.w	r2, #1
 80075b6:	fa02 f303 	lsl.w	r3, r2, r3
 80075ba:	613b      	str	r3, [r7, #16]
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80075bc:	683b      	ldr	r3, [r7, #0]
 80075be:	681a      	ldr	r2, [r3, #0]
 80075c0:	693b      	ldr	r3, [r7, #16]
 80075c2:	4013      	ands	r3, r2
 80075c4:	60fb      	str	r3, [r7, #12]

    if (currentpin == pos)
 80075c6:	68fa      	ldr	r2, [r7, #12]
 80075c8:	693b      	ldr	r3, [r7, #16]
 80075ca:	429a      	cmp	r2, r3
 80075cc:	d173      	bne.n	80076b6 <GPIO_Init+0x12a>
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 80075ce:	687b      	ldr	r3, [r7, #4]
 80075d0:	681a      	ldr	r2, [r3, #0]
 80075d2:	697b      	ldr	r3, [r7, #20]
 80075d4:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80075d8:	f04f 0103 	mov.w	r1, #3
 80075dc:	fa01 f303 	lsl.w	r3, r1, r3
 80075e0:	ea6f 0303 	mvn.w	r3, r3
 80075e4:	401a      	ands	r2, r3
 80075e6:	687b      	ldr	r3, [r7, #4]
 80075e8:	601a      	str	r2, [r3, #0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80075ea:	687b      	ldr	r3, [r7, #4]
 80075ec:	681a      	ldr	r2, [r3, #0]
 80075ee:	683b      	ldr	r3, [r7, #0]
 80075f0:	791b      	ldrb	r3, [r3, #4]
 80075f2:	4619      	mov	r1, r3
 80075f4:	697b      	ldr	r3, [r7, #20]
 80075f6:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80075fa:	fa01 f303 	lsl.w	r3, r1, r3
 80075fe:	431a      	orrs	r2, r3
 8007600:	687b      	ldr	r3, [r7, #4]
 8007602:	601a      	str	r2, [r3, #0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8007604:	683b      	ldr	r3, [r7, #0]
 8007606:	791b      	ldrb	r3, [r3, #4]
 8007608:	2b01      	cmp	r3, #1
 800760a:	d003      	beq.n	8007614 <GPIO_Init+0x88>
 800760c:	683b      	ldr	r3, [r7, #0]
 800760e:	791b      	ldrb	r3, [r3, #4]
 8007610:	2b02      	cmp	r3, #2
 8007612:	d134      	bne.n	800767e <GPIO_Init+0xf2>
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 8007614:	687b      	ldr	r3, [r7, #4]
 8007616:	689a      	ldr	r2, [r3, #8]
 8007618:	697b      	ldr	r3, [r7, #20]
 800761a:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800761e:	f04f 0103 	mov.w	r1, #3
 8007622:	fa01 f303 	lsl.w	r3, r1, r3
 8007626:	ea6f 0303 	mvn.w	r3, r3
 800762a:	401a      	ands	r2, r3
 800762c:	687b      	ldr	r3, [r7, #4]
 800762e:	609a      	str	r2, [r3, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 8007630:	687b      	ldr	r3, [r7, #4]
 8007632:	689a      	ldr	r2, [r3, #8]
 8007634:	683b      	ldr	r3, [r7, #0]
 8007636:	795b      	ldrb	r3, [r3, #5]
 8007638:	4619      	mov	r1, r3
 800763a:	697b      	ldr	r3, [r7, #20]
 800763c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8007640:	fa01 f303 	lsl.w	r3, r1, r3
 8007644:	431a      	orrs	r2, r3
 8007646:	687b      	ldr	r3, [r7, #4]
 8007648:	609a      	str	r2, [r3, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 800764a:	687b      	ldr	r3, [r7, #4]
 800764c:	685a      	ldr	r2, [r3, #4]
 800764e:	697b      	ldr	r3, [r7, #20]
 8007650:	b29b      	uxth	r3, r3
 8007652:	f04f 0101 	mov.w	r1, #1
 8007656:	fa01 f303 	lsl.w	r3, r1, r3
 800765a:	ea6f 0303 	mvn.w	r3, r3
 800765e:	401a      	ands	r2, r3
 8007660:	687b      	ldr	r3, [r7, #4]
 8007662:	605a      	str	r2, [r3, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 8007664:	687b      	ldr	r3, [r7, #4]
 8007666:	685a      	ldr	r2, [r3, #4]
 8007668:	683b      	ldr	r3, [r7, #0]
 800766a:	799b      	ldrb	r3, [r3, #6]
 800766c:	4619      	mov	r1, r3
 800766e:	697b      	ldr	r3, [r7, #20]
 8007670:	b29b      	uxth	r3, r3
 8007672:	fa01 f303 	lsl.w	r3, r1, r3
 8007676:	b29b      	uxth	r3, r3
 8007678:	431a      	orrs	r2, r3
 800767a:	687b      	ldr	r3, [r7, #4]
 800767c:	605a      	str	r2, [r3, #4]
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 800767e:	687b      	ldr	r3, [r7, #4]
 8007680:	68da      	ldr	r2, [r3, #12]
 8007682:	697b      	ldr	r3, [r7, #20]
 8007684:	b29b      	uxth	r3, r3
 8007686:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800768a:	f04f 0103 	mov.w	r1, #3
 800768e:	fa01 f303 	lsl.w	r3, r1, r3
 8007692:	ea6f 0303 	mvn.w	r3, r3
 8007696:	401a      	ands	r2, r3
 8007698:	687b      	ldr	r3, [r7, #4]
 800769a:	60da      	str	r2, [r3, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 800769c:	687b      	ldr	r3, [r7, #4]
 800769e:	68da      	ldr	r2, [r3, #12]
 80076a0:	683b      	ldr	r3, [r7, #0]
 80076a2:	79db      	ldrb	r3, [r3, #7]
 80076a4:	4619      	mov	r1, r3
 80076a6:	697b      	ldr	r3, [r7, #20]
 80076a8:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80076ac:	fa01 f303 	lsl.w	r3, r1, r3
 80076b0:	431a      	orrs	r2, r3
 80076b2:	687b      	ldr	r3, [r7, #4]
 80076b4:	60da      	str	r2, [r3, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80076b6:	697b      	ldr	r3, [r7, #20]
 80076b8:	f103 0301 	add.w	r3, r3, #1
 80076bc:	617b      	str	r3, [r7, #20]
 80076be:	697b      	ldr	r3, [r7, #20]
 80076c0:	2b0f      	cmp	r3, #15
 80076c2:	f67f af75 	bls.w	80075b0 <GPIO_Init+0x24>
      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
    }
  }
}
 80076c6:	f107 071c 	add.w	r7, r7, #28
 80076ca:	46bd      	mov	sp, r7
 80076cc:	bc80      	pop	{r7}
 80076ce:	4770      	bx	lr

080076d0 <GPIO_StructInit>:
  * @brief  Fills each GPIO_InitStruct member with its default value.
  * @param  GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure which will be initialized.
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
 80076d0:	b480      	push	{r7}
 80076d2:	b083      	sub	sp, #12
 80076d4:	af00      	add	r7, sp, #0
 80076d6:	6078      	str	r0, [r7, #4]
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 80076d8:	687b      	ldr	r3, [r7, #4]
 80076da:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80076de:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
 80076e0:	687b      	ldr	r3, [r7, #4]
 80076e2:	f04f 0200 	mov.w	r2, #0
 80076e6:	711a      	strb	r2, [r3, #4]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 80076e8:	687b      	ldr	r3, [r7, #4]
 80076ea:	f04f 0200 	mov.w	r2, #0
 80076ee:	715a      	strb	r2, [r3, #5]
  GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
 80076f0:	687b      	ldr	r3, [r7, #4]
 80076f2:	f04f 0200 	mov.w	r2, #0
 80076f6:	719a      	strb	r2, [r3, #6]
  GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
 80076f8:	687b      	ldr	r3, [r7, #4]
 80076fa:	f04f 0200 	mov.w	r2, #0
 80076fe:	71da      	strb	r2, [r3, #7]
}
 8007700:	f107 070c 	add.w	r7, r7, #12
 8007704:	46bd      	mov	sp, r7
 8007706:	bc80      	pop	{r7}
 8007708:	4770      	bx	lr
 800770a:	bf00      	nop

0800770c <GPIO_PinLockConfig>:
  * @param  GPIO_Pin: specifies the port bit to be locked.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 800770c:	b480      	push	{r7}
 800770e:	b085      	sub	sp, #20
 8007710:	af00      	add	r7, sp, #0
 8007712:	6078      	str	r0, [r7, #4]
 8007714:	460b      	mov	r3, r1
 8007716:	807b      	strh	r3, [r7, #2]
  __IO uint32_t tmp = 0x00010000;
 8007718:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800771c:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  tmp |= GPIO_Pin;
 800771e:	887a      	ldrh	r2, [r7, #2]
 8007720:	68fb      	ldr	r3, [r7, #12]
 8007722:	4313      	orrs	r3, r2
 8007724:	60fb      	str	r3, [r7, #12]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 8007726:	68fa      	ldr	r2, [r7, #12]
 8007728:	687b      	ldr	r3, [r7, #4]
 800772a:	61da      	str	r2, [r3, #28]
  /* Reset LCKK bit */
  GPIOx->LCKR =  GPIO_Pin;
 800772c:	887a      	ldrh	r2, [r7, #2]
 800772e:	687b      	ldr	r3, [r7, #4]
 8007730:	61da      	str	r2, [r3, #28]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 8007732:	68fa      	ldr	r2, [r7, #12]
 8007734:	687b      	ldr	r3, [r7, #4]
 8007736:	61da      	str	r2, [r3, #28]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 8007738:	687b      	ldr	r3, [r7, #4]
 800773a:	69db      	ldr	r3, [r3, #28]
 800773c:	60fb      	str	r3, [r7, #12]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 800773e:	687b      	ldr	r3, [r7, #4]
 8007740:	69db      	ldr	r3, [r3, #28]
 8007742:	60fb      	str	r3, [r7, #12]
}
 8007744:	f107 0714 	add.w	r7, r7, #20
 8007748:	46bd      	mov	sp, r7
 800774a:	bc80      	pop	{r7}
 800774c:	4770      	bx	lr
 800774e:	bf00      	nop

08007750 <GPIO_ReadInputDataBit>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *         This parameter can be GPIO_Pin_x where x can be (0..15).
  * @retval The input port pin value.
  */
uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8007750:	b480      	push	{r7}
 8007752:	b085      	sub	sp, #20
 8007754:	af00      	add	r7, sp, #0
 8007756:	6078      	str	r0, [r7, #4]
 8007758:	460b      	mov	r3, r1
 800775a:	807b      	strh	r3, [r7, #2]
  uint8_t bitstatus = 0x00;
 800775c:	f04f 0300 	mov.w	r3, #0
 8007760:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8007762:	687b      	ldr	r3, [r7, #4]
 8007764:	691a      	ldr	r2, [r3, #16]
 8007766:	887b      	ldrh	r3, [r7, #2]
 8007768:	4013      	ands	r3, r2
 800776a:	2b00      	cmp	r3, #0
 800776c:	d003      	beq.n	8007776 <GPIO_ReadInputDataBit+0x26>
  {
    bitstatus = (uint8_t)Bit_SET;
 800776e:	f04f 0301 	mov.w	r3, #1
 8007772:	73fb      	strb	r3, [r7, #15]
 8007774:	e002      	b.n	800777c <GPIO_ReadInputDataBit+0x2c>
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
 8007776:	f04f 0300 	mov.w	r3, #0
 800777a:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 800777c:	7bfb      	ldrb	r3, [r7, #15]
}
 800777e:	4618      	mov	r0, r3
 8007780:	f107 0714 	add.w	r7, r7, #20
 8007784:	46bd      	mov	sp, r7
 8007786:	bc80      	pop	{r7}
 8007788:	4770      	bx	lr
 800778a:	bf00      	nop

0800778c <GPIO_ReadInputData>:
  * @brief  Reads the specified GPIO input data port.
  * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
  * @retval GPIO input data port value.
  */
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
 800778c:	b480      	push	{r7}
 800778e:	b083      	sub	sp, #12
 8007790:	af00      	add	r7, sp, #0
 8007792:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->IDR);
 8007794:	687b      	ldr	r3, [r7, #4]
 8007796:	691b      	ldr	r3, [r3, #16]
 8007798:	b29b      	uxth	r3, r3
}
 800779a:	4618      	mov	r0, r3
 800779c:	f107 070c 	add.w	r7, r7, #12
 80077a0:	46bd      	mov	sp, r7
 80077a2:	bc80      	pop	{r7}
 80077a4:	4770      	bx	lr
 80077a6:	bf00      	nop

080077a8 <GPIO_ReadOutputDataBit>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *          This parameter can be GPIO_Pin_x where x can be (0..15).
  * @retval The output port pin value.
  */
uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 80077a8:	b480      	push	{r7}
 80077aa:	b085      	sub	sp, #20
 80077ac:	af00      	add	r7, sp, #0
 80077ae:	6078      	str	r0, [r7, #4]
 80077b0:	460b      	mov	r3, r1
 80077b2:	807b      	strh	r3, [r7, #2]
  uint8_t bitstatus = 0x00;
 80077b4:	f04f 0300 	mov.w	r3, #0
 80077b8:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
 80077ba:	687b      	ldr	r3, [r7, #4]
 80077bc:	695a      	ldr	r2, [r3, #20]
 80077be:	887b      	ldrh	r3, [r7, #2]
 80077c0:	4013      	ands	r3, r2
 80077c2:	2b00      	cmp	r3, #0
 80077c4:	d003      	beq.n	80077ce <GPIO_ReadOutputDataBit+0x26>
  {
    bitstatus = (uint8_t)Bit_SET;
 80077c6:	f04f 0301 	mov.w	r3, #1
 80077ca:	73fb      	strb	r3, [r7, #15]
 80077cc:	e002      	b.n	80077d4 <GPIO_ReadOutputDataBit+0x2c>
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
 80077ce:	f04f 0300 	mov.w	r3, #0
 80077d2:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 80077d4:	7bfb      	ldrb	r3, [r7, #15]
}
 80077d6:	4618      	mov	r0, r3
 80077d8:	f107 0714 	add.w	r7, r7, #20
 80077dc:	46bd      	mov	sp, r7
 80077de:	bc80      	pop	{r7}
 80077e0:	4770      	bx	lr
 80077e2:	bf00      	nop

080077e4 <GPIO_ReadOutputData>:
  * @brief  Reads the specified GPIO output data port.
  * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
  * @retval GPIO output data port value.
  */
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
 80077e4:	b480      	push	{r7}
 80077e6:	b083      	sub	sp, #12
 80077e8:	af00      	add	r7, sp, #0
 80077ea:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->ODR);
 80077ec:	687b      	ldr	r3, [r7, #4]
 80077ee:	695b      	ldr	r3, [r3, #20]
 80077f0:	b29b      	uxth	r3, r3
}
 80077f2:	4618      	mov	r0, r3
 80077f4:	f107 070c 	add.w	r7, r7, #12
 80077f8:	46bd      	mov	sp, r7
 80077fa:	bc80      	pop	{r7}
 80077fc:	4770      	bx	lr
 80077fe:	bf00      	nop

08007800 <GPIO_SetBits>:
  * @param  GPIO_Pin: specifies the port bits to be written.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8007800:	b480      	push	{r7}
 8007802:	b083      	sub	sp, #12
 8007804:	af00      	add	r7, sp, #0
 8007806:	6078      	str	r0, [r7, #4]
 8007808:	460b      	mov	r3, r1
 800780a:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRL = GPIO_Pin;
 800780c:	687b      	ldr	r3, [r7, #4]
 800780e:	887a      	ldrh	r2, [r7, #2]
 8007810:	831a      	strh	r2, [r3, #24]
}
 8007812:	f107 070c 	add.w	r7, r7, #12
 8007816:	46bd      	mov	sp, r7
 8007818:	bc80      	pop	{r7}
 800781a:	4770      	bx	lr

0800781c <GPIO_ResetBits>:
  * @param  GPIO_Pin: specifies the port bits to be written.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 800781c:	b480      	push	{r7}
 800781e:	b083      	sub	sp, #12
 8007820:	af00      	add	r7, sp, #0
 8007822:	6078      	str	r0, [r7, #4]
 8007824:	460b      	mov	r3, r1
 8007826:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRH = GPIO_Pin;
 8007828:	687b      	ldr	r3, [r7, #4]
 800782a:	887a      	ldrh	r2, [r7, #2]
 800782c:	835a      	strh	r2, [r3, #26]
}
 800782e:	f107 070c 	add.w	r7, r7, #12
 8007832:	46bd      	mov	sp, r7
 8007834:	bc80      	pop	{r7}
 8007836:	4770      	bx	lr

08007838 <GPIO_WriteBit>:
  *            @arg Bit_RESET: to clear the port pin
  *            @arg Bit_SET: to set the port pin
  * @retval None
  */
void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
{
 8007838:	b480      	push	{r7}
 800783a:	b083      	sub	sp, #12
 800783c:	af00      	add	r7, sp, #0
 800783e:	6078      	str	r0, [r7, #4]
 8007840:	4613      	mov	r3, r2
 8007842:	460a      	mov	r2, r1
 8007844:	807a      	strh	r2, [r7, #2]
 8007846:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));

  if (BitVal != Bit_RESET)
 8007848:	787b      	ldrb	r3, [r7, #1]
 800784a:	2b00      	cmp	r3, #0
 800784c:	d003      	beq.n	8007856 <GPIO_WriteBit+0x1e>
  {
    GPIOx->BSRRL = GPIO_Pin;
 800784e:	687b      	ldr	r3, [r7, #4]
 8007850:	887a      	ldrh	r2, [r7, #2]
 8007852:	831a      	strh	r2, [r3, #24]
 8007854:	e002      	b.n	800785c <GPIO_WriteBit+0x24>
  }
  else
  {
    GPIOx->BSRRH = GPIO_Pin ;
 8007856:	687b      	ldr	r3, [r7, #4]
 8007858:	887a      	ldrh	r2, [r7, #2]
 800785a:	835a      	strh	r2, [r3, #26]
  }
}
 800785c:	f107 070c 	add.w	r7, r7, #12
 8007860:	46bd      	mov	sp, r7
 8007862:	bc80      	pop	{r7}
 8007864:	4770      	bx	lr
 8007866:	bf00      	nop

08007868 <GPIO_Write>:
  * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
  * @param  PortVal: specifies the value to be written to the port output data register.
  * @retval None
  */
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
{
 8007868:	b480      	push	{r7}
 800786a:	b083      	sub	sp, #12
 800786c:	af00      	add	r7, sp, #0
 800786e:	6078      	str	r0, [r7, #4]
 8007870:	460b      	mov	r3, r1
 8007872:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR = PortVal;
 8007874:	887a      	ldrh	r2, [r7, #2]
 8007876:	687b      	ldr	r3, [r7, #4]
 8007878:	615a      	str	r2, [r3, #20]
}
 800787a:	f107 070c 	add.w	r7, r7, #12
 800787e:	46bd      	mov	sp, r7
 8007880:	bc80      	pop	{r7}
 8007882:	4770      	bx	lr

08007884 <GPIO_ToggleBits>:
  * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
  * @param  GPIO_Pin: Specifies the pins to be toggled.
  * @retval None
  */
void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8007884:	b480      	push	{r7}
 8007886:	b083      	sub	sp, #12
 8007888:	af00      	add	r7, sp, #0
 800788a:	6078      	str	r0, [r7, #4]
 800788c:	460b      	mov	r3, r1
 800788e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR ^= GPIO_Pin;
 8007890:	687b      	ldr	r3, [r7, #4]
 8007892:	695a      	ldr	r2, [r3, #20]
 8007894:	887b      	ldrh	r3, [r7, #2]
 8007896:	405a      	eors	r2, r3
 8007898:	687b      	ldr	r3, [r7, #4]
 800789a:	615a      	str	r2, [r3, #20]
}
 800789c:	f107 070c 	add.w	r7, r7, #12
 80078a0:	46bd      	mov	sp, r7
 80078a2:	bc80      	pop	{r7}
 80078a4:	4770      	bx	lr
 80078a6:	bf00      	nop

080078a8 <GPIO_PinAFConfig>:
  *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13
  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 80078a8:	b480      	push	{r7}
 80078aa:	b085      	sub	sp, #20
 80078ac:	af00      	add	r7, sp, #0
 80078ae:	6078      	str	r0, [r7, #4]
 80078b0:	4613      	mov	r3, r2
 80078b2:	460a      	mov	r2, r1
 80078b4:	807a      	strh	r2, [r7, #2]
 80078b6:	707b      	strb	r3, [r7, #1]
  uint32_t temp = 0x00;
 80078b8:	f04f 0300 	mov.w	r3, #0
 80078bc:	60fb      	str	r3, [r7, #12]
  uint32_t temp_2 = 0x00;
 80078be:	f04f 0300 	mov.w	r3, #0
 80078c2:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 80078c4:	787a      	ldrb	r2, [r7, #1]
 80078c6:	887b      	ldrh	r3, [r7, #2]
 80078c8:	f003 0307 	and.w	r3, r3, #7
 80078cc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80078d0:	fa02 f303 	lsl.w	r3, r2, r3
 80078d4:	60fb      	str	r3, [r7, #12]
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 80078d6:	887b      	ldrh	r3, [r7, #2]
 80078d8:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 80078dc:	b29b      	uxth	r3, r3
 80078de:	461a      	mov	r2, r3
 80078e0:	887b      	ldrh	r3, [r7, #2]
 80078e2:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 80078e6:	b29b      	uxth	r3, r3
 80078e8:	4619      	mov	r1, r3
 80078ea:	687b      	ldr	r3, [r7, #4]
 80078ec:	f101 0108 	add.w	r1, r1, #8
 80078f0:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 80078f4:	887b      	ldrh	r3, [r7, #2]
 80078f6:	f003 0307 	and.w	r3, r3, #7
 80078fa:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80078fe:	f04f 000f 	mov.w	r0, #15
 8007902:	fa00 f303 	lsl.w	r3, r0, r3
 8007906:	ea6f 0303 	mvn.w	r3, r3
 800790a:	4019      	ands	r1, r3
 800790c:	687b      	ldr	r3, [r7, #4]
 800790e:	f102 0208 	add.w	r2, r2, #8
 8007912:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 8007916:	887b      	ldrh	r3, [r7, #2]
 8007918:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 800791c:	b29b      	uxth	r3, r3
 800791e:	461a      	mov	r2, r3
 8007920:	687b      	ldr	r3, [r7, #4]
 8007922:	f102 0208 	add.w	r2, r2, #8
 8007926:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800792a:	68fb      	ldr	r3, [r7, #12]
 800792c:	4313      	orrs	r3, r2
 800792e:	60bb      	str	r3, [r7, #8]
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 8007930:	887b      	ldrh	r3, [r7, #2]
 8007932:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 8007936:	b29b      	uxth	r3, r3
 8007938:	461a      	mov	r2, r3
 800793a:	687b      	ldr	r3, [r7, #4]
 800793c:	f102 0208 	add.w	r2, r2, #8
 8007940:	68b9      	ldr	r1, [r7, #8]
 8007942:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8007946:	f107 0714 	add.w	r7, r7, #20
 800794a:	46bd      	mov	sp, r7
 800794c:	bc80      	pop	{r7}
 800794e:	4770      	bx	lr

08007950 <PWR_DeInit>:
  * @brief  Deinitializes the PWR peripheral registers to their default reset values.     
  * @param  None
  * @retval None
  */
void PWR_DeInit(void)
{
 8007950:	b580      	push	{r7, lr}
 8007952:	af00      	add	r7, sp, #0
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
 8007954:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 8007958:	f04f 0101 	mov.w	r1, #1
 800795c:	f000 fd28 	bl	80083b0 <RCC_APB1PeriphResetCmd>
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
 8007960:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 8007964:	f04f 0100 	mov.w	r1, #0
 8007968:	f000 fd22 	bl	80083b0 <RCC_APB1PeriphResetCmd>
}
 800796c:	bd80      	pop	{r7, pc}
 800796e:	bf00      	nop

08007970 <PWR_BackupAccessCmd>:
  * @param  NewState: new state of the access to the backup domain.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void PWR_BackupAccessCmd(FunctionalState NewState)
{
 8007970:	b480      	push	{r7}
 8007972:	b083      	sub	sp, #12
 8007974:	af00      	add	r7, sp, #0
 8007976:	4603      	mov	r3, r0
 8007978:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
 800797a:	4b04      	ldr	r3, [pc, #16]	; (800798c <PWR_BackupAccessCmd+0x1c>)
 800797c:	79fa      	ldrb	r2, [r7, #7]
 800797e:	601a      	str	r2, [r3, #0]
}
 8007980:	f107 070c 	add.w	r7, r7, #12
 8007984:	46bd      	mov	sp, r7
 8007986:	bc80      	pop	{r7}
 8007988:	4770      	bx	lr
 800798a:	bf00      	nop
 800798c:	420e0020 	.word	0x420e0020

08007990 <PWR_PVDLevelConfig>:
  *            @arg PWR_PVDLevel_7: PVD detection level set to 3.0V
  * @note   Refer to the electrical characteristics of you device datasheet for more details. 
  * @retval None
  */
void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
{
 8007990:	b480      	push	{r7}
 8007992:	b085      	sub	sp, #20
 8007994:	af00      	add	r7, sp, #0
 8007996:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8007998:	f04f 0300 	mov.w	r3, #0
 800799c:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
  
  tmpreg = PWR->CR;
 800799e:	4b09      	ldr	r3, [pc, #36]	; (80079c4 <PWR_PVDLevelConfig+0x34>)
 80079a0:	681b      	ldr	r3, [r3, #0]
 80079a2:	60fb      	str	r3, [r7, #12]
  
  /* Clear PLS[7:5] bits */
  tmpreg &= CR_PLS_MASK;
 80079a4:	68fb      	ldr	r3, [r7, #12]
 80079a6:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
 80079aa:	60fb      	str	r3, [r7, #12]
  
  /* Set PLS[7:5] bits according to PWR_PVDLevel value */
  tmpreg |= PWR_PVDLevel;
 80079ac:	68fa      	ldr	r2, [r7, #12]
 80079ae:	687b      	ldr	r3, [r7, #4]
 80079b0:	4313      	orrs	r3, r2
 80079b2:	60fb      	str	r3, [r7, #12]
  
  /* Store the new value */
  PWR->CR = tmpreg;
 80079b4:	4b03      	ldr	r3, [pc, #12]	; (80079c4 <PWR_PVDLevelConfig+0x34>)
 80079b6:	68fa      	ldr	r2, [r7, #12]
 80079b8:	601a      	str	r2, [r3, #0]
}
 80079ba:	f107 0714 	add.w	r7, r7, #20
 80079be:	46bd      	mov	sp, r7
 80079c0:	bc80      	pop	{r7}
 80079c2:	4770      	bx	lr
 80079c4:	40007000 	.word	0x40007000

080079c8 <PWR_PVDCmd>:
  * @param  NewState: new state of the PVD.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void PWR_PVDCmd(FunctionalState NewState)
{
 80079c8:	b480      	push	{r7}
 80079ca:	b083      	sub	sp, #12
 80079cc:	af00      	add	r7, sp, #0
 80079ce:	4603      	mov	r3, r0
 80079d0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
 80079d2:	4b04      	ldr	r3, [pc, #16]	; (80079e4 <PWR_PVDCmd+0x1c>)
 80079d4:	79fa      	ldrb	r2, [r7, #7]
 80079d6:	601a      	str	r2, [r3, #0]
}
 80079d8:	f107 070c 	add.w	r7, r7, #12
 80079dc:	46bd      	mov	sp, r7
 80079de:	bc80      	pop	{r7}
 80079e0:	4770      	bx	lr
 80079e2:	bf00      	nop
 80079e4:	420e0010 	.word	0x420e0010

080079e8 <PWR_WakeUpPinCmd>:
  * @param  NewState: new state of the WakeUp Pin functionality.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void PWR_WakeUpPinCmd(FunctionalState NewState)
{
 80079e8:	b480      	push	{r7}
 80079ea:	b083      	sub	sp, #12
 80079ec:	af00      	add	r7, sp, #0
 80079ee:	4603      	mov	r3, r0
 80079f0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CSR_EWUP_BB = (uint32_t)NewState;
 80079f2:	4b04      	ldr	r3, [pc, #16]	; (8007a04 <PWR_WakeUpPinCmd+0x1c>)
 80079f4:	79fa      	ldrb	r2, [r7, #7]
 80079f6:	601a      	str	r2, [r3, #0]
}
 80079f8:	f107 070c 	add.w	r7, r7, #12
 80079fc:	46bd      	mov	sp, r7
 80079fe:	bc80      	pop	{r7}
 8007a00:	4770      	bx	lr
 8007a02:	bf00      	nop
 8007a04:	420e00a0 	.word	0x420e00a0

08007a08 <PWR_BackupRegulatorCmd>:
  * @param  NewState: new state of the Backup Regulator.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void PWR_BackupRegulatorCmd(FunctionalState NewState)
{
 8007a08:	b480      	push	{r7}
 8007a0a:	b083      	sub	sp, #12
 8007a0c:	af00      	add	r7, sp, #0
 8007a0e:	4603      	mov	r3, r0
 8007a10:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)NewState;
 8007a12:	4b04      	ldr	r3, [pc, #16]	; (8007a24 <PWR_BackupRegulatorCmd+0x1c>)
 8007a14:	79fa      	ldrb	r2, [r7, #7]
 8007a16:	601a      	str	r2, [r3, #0]
}
 8007a18:	f107 070c 	add.w	r7, r7, #12
 8007a1c:	46bd      	mov	sp, r7
 8007a1e:	bc80      	pop	{r7}
 8007a20:	4770      	bx	lr
 8007a22:	bf00      	nop
 8007a24:	420e00a4 	.word	0x420e00a4

08007a28 <PWR_MainRegulatorModeConfig>:
  *            @arg PWR_Regulator_Voltage_Scale2: Regulator voltage output Scale 2 mode, 
  *                                                System frequency up to 144 MHz.    
  * @retval None
  */
void PWR_MainRegulatorModeConfig(uint32_t PWR_Regulator_Voltage)
{
 8007a28:	b480      	push	{r7}
 8007a2a:	b083      	sub	sp, #12
 8007a2c:	af00      	add	r7, sp, #0
 8007a2e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR_VOLTAGE(PWR_Regulator_Voltage));

  if (PWR_Regulator_Voltage == PWR_Regulator_Voltage_Scale2)
 8007a30:	687b      	ldr	r3, [r7, #4]
 8007a32:	2b00      	cmp	r3, #0
 8007a34:	d106      	bne.n	8007a44 <PWR_MainRegulatorModeConfig+0x1c>
  {
    PWR->CR &= ~PWR_Regulator_Voltage_Scale1;
 8007a36:	4b09      	ldr	r3, [pc, #36]	; (8007a5c <PWR_MainRegulatorModeConfig+0x34>)
 8007a38:	4a08      	ldr	r2, [pc, #32]	; (8007a5c <PWR_MainRegulatorModeConfig+0x34>)
 8007a3a:	6812      	ldr	r2, [r2, #0]
 8007a3c:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8007a40:	601a      	str	r2, [r3, #0]
 8007a42:	e005      	b.n	8007a50 <PWR_MainRegulatorModeConfig+0x28>
  }
  else
  {    
    PWR->CR |= PWR_Regulator_Voltage_Scale1;
 8007a44:	4b05      	ldr	r3, [pc, #20]	; (8007a5c <PWR_MainRegulatorModeConfig+0x34>)
 8007a46:	4a05      	ldr	r2, [pc, #20]	; (8007a5c <PWR_MainRegulatorModeConfig+0x34>)
 8007a48:	6812      	ldr	r2, [r2, #0]
 8007a4a:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8007a4e:	601a      	str	r2, [r3, #0]
  }
}
 8007a50:	f107 070c 	add.w	r7, r7, #12
 8007a54:	46bd      	mov	sp, r7
 8007a56:	bc80      	pop	{r7}
 8007a58:	4770      	bx	lr
 8007a5a:	bf00      	nop
 8007a5c:	40007000 	.word	0x40007000

08007a60 <PWR_FlashPowerDownCmd>:
  * @param  NewState: new state of the Flash power mode.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void PWR_FlashPowerDownCmd(FunctionalState NewState)
{
 8007a60:	b480      	push	{r7}
 8007a62:	b083      	sub	sp, #12
 8007a64:	af00      	add	r7, sp, #0
 8007a66:	4603      	mov	r3, r0
 8007a68:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)NewState;
 8007a6a:	4b04      	ldr	r3, [pc, #16]	; (8007a7c <PWR_FlashPowerDownCmd+0x1c>)
 8007a6c:	79fa      	ldrb	r2, [r7, #7]
 8007a6e:	601a      	str	r2, [r3, #0]
}
 8007a70:	f107 070c 	add.w	r7, r7, #12
 8007a74:	46bd      	mov	sp, r7
 8007a76:	bc80      	pop	{r7}
 8007a78:	4770      	bx	lr
 8007a7a:	bf00      	nop
 8007a7c:	420e0024 	.word	0x420e0024

08007a80 <PWR_EnterSTOPMode>:
  *            @arg PWR_STOPEntry_WFI: enter STOP mode with WFI instruction
  *            @arg PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
  * @retval None
  */
void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
{
 8007a80:	b480      	push	{r7}
 8007a82:	b085      	sub	sp, #20
 8007a84:	af00      	add	r7, sp, #0
 8007a86:	6078      	str	r0, [r7, #4]
 8007a88:	460b      	mov	r3, r1
 8007a8a:	70fb      	strb	r3, [r7, #3]
  uint32_t tmpreg = 0;
 8007a8c:	f04f 0300 	mov.w	r3, #0
 8007a90:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(PWR_Regulator));
  assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
  
  /* Select the regulator state in STOP mode ---------------------------------*/
  tmpreg = PWR->CR;
 8007a92:	4b12      	ldr	r3, [pc, #72]	; (8007adc <PWR_EnterSTOPMode+0x5c>)
 8007a94:	681b      	ldr	r3, [r3, #0]
 8007a96:	60fb      	str	r3, [r7, #12]
  /* Clear PDDS and LPDSR bits */
  tmpreg &= CR_DS_MASK;
 8007a98:	68fb      	ldr	r3, [r7, #12]
 8007a9a:	f023 0303 	bic.w	r3, r3, #3
 8007a9e:	60fb      	str	r3, [r7, #12]
  
  /* Set LPDSR bit according to PWR_Regulator value */
  tmpreg |= PWR_Regulator;
 8007aa0:	68fa      	ldr	r2, [r7, #12]
 8007aa2:	687b      	ldr	r3, [r7, #4]
 8007aa4:	4313      	orrs	r3, r2
 8007aa6:	60fb      	str	r3, [r7, #12]
  
  /* Store the new value */
  PWR->CR = tmpreg;
 8007aa8:	4b0c      	ldr	r3, [pc, #48]	; (8007adc <PWR_EnterSTOPMode+0x5c>)
 8007aaa:	68fa      	ldr	r2, [r7, #12]
 8007aac:	601a      	str	r2, [r3, #0]
  
  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 8007aae:	4b0c      	ldr	r3, [pc, #48]	; (8007ae0 <PWR_EnterSTOPMode+0x60>)
 8007ab0:	4a0b      	ldr	r2, [pc, #44]	; (8007ae0 <PWR_EnterSTOPMode+0x60>)
 8007ab2:	6912      	ldr	r2, [r2, #16]
 8007ab4:	f042 0204 	orr.w	r2, r2, #4
 8007ab8:	611a      	str	r2, [r3, #16]
  
  /* Select STOP mode entry --------------------------------------------------*/
  if(PWR_STOPEntry == PWR_STOPEntry_WFI)
 8007aba:	78fb      	ldrb	r3, [r7, #3]
 8007abc:	2b01      	cmp	r3, #1
 8007abe:	d101      	bne.n	8007ac4 <PWR_EnterSTOPMode+0x44>
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__( ( always_inline ) ) static __INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
 8007ac0:	bf30      	wfi
 8007ac2:	e000      	b.n	8007ac6 <PWR_EnterSTOPMode+0x46>
    Wait For Event is a hint instruction that permits the processor to enter
    a low-power state until one of a number of events occurs.
 */
__attribute__( ( always_inline ) ) static __INLINE void __WFE(void)
{
  __ASM volatile ("wfe");
 8007ac4:	bf20      	wfe
  {
    /* Request Wait For Event */
    __WFE();
  }
  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
 8007ac6:	4b06      	ldr	r3, [pc, #24]	; (8007ae0 <PWR_EnterSTOPMode+0x60>)
 8007ac8:	4a05      	ldr	r2, [pc, #20]	; (8007ae0 <PWR_EnterSTOPMode+0x60>)
 8007aca:	6912      	ldr	r2, [r2, #16]
 8007acc:	f022 0204 	bic.w	r2, r2, #4
 8007ad0:	611a      	str	r2, [r3, #16]
}
 8007ad2:	f107 0714 	add.w	r7, r7, #20
 8007ad6:	46bd      	mov	sp, r7
 8007ad8:	bc80      	pop	{r7}
 8007ada:	4770      	bx	lr
 8007adc:	40007000 	.word	0x40007000
 8007ae0:	e000ed00 	.word	0xe000ed00

08007ae4 <PWR_EnterSTANDBYMode>:
  *          - WKUP pin 1 (PA0) if enabled.       
  * @param  None
  * @retval None
  */
void PWR_EnterSTANDBYMode(void)
{
 8007ae4:	b480      	push	{r7}
 8007ae6:	af00      	add	r7, sp, #0
  /* Clear Wakeup flag */
  PWR->CR |= PWR_CR_CWUF;
 8007ae8:	4b0a      	ldr	r3, [pc, #40]	; (8007b14 <PWR_EnterSTANDBYMode+0x30>)
 8007aea:	4a0a      	ldr	r2, [pc, #40]	; (8007b14 <PWR_EnterSTANDBYMode+0x30>)
 8007aec:	6812      	ldr	r2, [r2, #0]
 8007aee:	f042 0204 	orr.w	r2, r2, #4
 8007af2:	601a      	str	r2, [r3, #0]
  
  /* Select STANDBY mode */
  PWR->CR |= PWR_CR_PDDS;
 8007af4:	4b07      	ldr	r3, [pc, #28]	; (8007b14 <PWR_EnterSTANDBYMode+0x30>)
 8007af6:	4a07      	ldr	r2, [pc, #28]	; (8007b14 <PWR_EnterSTANDBYMode+0x30>)
 8007af8:	6812      	ldr	r2, [r2, #0]
 8007afa:	f042 0202 	orr.w	r2, r2, #2
 8007afe:	601a      	str	r2, [r3, #0]
  
  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 8007b00:	4b05      	ldr	r3, [pc, #20]	; (8007b18 <PWR_EnterSTANDBYMode+0x34>)
 8007b02:	4a05      	ldr	r2, [pc, #20]	; (8007b18 <PWR_EnterSTANDBYMode+0x34>)
 8007b04:	6912      	ldr	r2, [r2, #16]
 8007b06:	f042 0204 	orr.w	r2, r2, #4
 8007b0a:	611a      	str	r2, [r3, #16]
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__( ( always_inline ) ) static __INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
 8007b0c:	bf30      	wfi
#if defined ( __CC_ARM   )
  __force_stores();
#endif
  /* Request Wait For Interrupt */
  __WFI();
}
 8007b0e:	46bd      	mov	sp, r7
 8007b10:	bc80      	pop	{r7}
 8007b12:	4770      	bx	lr
 8007b14:	40007000 	.word	0x40007000
 8007b18:	e000ed00 	.word	0xe000ed00

08007b1c <PWR_GetFlagStatus>:
  *            @arg PWR_FLAG_VOSRDY: This flag indicates that the Regulator voltage 
  *                 scaling output selection is ready. 
  * @retval The new state of PWR_FLAG (SET or RESET).
  */
FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
{
 8007b1c:	b480      	push	{r7}
 8007b1e:	b085      	sub	sp, #20
 8007b20:	af00      	add	r7, sp, #0
 8007b22:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
 8007b24:	f04f 0300 	mov.w	r3, #0
 8007b28:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
  
  if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
 8007b2a:	4b0a      	ldr	r3, [pc, #40]	; (8007b54 <PWR_GetFlagStatus+0x38>)
 8007b2c:	685a      	ldr	r2, [r3, #4]
 8007b2e:	687b      	ldr	r3, [r7, #4]
 8007b30:	4013      	ands	r3, r2
 8007b32:	2b00      	cmp	r3, #0
 8007b34:	d003      	beq.n	8007b3e <PWR_GetFlagStatus+0x22>
  {
    bitstatus = SET;
 8007b36:	f04f 0301 	mov.w	r3, #1
 8007b3a:	73fb      	strb	r3, [r7, #15]
 8007b3c:	e002      	b.n	8007b44 <PWR_GetFlagStatus+0x28>
  }
  else
  {
    bitstatus = RESET;
 8007b3e:	f04f 0300 	mov.w	r3, #0
 8007b42:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the flag status */
  return bitstatus;
 8007b44:	7bfb      	ldrb	r3, [r7, #15]
}
 8007b46:	4618      	mov	r0, r3
 8007b48:	f107 0714 	add.w	r7, r7, #20
 8007b4c:	46bd      	mov	sp, r7
 8007b4e:	bc80      	pop	{r7}
 8007b50:	4770      	bx	lr
 8007b52:	bf00      	nop
 8007b54:	40007000 	.word	0x40007000

08007b58 <PWR_ClearFlag>:
  *            @arg PWR_FLAG_WU: Wake Up flag
  *            @arg PWR_FLAG_SB: StandBy flag
  * @retval None
  */
void PWR_ClearFlag(uint32_t PWR_FLAG)
{
 8007b58:	b480      	push	{r7}
 8007b5a:	b083      	sub	sp, #12
 8007b5c:	af00      	add	r7, sp, #0
 8007b5e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
         
  PWR->CR |=  PWR_FLAG << 2;
 8007b60:	4b06      	ldr	r3, [pc, #24]	; (8007b7c <PWR_ClearFlag+0x24>)
 8007b62:	4a06      	ldr	r2, [pc, #24]	; (8007b7c <PWR_ClearFlag+0x24>)
 8007b64:	6811      	ldr	r1, [r2, #0]
 8007b66:	687a      	ldr	r2, [r7, #4]
 8007b68:	ea4f 0282 	mov.w	r2, r2, lsl #2
 8007b6c:	430a      	orrs	r2, r1
 8007b6e:	601a      	str	r2, [r3, #0]
}
 8007b70:	f107 070c 	add.w	r7, r7, #12
 8007b74:	46bd      	mov	sp, r7
 8007b76:	bc80      	pop	{r7}
 8007b78:	4770      	bx	lr
 8007b7a:	bf00      	nop
 8007b7c:	40007000 	.word	0x40007000

08007b80 <RCC_DeInit>:
  *            - LSI, LSE and RTC clocks 
  * @param  None
  * @retval None
  */
void RCC_DeInit(void)
{
 8007b80:	b480      	push	{r7}
 8007b82:	af00      	add	r7, sp, #0
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8007b84:	4b10      	ldr	r3, [pc, #64]	; (8007bc8 <RCC_DeInit+0x48>)
 8007b86:	4a10      	ldr	r2, [pc, #64]	; (8007bc8 <RCC_DeInit+0x48>)
 8007b88:	6812      	ldr	r2, [r2, #0]
 8007b8a:	f042 0201 	orr.w	r2, r2, #1
 8007b8e:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8007b90:	4b0d      	ldr	r3, [pc, #52]	; (8007bc8 <RCC_DeInit+0x48>)
 8007b92:	f04f 0200 	mov.w	r2, #0
 8007b96:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8007b98:	4a0b      	ldr	r2, [pc, #44]	; (8007bc8 <RCC_DeInit+0x48>)
 8007b9a:	4b0b      	ldr	r3, [pc, #44]	; (8007bc8 <RCC_DeInit+0x48>)
 8007b9c:	681b      	ldr	r3, [r3, #0]
 8007b9e:	f023 7384 	bic.w	r3, r3, #17301504	; 0x1080000
 8007ba2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8007ba6:	6013      	str	r3, [r2, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8007ba8:	4b07      	ldr	r3, [pc, #28]	; (8007bc8 <RCC_DeInit+0x48>)
 8007baa:	4a08      	ldr	r2, [pc, #32]	; (8007bcc <RCC_DeInit+0x4c>)
 8007bac:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8007bae:	4b06      	ldr	r3, [pc, #24]	; (8007bc8 <RCC_DeInit+0x48>)
 8007bb0:	4a05      	ldr	r2, [pc, #20]	; (8007bc8 <RCC_DeInit+0x48>)
 8007bb2:	6812      	ldr	r2, [r2, #0]
 8007bb4:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8007bb8:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8007bba:	4b03      	ldr	r3, [pc, #12]	; (8007bc8 <RCC_DeInit+0x48>)
 8007bbc:	f04f 0200 	mov.w	r2, #0
 8007bc0:	60da      	str	r2, [r3, #12]
}
 8007bc2:	46bd      	mov	sp, r7
 8007bc4:	bc80      	pop	{r7}
 8007bc6:	4770      	bx	lr
 8007bc8:	40023800 	.word	0x40023800
 8007bcc:	24003010 	.word	0x24003010

08007bd0 <RCC_HSEConfig>:
  *            @arg RCC_HSE_ON: turn ON the HSE oscillator
  *            @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
  * @retval None
  */
void RCC_HSEConfig(uint8_t RCC_HSE)
{
 8007bd0:	b480      	push	{r7}
 8007bd2:	b083      	sub	sp, #12
 8007bd4:	af00      	add	r7, sp, #0
 8007bd6:	4603      	mov	r3, r0
 8007bd8:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));

  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
 8007bda:	4b06      	ldr	r3, [pc, #24]	; (8007bf4 <RCC_HSEConfig+0x24>)
 8007bdc:	f04f 0200 	mov.w	r2, #0
 8007be0:	701a      	strb	r2, [r3, #0]

  /* Set the new HSE configuration -------------------------------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
 8007be2:	4b04      	ldr	r3, [pc, #16]	; (8007bf4 <RCC_HSEConfig+0x24>)
 8007be4:	79fa      	ldrb	r2, [r7, #7]
 8007be6:	701a      	strb	r2, [r3, #0]
}
 8007be8:	f107 070c 	add.w	r7, r7, #12
 8007bec:	46bd      	mov	sp, r7
 8007bee:	bc80      	pop	{r7}
 8007bf0:	4770      	bx	lr
 8007bf2:	bf00      	nop
 8007bf4:	40023802 	.word	0x40023802

08007bf8 <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: HSE oscillator is stable and ready to use
  *          - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 8007bf8:	b580      	push	{r7, lr}
 8007bfa:	b082      	sub	sp, #8
 8007bfc:	af00      	add	r7, sp, #0
  __IO uint32_t startupcounter = 0;
 8007bfe:	f04f 0300 	mov.w	r3, #0
 8007c02:	603b      	str	r3, [r7, #0]
  ErrorStatus status = ERROR;
 8007c04:	f04f 0300 	mov.w	r3, #0
 8007c08:	71fb      	strb	r3, [r7, #7]
  FlagStatus hsestatus = RESET;
 8007c0a:	f04f 0300 	mov.w	r3, #0
 8007c0e:	71bb      	strb	r3, [r7, #6]
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 8007c10:	f04f 0031 	mov.w	r0, #49	; 0x31
 8007c14:	f000 fcd2 	bl	80085bc <RCC_GetFlagStatus>
 8007c18:	4603      	mov	r3, r0
 8007c1a:	71bb      	strb	r3, [r7, #6]
    startupcounter++;
 8007c1c:	683b      	ldr	r3, [r7, #0]
 8007c1e:	f103 0301 	add.w	r3, r3, #1
 8007c22:	603b      	str	r3, [r7, #0]
  } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
 8007c24:	683b      	ldr	r3, [r7, #0]
 8007c26:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8007c2a:	d002      	beq.n	8007c32 <RCC_WaitForHSEStartUp+0x3a>
 8007c2c:	79bb      	ldrb	r3, [r7, #6]
 8007c2e:	2b00      	cmp	r3, #0
 8007c30:	d0ee      	beq.n	8007c10 <RCC_WaitForHSEStartUp+0x18>

  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 8007c32:	f04f 0031 	mov.w	r0, #49	; 0x31
 8007c36:	f000 fcc1 	bl	80085bc <RCC_GetFlagStatus>
 8007c3a:	4603      	mov	r3, r0
 8007c3c:	2b00      	cmp	r3, #0
 8007c3e:	d003      	beq.n	8007c48 <RCC_WaitForHSEStartUp+0x50>
  {
    status = SUCCESS;
 8007c40:	f04f 0301 	mov.w	r3, #1
 8007c44:	71fb      	strb	r3, [r7, #7]
 8007c46:	e002      	b.n	8007c4e <RCC_WaitForHSEStartUp+0x56>
  }
  else
  {
    status = ERROR;
 8007c48:	f04f 0300 	mov.w	r3, #0
 8007c4c:	71fb      	strb	r3, [r7, #7]
  }
  return (status);
 8007c4e:	79fb      	ldrb	r3, [r7, #7]
}
 8007c50:	4618      	mov	r0, r3
 8007c52:	f107 0708 	add.w	r7, r7, #8
 8007c56:	46bd      	mov	sp, r7
 8007c58:	bd80      	pop	{r7, pc}
 8007c5a:	bf00      	nop

08007c5c <RCC_AdjustHSICalibrationValue>:
  * @param  HSICalibrationValue: specifies the calibration trimming value.
  *         This parameter must be a number between 0 and 0x1F.
  * @retval None
  */
void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
{
 8007c5c:	b480      	push	{r7}
 8007c5e:	b085      	sub	sp, #20
 8007c60:	af00      	add	r7, sp, #0
 8007c62:	4603      	mov	r3, r0
 8007c64:	71fb      	strb	r3, [r7, #7]
  uint32_t tmpreg = 0;
 8007c66:	f04f 0300 	mov.w	r3, #0
 8007c6a:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));

  tmpreg = RCC->CR;
 8007c6c:	4b0a      	ldr	r3, [pc, #40]	; (8007c98 <RCC_AdjustHSICalibrationValue+0x3c>)
 8007c6e:	681b      	ldr	r3, [r3, #0]
 8007c70:	60fb      	str	r3, [r7, #12]

  /* Clear HSITRIM[4:0] bits */
  tmpreg &= ~RCC_CR_HSITRIM;
 8007c72:	68fb      	ldr	r3, [r7, #12]
 8007c74:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8007c78:	60fb      	str	r3, [r7, #12]

  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (uint32_t)HSICalibrationValue << 3;
 8007c7a:	79fb      	ldrb	r3, [r7, #7]
 8007c7c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8007c80:	68fa      	ldr	r2, [r7, #12]
 8007c82:	4313      	orrs	r3, r2
 8007c84:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CR = tmpreg;
 8007c86:	4b04      	ldr	r3, [pc, #16]	; (8007c98 <RCC_AdjustHSICalibrationValue+0x3c>)
 8007c88:	68fa      	ldr	r2, [r7, #12]
 8007c8a:	601a      	str	r2, [r3, #0]
}
 8007c8c:	f107 0714 	add.w	r7, r7, #20
 8007c90:	46bd      	mov	sp, r7
 8007c92:	bc80      	pop	{r7}
 8007c94:	4770      	bx	lr
 8007c96:	bf00      	nop
 8007c98:	40023800 	.word	0x40023800

08007c9c <RCC_HSICmd>:
  * @note   When the HSI is stopped, HSIRDY flag goes low after 6 HSI oscillator
  *         clock cycles.  
  * @retval None
  */
void RCC_HSICmd(FunctionalState NewState)
{
 8007c9c:	b480      	push	{r7}
 8007c9e:	b083      	sub	sp, #12
 8007ca0:	af00      	add	r7, sp, #0
 8007ca2:	4603      	mov	r3, r0
 8007ca4:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
 8007ca6:	4b04      	ldr	r3, [pc, #16]	; (8007cb8 <RCC_HSICmd+0x1c>)
 8007ca8:	79fa      	ldrb	r2, [r7, #7]
 8007caa:	601a      	str	r2, [r3, #0]
}
 8007cac:	f107 070c 	add.w	r7, r7, #12
 8007cb0:	46bd      	mov	sp, r7
 8007cb2:	bc80      	pop	{r7}
 8007cb4:	4770      	bx	lr
 8007cb6:	bf00      	nop
 8007cb8:	42470000 	.word	0x42470000

08007cbc <RCC_LSEConfig>:
  *            @arg RCC_LSE_ON: turn ON the LSE oscillator
  *            @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock
  * @retval None
  */
void RCC_LSEConfig(uint8_t RCC_LSE)
{
 8007cbc:	b480      	push	{r7}
 8007cbe:	b083      	sub	sp, #12
 8007cc0:	af00      	add	r7, sp, #0
 8007cc2:	4603      	mov	r3, r0
 8007cc4:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8007cc6:	4b0f      	ldr	r3, [pc, #60]	; (8007d04 <RCC_LSEConfig+0x48>)
 8007cc8:	f04f 0200 	mov.w	r2, #0
 8007ccc:	701a      	strb	r2, [r3, #0]

  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8007cce:	4b0d      	ldr	r3, [pc, #52]	; (8007d04 <RCC_LSEConfig+0x48>)
 8007cd0:	f04f 0200 	mov.w	r2, #0
 8007cd4:	701a      	strb	r2, [r3, #0]

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch (RCC_LSE)
 8007cd6:	79fb      	ldrb	r3, [r7, #7]
 8007cd8:	2b01      	cmp	r3, #1
 8007cda:	d002      	beq.n	8007ce2 <RCC_LSEConfig+0x26>
 8007cdc:	2b04      	cmp	r3, #4
 8007cde:	d005      	beq.n	8007cec <RCC_LSEConfig+0x30>
 8007ce0:	e009      	b.n	8007cf6 <RCC_LSEConfig+0x3a>
  {
    case RCC_LSE_ON:
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
 8007ce2:	4b08      	ldr	r3, [pc, #32]	; (8007d04 <RCC_LSEConfig+0x48>)
 8007ce4:	f04f 0201 	mov.w	r2, #1
 8007ce8:	701a      	strb	r2, [r3, #0]
      break;
 8007cea:	e005      	b.n	8007cf8 <RCC_LSEConfig+0x3c>
    case RCC_LSE_Bypass:
      /* Set LSEBYP and LSEON bits */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
 8007cec:	4b05      	ldr	r3, [pc, #20]	; (8007d04 <RCC_LSEConfig+0x48>)
 8007cee:	f04f 0205 	mov.w	r2, #5
 8007cf2:	701a      	strb	r2, [r3, #0]
      break;
 8007cf4:	e000      	b.n	8007cf8 <RCC_LSEConfig+0x3c>
    default:
      break;
 8007cf6:	bf00      	nop
  }
}
 8007cf8:	f107 070c 	add.w	r7, r7, #12
 8007cfc:	46bd      	mov	sp, r7
 8007cfe:	bc80      	pop	{r7}
 8007d00:	4770      	bx	lr
 8007d02:	bf00      	nop
 8007d04:	40023870 	.word	0x40023870

08007d08 <RCC_LSICmd>:
  * @note   When the LSI is stopped, LSIRDY flag goes low after 6 LSI oscillator
  *         clock cycles. 
  * @retval None
  */
void RCC_LSICmd(FunctionalState NewState)
{
 8007d08:	b480      	push	{r7}
 8007d0a:	b083      	sub	sp, #12
 8007d0c:	af00      	add	r7, sp, #0
 8007d0e:	4603      	mov	r3, r0
 8007d10:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
 8007d12:	4b04      	ldr	r3, [pc, #16]	; (8007d24 <RCC_LSICmd+0x1c>)
 8007d14:	79fa      	ldrb	r2, [r7, #7]
 8007d16:	601a      	str	r2, [r3, #0]
}
 8007d18:	f107 070c 	add.w	r7, r7, #12
 8007d1c:	46bd      	mov	sp, r7
 8007d1e:	bc80      	pop	{r7}
 8007d20:	4770      	bx	lr
 8007d22:	bf00      	nop
 8007d24:	42470e80 	.word	0x42470e80

08007d28 <RCC_PLLConfig>:
  *         correctly.
  *   
  * @retval None
  */
void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ)
{
 8007d28:	b480      	push	{r7}
 8007d2a:	b085      	sub	sp, #20
 8007d2c:	af00      	add	r7, sp, #0
 8007d2e:	60f8      	str	r0, [r7, #12]
 8007d30:	60b9      	str	r1, [r7, #8]
 8007d32:	607a      	str	r2, [r7, #4]
 8007d34:	603b      	str	r3, [r7, #0]
  assert_param(IS_RCC_PLLM_VALUE(PLLM));
  assert_param(IS_RCC_PLLN_VALUE(PLLN));
  assert_param(IS_RCC_PLLP_VALUE(PLLP));
  assert_param(IS_RCC_PLLQ_VALUE(PLLQ));

  RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
 8007d36:	4b0d      	ldr	r3, [pc, #52]	; (8007d6c <RCC_PLLConfig+0x44>)
 8007d38:	687a      	ldr	r2, [r7, #4]
 8007d3a:	ea4f 1182 	mov.w	r1, r2, lsl #6
 8007d3e:	68ba      	ldr	r2, [r7, #8]
 8007d40:	4311      	orrs	r1, r2
 8007d42:	683a      	ldr	r2, [r7, #0]
 8007d44:	ea4f 0252 	mov.w	r2, r2, lsr #1
 8007d48:	f102 32ff 	add.w	r2, r2, #4294967295
 8007d4c:	ea4f 4202 	mov.w	r2, r2, lsl #16
 8007d50:	4311      	orrs	r1, r2
 8007d52:	68fa      	ldr	r2, [r7, #12]
 8007d54:	4311      	orrs	r1, r2
                 (PLLQ << 24);
 8007d56:	69ba      	ldr	r2, [r7, #24]
 8007d58:	ea4f 6202 	mov.w	r2, r2, lsl #24
  assert_param(IS_RCC_PLLM_VALUE(PLLM));
  assert_param(IS_RCC_PLLN_VALUE(PLLN));
  assert_param(IS_RCC_PLLP_VALUE(PLLP));
  assert_param(IS_RCC_PLLQ_VALUE(PLLQ));

  RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
 8007d5c:	430a      	orrs	r2, r1
 8007d5e:	605a      	str	r2, [r3, #4]
                 (PLLQ << 24);
}
 8007d60:	f107 0714 	add.w	r7, r7, #20
 8007d64:	46bd      	mov	sp, r7
 8007d66:	bc80      	pop	{r7}
 8007d68:	4770      	bx	lr
 8007d6a:	bf00      	nop
 8007d6c:	40023800 	.word	0x40023800

08007d70 <RCC_PLLCmd>:
  * @note   The main PLL is disabled by hardware when entering STOP and STANDBY modes.
  * @param  NewState: new state of the main PLL. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_PLLCmd(FunctionalState NewState)
{
 8007d70:	b480      	push	{r7}
 8007d72:	b083      	sub	sp, #12
 8007d74:	af00      	add	r7, sp, #0
 8007d76:	4603      	mov	r3, r0
 8007d78:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 8007d7a:	4b04      	ldr	r3, [pc, #16]	; (8007d8c <RCC_PLLCmd+0x1c>)
 8007d7c:	79fa      	ldrb	r2, [r7, #7]
 8007d7e:	601a      	str	r2, [r3, #0]
}
 8007d80:	f107 070c 	add.w	r7, r7, #12
 8007d84:	46bd      	mov	sp, r7
 8007d86:	bc80      	pop	{r7}
 8007d88:	4770      	bx	lr
 8007d8a:	bf00      	nop
 8007d8c:	42470060 	.word	0x42470060

08007d90 <RCC_PLLI2SConfig>:
  *         on the I2S clock frequency.
  *   
  * @retval None
  */
void RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR)
{
 8007d90:	b480      	push	{r7}
 8007d92:	b083      	sub	sp, #12
 8007d94:	af00      	add	r7, sp, #0
 8007d96:	6078      	str	r0, [r7, #4]
 8007d98:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
  assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));

  RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
 8007d9a:	4b07      	ldr	r3, [pc, #28]	; (8007db8 <RCC_PLLI2SConfig+0x28>)
 8007d9c:	687a      	ldr	r2, [r7, #4]
 8007d9e:	ea4f 1182 	mov.w	r1, r2, lsl #6
 8007da2:	683a      	ldr	r2, [r7, #0]
 8007da4:	ea4f 7202 	mov.w	r2, r2, lsl #28
 8007da8:	430a      	orrs	r2, r1
 8007daa:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
 8007dae:	f107 070c 	add.w	r7, r7, #12
 8007db2:	46bd      	mov	sp, r7
 8007db4:	bc80      	pop	{r7}
 8007db6:	4770      	bx	lr
 8007db8:	40023800 	.word	0x40023800

08007dbc <RCC_PLLI2SCmd>:
  * @note   The PLLI2S is disabled by hardware when entering STOP and STANDBY modes.  
  * @param  NewState: new state of the PLLI2S. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_PLLI2SCmd(FunctionalState NewState)
{
 8007dbc:	b480      	push	{r7}
 8007dbe:	b083      	sub	sp, #12
 8007dc0:	af00      	add	r7, sp, #0
 8007dc2:	4603      	mov	r3, r0
 8007dc4:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
 8007dc6:	4b04      	ldr	r3, [pc, #16]	; (8007dd8 <RCC_PLLI2SCmd+0x1c>)
 8007dc8:	79fa      	ldrb	r2, [r7, #7]
 8007dca:	601a      	str	r2, [r3, #0]
}
 8007dcc:	f107 070c 	add.w	r7, r7, #12
 8007dd0:	46bd      	mov	sp, r7
 8007dd2:	bc80      	pop	{r7}
 8007dd4:	4770      	bx	lr
 8007dd6:	bf00      	nop
 8007dd8:	42470068 	.word	0x42470068

08007ddc <RCC_ClockSecuritySystemCmd>:
  * @param  NewState: new state of the Clock Security System.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
 8007ddc:	b480      	push	{r7}
 8007dde:	b083      	sub	sp, #12
 8007de0:	af00      	add	r7, sp, #0
 8007de2:	4603      	mov	r3, r0
 8007de4:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
 8007de6:	4b04      	ldr	r3, [pc, #16]	; (8007df8 <RCC_ClockSecuritySystemCmd+0x1c>)
 8007de8:	79fa      	ldrb	r2, [r7, #7]
 8007dea:	601a      	str	r2, [r3, #0]
}
 8007dec:	f107 070c 	add.w	r7, r7, #12
 8007df0:	46bd      	mov	sp, r7
 8007df2:	bc80      	pop	{r7}
 8007df4:	4770      	bx	lr
 8007df6:	bf00      	nop
 8007df8:	4247004c 	.word	0x4247004c

08007dfc <RCC_MCO1Config>:
  *            @arg RCC_MCO1Div_4: division by 4 applied to MCO1 clock
  *            @arg RCC_MCO1Div_5: division by 5 applied to MCO1 clock
  * @retval None
  */
void RCC_MCO1Config(uint32_t RCC_MCO1Source, uint32_t RCC_MCO1Div)
{
 8007dfc:	b480      	push	{r7}
 8007dfe:	b085      	sub	sp, #20
 8007e00:	af00      	add	r7, sp, #0
 8007e02:	6078      	str	r0, [r7, #4]
 8007e04:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8007e06:	f04f 0300 	mov.w	r3, #0
 8007e0a:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
  assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  

  tmpreg = RCC->CFGR;
 8007e0c:	4b0a      	ldr	r3, [pc, #40]	; (8007e38 <RCC_MCO1Config+0x3c>)
 8007e0e:	689b      	ldr	r3, [r3, #8]
 8007e10:	60fb      	str	r3, [r7, #12]

  /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
  tmpreg &= CFGR_MCO1_RESET_MASK;
 8007e12:	68fb      	ldr	r3, [r7, #12]
 8007e14:	f023 63ec 	bic.w	r3, r3, #123731968	; 0x7600000
 8007e18:	60fb      	str	r3, [r7, #12]

  /* Select MCO1 clock source and prescaler */
  tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
 8007e1a:	687a      	ldr	r2, [r7, #4]
 8007e1c:	683b      	ldr	r3, [r7, #0]
 8007e1e:	4313      	orrs	r3, r2
 8007e20:	68fa      	ldr	r2, [r7, #12]
 8007e22:	4313      	orrs	r3, r2
 8007e24:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;  
 8007e26:	4b04      	ldr	r3, [pc, #16]	; (8007e38 <RCC_MCO1Config+0x3c>)
 8007e28:	68fa      	ldr	r2, [r7, #12]
 8007e2a:	609a      	str	r2, [r3, #8]
}
 8007e2c:	f107 0714 	add.w	r7, r7, #20
 8007e30:	46bd      	mov	sp, r7
 8007e32:	bc80      	pop	{r7}
 8007e34:	4770      	bx	lr
 8007e36:	bf00      	nop
 8007e38:	40023800 	.word	0x40023800

08007e3c <RCC_MCO2Config>:
  *            @arg RCC_MCO2Div_4: division by 4 applied to MCO2 clock
  *            @arg RCC_MCO2Div_5: division by 5 applied to MCO2 clock
  * @retval None
  */
void RCC_MCO2Config(uint32_t RCC_MCO2Source, uint32_t RCC_MCO2Div)
{
 8007e3c:	b480      	push	{r7}
 8007e3e:	b085      	sub	sp, #20
 8007e40:	af00      	add	r7, sp, #0
 8007e42:	6078      	str	r0, [r7, #4]
 8007e44:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8007e46:	f04f 0300 	mov.w	r3, #0
 8007e4a:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
  assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
  
  tmpreg = RCC->CFGR;
 8007e4c:	4b0a      	ldr	r3, [pc, #40]	; (8007e78 <RCC_MCO2Config+0x3c>)
 8007e4e:	689b      	ldr	r3, [r3, #8]
 8007e50:	60fb      	str	r3, [r7, #12]
  
  /* Clear MCO2 and MCO2PRE[2:0] bits */
  tmpreg &= CFGR_MCO2_RESET_MASK;
 8007e52:	68fb      	ldr	r3, [r7, #12]
 8007e54:	f023 4378 	bic.w	r3, r3, #4160749568	; 0xf8000000
 8007e58:	60fb      	str	r3, [r7, #12]

  /* Select MCO2 clock source and prescaler */
  tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
 8007e5a:	687a      	ldr	r2, [r7, #4]
 8007e5c:	683b      	ldr	r3, [r7, #0]
 8007e5e:	4313      	orrs	r3, r2
 8007e60:	68fa      	ldr	r2, [r7, #12]
 8007e62:	4313      	orrs	r3, r2
 8007e64:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;  
 8007e66:	4b04      	ldr	r3, [pc, #16]	; (8007e78 <RCC_MCO2Config+0x3c>)
 8007e68:	68fa      	ldr	r2, [r7, #12]
 8007e6a:	609a      	str	r2, [r3, #8]
}
 8007e6c:	f107 0714 	add.w	r7, r7, #20
 8007e70:	46bd      	mov	sp, r7
 8007e72:	bc80      	pop	{r7}
 8007e74:	4770      	bx	lr
 8007e76:	bf00      	nop
 8007e78:	40023800 	.word	0x40023800

08007e7c <RCC_SYSCLKConfig>:
  *            @arg RCC_SYSCLKSource_HSE:    HSE selected as system clock source
  *            @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock source
  * @retval None
  */
void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
{
 8007e7c:	b480      	push	{r7}
 8007e7e:	b085      	sub	sp, #20
 8007e80:	af00      	add	r7, sp, #0
 8007e82:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8007e84:	f04f 0300 	mov.w	r3, #0
 8007e88:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));

  tmpreg = RCC->CFGR;
 8007e8a:	4b09      	ldr	r3, [pc, #36]	; (8007eb0 <RCC_SYSCLKConfig+0x34>)
 8007e8c:	689b      	ldr	r3, [r3, #8]
 8007e8e:	60fb      	str	r3, [r7, #12]

  /* Clear SW[1:0] bits */
  tmpreg &= ~RCC_CFGR_SW;
 8007e90:	68fb      	ldr	r3, [r7, #12]
 8007e92:	f023 0303 	bic.w	r3, r3, #3
 8007e96:	60fb      	str	r3, [r7, #12]

  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 8007e98:	68fa      	ldr	r2, [r7, #12]
 8007e9a:	687b      	ldr	r3, [r7, #4]
 8007e9c:	4313      	orrs	r3, r2
 8007e9e:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;
 8007ea0:	4b03      	ldr	r3, [pc, #12]	; (8007eb0 <RCC_SYSCLKConfig+0x34>)
 8007ea2:	68fa      	ldr	r2, [r7, #12]
 8007ea4:	609a      	str	r2, [r3, #8]
}
 8007ea6:	f107 0714 	add.w	r7, r7, #20
 8007eaa:	46bd      	mov	sp, r7
 8007eac:	bc80      	pop	{r7}
 8007eae:	4770      	bx	lr
 8007eb0:	40023800 	.word	0x40023800

08007eb4 <RCC_GetSYSCLKSource>:
  *              - 0x00: HSI used as system clock
  *              - 0x04: HSE used as system clock
  *              - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
 8007eb4:	b480      	push	{r7}
 8007eb6:	af00      	add	r7, sp, #0
  return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
 8007eb8:	4b04      	ldr	r3, [pc, #16]	; (8007ecc <RCC_GetSYSCLKSource+0x18>)
 8007eba:	689b      	ldr	r3, [r3, #8]
 8007ebc:	b2db      	uxtb	r3, r3
 8007ebe:	f003 030c 	and.w	r3, r3, #12
 8007ec2:	b2db      	uxtb	r3, r3
}
 8007ec4:	4618      	mov	r0, r3
 8007ec6:	46bd      	mov	sp, r7
 8007ec8:	bc80      	pop	{r7}
 8007eca:	4770      	bx	lr
 8007ecc:	40023800 	.word	0x40023800

08007ed0 <RCC_HCLKConfig>:
  *            @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
  *            @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
  * @retval None
  */
void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
{
 8007ed0:	b480      	push	{r7}
 8007ed2:	b085      	sub	sp, #20
 8007ed4:	af00      	add	r7, sp, #0
 8007ed6:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8007ed8:	f04f 0300 	mov.w	r3, #0
 8007edc:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));

  tmpreg = RCC->CFGR;
 8007ede:	4b09      	ldr	r3, [pc, #36]	; (8007f04 <RCC_HCLKConfig+0x34>)
 8007ee0:	689b      	ldr	r3, [r3, #8]
 8007ee2:	60fb      	str	r3, [r7, #12]

  /* Clear HPRE[3:0] bits */
  tmpreg &= ~RCC_CFGR_HPRE;
 8007ee4:	68fb      	ldr	r3, [r7, #12]
 8007ee6:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8007eea:	60fb      	str	r3, [r7, #12]

  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 8007eec:	68fa      	ldr	r2, [r7, #12]
 8007eee:	687b      	ldr	r3, [r7, #4]
 8007ef0:	4313      	orrs	r3, r2
 8007ef2:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;
 8007ef4:	4b03      	ldr	r3, [pc, #12]	; (8007f04 <RCC_HCLKConfig+0x34>)
 8007ef6:	68fa      	ldr	r2, [r7, #12]
 8007ef8:	609a      	str	r2, [r3, #8]
}
 8007efa:	f107 0714 	add.w	r7, r7, #20
 8007efe:	46bd      	mov	sp, r7
 8007f00:	bc80      	pop	{r7}
 8007f02:	4770      	bx	lr
 8007f04:	40023800 	.word	0x40023800

08007f08 <RCC_PCLK1Config>:
  *            @arg RCC_HCLK_Div8:  APB1 clock = HCLK/8
  *            @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
  * @retval None
  */
void RCC_PCLK1Config(uint32_t RCC_HCLK)
{
 8007f08:	b480      	push	{r7}
 8007f0a:	b085      	sub	sp, #20
 8007f0c:	af00      	add	r7, sp, #0
 8007f0e:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8007f10:	f04f 0300 	mov.w	r3, #0
 8007f14:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 8007f16:	4b09      	ldr	r3, [pc, #36]	; (8007f3c <RCC_PCLK1Config+0x34>)
 8007f18:	689b      	ldr	r3, [r3, #8]
 8007f1a:	60fb      	str	r3, [r7, #12]

  /* Clear PPRE1[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE1;
 8007f1c:	68fb      	ldr	r3, [r7, #12]
 8007f1e:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 8007f22:	60fb      	str	r3, [r7, #12]

  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 8007f24:	68fa      	ldr	r2, [r7, #12]
 8007f26:	687b      	ldr	r3, [r7, #4]
 8007f28:	4313      	orrs	r3, r2
 8007f2a:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;
 8007f2c:	4b03      	ldr	r3, [pc, #12]	; (8007f3c <RCC_PCLK1Config+0x34>)
 8007f2e:	68fa      	ldr	r2, [r7, #12]
 8007f30:	609a      	str	r2, [r3, #8]
}
 8007f32:	f107 0714 	add.w	r7, r7, #20
 8007f36:	46bd      	mov	sp, r7
 8007f38:	bc80      	pop	{r7}
 8007f3a:	4770      	bx	lr
 8007f3c:	40023800 	.word	0x40023800

08007f40 <RCC_PCLK2Config>:
  *            @arg RCC_HCLK_Div8:  APB2 clock = HCLK/8
  *            @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
  * @retval None
  */
void RCC_PCLK2Config(uint32_t RCC_HCLK)
{
 8007f40:	b480      	push	{r7}
 8007f42:	b085      	sub	sp, #20
 8007f44:	af00      	add	r7, sp, #0
 8007f46:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8007f48:	f04f 0300 	mov.w	r3, #0
 8007f4c:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 8007f4e:	4b0a      	ldr	r3, [pc, #40]	; (8007f78 <RCC_PCLK2Config+0x38>)
 8007f50:	689b      	ldr	r3, [r3, #8]
 8007f52:	60fb      	str	r3, [r7, #12]

  /* Clear PPRE2[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE2;
 8007f54:	68fb      	ldr	r3, [r7, #12]
 8007f56:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8007f5a:	60fb      	str	r3, [r7, #12]

  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 8007f5c:	687b      	ldr	r3, [r7, #4]
 8007f5e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8007f62:	68fa      	ldr	r2, [r7, #12]
 8007f64:	4313      	orrs	r3, r2
 8007f66:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;
 8007f68:	4b03      	ldr	r3, [pc, #12]	; (8007f78 <RCC_PCLK2Config+0x38>)
 8007f6a:	68fa      	ldr	r2, [r7, #12]
 8007f6c:	609a      	str	r2, [r3, #8]
}
 8007f6e:	f107 0714 	add.w	r7, r7, #20
 8007f72:	46bd      	mov	sp, r7
 8007f74:	bc80      	pop	{r7}
 8007f76:	4770      	bx	lr
 8007f78:	40023800 	.word	0x40023800

08007f7c <RCC_GetClocksFreq>:
  *         configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 8007f7c:	b480      	push	{r7}
 8007f7e:	b089      	sub	sp, #36	; 0x24
 8007f80:	af00      	add	r7, sp, #0
 8007f82:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
 8007f84:	f04f 0300 	mov.w	r3, #0
 8007f88:	61bb      	str	r3, [r7, #24]
 8007f8a:	f04f 0300 	mov.w	r3, #0
 8007f8e:	617b      	str	r3, [r7, #20]
 8007f90:	f04f 0300 	mov.w	r3, #0
 8007f94:	61fb      	str	r3, [r7, #28]
 8007f96:	f04f 0302 	mov.w	r3, #2
 8007f9a:	613b      	str	r3, [r7, #16]
 8007f9c:	f04f 0300 	mov.w	r3, #0
 8007fa0:	60fb      	str	r3, [r7, #12]
 8007fa2:	f04f 0302 	mov.w	r3, #2
 8007fa6:	60bb      	str	r3, [r7, #8]

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8007fa8:	4b4e      	ldr	r3, [pc, #312]	; (80080e4 <RCC_GetClocksFreq+0x168>)
 8007faa:	689b      	ldr	r3, [r3, #8]
 8007fac:	f003 030c 	and.w	r3, r3, #12
 8007fb0:	61bb      	str	r3, [r7, #24]

  switch (tmp)
 8007fb2:	69bb      	ldr	r3, [r7, #24]
 8007fb4:	2b04      	cmp	r3, #4
 8007fb6:	d007      	beq.n	8007fc8 <RCC_GetClocksFreq+0x4c>
 8007fb8:	2b08      	cmp	r3, #8
 8007fba:	d009      	beq.n	8007fd0 <RCC_GetClocksFreq+0x54>
 8007fbc:	2b00      	cmp	r3, #0
 8007fbe:	d145      	bne.n	800804c <RCC_GetClocksFreq+0xd0>
  {
    case 0x00:  /* HSI used as system clock source */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8007fc0:	687b      	ldr	r3, [r7, #4]
 8007fc2:	4a49      	ldr	r2, [pc, #292]	; (80080e8 <RCC_GetClocksFreq+0x16c>)
 8007fc4:	601a      	str	r2, [r3, #0]
      break;
 8007fc6:	e045      	b.n	8008054 <RCC_GetClocksFreq+0xd8>
    case 0x04:  /* HSE used as system clock  source */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 8007fc8:	687b      	ldr	r3, [r7, #4]
 8007fca:	4a48      	ldr	r2, [pc, #288]	; (80080ec <RCC_GetClocksFreq+0x170>)
 8007fcc:	601a      	str	r2, [r3, #0]
      break;
 8007fce:	e041      	b.n	8008054 <RCC_GetClocksFreq+0xd8>
    case 0x08:  /* PLL used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 8007fd0:	4b44      	ldr	r3, [pc, #272]	; (80080e4 <RCC_GetClocksFreq+0x168>)
 8007fd2:	685b      	ldr	r3, [r3, #4]
 8007fd4:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8007fd8:	ea4f 5393 	mov.w	r3, r3, lsr #22
 8007fdc:	60fb      	str	r3, [r7, #12]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8007fde:	4b41      	ldr	r3, [pc, #260]	; (80080e4 <RCC_GetClocksFreq+0x168>)
 8007fe0:	685b      	ldr	r3, [r3, #4]
 8007fe2:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8007fe6:	60bb      	str	r3, [r7, #8]
      
      if (pllsource != 0)
 8007fe8:	68fb      	ldr	r3, [r7, #12]
 8007fea:	2b00      	cmp	r3, #0
 8007fec:	d00e      	beq.n	800800c <RCC_GetClocksFreq+0x90>
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8007fee:	4a3f      	ldr	r2, [pc, #252]	; (80080ec <RCC_GetClocksFreq+0x170>)
 8007ff0:	68bb      	ldr	r3, [r7, #8]
 8007ff2:	fbb2 f2f3 	udiv	r2, r2, r3
 8007ff6:	4b3b      	ldr	r3, [pc, #236]	; (80080e4 <RCC_GetClocksFreq+0x168>)
 8007ff8:	6859      	ldr	r1, [r3, #4]
 8007ffa:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8007ffe:	400b      	ands	r3, r1
 8008000:	ea4f 1393 	mov.w	r3, r3, lsr #6
 8008004:	fb03 f302 	mul.w	r3, r3, r2
 8008008:	61fb      	str	r3, [r7, #28]
 800800a:	e00d      	b.n	8008028 <RCC_GetClocksFreq+0xac>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 800800c:	4a36      	ldr	r2, [pc, #216]	; (80080e8 <RCC_GetClocksFreq+0x16c>)
 800800e:	68bb      	ldr	r3, [r7, #8]
 8008010:	fbb2 f2f3 	udiv	r2, r2, r3
 8008014:	4b33      	ldr	r3, [pc, #204]	; (80080e4 <RCC_GetClocksFreq+0x168>)
 8008016:	6859      	ldr	r1, [r3, #4]
 8008018:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 800801c:	400b      	ands	r3, r1
 800801e:	ea4f 1393 	mov.w	r3, r3, lsr #6
 8008022:	fb03 f302 	mul.w	r3, r3, r2
 8008026:	61fb      	str	r3, [r7, #28]
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8008028:	4b2e      	ldr	r3, [pc, #184]	; (80080e4 <RCC_GetClocksFreq+0x168>)
 800802a:	685b      	ldr	r3, [r3, #4]
 800802c:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8008030:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8008034:	f103 0301 	add.w	r3, r3, #1
 8008038:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800803c:	613b      	str	r3, [r7, #16]
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 800803e:	69fa      	ldr	r2, [r7, #28]
 8008040:	693b      	ldr	r3, [r7, #16]
 8008042:	fbb2 f2f3 	udiv	r2, r2, r3
 8008046:	687b      	ldr	r3, [r7, #4]
 8008048:	601a      	str	r2, [r3, #0]
      break;
 800804a:	e003      	b.n	8008054 <RCC_GetClocksFreq+0xd8>
    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 800804c:	687b      	ldr	r3, [r7, #4]
 800804e:	4a26      	ldr	r2, [pc, #152]	; (80080e8 <RCC_GetClocksFreq+0x16c>)
 8008050:	601a      	str	r2, [r3, #0]
      break;
 8008052:	bf00      	nop
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 8008054:	4b23      	ldr	r3, [pc, #140]	; (80080e4 <RCC_GetClocksFreq+0x168>)
 8008056:	689b      	ldr	r3, [r3, #8]
 8008058:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800805c:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 4;
 800805e:	69bb      	ldr	r3, [r7, #24]
 8008060:	ea4f 1313 	mov.w	r3, r3, lsr #4
 8008064:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 8008066:	4a22      	ldr	r2, [pc, #136]	; (80080f0 <RCC_GetClocksFreq+0x174>)
 8008068:	69bb      	ldr	r3, [r7, #24]
 800806a:	18d3      	adds	r3, r2, r3
 800806c:	781b      	ldrb	r3, [r3, #0]
 800806e:	b2db      	uxtb	r3, r3
 8008070:	617b      	str	r3, [r7, #20]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 8008072:	687b      	ldr	r3, [r7, #4]
 8008074:	681a      	ldr	r2, [r3, #0]
 8008076:	697b      	ldr	r3, [r7, #20]
 8008078:	fa22 f203 	lsr.w	r2, r2, r3
 800807c:	687b      	ldr	r3, [r7, #4]
 800807e:	605a      	str	r2, [r3, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 8008080:	4b18      	ldr	r3, [pc, #96]	; (80080e4 <RCC_GetClocksFreq+0x168>)
 8008082:	689b      	ldr	r3, [r3, #8]
 8008084:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
 8008088:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 10;
 800808a:	69bb      	ldr	r3, [r7, #24]
 800808c:	ea4f 2393 	mov.w	r3, r3, lsr #10
 8008090:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 8008092:	4a17      	ldr	r2, [pc, #92]	; (80080f0 <RCC_GetClocksFreq+0x174>)
 8008094:	69bb      	ldr	r3, [r7, #24]
 8008096:	18d3      	adds	r3, r2, r3
 8008098:	781b      	ldrb	r3, [r3, #0]
 800809a:	b2db      	uxtb	r3, r3
 800809c:	617b      	str	r3, [r7, #20]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 800809e:	687b      	ldr	r3, [r7, #4]
 80080a0:	685a      	ldr	r2, [r3, #4]
 80080a2:	697b      	ldr	r3, [r7, #20]
 80080a4:	fa22 f203 	lsr.w	r2, r2, r3
 80080a8:	687b      	ldr	r3, [r7, #4]
 80080aa:	609a      	str	r2, [r3, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 80080ac:	4b0d      	ldr	r3, [pc, #52]	; (80080e4 <RCC_GetClocksFreq+0x168>)
 80080ae:	689b      	ldr	r3, [r3, #8]
 80080b0:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 80080b4:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 13;
 80080b6:	69bb      	ldr	r3, [r7, #24]
 80080b8:	ea4f 3353 	mov.w	r3, r3, lsr #13
 80080bc:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 80080be:	4a0c      	ldr	r2, [pc, #48]	; (80080f0 <RCC_GetClocksFreq+0x174>)
 80080c0:	69bb      	ldr	r3, [r7, #24]
 80080c2:	18d3      	adds	r3, r2, r3
 80080c4:	781b      	ldrb	r3, [r3, #0]
 80080c6:	b2db      	uxtb	r3, r3
 80080c8:	617b      	str	r3, [r7, #20]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 80080ca:	687b      	ldr	r3, [r7, #4]
 80080cc:	685a      	ldr	r2, [r3, #4]
 80080ce:	697b      	ldr	r3, [r7, #20]
 80080d0:	fa22 f203 	lsr.w	r2, r2, r3
 80080d4:	687b      	ldr	r3, [r7, #4]
 80080d6:	60da      	str	r2, [r3, #12]
}
 80080d8:	f107 0724 	add.w	r7, r7, #36	; 0x24
 80080dc:	46bd      	mov	sp, r7
 80080de:	bc80      	pop	{r7}
 80080e0:	4770      	bx	lr
 80080e2:	bf00      	nop
 80080e4:	40023800 	.word	0x40023800
 80080e8:	00f42400 	.word	0x00f42400
 80080ec:	017d7840 	.word	0x017d7840
 80080f0:	20000028 	.word	0x20000028

080080f4 <RCC_RTCCLKConfig>:
  *         RTC clock source).
  *  
  * @retval None
  */
void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
{
 80080f4:	b480      	push	{r7}
 80080f6:	b085      	sub	sp, #20
 80080f8:	af00      	add	r7, sp, #0
 80080fa:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 80080fc:	f04f 0300 	mov.w	r3, #0
 8008100:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));

  if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
 8008102:	687b      	ldr	r3, [r7, #4]
 8008104:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8008108:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800810c:	d111      	bne.n	8008132 <RCC_RTCCLKConfig+0x3e>
  { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
    tmpreg = RCC->CFGR;
 800810e:	4b10      	ldr	r3, [pc, #64]	; (8008150 <RCC_RTCCLKConfig+0x5c>)
 8008110:	689b      	ldr	r3, [r3, #8]
 8008112:	60fb      	str	r3, [r7, #12]

    /* Clear RTCPRE[4:0] bits */
    tmpreg &= ~RCC_CFGR_RTCPRE;
 8008114:	68fb      	ldr	r3, [r7, #12]
 8008116:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 800811a:	60fb      	str	r3, [r7, #12]

    /* Configure HSE division factor for RTC clock */
    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
 800811c:	687b      	ldr	r3, [r7, #4]
 800811e:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8008122:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8008126:	68fa      	ldr	r2, [r7, #12]
 8008128:	4313      	orrs	r3, r2
 800812a:	60fb      	str	r3, [r7, #12]

    /* Store the new value */
    RCC->CFGR = tmpreg;
 800812c:	4b08      	ldr	r3, [pc, #32]	; (8008150 <RCC_RTCCLKConfig+0x5c>)
 800812e:	68fa      	ldr	r2, [r7, #12]
 8008130:	609a      	str	r2, [r3, #8]
  }
    
  /* Select the RTC clock source */
  RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
 8008132:	4a07      	ldr	r2, [pc, #28]	; (8008150 <RCC_RTCCLKConfig+0x5c>)
 8008134:	4b06      	ldr	r3, [pc, #24]	; (8008150 <RCC_RTCCLKConfig+0x5c>)
 8008136:	6f19      	ldr	r1, [r3, #112]	; 0x70
 8008138:	687b      	ldr	r3, [r7, #4]
 800813a:	ea4f 5303 	mov.w	r3, r3, lsl #20
 800813e:	ea4f 5313 	mov.w	r3, r3, lsr #20
 8008142:	430b      	orrs	r3, r1
 8008144:	6713      	str	r3, [r2, #112]	; 0x70
}
 8008146:	f107 0714 	add.w	r7, r7, #20
 800814a:	46bd      	mov	sp, r7
 800814c:	bc80      	pop	{r7}
 800814e:	4770      	bx	lr
 8008150:	40023800 	.word	0x40023800

08008154 <RCC_RTCCLKCmd>:
  *         using the RCC_RTCCLKConfig function.
  * @param  NewState: new state of the RTC clock. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_RTCCLKCmd(FunctionalState NewState)
{
 8008154:	b480      	push	{r7}
 8008156:	b083      	sub	sp, #12
 8008158:	af00      	add	r7, sp, #0
 800815a:	4603      	mov	r3, r0
 800815c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 800815e:	4b04      	ldr	r3, [pc, #16]	; (8008170 <RCC_RTCCLKCmd+0x1c>)
 8008160:	79fa      	ldrb	r2, [r7, #7]
 8008162:	601a      	str	r2, [r3, #0]
}
 8008164:	f107 070c 	add.w	r7, r7, #12
 8008168:	46bd      	mov	sp, r7
 800816a:	bc80      	pop	{r7}
 800816c:	4770      	bx	lr
 800816e:	bf00      	nop
 8008170:	42470e3c 	.word	0x42470e3c

08008174 <RCC_BackupResetCmd>:
  * @param  NewState: new state of the Backup domain reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_BackupResetCmd(FunctionalState NewState)
{
 8008174:	b480      	push	{r7}
 8008176:	b083      	sub	sp, #12
 8008178:	af00      	add	r7, sp, #0
 800817a:	4603      	mov	r3, r0
 800817c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 800817e:	4b04      	ldr	r3, [pc, #16]	; (8008190 <RCC_BackupResetCmd+0x1c>)
 8008180:	79fa      	ldrb	r2, [r7, #7]
 8008182:	601a      	str	r2, [r3, #0]
}
 8008184:	f107 070c 	add.w	r7, r7, #12
 8008188:	46bd      	mov	sp, r7
 800818a:	bc80      	pop	{r7}
 800818c:	4770      	bx	lr
 800818e:	bf00      	nop
 8008190:	42470e40 	.word	0x42470e40

08008194 <RCC_I2SCLKConfig>:
  *            @arg RCC_I2S2CLKSource_Ext: External clock mapped on the I2S_CKIN pin
  *                                        used as I2S clock source
  * @retval None
  */
void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
{
 8008194:	b480      	push	{r7}
 8008196:	b083      	sub	sp, #12
 8008198:	af00      	add	r7, sp, #0
 800819a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));

  *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
 800819c:	4b03      	ldr	r3, [pc, #12]	; (80081ac <RCC_I2SCLKConfig+0x18>)
 800819e:	687a      	ldr	r2, [r7, #4]
 80081a0:	601a      	str	r2, [r3, #0]
}
 80081a2:	f107 070c 	add.w	r7, r7, #12
 80081a6:	46bd      	mov	sp, r7
 80081a8:	bc80      	pop	{r7}
 80081aa:	4770      	bx	lr
 80081ac:	4247015c 	.word	0x4247015c

080081b0 <RCC_AHB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
 80081b0:	b480      	push	{r7}
 80081b2:	b083      	sub	sp, #12
 80081b4:	af00      	add	r7, sp, #0
 80081b6:	6078      	str	r0, [r7, #4]
 80081b8:	460b      	mov	r3, r1
 80081ba:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80081bc:	78fb      	ldrb	r3, [r7, #3]
 80081be:	2b00      	cmp	r3, #0
 80081c0:	d006      	beq.n	80081d0 <RCC_AHB1PeriphClockCmd+0x20>
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
 80081c2:	4b0a      	ldr	r3, [pc, #40]	; (80081ec <RCC_AHB1PeriphClockCmd+0x3c>)
 80081c4:	4a09      	ldr	r2, [pc, #36]	; (80081ec <RCC_AHB1PeriphClockCmd+0x3c>)
 80081c6:	6b11      	ldr	r1, [r2, #48]	; 0x30
 80081c8:	687a      	ldr	r2, [r7, #4]
 80081ca:	430a      	orrs	r2, r1
 80081cc:	631a      	str	r2, [r3, #48]	; 0x30
 80081ce:	e007      	b.n	80081e0 <RCC_AHB1PeriphClockCmd+0x30>
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
 80081d0:	4b06      	ldr	r3, [pc, #24]	; (80081ec <RCC_AHB1PeriphClockCmd+0x3c>)
 80081d2:	4a06      	ldr	r2, [pc, #24]	; (80081ec <RCC_AHB1PeriphClockCmd+0x3c>)
 80081d4:	6b11      	ldr	r1, [r2, #48]	; 0x30
 80081d6:	687a      	ldr	r2, [r7, #4]
 80081d8:	ea6f 0202 	mvn.w	r2, r2
 80081dc:	400a      	ands	r2, r1
 80081de:	631a      	str	r2, [r3, #48]	; 0x30
  }
}
 80081e0:	f107 070c 	add.w	r7, r7, #12
 80081e4:	46bd      	mov	sp, r7
 80081e6:	bc80      	pop	{r7}
 80081e8:	4770      	bx	lr
 80081ea:	bf00      	nop
 80081ec:	40023800 	.word	0x40023800

080081f0 <RCC_AHB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
{
 80081f0:	b480      	push	{r7}
 80081f2:	b083      	sub	sp, #12
 80081f4:	af00      	add	r7, sp, #0
 80081f6:	6078      	str	r0, [r7, #4]
 80081f8:	460b      	mov	r3, r1
 80081fa:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80081fc:	78fb      	ldrb	r3, [r7, #3]
 80081fe:	2b00      	cmp	r3, #0
 8008200:	d006      	beq.n	8008210 <RCC_AHB2PeriphClockCmd+0x20>
  {
    RCC->AHB2ENR |= RCC_AHB2Periph;
 8008202:	4b0a      	ldr	r3, [pc, #40]	; (800822c <RCC_AHB2PeriphClockCmd+0x3c>)
 8008204:	4a09      	ldr	r2, [pc, #36]	; (800822c <RCC_AHB2PeriphClockCmd+0x3c>)
 8008206:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8008208:	687a      	ldr	r2, [r7, #4]
 800820a:	430a      	orrs	r2, r1
 800820c:	635a      	str	r2, [r3, #52]	; 0x34
 800820e:	e007      	b.n	8008220 <RCC_AHB2PeriphClockCmd+0x30>
  }
  else
  {
    RCC->AHB2ENR &= ~RCC_AHB2Periph;
 8008210:	4b06      	ldr	r3, [pc, #24]	; (800822c <RCC_AHB2PeriphClockCmd+0x3c>)
 8008212:	4a06      	ldr	r2, [pc, #24]	; (800822c <RCC_AHB2PeriphClockCmd+0x3c>)
 8008214:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8008216:	687a      	ldr	r2, [r7, #4]
 8008218:	ea6f 0202 	mvn.w	r2, r2
 800821c:	400a      	ands	r2, r1
 800821e:	635a      	str	r2, [r3, #52]	; 0x34
  }
}
 8008220:	f107 070c 	add.w	r7, r7, #12
 8008224:	46bd      	mov	sp, r7
 8008226:	bc80      	pop	{r7}
 8008228:	4770      	bx	lr
 800822a:	bf00      	nop
 800822c:	40023800 	.word	0x40023800

08008230 <RCC_AHB3PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
{
 8008230:	b480      	push	{r7}
 8008232:	b083      	sub	sp, #12
 8008234:	af00      	add	r7, sp, #0
 8008236:	6078      	str	r0, [r7, #4]
 8008238:	460b      	mov	r3, r1
 800823a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800823c:	78fb      	ldrb	r3, [r7, #3]
 800823e:	2b00      	cmp	r3, #0
 8008240:	d006      	beq.n	8008250 <RCC_AHB3PeriphClockCmd+0x20>
  {
    RCC->AHB3ENR |= RCC_AHB3Periph;
 8008242:	4b0a      	ldr	r3, [pc, #40]	; (800826c <RCC_AHB3PeriphClockCmd+0x3c>)
 8008244:	4a09      	ldr	r2, [pc, #36]	; (800826c <RCC_AHB3PeriphClockCmd+0x3c>)
 8008246:	6b91      	ldr	r1, [r2, #56]	; 0x38
 8008248:	687a      	ldr	r2, [r7, #4]
 800824a:	430a      	orrs	r2, r1
 800824c:	639a      	str	r2, [r3, #56]	; 0x38
 800824e:	e007      	b.n	8008260 <RCC_AHB3PeriphClockCmd+0x30>
  }
  else
  {
    RCC->AHB3ENR &= ~RCC_AHB3Periph;
 8008250:	4b06      	ldr	r3, [pc, #24]	; (800826c <RCC_AHB3PeriphClockCmd+0x3c>)
 8008252:	4a06      	ldr	r2, [pc, #24]	; (800826c <RCC_AHB3PeriphClockCmd+0x3c>)
 8008254:	6b91      	ldr	r1, [r2, #56]	; 0x38
 8008256:	687a      	ldr	r2, [r7, #4]
 8008258:	ea6f 0202 	mvn.w	r2, r2
 800825c:	400a      	ands	r2, r1
 800825e:	639a      	str	r2, [r3, #56]	; 0x38
  }
}
 8008260:	f107 070c 	add.w	r7, r7, #12
 8008264:	46bd      	mov	sp, r7
 8008266:	bc80      	pop	{r7}
 8008268:	4770      	bx	lr
 800826a:	bf00      	nop
 800826c:	40023800 	.word	0x40023800

08008270 <RCC_APB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 8008270:	b480      	push	{r7}
 8008272:	b083      	sub	sp, #12
 8008274:	af00      	add	r7, sp, #0
 8008276:	6078      	str	r0, [r7, #4]
 8008278:	460b      	mov	r3, r1
 800827a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800827c:	78fb      	ldrb	r3, [r7, #3]
 800827e:	2b00      	cmp	r3, #0
 8008280:	d006      	beq.n	8008290 <RCC_APB1PeriphClockCmd+0x20>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 8008282:	4b0a      	ldr	r3, [pc, #40]	; (80082ac <RCC_APB1PeriphClockCmd+0x3c>)
 8008284:	4a09      	ldr	r2, [pc, #36]	; (80082ac <RCC_APB1PeriphClockCmd+0x3c>)
 8008286:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8008288:	687a      	ldr	r2, [r7, #4]
 800828a:	430a      	orrs	r2, r1
 800828c:	641a      	str	r2, [r3, #64]	; 0x40
 800828e:	e007      	b.n	80082a0 <RCC_APB1PeriphClockCmd+0x30>
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 8008290:	4b06      	ldr	r3, [pc, #24]	; (80082ac <RCC_APB1PeriphClockCmd+0x3c>)
 8008292:	4a06      	ldr	r2, [pc, #24]	; (80082ac <RCC_APB1PeriphClockCmd+0x3c>)
 8008294:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8008296:	687a      	ldr	r2, [r7, #4]
 8008298:	ea6f 0202 	mvn.w	r2, r2
 800829c:	400a      	ands	r2, r1
 800829e:	641a      	str	r2, [r3, #64]	; 0x40
  }
}
 80082a0:	f107 070c 	add.w	r7, r7, #12
 80082a4:	46bd      	mov	sp, r7
 80082a6:	bc80      	pop	{r7}
 80082a8:	4770      	bx	lr
 80082aa:	bf00      	nop
 80082ac:	40023800 	.word	0x40023800

080082b0 <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 80082b0:	b480      	push	{r7}
 80082b2:	b083      	sub	sp, #12
 80082b4:	af00      	add	r7, sp, #0
 80082b6:	6078      	str	r0, [r7, #4]
 80082b8:	460b      	mov	r3, r1
 80082ba:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80082bc:	78fb      	ldrb	r3, [r7, #3]
 80082be:	2b00      	cmp	r3, #0
 80082c0:	d006      	beq.n	80082d0 <RCC_APB2PeriphClockCmd+0x20>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 80082c2:	4b0a      	ldr	r3, [pc, #40]	; (80082ec <RCC_APB2PeriphClockCmd+0x3c>)
 80082c4:	4a09      	ldr	r2, [pc, #36]	; (80082ec <RCC_APB2PeriphClockCmd+0x3c>)
 80082c6:	6c51      	ldr	r1, [r2, #68]	; 0x44
 80082c8:	687a      	ldr	r2, [r7, #4]
 80082ca:	430a      	orrs	r2, r1
 80082cc:	645a      	str	r2, [r3, #68]	; 0x44
 80082ce:	e007      	b.n	80082e0 <RCC_APB2PeriphClockCmd+0x30>
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 80082d0:	4b06      	ldr	r3, [pc, #24]	; (80082ec <RCC_APB2PeriphClockCmd+0x3c>)
 80082d2:	4a06      	ldr	r2, [pc, #24]	; (80082ec <RCC_APB2PeriphClockCmd+0x3c>)
 80082d4:	6c51      	ldr	r1, [r2, #68]	; 0x44
 80082d6:	687a      	ldr	r2, [r7, #4]
 80082d8:	ea6f 0202 	mvn.w	r2, r2
 80082dc:	400a      	ands	r2, r1
 80082de:	645a      	str	r2, [r3, #68]	; 0x44
  }
}
 80082e0:	f107 070c 	add.w	r7, r7, #12
 80082e4:	46bd      	mov	sp, r7
 80082e6:	bc80      	pop	{r7}
 80082e8:	4770      	bx	lr
 80082ea:	bf00      	nop
 80082ec:	40023800 	.word	0x40023800

080082f0 <RCC_AHB1PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
 80082f0:	b480      	push	{r7}
 80082f2:	b083      	sub	sp, #12
 80082f4:	af00      	add	r7, sp, #0
 80082f6:	6078      	str	r0, [r7, #4]
 80082f8:	460b      	mov	r3, r1
 80082fa:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80082fc:	78fb      	ldrb	r3, [r7, #3]
 80082fe:	2b00      	cmp	r3, #0
 8008300:	d006      	beq.n	8008310 <RCC_AHB1PeriphResetCmd+0x20>
  {
    RCC->AHB1RSTR |= RCC_AHB1Periph;
 8008302:	4b0a      	ldr	r3, [pc, #40]	; (800832c <RCC_AHB1PeriphResetCmd+0x3c>)
 8008304:	4a09      	ldr	r2, [pc, #36]	; (800832c <RCC_AHB1PeriphResetCmd+0x3c>)
 8008306:	6911      	ldr	r1, [r2, #16]
 8008308:	687a      	ldr	r2, [r7, #4]
 800830a:	430a      	orrs	r2, r1
 800830c:	611a      	str	r2, [r3, #16]
 800830e:	e007      	b.n	8008320 <RCC_AHB1PeriphResetCmd+0x30>
  }
  else
  {
    RCC->AHB1RSTR &= ~RCC_AHB1Periph;
 8008310:	4b06      	ldr	r3, [pc, #24]	; (800832c <RCC_AHB1PeriphResetCmd+0x3c>)
 8008312:	4a06      	ldr	r2, [pc, #24]	; (800832c <RCC_AHB1PeriphResetCmd+0x3c>)
 8008314:	6911      	ldr	r1, [r2, #16]
 8008316:	687a      	ldr	r2, [r7, #4]
 8008318:	ea6f 0202 	mvn.w	r2, r2
 800831c:	400a      	ands	r2, r1
 800831e:	611a      	str	r2, [r3, #16]
  }
}
 8008320:	f107 070c 	add.w	r7, r7, #12
 8008324:	46bd      	mov	sp, r7
 8008326:	bc80      	pop	{r7}
 8008328:	4770      	bx	lr
 800832a:	bf00      	nop
 800832c:	40023800 	.word	0x40023800

08008330 <RCC_AHB2PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
{
 8008330:	b480      	push	{r7}
 8008332:	b083      	sub	sp, #12
 8008334:	af00      	add	r7, sp, #0
 8008336:	6078      	str	r0, [r7, #4]
 8008338:	460b      	mov	r3, r1
 800833a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800833c:	78fb      	ldrb	r3, [r7, #3]
 800833e:	2b00      	cmp	r3, #0
 8008340:	d006      	beq.n	8008350 <RCC_AHB2PeriphResetCmd+0x20>
  {
    RCC->AHB2RSTR |= RCC_AHB2Periph;
 8008342:	4b0a      	ldr	r3, [pc, #40]	; (800836c <RCC_AHB2PeriphResetCmd+0x3c>)
 8008344:	4a09      	ldr	r2, [pc, #36]	; (800836c <RCC_AHB2PeriphResetCmd+0x3c>)
 8008346:	6951      	ldr	r1, [r2, #20]
 8008348:	687a      	ldr	r2, [r7, #4]
 800834a:	430a      	orrs	r2, r1
 800834c:	615a      	str	r2, [r3, #20]
 800834e:	e007      	b.n	8008360 <RCC_AHB2PeriphResetCmd+0x30>
  }
  else
  {
    RCC->AHB2RSTR &= ~RCC_AHB2Periph;
 8008350:	4b06      	ldr	r3, [pc, #24]	; (800836c <RCC_AHB2PeriphResetCmd+0x3c>)
 8008352:	4a06      	ldr	r2, [pc, #24]	; (800836c <RCC_AHB2PeriphResetCmd+0x3c>)
 8008354:	6951      	ldr	r1, [r2, #20]
 8008356:	687a      	ldr	r2, [r7, #4]
 8008358:	ea6f 0202 	mvn.w	r2, r2
 800835c:	400a      	ands	r2, r1
 800835e:	615a      	str	r2, [r3, #20]
  }
}
 8008360:	f107 070c 	add.w	r7, r7, #12
 8008364:	46bd      	mov	sp, r7
 8008366:	bc80      	pop	{r7}
 8008368:	4770      	bx	lr
 800836a:	bf00      	nop
 800836c:	40023800 	.word	0x40023800

08008370 <RCC_AHB3PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
{
 8008370:	b480      	push	{r7}
 8008372:	b083      	sub	sp, #12
 8008374:	af00      	add	r7, sp, #0
 8008376:	6078      	str	r0, [r7, #4]
 8008378:	460b      	mov	r3, r1
 800837a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800837c:	78fb      	ldrb	r3, [r7, #3]
 800837e:	2b00      	cmp	r3, #0
 8008380:	d006      	beq.n	8008390 <RCC_AHB3PeriphResetCmd+0x20>
  {
    RCC->AHB3RSTR |= RCC_AHB3Periph;
 8008382:	4b0a      	ldr	r3, [pc, #40]	; (80083ac <RCC_AHB3PeriphResetCmd+0x3c>)
 8008384:	4a09      	ldr	r2, [pc, #36]	; (80083ac <RCC_AHB3PeriphResetCmd+0x3c>)
 8008386:	6991      	ldr	r1, [r2, #24]
 8008388:	687a      	ldr	r2, [r7, #4]
 800838a:	430a      	orrs	r2, r1
 800838c:	619a      	str	r2, [r3, #24]
 800838e:	e007      	b.n	80083a0 <RCC_AHB3PeriphResetCmd+0x30>
  }
  else
  {
    RCC->AHB3RSTR &= ~RCC_AHB3Periph;
 8008390:	4b06      	ldr	r3, [pc, #24]	; (80083ac <RCC_AHB3PeriphResetCmd+0x3c>)
 8008392:	4a06      	ldr	r2, [pc, #24]	; (80083ac <RCC_AHB3PeriphResetCmd+0x3c>)
 8008394:	6991      	ldr	r1, [r2, #24]
 8008396:	687a      	ldr	r2, [r7, #4]
 8008398:	ea6f 0202 	mvn.w	r2, r2
 800839c:	400a      	ands	r2, r1
 800839e:	619a      	str	r2, [r3, #24]
  }
}
 80083a0:	f107 070c 	add.w	r7, r7, #12
 80083a4:	46bd      	mov	sp, r7
 80083a6:	bc80      	pop	{r7}
 80083a8:	4770      	bx	lr
 80083aa:	bf00      	nop
 80083ac:	40023800 	.word	0x40023800

080083b0 <RCC_APB1PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 80083b0:	b480      	push	{r7}
 80083b2:	b083      	sub	sp, #12
 80083b4:	af00      	add	r7, sp, #0
 80083b6:	6078      	str	r0, [r7, #4]
 80083b8:	460b      	mov	r3, r1
 80083ba:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80083bc:	78fb      	ldrb	r3, [r7, #3]
 80083be:	2b00      	cmp	r3, #0
 80083c0:	d006      	beq.n	80083d0 <RCC_APB1PeriphResetCmd+0x20>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 80083c2:	4b0a      	ldr	r3, [pc, #40]	; (80083ec <RCC_APB1PeriphResetCmd+0x3c>)
 80083c4:	4a09      	ldr	r2, [pc, #36]	; (80083ec <RCC_APB1PeriphResetCmd+0x3c>)
 80083c6:	6a11      	ldr	r1, [r2, #32]
 80083c8:	687a      	ldr	r2, [r7, #4]
 80083ca:	430a      	orrs	r2, r1
 80083cc:	621a      	str	r2, [r3, #32]
 80083ce:	e007      	b.n	80083e0 <RCC_APB1PeriphResetCmd+0x30>
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 80083d0:	4b06      	ldr	r3, [pc, #24]	; (80083ec <RCC_APB1PeriphResetCmd+0x3c>)
 80083d2:	4a06      	ldr	r2, [pc, #24]	; (80083ec <RCC_APB1PeriphResetCmd+0x3c>)
 80083d4:	6a11      	ldr	r1, [r2, #32]
 80083d6:	687a      	ldr	r2, [r7, #4]
 80083d8:	ea6f 0202 	mvn.w	r2, r2
 80083dc:	400a      	ands	r2, r1
 80083de:	621a      	str	r2, [r3, #32]
  }
}
 80083e0:	f107 070c 	add.w	r7, r7, #12
 80083e4:	46bd      	mov	sp, r7
 80083e6:	bc80      	pop	{r7}
 80083e8:	4770      	bx	lr
 80083ea:	bf00      	nop
 80083ec:	40023800 	.word	0x40023800

080083f0 <RCC_APB2PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 80083f0:	b480      	push	{r7}
 80083f2:	b083      	sub	sp, #12
 80083f4:	af00      	add	r7, sp, #0
 80083f6:	6078      	str	r0, [r7, #4]
 80083f8:	460b      	mov	r3, r1
 80083fa:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80083fc:	78fb      	ldrb	r3, [r7, #3]
 80083fe:	2b00      	cmp	r3, #0
 8008400:	d006      	beq.n	8008410 <RCC_APB2PeriphResetCmd+0x20>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 8008402:	4b0a      	ldr	r3, [pc, #40]	; (800842c <RCC_APB2PeriphResetCmd+0x3c>)
 8008404:	4a09      	ldr	r2, [pc, #36]	; (800842c <RCC_APB2PeriphResetCmd+0x3c>)
 8008406:	6a51      	ldr	r1, [r2, #36]	; 0x24
 8008408:	687a      	ldr	r2, [r7, #4]
 800840a:	430a      	orrs	r2, r1
 800840c:	625a      	str	r2, [r3, #36]	; 0x24
 800840e:	e007      	b.n	8008420 <RCC_APB2PeriphResetCmd+0x30>
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 8008410:	4b06      	ldr	r3, [pc, #24]	; (800842c <RCC_APB2PeriphResetCmd+0x3c>)
 8008412:	4a06      	ldr	r2, [pc, #24]	; (800842c <RCC_APB2PeriphResetCmd+0x3c>)
 8008414:	6a51      	ldr	r1, [r2, #36]	; 0x24
 8008416:	687a      	ldr	r2, [r7, #4]
 8008418:	ea6f 0202 	mvn.w	r2, r2
 800841c:	400a      	ands	r2, r1
 800841e:	625a      	str	r2, [r3, #36]	; 0x24
  }
}
 8008420:	f107 070c 	add.w	r7, r7, #12
 8008424:	46bd      	mov	sp, r7
 8008426:	bc80      	pop	{r7}
 8008428:	4770      	bx	lr
 800842a:	bf00      	nop
 800842c:	40023800 	.word	0x40023800

08008430 <RCC_AHB1PeriphClockLPModeCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
 8008430:	b480      	push	{r7}
 8008432:	b083      	sub	sp, #12
 8008434:	af00      	add	r7, sp, #0
 8008436:	6078      	str	r0, [r7, #4]
 8008438:	460b      	mov	r3, r1
 800843a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800843c:	78fb      	ldrb	r3, [r7, #3]
 800843e:	2b00      	cmp	r3, #0
 8008440:	d006      	beq.n	8008450 <RCC_AHB1PeriphClockLPModeCmd+0x20>
  {
    RCC->AHB1LPENR |= RCC_AHB1Periph;
 8008442:	4b0a      	ldr	r3, [pc, #40]	; (800846c <RCC_AHB1PeriphClockLPModeCmd+0x3c>)
 8008444:	4a09      	ldr	r2, [pc, #36]	; (800846c <RCC_AHB1PeriphClockLPModeCmd+0x3c>)
 8008446:	6d11      	ldr	r1, [r2, #80]	; 0x50
 8008448:	687a      	ldr	r2, [r7, #4]
 800844a:	430a      	orrs	r2, r1
 800844c:	651a      	str	r2, [r3, #80]	; 0x50
 800844e:	e007      	b.n	8008460 <RCC_AHB1PeriphClockLPModeCmd+0x30>
  }
  else
  {
    RCC->AHB1LPENR &= ~RCC_AHB1Periph;
 8008450:	4b06      	ldr	r3, [pc, #24]	; (800846c <RCC_AHB1PeriphClockLPModeCmd+0x3c>)
 8008452:	4a06      	ldr	r2, [pc, #24]	; (800846c <RCC_AHB1PeriphClockLPModeCmd+0x3c>)
 8008454:	6d11      	ldr	r1, [r2, #80]	; 0x50
 8008456:	687a      	ldr	r2, [r7, #4]
 8008458:	ea6f 0202 	mvn.w	r2, r2
 800845c:	400a      	ands	r2, r1
 800845e:	651a      	str	r2, [r3, #80]	; 0x50
  }
}
 8008460:	f107 070c 	add.w	r7, r7, #12
 8008464:	46bd      	mov	sp, r7
 8008466:	bc80      	pop	{r7}
 8008468:	4770      	bx	lr
 800846a:	bf00      	nop
 800846c:	40023800 	.word	0x40023800

08008470 <RCC_AHB2PeriphClockLPModeCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
{
 8008470:	b480      	push	{r7}
 8008472:	b083      	sub	sp, #12
 8008474:	af00      	add	r7, sp, #0
 8008476:	6078      	str	r0, [r7, #4]
 8008478:	460b      	mov	r3, r1
 800847a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800847c:	78fb      	ldrb	r3, [r7, #3]
 800847e:	2b00      	cmp	r3, #0
 8008480:	d006      	beq.n	8008490 <RCC_AHB2PeriphClockLPModeCmd+0x20>
  {
    RCC->AHB2LPENR |= RCC_AHB2Periph;
 8008482:	4b0a      	ldr	r3, [pc, #40]	; (80084ac <RCC_AHB2PeriphClockLPModeCmd+0x3c>)
 8008484:	4a09      	ldr	r2, [pc, #36]	; (80084ac <RCC_AHB2PeriphClockLPModeCmd+0x3c>)
 8008486:	6d51      	ldr	r1, [r2, #84]	; 0x54
 8008488:	687a      	ldr	r2, [r7, #4]
 800848a:	430a      	orrs	r2, r1
 800848c:	655a      	str	r2, [r3, #84]	; 0x54
 800848e:	e007      	b.n	80084a0 <RCC_AHB2PeriphClockLPModeCmd+0x30>
  }
  else
  {
    RCC->AHB2LPENR &= ~RCC_AHB2Periph;
 8008490:	4b06      	ldr	r3, [pc, #24]	; (80084ac <RCC_AHB2PeriphClockLPModeCmd+0x3c>)
 8008492:	4a06      	ldr	r2, [pc, #24]	; (80084ac <RCC_AHB2PeriphClockLPModeCmd+0x3c>)
 8008494:	6d51      	ldr	r1, [r2, #84]	; 0x54
 8008496:	687a      	ldr	r2, [r7, #4]
 8008498:	ea6f 0202 	mvn.w	r2, r2
 800849c:	400a      	ands	r2, r1
 800849e:	655a      	str	r2, [r3, #84]	; 0x54
  }
}
 80084a0:	f107 070c 	add.w	r7, r7, #12
 80084a4:	46bd      	mov	sp, r7
 80084a6:	bc80      	pop	{r7}
 80084a8:	4770      	bx	lr
 80084aa:	bf00      	nop
 80084ac:	40023800 	.word	0x40023800

080084b0 <RCC_AHB3PeriphClockLPModeCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
{
 80084b0:	b480      	push	{r7}
 80084b2:	b083      	sub	sp, #12
 80084b4:	af00      	add	r7, sp, #0
 80084b6:	6078      	str	r0, [r7, #4]
 80084b8:	460b      	mov	r3, r1
 80084ba:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80084bc:	78fb      	ldrb	r3, [r7, #3]
 80084be:	2b00      	cmp	r3, #0
 80084c0:	d006      	beq.n	80084d0 <RCC_AHB3PeriphClockLPModeCmd+0x20>
  {
    RCC->AHB3LPENR |= RCC_AHB3Periph;
 80084c2:	4b0a      	ldr	r3, [pc, #40]	; (80084ec <RCC_AHB3PeriphClockLPModeCmd+0x3c>)
 80084c4:	4a09      	ldr	r2, [pc, #36]	; (80084ec <RCC_AHB3PeriphClockLPModeCmd+0x3c>)
 80084c6:	6d91      	ldr	r1, [r2, #88]	; 0x58
 80084c8:	687a      	ldr	r2, [r7, #4]
 80084ca:	430a      	orrs	r2, r1
 80084cc:	659a      	str	r2, [r3, #88]	; 0x58
 80084ce:	e007      	b.n	80084e0 <RCC_AHB3PeriphClockLPModeCmd+0x30>
  }
  else
  {
    RCC->AHB3LPENR &= ~RCC_AHB3Periph;
 80084d0:	4b06      	ldr	r3, [pc, #24]	; (80084ec <RCC_AHB3PeriphClockLPModeCmd+0x3c>)
 80084d2:	4a06      	ldr	r2, [pc, #24]	; (80084ec <RCC_AHB3PeriphClockLPModeCmd+0x3c>)
 80084d4:	6d91      	ldr	r1, [r2, #88]	; 0x58
 80084d6:	687a      	ldr	r2, [r7, #4]
 80084d8:	ea6f 0202 	mvn.w	r2, r2
 80084dc:	400a      	ands	r2, r1
 80084de:	659a      	str	r2, [r3, #88]	; 0x58
  }
}
 80084e0:	f107 070c 	add.w	r7, r7, #12
 80084e4:	46bd      	mov	sp, r7
 80084e6:	bc80      	pop	{r7}
 80084e8:	4770      	bx	lr
 80084ea:	bf00      	nop
 80084ec:	40023800 	.word	0x40023800

080084f0 <RCC_APB1PeriphClockLPModeCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 80084f0:	b480      	push	{r7}
 80084f2:	b083      	sub	sp, #12
 80084f4:	af00      	add	r7, sp, #0
 80084f6:	6078      	str	r0, [r7, #4]
 80084f8:	460b      	mov	r3, r1
 80084fa:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80084fc:	78fb      	ldrb	r3, [r7, #3]
 80084fe:	2b00      	cmp	r3, #0
 8008500:	d006      	beq.n	8008510 <RCC_APB1PeriphClockLPModeCmd+0x20>
  {
    RCC->APB1LPENR |= RCC_APB1Periph;
 8008502:	4b0a      	ldr	r3, [pc, #40]	; (800852c <RCC_APB1PeriphClockLPModeCmd+0x3c>)
 8008504:	4a09      	ldr	r2, [pc, #36]	; (800852c <RCC_APB1PeriphClockLPModeCmd+0x3c>)
 8008506:	6e11      	ldr	r1, [r2, #96]	; 0x60
 8008508:	687a      	ldr	r2, [r7, #4]
 800850a:	430a      	orrs	r2, r1
 800850c:	661a      	str	r2, [r3, #96]	; 0x60
 800850e:	e007      	b.n	8008520 <RCC_APB1PeriphClockLPModeCmd+0x30>
  }
  else
  {
    RCC->APB1LPENR &= ~RCC_APB1Periph;
 8008510:	4b06      	ldr	r3, [pc, #24]	; (800852c <RCC_APB1PeriphClockLPModeCmd+0x3c>)
 8008512:	4a06      	ldr	r2, [pc, #24]	; (800852c <RCC_APB1PeriphClockLPModeCmd+0x3c>)
 8008514:	6e11      	ldr	r1, [r2, #96]	; 0x60
 8008516:	687a      	ldr	r2, [r7, #4]
 8008518:	ea6f 0202 	mvn.w	r2, r2
 800851c:	400a      	ands	r2, r1
 800851e:	661a      	str	r2, [r3, #96]	; 0x60
  }
}
 8008520:	f107 070c 	add.w	r7, r7, #12
 8008524:	46bd      	mov	sp, r7
 8008526:	bc80      	pop	{r7}
 8008528:	4770      	bx	lr
 800852a:	bf00      	nop
 800852c:	40023800 	.word	0x40023800

08008530 <RCC_APB2PeriphClockLPModeCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 8008530:	b480      	push	{r7}
 8008532:	b083      	sub	sp, #12
 8008534:	af00      	add	r7, sp, #0
 8008536:	6078      	str	r0, [r7, #4]
 8008538:	460b      	mov	r3, r1
 800853a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800853c:	78fb      	ldrb	r3, [r7, #3]
 800853e:	2b00      	cmp	r3, #0
 8008540:	d006      	beq.n	8008550 <RCC_APB2PeriphClockLPModeCmd+0x20>
  {
    RCC->APB2LPENR |= RCC_APB2Periph;
 8008542:	4b0a      	ldr	r3, [pc, #40]	; (800856c <RCC_APB2PeriphClockLPModeCmd+0x3c>)
 8008544:	4a09      	ldr	r2, [pc, #36]	; (800856c <RCC_APB2PeriphClockLPModeCmd+0x3c>)
 8008546:	6e51      	ldr	r1, [r2, #100]	; 0x64
 8008548:	687a      	ldr	r2, [r7, #4]
 800854a:	430a      	orrs	r2, r1
 800854c:	665a      	str	r2, [r3, #100]	; 0x64
 800854e:	e007      	b.n	8008560 <RCC_APB2PeriphClockLPModeCmd+0x30>
  }
  else
  {
    RCC->APB2LPENR &= ~RCC_APB2Periph;
 8008550:	4b06      	ldr	r3, [pc, #24]	; (800856c <RCC_APB2PeriphClockLPModeCmd+0x3c>)
 8008552:	4a06      	ldr	r2, [pc, #24]	; (800856c <RCC_APB2PeriphClockLPModeCmd+0x3c>)
 8008554:	6e51      	ldr	r1, [r2, #100]	; 0x64
 8008556:	687a      	ldr	r2, [r7, #4]
 8008558:	ea6f 0202 	mvn.w	r2, r2
 800855c:	400a      	ands	r2, r1
 800855e:	665a      	str	r2, [r3, #100]	; 0x64
  }
}
 8008560:	f107 070c 	add.w	r7, r7, #12
 8008564:	46bd      	mov	sp, r7
 8008566:	bc80      	pop	{r7}
 8008568:	4770      	bx	lr
 800856a:	bf00      	nop
 800856c:	40023800 	.word	0x40023800

08008570 <RCC_ITConfig>:
  * @param  NewState: new state of the specified RCC interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
{
 8008570:	b480      	push	{r7}
 8008572:	b083      	sub	sp, #12
 8008574:	af00      	add	r7, sp, #0
 8008576:	4602      	mov	r2, r0
 8008578:	460b      	mov	r3, r1
 800857a:	71fa      	strb	r2, [r7, #7]
 800857c:	71bb      	strb	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800857e:	79bb      	ldrb	r3, [r7, #6]
 8008580:	2b00      	cmp	r3, #0
 8008582:	d008      	beq.n	8008596 <RCC_ITConfig+0x26>
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 8008584:	4b0c      	ldr	r3, [pc, #48]	; (80085b8 <RCC_ITConfig+0x48>)
 8008586:	4a0c      	ldr	r2, [pc, #48]	; (80085b8 <RCC_ITConfig+0x48>)
 8008588:	7812      	ldrb	r2, [r2, #0]
 800858a:	b2d1      	uxtb	r1, r2
 800858c:	79fa      	ldrb	r2, [r7, #7]
 800858e:	430a      	orrs	r2, r1
 8008590:	b2d2      	uxtb	r2, r2
 8008592:	701a      	strb	r2, [r3, #0]
 8008594:	e00a      	b.n	80085ac <RCC_ITConfig+0x3c>
  }
  else
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
 8008596:	4b08      	ldr	r3, [pc, #32]	; (80085b8 <RCC_ITConfig+0x48>)
 8008598:	4a07      	ldr	r2, [pc, #28]	; (80085b8 <RCC_ITConfig+0x48>)
 800859a:	7812      	ldrb	r2, [r2, #0]
 800859c:	b2d1      	uxtb	r1, r2
 800859e:	79fa      	ldrb	r2, [r7, #7]
 80085a0:	ea6f 0202 	mvn.w	r2, r2
 80085a4:	b2d2      	uxtb	r2, r2
 80085a6:	400a      	ands	r2, r1
 80085a8:	b2d2      	uxtb	r2, r2
 80085aa:	701a      	strb	r2, [r3, #0]
  }
}
 80085ac:	f107 070c 	add.w	r7, r7, #12
 80085b0:	46bd      	mov	sp, r7
 80085b2:	bc80      	pop	{r7}
 80085b4:	4770      	bx	lr
 80085b6:	bf00      	nop
 80085b8:	4002380d 	.word	0x4002380d

080085bc <RCC_GetFlagStatus>:
  *            @arg RCC_FLAG_WWDGRST: Window Watchdog reset
  *            @arg RCC_FLAG_LPWRRST: Low Power reset
  * @retval The new state of RCC_FLAG (SET or RESET).
  */
FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
{
 80085bc:	b480      	push	{r7}
 80085be:	b087      	sub	sp, #28
 80085c0:	af00      	add	r7, sp, #0
 80085c2:	4603      	mov	r3, r0
 80085c4:	71fb      	strb	r3, [r7, #7]
  uint32_t tmp = 0;
 80085c6:	f04f 0300 	mov.w	r3, #0
 80085ca:	60fb      	str	r3, [r7, #12]
  uint32_t statusreg = 0;
 80085cc:	f04f 0300 	mov.w	r3, #0
 80085d0:	617b      	str	r3, [r7, #20]
  FlagStatus bitstatus = RESET;
 80085d2:	f04f 0300 	mov.w	r3, #0
 80085d6:	74fb      	strb	r3, [r7, #19]

  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 80085d8:	79fb      	ldrb	r3, [r7, #7]
 80085da:	ea4f 1353 	mov.w	r3, r3, lsr #5
 80085de:	b2db      	uxtb	r3, r3
 80085e0:	60fb      	str	r3, [r7, #12]
  if (tmp == 1)               /* The flag to check is in CR register */
 80085e2:	68fb      	ldr	r3, [r7, #12]
 80085e4:	2b01      	cmp	r3, #1
 80085e6:	d103      	bne.n	80085f0 <RCC_GetFlagStatus+0x34>
  {
    statusreg = RCC->CR;
 80085e8:	4b13      	ldr	r3, [pc, #76]	; (8008638 <RCC_GetFlagStatus+0x7c>)
 80085ea:	681b      	ldr	r3, [r3, #0]
 80085ec:	617b      	str	r3, [r7, #20]
 80085ee:	e009      	b.n	8008604 <RCC_GetFlagStatus+0x48>
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 80085f0:	68fb      	ldr	r3, [r7, #12]
 80085f2:	2b02      	cmp	r3, #2
 80085f4:	d103      	bne.n	80085fe <RCC_GetFlagStatus+0x42>
  {
    statusreg = RCC->BDCR;
 80085f6:	4b10      	ldr	r3, [pc, #64]	; (8008638 <RCC_GetFlagStatus+0x7c>)
 80085f8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80085fa:	617b      	str	r3, [r7, #20]
 80085fc:	e002      	b.n	8008604 <RCC_GetFlagStatus+0x48>
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 80085fe:	4b0e      	ldr	r3, [pc, #56]	; (8008638 <RCC_GetFlagStatus+0x7c>)
 8008600:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8008602:	617b      	str	r3, [r7, #20]
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;
 8008604:	79fb      	ldrb	r3, [r7, #7]
 8008606:	f003 031f 	and.w	r3, r3, #31
 800860a:	60fb      	str	r3, [r7, #12]
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 800860c:	68fb      	ldr	r3, [r7, #12]
 800860e:	697a      	ldr	r2, [r7, #20]
 8008610:	fa22 f303 	lsr.w	r3, r2, r3
 8008614:	f003 0301 	and.w	r3, r3, #1
 8008618:	2b00      	cmp	r3, #0
 800861a:	d003      	beq.n	8008624 <RCC_GetFlagStatus+0x68>
  {
    bitstatus = SET;
 800861c:	f04f 0301 	mov.w	r3, #1
 8008620:	74fb      	strb	r3, [r7, #19]
 8008622:	e002      	b.n	800862a <RCC_GetFlagStatus+0x6e>
  }
  else
  {
    bitstatus = RESET;
 8008624:	f04f 0300 	mov.w	r3, #0
 8008628:	74fb      	strb	r3, [r7, #19]
  }
  /* Return the flag status */
  return bitstatus;
 800862a:	7cfb      	ldrb	r3, [r7, #19]
}
 800862c:	4618      	mov	r0, r3
 800862e:	f107 071c 	add.w	r7, r7, #28
 8008632:	46bd      	mov	sp, r7
 8008634:	bc80      	pop	{r7}
 8008636:	4770      	bx	lr
 8008638:	40023800 	.word	0x40023800

0800863c <RCC_ClearFlag>:
  *         RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST
  * @param  None
  * @retval None
  */
void RCC_ClearFlag(void)
{
 800863c:	b480      	push	{r7}
 800863e:	af00      	add	r7, sp, #0
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= RCC_CSR_RMVF;
 8008640:	4b04      	ldr	r3, [pc, #16]	; (8008654 <RCC_ClearFlag+0x18>)
 8008642:	4a04      	ldr	r2, [pc, #16]	; (8008654 <RCC_ClearFlag+0x18>)
 8008644:	6f52      	ldr	r2, [r2, #116]	; 0x74
 8008646:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800864a:	675a      	str	r2, [r3, #116]	; 0x74
}
 800864c:	46bd      	mov	sp, r7
 800864e:	bc80      	pop	{r7}
 8008650:	4770      	bx	lr
 8008652:	bf00      	nop
 8008654:	40023800 	.word	0x40023800

08008658 <RCC_GetITStatus>:
  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt  
  *            @arg RCC_IT_CSS: Clock Security System interrupt
  * @retval The new state of RCC_IT (SET or RESET).
  */
ITStatus RCC_GetITStatus(uint8_t RCC_IT)
{
 8008658:	b480      	push	{r7}
 800865a:	b085      	sub	sp, #20
 800865c:	af00      	add	r7, sp, #0
 800865e:	4603      	mov	r3, r0
 8008660:	71fb      	strb	r3, [r7, #7]
  ITStatus bitstatus = RESET;
 8008662:	f04f 0300 	mov.w	r3, #0
 8008666:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));

  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
 8008668:	4b09      	ldr	r3, [pc, #36]	; (8008690 <RCC_GetITStatus+0x38>)
 800866a:	68da      	ldr	r2, [r3, #12]
 800866c:	79fb      	ldrb	r3, [r7, #7]
 800866e:	4013      	ands	r3, r2
 8008670:	2b00      	cmp	r3, #0
 8008672:	d003      	beq.n	800867c <RCC_GetITStatus+0x24>
  {
    bitstatus = SET;
 8008674:	f04f 0301 	mov.w	r3, #1
 8008678:	73fb      	strb	r3, [r7, #15]
 800867a:	e002      	b.n	8008682 <RCC_GetITStatus+0x2a>
  }
  else
  {
    bitstatus = RESET;
 800867c:	f04f 0300 	mov.w	r3, #0
 8008680:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the RCC_IT status */
  return  bitstatus;
 8008682:	7bfb      	ldrb	r3, [r7, #15]
}
 8008684:	4618      	mov	r0, r3
 8008686:	f107 0714 	add.w	r7, r7, #20
 800868a:	46bd      	mov	sp, r7
 800868c:	bc80      	pop	{r7}
 800868e:	4770      	bx	lr
 8008690:	40023800 	.word	0x40023800

08008694 <RCC_ClearITPendingBit>:
  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt  
  *            @arg RCC_IT_CSS: Clock Security System interrupt
  * @retval None
  */
void RCC_ClearITPendingBit(uint8_t RCC_IT)
{
 8008694:	b480      	push	{r7}
 8008696:	b083      	sub	sp, #12
 8008698:	af00      	add	r7, sp, #0
 800869a:	4603      	mov	r3, r0
 800869c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));

  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
 800869e:	4b04      	ldr	r3, [pc, #16]	; (80086b0 <RCC_ClearITPendingBit+0x1c>)
 80086a0:	79fa      	ldrb	r2, [r7, #7]
 80086a2:	701a      	strb	r2, [r3, #0]
}
 80086a4:	f107 070c 	add.w	r7, r7, #12
 80086a8:	46bd      	mov	sp, r7
 80086aa:	bc80      	pop	{r7}
 80086ac:	4770      	bx	lr
 80086ae:	bf00      	nop
 80086b0:	4002380e 	.word	0x4002380e

080086b4 <RTC_DeInit>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are deinitialized
  *          - ERROR: RTC registers are not deinitialized
  */
ErrorStatus RTC_DeInit(void)
{
 80086b4:	b580      	push	{r7, lr}
 80086b6:	b084      	sub	sp, #16
 80086b8:	af00      	add	r7, sp, #0
  __IO uint32_t wutcounter = 0x00;
 80086ba:	f04f 0300 	mov.w	r3, #0
 80086be:	607b      	str	r3, [r7, #4]
  uint32_t wutwfstatus = 0x00;
 80086c0:	f04f 0300 	mov.w	r3, #0
 80086c4:	60bb      	str	r3, [r7, #8]
  ErrorStatus status = ERROR;
 80086c6:	f04f 0300 	mov.w	r3, #0
 80086ca:	73fb      	strb	r3, [r7, #15]
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80086cc:	4b37      	ldr	r3, [pc, #220]	; (80087ac <RTC_DeInit+0xf8>)
 80086ce:	f04f 02ca 	mov.w	r2, #202	; 0xca
 80086d2:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80086d4:	4b35      	ldr	r3, [pc, #212]	; (80087ac <RTC_DeInit+0xf8>)
 80086d6:	f04f 0253 	mov.w	r2, #83	; 0x53
 80086da:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 80086dc:	f000 f8e0 	bl	80088a0 <RTC_EnterInitMode>
 80086e0:	4603      	mov	r3, r0
 80086e2:	2b00      	cmp	r3, #0
 80086e4:	d103      	bne.n	80086ee <RTC_DeInit+0x3a>
  {
    status = ERROR;
 80086e6:	f04f 0300 	mov.w	r3, #0
 80086ea:	73fb      	strb	r3, [r7, #15]
 80086ec:	e054      	b.n	8008798 <RTC_DeInit+0xe4>
  }  
  else
  {
    /* Reset TR, DR and CR registers */
    RTC->TR = (uint32_t)0x00000000;
 80086ee:	4b2f      	ldr	r3, [pc, #188]	; (80087ac <RTC_DeInit+0xf8>)
 80086f0:	f04f 0200 	mov.w	r2, #0
 80086f4:	601a      	str	r2, [r3, #0]
    RTC->DR = (uint32_t)0x00002101;
 80086f6:	4b2d      	ldr	r3, [pc, #180]	; (80087ac <RTC_DeInit+0xf8>)
 80086f8:	f242 1201 	movw	r2, #8449	; 0x2101
 80086fc:	605a      	str	r2, [r3, #4]
    /* Reset All CR bits except CR[2:0] */
    RTC->CR &= (uint32_t)0x00000007;
 80086fe:	4b2b      	ldr	r3, [pc, #172]	; (80087ac <RTC_DeInit+0xf8>)
 8008700:	4a2a      	ldr	r2, [pc, #168]	; (80087ac <RTC_DeInit+0xf8>)
 8008702:	6892      	ldr	r2, [r2, #8]
 8008704:	f002 0207 	and.w	r2, r2, #7
 8008708:	609a      	str	r2, [r3, #8]
  
    /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
    do
    {
      wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
 800870a:	4b28      	ldr	r3, [pc, #160]	; (80087ac <RTC_DeInit+0xf8>)
 800870c:	68db      	ldr	r3, [r3, #12]
 800870e:	f003 0304 	and.w	r3, r3, #4
 8008712:	60bb      	str	r3, [r7, #8]
      wutcounter++;  
 8008714:	687b      	ldr	r3, [r7, #4]
 8008716:	f103 0301 	add.w	r3, r3, #1
 800871a:	607b      	str	r3, [r7, #4]
    } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
 800871c:	687b      	ldr	r3, [r7, #4]
 800871e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8008722:	d002      	beq.n	800872a <RTC_DeInit+0x76>
 8008724:	68bb      	ldr	r3, [r7, #8]
 8008726:	2b00      	cmp	r3, #0
 8008728:	d0ef      	beq.n	800870a <RTC_DeInit+0x56>
    
    if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
 800872a:	4b20      	ldr	r3, [pc, #128]	; (80087ac <RTC_DeInit+0xf8>)
 800872c:	68db      	ldr	r3, [r3, #12]
 800872e:	f003 0304 	and.w	r3, r3, #4
 8008732:	2b00      	cmp	r3, #0
 8008734:	d103      	bne.n	800873e <RTC_DeInit+0x8a>
    {
      status = ERROR;
 8008736:	f04f 0300 	mov.w	r3, #0
 800873a:	73fb      	strb	r3, [r7, #15]
 800873c:	e02c      	b.n	8008798 <RTC_DeInit+0xe4>
    }
    else
    {
      /* Reset all RTC CR register bits */
      RTC->CR &= (uint32_t)0x00000000;
 800873e:	4b1b      	ldr	r3, [pc, #108]	; (80087ac <RTC_DeInit+0xf8>)
 8008740:	689b      	ldr	r3, [r3, #8]
 8008742:	4b1a      	ldr	r3, [pc, #104]	; (80087ac <RTC_DeInit+0xf8>)
 8008744:	f04f 0200 	mov.w	r2, #0
 8008748:	609a      	str	r2, [r3, #8]
      RTC->WUTR = (uint32_t)0x0000FFFF;
 800874a:	4b18      	ldr	r3, [pc, #96]	; (80087ac <RTC_DeInit+0xf8>)
 800874c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8008750:	615a      	str	r2, [r3, #20]
      RTC->PRER = (uint32_t)0x007F00FF;
 8008752:	4b16      	ldr	r3, [pc, #88]	; (80087ac <RTC_DeInit+0xf8>)
 8008754:	4a16      	ldr	r2, [pc, #88]	; (80087b0 <RTC_DeInit+0xfc>)
 8008756:	611a      	str	r2, [r3, #16]
      RTC->CALIBR = (uint32_t)0x00000000;
 8008758:	4b14      	ldr	r3, [pc, #80]	; (80087ac <RTC_DeInit+0xf8>)
 800875a:	f04f 0200 	mov.w	r2, #0
 800875e:	619a      	str	r2, [r3, #24]
      RTC->ALRMAR = (uint32_t)0x00000000;        
 8008760:	4b12      	ldr	r3, [pc, #72]	; (80087ac <RTC_DeInit+0xf8>)
 8008762:	f04f 0200 	mov.w	r2, #0
 8008766:	61da      	str	r2, [r3, #28]
      RTC->ALRMBR = (uint32_t)0x00000000;
 8008768:	4b10      	ldr	r3, [pc, #64]	; (80087ac <RTC_DeInit+0xf8>)
 800876a:	f04f 0200 	mov.w	r2, #0
 800876e:	621a      	str	r2, [r3, #32]
      
      /* Reset ISR register and exit initialization mode */
      RTC->ISR = (uint32_t)0x00000000;
 8008770:	4b0e      	ldr	r3, [pc, #56]	; (80087ac <RTC_DeInit+0xf8>)
 8008772:	f04f 0200 	mov.w	r2, #0
 8008776:	60da      	str	r2, [r3, #12]
      
      /* Reset Tamper and alternate functions configuration register */
      RTC->TAFCR = 0x00000000;
 8008778:	4b0c      	ldr	r3, [pc, #48]	; (80087ac <RTC_DeInit+0xf8>)
 800877a:	f04f 0200 	mov.w	r2, #0
 800877e:	641a      	str	r2, [r3, #64]	; 0x40
  
      if(RTC_WaitForSynchro() == ERROR)
 8008780:	f000 f8dc 	bl	800893c <RTC_WaitForSynchro>
 8008784:	4603      	mov	r3, r0
 8008786:	2b00      	cmp	r3, #0
 8008788:	d103      	bne.n	8008792 <RTC_DeInit+0xde>
      {
        status = ERROR;
 800878a:	f04f 0300 	mov.w	r3, #0
 800878e:	73fb      	strb	r3, [r7, #15]
 8008790:	e002      	b.n	8008798 <RTC_DeInit+0xe4>
      }
      else
      {
        status = SUCCESS;      
 8008792:	f04f 0301 	mov.w	r3, #1
 8008796:	73fb      	strb	r3, [r7, #15]
      }
    }
  }
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;  
 8008798:	4b04      	ldr	r3, [pc, #16]	; (80087ac <RTC_DeInit+0xf8>)
 800879a:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800879e:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
 80087a0:	7bfb      	ldrb	r3, [r7, #15]
}
 80087a2:	4618      	mov	r0, r3
 80087a4:	f107 0710 	add.w	r7, r7, #16
 80087a8:	46bd      	mov	sp, r7
 80087aa:	bd80      	pop	{r7, pc}
 80087ac:	40002800 	.word	0x40002800
 80087b0:	007f00ff 	.word	0x007f00ff

080087b4 <RTC_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are initialized
  *          - ERROR: RTC registers are not initialized  
  */
ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
{
 80087b4:	b580      	push	{r7, lr}
 80087b6:	b084      	sub	sp, #16
 80087b8:	af00      	add	r7, sp, #0
 80087ba:	6078      	str	r0, [r7, #4]
  ErrorStatus status = ERROR;
 80087bc:	f04f 0300 	mov.w	r3, #0
 80087c0:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
  assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
  assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80087c2:	4b1d      	ldr	r3, [pc, #116]	; (8008838 <RTC_Init+0x84>)
 80087c4:	f04f 02ca 	mov.w	r2, #202	; 0xca
 80087c8:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80087ca:	4b1b      	ldr	r3, [pc, #108]	; (8008838 <RTC_Init+0x84>)
 80087cc:	f04f 0253 	mov.w	r2, #83	; 0x53
 80087d0:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 80087d2:	f000 f865 	bl	80088a0 <RTC_EnterInitMode>
 80087d6:	4603      	mov	r3, r0
 80087d8:	2b00      	cmp	r3, #0
 80087da:	d103      	bne.n	80087e4 <RTC_Init+0x30>
  {
    status = ERROR;
 80087dc:	f04f 0300 	mov.w	r3, #0
 80087e0:	73fb      	strb	r3, [r7, #15]
 80087e2:	e01e      	b.n	8008822 <RTC_Init+0x6e>
  } 
  else
  {
    /* Clear RTC CR FMT Bit */
    RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
 80087e4:	4b14      	ldr	r3, [pc, #80]	; (8008838 <RTC_Init+0x84>)
 80087e6:	4a14      	ldr	r2, [pc, #80]	; (8008838 <RTC_Init+0x84>)
 80087e8:	6892      	ldr	r2, [r2, #8]
 80087ea:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80087ee:	609a      	str	r2, [r3, #8]
    /* Set RTC_CR register */
    RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
 80087f0:	4b11      	ldr	r3, [pc, #68]	; (8008838 <RTC_Init+0x84>)
 80087f2:	4a11      	ldr	r2, [pc, #68]	; (8008838 <RTC_Init+0x84>)
 80087f4:	6891      	ldr	r1, [r2, #8]
 80087f6:	687a      	ldr	r2, [r7, #4]
 80087f8:	6812      	ldr	r2, [r2, #0]
 80087fa:	430a      	orrs	r2, r1
 80087fc:	609a      	str	r2, [r3, #8]
  
    /* Configure the RTC PRER */
    RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
 80087fe:	4b0e      	ldr	r3, [pc, #56]	; (8008838 <RTC_Init+0x84>)
 8008800:	687a      	ldr	r2, [r7, #4]
 8008802:	6892      	ldr	r2, [r2, #8]
 8008804:	611a      	str	r2, [r3, #16]
    RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
 8008806:	4b0c      	ldr	r3, [pc, #48]	; (8008838 <RTC_Init+0x84>)
 8008808:	4a0b      	ldr	r2, [pc, #44]	; (8008838 <RTC_Init+0x84>)
 800880a:	6911      	ldr	r1, [r2, #16]
 800880c:	687a      	ldr	r2, [r7, #4]
 800880e:	6852      	ldr	r2, [r2, #4]
 8008810:	ea4f 4202 	mov.w	r2, r2, lsl #16
 8008814:	430a      	orrs	r2, r1
 8008816:	611a      	str	r2, [r3, #16]

    /* Exit Initialization mode */
    RTC_ExitInitMode();
 8008818:	f000 f882 	bl	8008920 <RTC_ExitInitMode>

    status = SUCCESS;    
 800881c:	f04f 0301 	mov.w	r3, #1
 8008820:	73fb      	strb	r3, [r7, #15]
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8008822:	4b05      	ldr	r3, [pc, #20]	; (8008838 <RTC_Init+0x84>)
 8008824:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8008828:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
 800882a:	7bfb      	ldrb	r3, [r7, #15]
}
 800882c:	4618      	mov	r0, r3
 800882e:	f107 0710 	add.w	r7, r7, #16
 8008832:	46bd      	mov	sp, r7
 8008834:	bd80      	pop	{r7, pc}
 8008836:	bf00      	nop
 8008838:	40002800 	.word	0x40002800

0800883c <RTC_StructInit>:
  * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure which will be 
  *         initialized.
  * @retval None
  */
void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
{
 800883c:	b480      	push	{r7}
 800883e:	b083      	sub	sp, #12
 8008840:	af00      	add	r7, sp, #0
 8008842:	6078      	str	r0, [r7, #4]
  /* Initialize the RTC_HourFormat member */
  RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
 8008844:	687b      	ldr	r3, [r7, #4]
 8008846:	f04f 0200 	mov.w	r2, #0
 800884a:	601a      	str	r2, [r3, #0]
    
  /* Initialize the RTC_AsynchPrediv member */
  RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
 800884c:	687b      	ldr	r3, [r7, #4]
 800884e:	f04f 027f 	mov.w	r2, #127	; 0x7f
 8008852:	605a      	str	r2, [r3, #4]

  /* Initialize the RTC_SynchPrediv member */
  RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
 8008854:	687b      	ldr	r3, [r7, #4]
 8008856:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800885a:	609a      	str	r2, [r3, #8]
}
 800885c:	f107 070c 	add.w	r7, r7, #12
 8008860:	46bd      	mov	sp, r7
 8008862:	bc80      	pop	{r7}
 8008864:	4770      	bx	lr
 8008866:	bf00      	nop

08008868 <RTC_WriteProtectionCmd>:
  * @param  NewState: new state of the write protection.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_WriteProtectionCmd(FunctionalState NewState)
{
 8008868:	b480      	push	{r7}
 800886a:	b083      	sub	sp, #12
 800886c:	af00      	add	r7, sp, #0
 800886e:	4603      	mov	r3, r0
 8008870:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
 8008872:	79fb      	ldrb	r3, [r7, #7]
 8008874:	2b00      	cmp	r3, #0
 8008876:	d004      	beq.n	8008882 <RTC_WriteProtectionCmd+0x1a>
  {
    /* Enable the write protection for RTC registers */
    RTC->WPR = 0xFF;   
 8008878:	4b08      	ldr	r3, [pc, #32]	; (800889c <RTC_WriteProtectionCmd+0x34>)
 800887a:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800887e:	625a      	str	r2, [r3, #36]	; 0x24
 8008880:	e007      	b.n	8008892 <RTC_WriteProtectionCmd+0x2a>
  }
  else
  {
    /* Disable the write protection for RTC registers */
    RTC->WPR = 0xCA;
 8008882:	4b06      	ldr	r3, [pc, #24]	; (800889c <RTC_WriteProtectionCmd+0x34>)
 8008884:	f04f 02ca 	mov.w	r2, #202	; 0xca
 8008888:	625a      	str	r2, [r3, #36]	; 0x24
    RTC->WPR = 0x53;    
 800888a:	4b04      	ldr	r3, [pc, #16]	; (800889c <RTC_WriteProtectionCmd+0x34>)
 800888c:	f04f 0253 	mov.w	r2, #83	; 0x53
 8008890:	625a      	str	r2, [r3, #36]	; 0x24
  }
}
 8008892:	f107 070c 	add.w	r7, r7, #12
 8008896:	46bd      	mov	sp, r7
 8008898:	bc80      	pop	{r7}
 800889a:	4770      	bx	lr
 800889c:	40002800 	.word	0x40002800

080088a0 <RTC_EnterInitMode>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC is in Init mode
  *          - ERROR: RTC is not in Init mode  
  */
ErrorStatus RTC_EnterInitMode(void)
{
 80088a0:	b480      	push	{r7}
 80088a2:	b085      	sub	sp, #20
 80088a4:	af00      	add	r7, sp, #0
  __IO uint32_t initcounter = 0x00;
 80088a6:	f04f 0300 	mov.w	r3, #0
 80088aa:	607b      	str	r3, [r7, #4]
  ErrorStatus status = ERROR;
 80088ac:	f04f 0300 	mov.w	r3, #0
 80088b0:	73fb      	strb	r3, [r7, #15]
  uint32_t initstatus = 0x00;
 80088b2:	f04f 0300 	mov.w	r3, #0
 80088b6:	60bb      	str	r3, [r7, #8]
     
  /* Check if the Initialization mode is set */
  if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 80088b8:	4b18      	ldr	r3, [pc, #96]	; (800891c <RTC_EnterInitMode+0x7c>)
 80088ba:	68db      	ldr	r3, [r3, #12]
 80088bc:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80088c0:	2b00      	cmp	r3, #0
 80088c2:	d121      	bne.n	8008908 <RTC_EnterInitMode+0x68>
  {
    /* Set the Initialization mode */
    RTC->ISR = (uint32_t)RTC_INIT_MASK;
 80088c4:	4b15      	ldr	r3, [pc, #84]	; (800891c <RTC_EnterInitMode+0x7c>)
 80088c6:	f04f 32ff 	mov.w	r2, #4294967295
 80088ca:	60da      	str	r2, [r3, #12]
    
    /* Wait till RTC is in INIT state and if Time out is reached exit */
    do
    {
      initstatus = RTC->ISR & RTC_ISR_INITF;
 80088cc:	4b13      	ldr	r3, [pc, #76]	; (800891c <RTC_EnterInitMode+0x7c>)
 80088ce:	68db      	ldr	r3, [r3, #12]
 80088d0:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80088d4:	60bb      	str	r3, [r7, #8]
      initcounter++;  
 80088d6:	687b      	ldr	r3, [r7, #4]
 80088d8:	f103 0301 	add.w	r3, r3, #1
 80088dc:	607b      	str	r3, [r7, #4]
    } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
 80088de:	687b      	ldr	r3, [r7, #4]
 80088e0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80088e4:	d002      	beq.n	80088ec <RTC_EnterInitMode+0x4c>
 80088e6:	68bb      	ldr	r3, [r7, #8]
 80088e8:	2b00      	cmp	r3, #0
 80088ea:	d0ef      	beq.n	80088cc <RTC_EnterInitMode+0x2c>
    
    if ((RTC->ISR & RTC_ISR_INITF) != RESET)
 80088ec:	4b0b      	ldr	r3, [pc, #44]	; (800891c <RTC_EnterInitMode+0x7c>)
 80088ee:	68db      	ldr	r3, [r3, #12]
 80088f0:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80088f4:	2b00      	cmp	r3, #0
 80088f6:	d003      	beq.n	8008900 <RTC_EnterInitMode+0x60>
    {
      status = SUCCESS;
 80088f8:	f04f 0301 	mov.w	r3, #1
 80088fc:	73fb      	strb	r3, [r7, #15]
 80088fe:	e006      	b.n	800890e <RTC_EnterInitMode+0x6e>
    }
    else
    {
      status = ERROR;
 8008900:	f04f 0300 	mov.w	r3, #0
 8008904:	73fb      	strb	r3, [r7, #15]
 8008906:	e002      	b.n	800890e <RTC_EnterInitMode+0x6e>
    }        
  }
  else
  {
    status = SUCCESS;  
 8008908:	f04f 0301 	mov.w	r3, #1
 800890c:	73fb      	strb	r3, [r7, #15]
  } 
    
  return (status);  
 800890e:	7bfb      	ldrb	r3, [r7, #15]
}
 8008910:	4618      	mov	r0, r3
 8008912:	f107 0714 	add.w	r7, r7, #20
 8008916:	46bd      	mov	sp, r7
 8008918:	bc80      	pop	{r7}
 800891a:	4770      	bx	lr
 800891c:	40002800 	.word	0x40002800

08008920 <RTC_ExitInitMode>:
  *         RTC_WriteProtectionCmd(DISABLE) before calling this function.      
  * @param  None
  * @retval None
  */
void RTC_ExitInitMode(void)
{ 
 8008920:	b480      	push	{r7}
 8008922:	af00      	add	r7, sp, #0
  /* Exit Initialization mode */
  RTC->ISR &= (uint32_t)~RTC_ISR_INIT;  
 8008924:	4b04      	ldr	r3, [pc, #16]	; (8008938 <RTC_ExitInitMode+0x18>)
 8008926:	4a04      	ldr	r2, [pc, #16]	; (8008938 <RTC_ExitInitMode+0x18>)
 8008928:	68d2      	ldr	r2, [r2, #12]
 800892a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800892e:	60da      	str	r2, [r3, #12]
}
 8008930:	46bd      	mov	sp, r7
 8008932:	bc80      	pop	{r7}
 8008934:	4770      	bx	lr
 8008936:	bf00      	nop
 8008938:	40002800 	.word	0x40002800

0800893c <RTC_WaitForSynchro>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are synchronised
  *          - ERROR: RTC registers are not synchronised
  */
ErrorStatus RTC_WaitForSynchro(void)
{
 800893c:	b480      	push	{r7}
 800893e:	b085      	sub	sp, #20
 8008940:	af00      	add	r7, sp, #0
  __IO uint32_t synchrocounter = 0;
 8008942:	f04f 0300 	mov.w	r3, #0
 8008946:	607b      	str	r3, [r7, #4]
  ErrorStatus status = ERROR;
 8008948:	f04f 0300 	mov.w	r3, #0
 800894c:	73fb      	strb	r3, [r7, #15]
  uint32_t synchrostatus = 0x00;
 800894e:	f04f 0300 	mov.w	r3, #0
 8008952:	60bb      	str	r3, [r7, #8]

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8008954:	4b1a      	ldr	r3, [pc, #104]	; (80089c0 <RTC_WaitForSynchro+0x84>)
 8008956:	f04f 02ca 	mov.w	r2, #202	; 0xca
 800895a:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800895c:	4b18      	ldr	r3, [pc, #96]	; (80089c0 <RTC_WaitForSynchro+0x84>)
 800895e:	f04f 0253 	mov.w	r2, #83	; 0x53
 8008962:	625a      	str	r2, [r3, #36]	; 0x24
    
  /* Clear RSF flag */
  RTC->ISR &= (uint32_t)RTC_RSF_MASK;
 8008964:	4b16      	ldr	r3, [pc, #88]	; (80089c0 <RTC_WaitForSynchro+0x84>)
 8008966:	4a16      	ldr	r2, [pc, #88]	; (80089c0 <RTC_WaitForSynchro+0x84>)
 8008968:	68d2      	ldr	r2, [r2, #12]
 800896a:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 800896e:	60da      	str	r2, [r3, #12]
    
  /* Wait the registers to be synchronised */
  do
  {
    synchrostatus = RTC->ISR & RTC_ISR_RSF;
 8008970:	4b13      	ldr	r3, [pc, #76]	; (80089c0 <RTC_WaitForSynchro+0x84>)
 8008972:	68db      	ldr	r3, [r3, #12]
 8008974:	f003 0320 	and.w	r3, r3, #32
 8008978:	60bb      	str	r3, [r7, #8]
    synchrocounter++;  
 800897a:	687b      	ldr	r3, [r7, #4]
 800897c:	f103 0301 	add.w	r3, r3, #1
 8008980:	607b      	str	r3, [r7, #4]
  } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
 8008982:	687b      	ldr	r3, [r7, #4]
 8008984:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8008988:	d002      	beq.n	8008990 <RTC_WaitForSynchro+0x54>
 800898a:	68bb      	ldr	r3, [r7, #8]
 800898c:	2b00      	cmp	r3, #0
 800898e:	d0ef      	beq.n	8008970 <RTC_WaitForSynchro+0x34>
    
  if ((RTC->ISR & RTC_ISR_RSF) != RESET)
 8008990:	4b0b      	ldr	r3, [pc, #44]	; (80089c0 <RTC_WaitForSynchro+0x84>)
 8008992:	68db      	ldr	r3, [r3, #12]
 8008994:	f003 0320 	and.w	r3, r3, #32
 8008998:	2b00      	cmp	r3, #0
 800899a:	d003      	beq.n	80089a4 <RTC_WaitForSynchro+0x68>
  {
    status = SUCCESS;
 800899c:	f04f 0301 	mov.w	r3, #1
 80089a0:	73fb      	strb	r3, [r7, #15]
 80089a2:	e002      	b.n	80089aa <RTC_WaitForSynchro+0x6e>
  }
  else
  {
    status = ERROR;
 80089a4:	f04f 0300 	mov.w	r3, #0
 80089a8:	73fb      	strb	r3, [r7, #15]
  }        

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 80089aa:	4b05      	ldr	r3, [pc, #20]	; (80089c0 <RTC_WaitForSynchro+0x84>)
 80089ac:	f04f 02ff 	mov.w	r2, #255	; 0xff
 80089b0:	625a      	str	r2, [r3, #36]	; 0x24
    
  return (status); 
 80089b2:	7bfb      	ldrb	r3, [r7, #15]
}
 80089b4:	4618      	mov	r0, r3
 80089b6:	f107 0714 	add.w	r7, r7, #20
 80089ba:	46bd      	mov	sp, r7
 80089bc:	bc80      	pop	{r7}
 80089be:	4770      	bx	lr
 80089c0:	40002800 	.word	0x40002800

080089c4 <RTC_RefClockCmd>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC reference clock detection is enabled
  *          - ERROR: RTC reference clock detection is disabled  
  */
ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
{ 
 80089c4:	b580      	push	{r7, lr}
 80089c6:	b084      	sub	sp, #16
 80089c8:	af00      	add	r7, sp, #0
 80089ca:	4603      	mov	r3, r0
 80089cc:	71fb      	strb	r3, [r7, #7]
  ErrorStatus status = ERROR;
 80089ce:	f04f 0300 	mov.w	r3, #0
 80089d2:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80089d4:	4b17      	ldr	r3, [pc, #92]	; (8008a34 <RTC_RefClockCmd+0x70>)
 80089d6:	f04f 02ca 	mov.w	r2, #202	; 0xca
 80089da:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80089dc:	4b15      	ldr	r3, [pc, #84]	; (8008a34 <RTC_RefClockCmd+0x70>)
 80089de:	f04f 0253 	mov.w	r2, #83	; 0x53
 80089e2:	625a      	str	r2, [r3, #36]	; 0x24
    
  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 80089e4:	f7ff ff5c 	bl	80088a0 <RTC_EnterInitMode>
 80089e8:	4603      	mov	r3, r0
 80089ea:	2b00      	cmp	r3, #0
 80089ec:	d103      	bne.n	80089f6 <RTC_RefClockCmd+0x32>
  {
    status = ERROR;
 80089ee:	f04f 0300 	mov.w	r3, #0
 80089f2:	73fb      	strb	r3, [r7, #15]
 80089f4:	e014      	b.n	8008a20 <RTC_RefClockCmd+0x5c>
  } 
  else
  {  
    if (NewState != DISABLE)
 80089f6:	79fb      	ldrb	r3, [r7, #7]
 80089f8:	2b00      	cmp	r3, #0
 80089fa:	d006      	beq.n	8008a0a <RTC_RefClockCmd+0x46>
    {
      /* Enable the RTC reference clock detection */
      RTC->CR |= RTC_CR_REFCKON;   
 80089fc:	4b0d      	ldr	r3, [pc, #52]	; (8008a34 <RTC_RefClockCmd+0x70>)
 80089fe:	4a0d      	ldr	r2, [pc, #52]	; (8008a34 <RTC_RefClockCmd+0x70>)
 8008a00:	6892      	ldr	r2, [r2, #8]
 8008a02:	f042 0210 	orr.w	r2, r2, #16
 8008a06:	609a      	str	r2, [r3, #8]
 8008a08:	e005      	b.n	8008a16 <RTC_RefClockCmd+0x52>
    }
    else
    {
      /* Disable the RTC reference clock detection */
      RTC->CR &= ~RTC_CR_REFCKON;    
 8008a0a:	4b0a      	ldr	r3, [pc, #40]	; (8008a34 <RTC_RefClockCmd+0x70>)
 8008a0c:	4a09      	ldr	r2, [pc, #36]	; (8008a34 <RTC_RefClockCmd+0x70>)
 8008a0e:	6892      	ldr	r2, [r2, #8]
 8008a10:	f022 0210 	bic.w	r2, r2, #16
 8008a14:	609a      	str	r2, [r3, #8]
    }
    /* Exit Initialization mode */
    RTC_ExitInitMode();
 8008a16:	f7ff ff83 	bl	8008920 <RTC_ExitInitMode>
    
    status = SUCCESS;
 8008a1a:	f04f 0301 	mov.w	r3, #1
 8008a1e:	73fb      	strb	r3, [r7, #15]
  }
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;  
 8008a20:	4b04      	ldr	r3, [pc, #16]	; (8008a34 <RTC_RefClockCmd+0x70>)
 8008a22:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8008a26:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status; 
 8008a28:	7bfb      	ldrb	r3, [r7, #15]
}
 8008a2a:	4618      	mov	r0, r3
 8008a2c:	f107 0710 	add.w	r7, r7, #16
 8008a30:	46bd      	mov	sp, r7
 8008a32:	bd80      	pop	{r7, pc}
 8008a34:	40002800 	.word	0x40002800

08008a38 <RTC_BypassShadowCmd>:
  * @param  NewState: new state of the Bypass Shadow feature.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
*/
void RTC_BypassShadowCmd(FunctionalState NewState)
{
 8008a38:	b480      	push	{r7}
 8008a3a:	b083      	sub	sp, #12
 8008a3c:	af00      	add	r7, sp, #0
 8008a3e:	4603      	mov	r3, r0
 8008a40:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8008a42:	4b10      	ldr	r3, [pc, #64]	; (8008a84 <RTC_BypassShadowCmd+0x4c>)
 8008a44:	f04f 02ca 	mov.w	r2, #202	; 0xca
 8008a48:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8008a4a:	4b0e      	ldr	r3, [pc, #56]	; (8008a84 <RTC_BypassShadowCmd+0x4c>)
 8008a4c:	f04f 0253 	mov.w	r2, #83	; 0x53
 8008a50:	625a      	str	r2, [r3, #36]	; 0x24
  
  if (NewState != DISABLE)
 8008a52:	79fb      	ldrb	r3, [r7, #7]
 8008a54:	2b00      	cmp	r3, #0
 8008a56:	d006      	beq.n	8008a66 <RTC_BypassShadowCmd+0x2e>
  {
    /* Set the BYPSHAD bit */
    RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
 8008a58:	4b0a      	ldr	r3, [pc, #40]	; (8008a84 <RTC_BypassShadowCmd+0x4c>)
 8008a5a:	4a0a      	ldr	r2, [pc, #40]	; (8008a84 <RTC_BypassShadowCmd+0x4c>)
 8008a5c:	6892      	ldr	r2, [r2, #8]
 8008a5e:	f042 0220 	orr.w	r2, r2, #32
 8008a62:	609a      	str	r2, [r3, #8]
 8008a64:	e005      	b.n	8008a72 <RTC_BypassShadowCmd+0x3a>
  }
  else
  {
    /* Reset the BYPSHAD bit */
    RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
 8008a66:	4b07      	ldr	r3, [pc, #28]	; (8008a84 <RTC_BypassShadowCmd+0x4c>)
 8008a68:	4a06      	ldr	r2, [pc, #24]	; (8008a84 <RTC_BypassShadowCmd+0x4c>)
 8008a6a:	6892      	ldr	r2, [r2, #8]
 8008a6c:	f002 02df 	and.w	r2, r2, #223	; 0xdf
 8008a70:	609a      	str	r2, [r3, #8]
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8008a72:	4b04      	ldr	r3, [pc, #16]	; (8008a84 <RTC_BypassShadowCmd+0x4c>)
 8008a74:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8008a78:	625a      	str	r2, [r3, #36]	; 0x24
}
 8008a7a:	f107 070c 	add.w	r7, r7, #12
 8008a7e:	46bd      	mov	sp, r7
 8008a80:	bc80      	pop	{r7}
 8008a82:	4770      	bx	lr
 8008a84:	40002800 	.word	0x40002800

08008a88 <RTC_SetTime>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Time register is configured
  *          - ERROR: RTC Time register is not configured
  */
ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
{
 8008a88:	b590      	push	{r4, r7, lr}
 8008a8a:	b085      	sub	sp, #20
 8008a8c:	af00      	add	r7, sp, #0
 8008a8e:	6078      	str	r0, [r7, #4]
 8008a90:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8008a92:	f04f 0300 	mov.w	r3, #0
 8008a96:	60fb      	str	r3, [r7, #12]
  ErrorStatus status = ERROR;
 8008a98:	f04f 0300 	mov.w	r3, #0
 8008a9c:	72fb      	strb	r3, [r7, #11]
    
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  
  if (RTC_Format == RTC_Format_BIN)
 8008a9e:	687b      	ldr	r3, [r7, #4]
 8008aa0:	2b00      	cmp	r3, #0
 8008aa2:	d10a      	bne.n	8008aba <RTC_SetTime+0x32>
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8008aa4:	4b40      	ldr	r3, [pc, #256]	; (8008ba8 <RTC_SetTime+0x120>)
 8008aa6:	689b      	ldr	r3, [r3, #8]
 8008aa8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8008aac:	2b00      	cmp	r3, #0
 8008aae:	d116      	bne.n	8008ade <RTC_SetTime+0x56>
      assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
      assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
    } 
    else
    {
      RTC_TimeStruct->RTC_H12 = 0x00;
 8008ab0:	683b      	ldr	r3, [r7, #0]
 8008ab2:	f04f 0200 	mov.w	r2, #0
 8008ab6:	70da      	strb	r2, [r3, #3]
 8008ab8:	e011      	b.n	8008ade <RTC_SetTime+0x56>
    assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
    assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
  }
  else
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8008aba:	4b3b      	ldr	r3, [pc, #236]	; (8008ba8 <RTC_SetTime+0x120>)
 8008abc:	689b      	ldr	r3, [r3, #8]
 8008abe:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8008ac2:	2b00      	cmp	r3, #0
 8008ac4:	d007      	beq.n	8008ad6 <RTC_SetTime+0x4e>
    {
      tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
 8008ac6:	683b      	ldr	r3, [r7, #0]
 8008ac8:	781b      	ldrb	r3, [r3, #0]
 8008aca:	4618      	mov	r0, r3
 8008acc:	f001 f944 	bl	8009d58 <RTC_Bcd2ToByte>
 8008ad0:	4603      	mov	r3, r0
 8008ad2:	60fb      	str	r3, [r7, #12]
 8008ad4:	e003      	b.n	8008ade <RTC_SetTime+0x56>
      assert_param(IS_RTC_HOUR12(tmpreg));
      assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
    } 
    else
    {
      RTC_TimeStruct->RTC_H12 = 0x00;
 8008ad6:	683b      	ldr	r3, [r7, #0]
 8008ad8:	f04f 0200 	mov.w	r2, #0
 8008adc:	70da      	strb	r2, [r3, #3]
    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
  }
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
 8008ade:	687b      	ldr	r3, [r7, #4]
 8008ae0:	2b00      	cmp	r3, #0
 8008ae2:	d012      	beq.n	8008b0a <RTC_SetTime+0x82>
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 8008ae4:	683b      	ldr	r3, [r7, #0]
 8008ae6:	781b      	ldrb	r3, [r3, #0]
 8008ae8:	ea4f 4203 	mov.w	r2, r3, lsl #16
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 8008aec:	683b      	ldr	r3, [r7, #0]
 8008aee:	785b      	ldrb	r3, [r3, #1]
 8008af0:	ea4f 2303 	mov.w	r3, r3, lsl #8
  }
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 8008af4:	431a      	orrs	r2, r3
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
 8008af6:	683b      	ldr	r3, [r7, #0]
 8008af8:	789b      	ldrb	r3, [r3, #2]
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 8008afa:	431a      	orrs	r2, r3
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
 8008afc:	683b      	ldr	r3, [r7, #0]
 8008afe:	78db      	ldrb	r3, [r3, #3]
 8008b00:	ea4f 4303 	mov.w	r3, r3, lsl #16
  }
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 8008b04:	4313      	orrs	r3, r2
 8008b06:	60fb      	str	r3, [r7, #12]
 8008b08:	e01e      	b.n	8008b48 <RTC_SetTime+0xc0>
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  }  
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 8008b0a:	683b      	ldr	r3, [r7, #0]
 8008b0c:	781b      	ldrb	r3, [r3, #0]
 8008b0e:	4618      	mov	r0, r3
 8008b10:	f001 f900 	bl	8009d14 <RTC_ByteToBcd2>
 8008b14:	4603      	mov	r3, r0
 8008b16:	ea4f 4403 	mov.w	r4, r3, lsl #16
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
 8008b1a:	683b      	ldr	r3, [r7, #0]
 8008b1c:	785b      	ldrb	r3, [r3, #1]
 8008b1e:	4618      	mov	r0, r3
 8008b20:	f001 f8f8 	bl	8009d14 <RTC_ByteToBcd2>
 8008b24:	4603      	mov	r3, r0
 8008b26:	ea4f 2303 	mov.w	r3, r3, lsl #8
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  }  
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 8008b2a:	431c      	orrs	r4, r3
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
 8008b2c:	683b      	ldr	r3, [r7, #0]
 8008b2e:	789b      	ldrb	r3, [r3, #2]
 8008b30:	4618      	mov	r0, r3
 8008b32:	f001 f8ef 	bl	8009d14 <RTC_ByteToBcd2>
 8008b36:	4603      	mov	r3, r0
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  }  
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
 8008b38:	ea44 0203 	orr.w	r2, r4, r3
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
                   (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
 8008b3c:	683b      	ldr	r3, [r7, #0]
 8008b3e:	78db      	ldrb	r3, [r3, #3]
 8008b40:	ea4f 4303 	mov.w	r3, r3, lsl #16
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  }  
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 8008b44:	4313      	orrs	r3, r2
 8008b46:	60fb      	str	r3, [r7, #12]
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
                   (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
  }  

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8008b48:	4b17      	ldr	r3, [pc, #92]	; (8008ba8 <RTC_SetTime+0x120>)
 8008b4a:	f04f 02ca 	mov.w	r2, #202	; 0xca
 8008b4e:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8008b50:	4b15      	ldr	r3, [pc, #84]	; (8008ba8 <RTC_SetTime+0x120>)
 8008b52:	f04f 0253 	mov.w	r2, #83	; 0x53
 8008b56:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 8008b58:	f7ff fea2 	bl	80088a0 <RTC_EnterInitMode>
 8008b5c:	4603      	mov	r3, r0
 8008b5e:	2b00      	cmp	r3, #0
 8008b60:	d103      	bne.n	8008b6a <RTC_SetTime+0xe2>
  {
    status = ERROR;
 8008b62:	f04f 0300 	mov.w	r3, #0
 8008b66:	72fb      	strb	r3, [r7, #11]
 8008b68:	e014      	b.n	8008b94 <RTC_SetTime+0x10c>
  } 
  else
  {
    /* Set the RTC_TR register */
    RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 8008b6a:	4a0f      	ldr	r2, [pc, #60]	; (8008ba8 <RTC_SetTime+0x120>)
 8008b6c:	68fb      	ldr	r3, [r7, #12]
 8008b6e:	f003 337f 	and.w	r3, r3, #2139062143	; 0x7f7f7f7f
 8008b72:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8008b76:	6013      	str	r3, [r2, #0]

    /* Exit Initialization mode */
    RTC_ExitInitMode(); 
 8008b78:	f7ff fed2 	bl	8008920 <RTC_ExitInitMode>

    if(RTC_WaitForSynchro() == ERROR)
 8008b7c:	f7ff fede 	bl	800893c <RTC_WaitForSynchro>
 8008b80:	4603      	mov	r3, r0
 8008b82:	2b00      	cmp	r3, #0
 8008b84:	d103      	bne.n	8008b8e <RTC_SetTime+0x106>
    {
      status = ERROR;
 8008b86:	f04f 0300 	mov.w	r3, #0
 8008b8a:	72fb      	strb	r3, [r7, #11]
 8008b8c:	e002      	b.n	8008b94 <RTC_SetTime+0x10c>
    }
    else
    {
      status = SUCCESS;
 8008b8e:	f04f 0301 	mov.w	r3, #1
 8008b92:	72fb      	strb	r3, [r7, #11]
    }
  
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8008b94:	4b04      	ldr	r3, [pc, #16]	; (8008ba8 <RTC_SetTime+0x120>)
 8008b96:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8008b9a:	625a      	str	r2, [r3, #36]	; 0x24
    
  return status;
 8008b9c:	7afb      	ldrb	r3, [r7, #11]
}
 8008b9e:	4618      	mov	r0, r3
 8008ba0:	f107 0714 	add.w	r7, r7, #20
 8008ba4:	46bd      	mov	sp, r7
 8008ba6:	bd90      	pop	{r4, r7, pc}
 8008ba8:	40002800 	.word	0x40002800

08008bac <RTC_TimeStructInit>:
  * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure which will be 
  *         initialized.
  * @retval None
  */
void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
{
 8008bac:	b480      	push	{r7}
 8008bae:	b083      	sub	sp, #12
 8008bb0:	af00      	add	r7, sp, #0
 8008bb2:	6078      	str	r0, [r7, #4]
  /* Time = 00h:00min:00sec */
  RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
 8008bb4:	687b      	ldr	r3, [r7, #4]
 8008bb6:	f04f 0200 	mov.w	r2, #0
 8008bba:	70da      	strb	r2, [r3, #3]
  RTC_TimeStruct->RTC_Hours = 0;
 8008bbc:	687b      	ldr	r3, [r7, #4]
 8008bbe:	f04f 0200 	mov.w	r2, #0
 8008bc2:	701a      	strb	r2, [r3, #0]
  RTC_TimeStruct->RTC_Minutes = 0;
 8008bc4:	687b      	ldr	r3, [r7, #4]
 8008bc6:	f04f 0200 	mov.w	r2, #0
 8008bca:	705a      	strb	r2, [r3, #1]
  RTC_TimeStruct->RTC_Seconds = 0; 
 8008bcc:	687b      	ldr	r3, [r7, #4]
 8008bce:	f04f 0200 	mov.w	r2, #0
 8008bd2:	709a      	strb	r2, [r3, #2]
}
 8008bd4:	f107 070c 	add.w	r7, r7, #12
 8008bd8:	46bd      	mov	sp, r7
 8008bda:	bc80      	pop	{r7}
 8008bdc:	4770      	bx	lr
 8008bde:	bf00      	nop

08008be0 <RTC_GetTime>:
  * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that will 
  *                        contain the returned current time configuration.     
  * @retval None
  */
void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
{
 8008be0:	b580      	push	{r7, lr}
 8008be2:	b084      	sub	sp, #16
 8008be4:	af00      	add	r7, sp, #0
 8008be6:	6078      	str	r0, [r7, #4]
 8008be8:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8008bea:	f04f 0300 	mov.w	r3, #0
 8008bee:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));

  /* Get the RTC_TR register */
  tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
 8008bf0:	4b23      	ldr	r3, [pc, #140]	; (8008c80 <RTC_GetTime+0xa0>)
 8008bf2:	681b      	ldr	r3, [r3, #0]
 8008bf4:	f003 337f 	and.w	r3, r3, #2139062143	; 0x7f7f7f7f
 8008bf8:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8008bfc:	60fb      	str	r3, [r7, #12]
  
  /* Fill the structure fields with the read parameters */
  RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8008bfe:	68fb      	ldr	r3, [r7, #12]
 8008c00:	f403 137c 	and.w	r3, r3, #4128768	; 0x3f0000
 8008c04:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8008c08:	b2da      	uxtb	r2, r3
 8008c0a:	683b      	ldr	r3, [r7, #0]
 8008c0c:	701a      	strb	r2, [r3, #0]
  RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
 8008c0e:	68fb      	ldr	r3, [r7, #12]
 8008c10:	f403 43fe 	and.w	r3, r3, #32512	; 0x7f00
 8008c14:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8008c18:	b2da      	uxtb	r2, r3
 8008c1a:	683b      	ldr	r3, [r7, #0]
 8008c1c:	705a      	strb	r2, [r3, #1]
  RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 8008c1e:	68fb      	ldr	r3, [r7, #12]
 8008c20:	b2db      	uxtb	r3, r3
 8008c22:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8008c26:	b2da      	uxtb	r2, r3
 8008c28:	683b      	ldr	r3, [r7, #0]
 8008c2a:	709a      	strb	r2, [r3, #2]
  RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
 8008c2c:	68fb      	ldr	r3, [r7, #12]
 8008c2e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8008c32:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8008c36:	b2da      	uxtb	r2, r3
 8008c38:	683b      	ldr	r3, [r7, #0]
 8008c3a:	70da      	strb	r2, [r3, #3]

  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
 8008c3c:	687b      	ldr	r3, [r7, #4]
 8008c3e:	2b00      	cmp	r3, #0
 8008c40:	d11a      	bne.n	8008c78 <RTC_GetTime+0x98>
  {
    /* Convert the structure parameters to Binary format */
    RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
 8008c42:	683b      	ldr	r3, [r7, #0]
 8008c44:	781b      	ldrb	r3, [r3, #0]
 8008c46:	4618      	mov	r0, r3
 8008c48:	f001 f886 	bl	8009d58 <RTC_Bcd2ToByte>
 8008c4c:	4603      	mov	r3, r0
 8008c4e:	461a      	mov	r2, r3
 8008c50:	683b      	ldr	r3, [r7, #0]
 8008c52:	701a      	strb	r2, [r3, #0]
    RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
 8008c54:	683b      	ldr	r3, [r7, #0]
 8008c56:	785b      	ldrb	r3, [r3, #1]
 8008c58:	4618      	mov	r0, r3
 8008c5a:	f001 f87d 	bl	8009d58 <RTC_Bcd2ToByte>
 8008c5e:	4603      	mov	r3, r0
 8008c60:	461a      	mov	r2, r3
 8008c62:	683b      	ldr	r3, [r7, #0]
 8008c64:	705a      	strb	r2, [r3, #1]
    RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
 8008c66:	683b      	ldr	r3, [r7, #0]
 8008c68:	789b      	ldrb	r3, [r3, #2]
 8008c6a:	4618      	mov	r0, r3
 8008c6c:	f001 f874 	bl	8009d58 <RTC_Bcd2ToByte>
 8008c70:	4603      	mov	r3, r0
 8008c72:	461a      	mov	r2, r3
 8008c74:	683b      	ldr	r3, [r7, #0]
 8008c76:	709a      	strb	r2, [r3, #2]
  }
}
 8008c78:	f107 0710 	add.w	r7, r7, #16
 8008c7c:	46bd      	mov	sp, r7
 8008c7e:	bd80      	pop	{r7, pc}
 8008c80:	40002800 	.word	0x40002800

08008c84 <RTC_GetSubSecond>:
  *         SSR register.
  * @param  None
  * @retval RTC current Calendar Subseconds value.
  */
uint32_t RTC_GetSubSecond(void)
{
 8008c84:	b480      	push	{r7}
 8008c86:	b083      	sub	sp, #12
 8008c88:	af00      	add	r7, sp, #0
  uint32_t tmpreg = 0;
 8008c8a:	f04f 0300 	mov.w	r3, #0
 8008c8e:	607b      	str	r3, [r7, #4]
  
  /* Get subseconds values from the correspondent registers*/
  tmpreg = (uint32_t)(RTC->SSR);
 8008c90:	4b05      	ldr	r3, [pc, #20]	; (8008ca8 <RTC_GetSubSecond+0x24>)
 8008c92:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008c94:	607b      	str	r3, [r7, #4]
  
  /* Read DR register to unfroze calendar registers */
  (void) (RTC->DR);
 8008c96:	4b04      	ldr	r3, [pc, #16]	; (8008ca8 <RTC_GetSubSecond+0x24>)
 8008c98:	685b      	ldr	r3, [r3, #4]
  
  return (tmpreg);
 8008c9a:	687b      	ldr	r3, [r7, #4]
}
 8008c9c:	4618      	mov	r0, r3
 8008c9e:	f107 070c 	add.w	r7, r7, #12
 8008ca2:	46bd      	mov	sp, r7
 8008ca4:	bc80      	pop	{r7}
 8008ca6:	4770      	bx	lr
 8008ca8:	40002800 	.word	0x40002800

08008cac <RTC_SetDate>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Date register is configured
  *          - ERROR: RTC Date register is not configured
  */
ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
{
 8008cac:	b590      	push	{r4, r7, lr}
 8008cae:	b085      	sub	sp, #20
 8008cb0:	af00      	add	r7, sp, #0
 8008cb2:	6078      	str	r0, [r7, #4]
 8008cb4:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8008cb6:	f04f 0300 	mov.w	r3, #0
 8008cba:	60fb      	str	r3, [r7, #12]
  ErrorStatus status = ERROR;
 8008cbc:	f04f 0300 	mov.w	r3, #0
 8008cc0:	72fb      	strb	r3, [r7, #11]
  
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));

  if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
 8008cc2:	687b      	ldr	r3, [r7, #4]
 8008cc4:	2b00      	cmp	r3, #0
 8008cc6:	d10f      	bne.n	8008ce8 <RTC_SetDate+0x3c>
 8008cc8:	683b      	ldr	r3, [r7, #0]
 8008cca:	785b      	ldrb	r3, [r3, #1]
 8008ccc:	f003 0310 	and.w	r3, r3, #16
 8008cd0:	2b00      	cmp	r3, #0
 8008cd2:	d009      	beq.n	8008ce8 <RTC_SetDate+0x3c>
  {
    RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
 8008cd4:	683b      	ldr	r3, [r7, #0]
 8008cd6:	785b      	ldrb	r3, [r3, #1]
 8008cd8:	f023 0310 	bic.w	r3, r3, #16
 8008cdc:	b2db      	uxtb	r3, r3
 8008cde:	f103 030a 	add.w	r3, r3, #10
 8008ce2:	b2da      	uxtb	r2, r3
 8008ce4:	683b      	ldr	r3, [r7, #0]
 8008ce6:	705a      	strb	r2, [r3, #1]
  }  
  if (RTC_Format == RTC_Format_BIN)
 8008ce8:	687b      	ldr	r3, [r7, #4]
 8008cea:	2b00      	cmp	r3, #0
 8008cec:	d00d      	beq.n	8008d0a <RTC_SetDate+0x5e>
    assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
  }
  else
  {
    assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
    tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
 8008cee:	683b      	ldr	r3, [r7, #0]
 8008cf0:	785b      	ldrb	r3, [r3, #1]
 8008cf2:	4618      	mov	r0, r3
 8008cf4:	f001 f830 	bl	8009d58 <RTC_Bcd2ToByte>
 8008cf8:	4603      	mov	r3, r0
 8008cfa:	60fb      	str	r3, [r7, #12]
    assert_param(IS_RTC_MONTH(tmpreg));
    tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
 8008cfc:	683b      	ldr	r3, [r7, #0]
 8008cfe:	789b      	ldrb	r3, [r3, #2]
 8008d00:	4618      	mov	r0, r3
 8008d02:	f001 f829 	bl	8009d58 <RTC_Bcd2ToByte>
 8008d06:	4603      	mov	r3, r0
 8008d08:	60fb      	str	r3, [r7, #12]
    assert_param(IS_RTC_DATE(tmpreg));
  }
  assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
 8008d0a:	687b      	ldr	r3, [r7, #4]
 8008d0c:	2b00      	cmp	r3, #0
 8008d0e:	d012      	beq.n	8008d36 <RTC_SetDate+0x8a>
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 8008d10:	683b      	ldr	r3, [r7, #0]
 8008d12:	78db      	ldrb	r3, [r3, #3]
 8008d14:	ea4f 4203 	mov.w	r2, r3, lsl #16
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
 8008d18:	683b      	ldr	r3, [r7, #0]
 8008d1a:	785b      	ldrb	r3, [r3, #1]
 8008d1c:	ea4f 2303 	mov.w	r3, r3, lsl #8
  assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 8008d20:	431a      	orrs	r2, r3
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
 8008d22:	683b      	ldr	r3, [r7, #0]
 8008d24:	789b      	ldrb	r3, [r3, #2]

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
 8008d26:	431a      	orrs	r2, r3
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
 8008d28:	683b      	ldr	r3, [r7, #0]
 8008d2a:	781b      	ldrb	r3, [r3, #0]
 8008d2c:	ea4f 3343 	mov.w	r3, r3, lsl #13
  assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 8008d30:	4313      	orrs	r3, r2
 8008d32:	60fb      	str	r3, [r7, #12]
 8008d34:	e01e      	b.n	8008d74 <RTC_SetDate+0xc8>
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 8008d36:	683b      	ldr	r3, [r7, #0]
 8008d38:	78db      	ldrb	r3, [r3, #3]
 8008d3a:	4618      	mov	r0, r3
 8008d3c:	f000 ffea 	bl	8009d14 <RTC_ByteToBcd2>
 8008d40:	4603      	mov	r3, r0
 8008d42:	ea4f 4403 	mov.w	r4, r3, lsl #16
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
 8008d46:	683b      	ldr	r3, [r7, #0]
 8008d48:	785b      	ldrb	r3, [r3, #1]
 8008d4a:	4618      	mov	r0, r3
 8008d4c:	f000 ffe2 	bl	8009d14 <RTC_ByteToBcd2>
 8008d50:	4603      	mov	r3, r0
 8008d52:	ea4f 2303 	mov.w	r3, r3, lsl #8
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 8008d56:	431c      	orrs	r4, r3
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
 8008d58:	683b      	ldr	r3, [r7, #0]
 8008d5a:	789b      	ldrb	r3, [r3, #2]
 8008d5c:	4618      	mov	r0, r3
 8008d5e:	f000 ffd9 	bl	8009d14 <RTC_ByteToBcd2>
 8008d62:	4603      	mov	r3, r0
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
 8008d64:	ea44 0203 	orr.w	r2, r4, r3
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
              ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
 8008d68:	683b      	ldr	r3, [r7, #0]
 8008d6a:	781b      	ldrb	r3, [r3, #0]
 8008d6c:	ea4f 3343 	mov.w	r3, r3, lsl #13
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 8008d70:	4313      	orrs	r3, r2
 8008d72:	60fb      	str	r3, [r7, #12]
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
              ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
  }

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8008d74:	4b17      	ldr	r3, [pc, #92]	; (8008dd4 <RTC_SetDate+0x128>)
 8008d76:	f04f 02ca 	mov.w	r2, #202	; 0xca
 8008d7a:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8008d7c:	4b15      	ldr	r3, [pc, #84]	; (8008dd4 <RTC_SetDate+0x128>)
 8008d7e:	f04f 0253 	mov.w	r2, #83	; 0x53
 8008d82:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 8008d84:	f7ff fd8c 	bl	80088a0 <RTC_EnterInitMode>
 8008d88:	4603      	mov	r3, r0
 8008d8a:	2b00      	cmp	r3, #0
 8008d8c:	d103      	bne.n	8008d96 <RTC_SetDate+0xea>
  {
    status = ERROR;
 8008d8e:	f04f 0300 	mov.w	r3, #0
 8008d92:	72fb      	strb	r3, [r7, #11]
 8008d94:	e014      	b.n	8008dc0 <RTC_SetDate+0x114>
  } 
  else
  {
    /* Set the RTC_DR register */
    RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
 8008d96:	4a0f      	ldr	r2, [pc, #60]	; (8008dd4 <RTC_SetDate+0x128>)
 8008d98:	68fb      	ldr	r3, [r7, #12]
 8008d9a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8008d9e:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8008da2:	6053      	str	r3, [r2, #4]

    /* Exit Initialization mode */
    RTC_ExitInitMode(); 
 8008da4:	f7ff fdbc 	bl	8008920 <RTC_ExitInitMode>

    if(RTC_WaitForSynchro() == ERROR)
 8008da8:	f7ff fdc8 	bl	800893c <RTC_WaitForSynchro>
 8008dac:	4603      	mov	r3, r0
 8008dae:	2b00      	cmp	r3, #0
 8008db0:	d103      	bne.n	8008dba <RTC_SetDate+0x10e>
    {
      status = ERROR;
 8008db2:	f04f 0300 	mov.w	r3, #0
 8008db6:	72fb      	strb	r3, [r7, #11]
 8008db8:	e002      	b.n	8008dc0 <RTC_SetDate+0x114>
    }
    else
    {
      status = SUCCESS;
 8008dba:	f04f 0301 	mov.w	r3, #1
 8008dbe:	72fb      	strb	r3, [r7, #11]
    }
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;   
 8008dc0:	4b04      	ldr	r3, [pc, #16]	; (8008dd4 <RTC_SetDate+0x128>)
 8008dc2:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8008dc6:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
 8008dc8:	7afb      	ldrb	r3, [r7, #11]
}
 8008dca:	4618      	mov	r0, r3
 8008dcc:	f107 0714 	add.w	r7, r7, #20
 8008dd0:	46bd      	mov	sp, r7
 8008dd2:	bd90      	pop	{r4, r7, pc}
 8008dd4:	40002800 	.word	0x40002800

08008dd8 <RTC_DateStructInit>:
  * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure which will be 
  *         initialized.
  * @retval None
  */
void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
{
 8008dd8:	b480      	push	{r7}
 8008dda:	b083      	sub	sp, #12
 8008ddc:	af00      	add	r7, sp, #0
 8008dde:	6078      	str	r0, [r7, #4]
  /* Monday, January 01 xx00 */
  RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
 8008de0:	687b      	ldr	r3, [r7, #4]
 8008de2:	f04f 0201 	mov.w	r2, #1
 8008de6:	701a      	strb	r2, [r3, #0]
  RTC_DateStruct->RTC_Date = 1;
 8008de8:	687b      	ldr	r3, [r7, #4]
 8008dea:	f04f 0201 	mov.w	r2, #1
 8008dee:	709a      	strb	r2, [r3, #2]
  RTC_DateStruct->RTC_Month = RTC_Month_January;
 8008df0:	687b      	ldr	r3, [r7, #4]
 8008df2:	f04f 0201 	mov.w	r2, #1
 8008df6:	705a      	strb	r2, [r3, #1]
  RTC_DateStruct->RTC_Year = 0;
 8008df8:	687b      	ldr	r3, [r7, #4]
 8008dfa:	f04f 0200 	mov.w	r2, #0
 8008dfe:	70da      	strb	r2, [r3, #3]
}
 8008e00:	f107 070c 	add.w	r7, r7, #12
 8008e04:	46bd      	mov	sp, r7
 8008e06:	bc80      	pop	{r7}
 8008e08:	4770      	bx	lr
 8008e0a:	bf00      	nop

08008e0c <RTC_GetDate>:
  * @param RTC_DateStruct: pointer to a RTC_DateTypeDef structure that will 
  *                        contain the returned current date configuration.     
  * @retval None
  */
void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
{
 8008e0c:	b580      	push	{r7, lr}
 8008e0e:	b084      	sub	sp, #16
 8008e10:	af00      	add	r7, sp, #0
 8008e12:	6078      	str	r0, [r7, #4]
 8008e14:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8008e16:	f04f 0300 	mov.w	r3, #0
 8008e1a:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  
  /* Get the RTC_TR register */
  tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
 8008e1c:	4b23      	ldr	r3, [pc, #140]	; (8008eac <RTC_GetDate+0xa0>)
 8008e1e:	685b      	ldr	r3, [r3, #4]
 8008e20:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8008e24:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8008e28:	60fb      	str	r3, [r7, #12]

  /* Fill the structure fields with the read parameters */
  RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
 8008e2a:	68fb      	ldr	r3, [r7, #12]
 8008e2c:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 8008e30:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8008e34:	b2da      	uxtb	r2, r3
 8008e36:	683b      	ldr	r3, [r7, #0]
 8008e38:	70da      	strb	r2, [r3, #3]
  RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 8008e3a:	68fb      	ldr	r3, [r7, #12]
 8008e3c:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
 8008e40:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8008e44:	b2da      	uxtb	r2, r3
 8008e46:	683b      	ldr	r3, [r7, #0]
 8008e48:	705a      	strb	r2, [r3, #1]
  RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
 8008e4a:	68fb      	ldr	r3, [r7, #12]
 8008e4c:	b2db      	uxtb	r3, r3
 8008e4e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8008e52:	b2da      	uxtb	r2, r3
 8008e54:	683b      	ldr	r3, [r7, #0]
 8008e56:	709a      	strb	r2, [r3, #2]
  RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);
 8008e58:	68fb      	ldr	r3, [r7, #12]
 8008e5a:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 8008e5e:	ea4f 3353 	mov.w	r3, r3, lsr #13
 8008e62:	b2da      	uxtb	r2, r3
 8008e64:	683b      	ldr	r3, [r7, #0]
 8008e66:	701a      	strb	r2, [r3, #0]

  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
 8008e68:	687b      	ldr	r3, [r7, #4]
 8008e6a:	2b00      	cmp	r3, #0
 8008e6c:	d11a      	bne.n	8008ea4 <RTC_GetDate+0x98>
  {
    /* Convert the structure parameters to Binary format */
    RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
 8008e6e:	683b      	ldr	r3, [r7, #0]
 8008e70:	78db      	ldrb	r3, [r3, #3]
 8008e72:	4618      	mov	r0, r3
 8008e74:	f000 ff70 	bl	8009d58 <RTC_Bcd2ToByte>
 8008e78:	4603      	mov	r3, r0
 8008e7a:	461a      	mov	r2, r3
 8008e7c:	683b      	ldr	r3, [r7, #0]
 8008e7e:	70da      	strb	r2, [r3, #3]
    RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
 8008e80:	683b      	ldr	r3, [r7, #0]
 8008e82:	785b      	ldrb	r3, [r3, #1]
 8008e84:	4618      	mov	r0, r3
 8008e86:	f000 ff67 	bl	8009d58 <RTC_Bcd2ToByte>
 8008e8a:	4603      	mov	r3, r0
 8008e8c:	461a      	mov	r2, r3
 8008e8e:	683b      	ldr	r3, [r7, #0]
 8008e90:	705a      	strb	r2, [r3, #1]
    RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
 8008e92:	683b      	ldr	r3, [r7, #0]
 8008e94:	789b      	ldrb	r3, [r3, #2]
 8008e96:	4618      	mov	r0, r3
 8008e98:	f000 ff5e 	bl	8009d58 <RTC_Bcd2ToByte>
 8008e9c:	4603      	mov	r3, r0
 8008e9e:	461a      	mov	r2, r3
 8008ea0:	683b      	ldr	r3, [r7, #0]
 8008ea2:	709a      	strb	r2, [r3, #2]
  }
}
 8008ea4:	f107 0710 	add.w	r7, r7, #16
 8008ea8:	46bd      	mov	sp, r7
 8008eaa:	bd80      	pop	{r7, pc}
 8008eac:	40002800 	.word	0x40002800

08008eb0 <RTC_SetAlarm>:
  * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that 
  *                          contains the alarm configuration parameters.     
  * @retval None
  */
void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
{
 8008eb0:	b590      	push	{r4, r7, lr}
 8008eb2:	b087      	sub	sp, #28
 8008eb4:	af00      	add	r7, sp, #0
 8008eb6:	60f8      	str	r0, [r7, #12]
 8008eb8:	60b9      	str	r1, [r7, #8]
 8008eba:	607a      	str	r2, [r7, #4]
  uint32_t tmpreg = 0;
 8008ebc:	f04f 0300 	mov.w	r3, #0
 8008ec0:	617b      	str	r3, [r7, #20]
  assert_param(IS_RTC_FORMAT(RTC_Format));
  assert_param(IS_RTC_ALARM(RTC_Alarm));
  assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
  assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));

  if (RTC_Format == RTC_Format_BIN)
 8008ec2:	68fb      	ldr	r3, [r7, #12]
 8008ec4:	2b00      	cmp	r3, #0
 8008ec6:	d10a      	bne.n	8008ede <RTC_SetAlarm+0x2e>
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8008ec8:	4b4d      	ldr	r3, [pc, #308]	; (8009000 <RTC_SetAlarm+0x150>)
 8008eca:	689b      	ldr	r3, [r3, #8]
 8008ecc:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8008ed0:	2b00      	cmp	r3, #0
 8008ed2:	d129      	bne.n	8008f28 <RTC_SetAlarm+0x78>
      assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
      assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
    } 
    else
    {
      RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
 8008ed4:	687b      	ldr	r3, [r7, #4]
 8008ed6:	f04f 0200 	mov.w	r2, #0
 8008eda:	70da      	strb	r2, [r3, #3]
 8008edc:	e024      	b.n	8008f28 <RTC_SetAlarm+0x78>
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
    }
  }
  else
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8008ede:	4b48      	ldr	r3, [pc, #288]	; (8009000 <RTC_SetAlarm+0x150>)
 8008ee0:	689b      	ldr	r3, [r3, #8]
 8008ee2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8008ee6:	2b00      	cmp	r3, #0
 8008ee8:	d007      	beq.n	8008efa <RTC_SetAlarm+0x4a>
    {
      tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
 8008eea:	687b      	ldr	r3, [r7, #4]
 8008eec:	781b      	ldrb	r3, [r3, #0]
 8008eee:	4618      	mov	r0, r3
 8008ef0:	f000 ff32 	bl	8009d58 <RTC_Bcd2ToByte>
 8008ef4:	4603      	mov	r3, r0
 8008ef6:	617b      	str	r3, [r7, #20]
 8008ef8:	e003      	b.n	8008f02 <RTC_SetAlarm+0x52>
      assert_param(IS_RTC_HOUR12(tmpreg));
      assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
    } 
    else
    {
      RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
 8008efa:	687b      	ldr	r3, [r7, #4]
 8008efc:	f04f 0200 	mov.w	r2, #0
 8008f00:	70da      	strb	r2, [r3, #3]
    }
    
    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
    
    if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
 8008f02:	687b      	ldr	r3, [r7, #4]
 8008f04:	689b      	ldr	r3, [r3, #8]
 8008f06:	2b00      	cmp	r3, #0
 8008f08:	d107      	bne.n	8008f1a <RTC_SetAlarm+0x6a>
    {
      tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
 8008f0a:	687b      	ldr	r3, [r7, #4]
 8008f0c:	7b1b      	ldrb	r3, [r3, #12]
 8008f0e:	4618      	mov	r0, r3
 8008f10:	f000 ff22 	bl	8009d58 <RTC_Bcd2ToByte>
 8008f14:	4603      	mov	r3, r0
 8008f16:	617b      	str	r3, [r7, #20]
 8008f18:	e006      	b.n	8008f28 <RTC_SetAlarm+0x78>
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
    }
    else
    {
      tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
 8008f1a:	687b      	ldr	r3, [r7, #4]
 8008f1c:	7b1b      	ldrb	r3, [r3, #12]
 8008f1e:	4618      	mov	r0, r3
 8008f20:	f000 ff1a 	bl	8009d58 <RTC_Bcd2ToByte>
 8008f24:	4603      	mov	r3, r0
 8008f26:	617b      	str	r3, [r7, #20]
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
    }    
  }

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
 8008f28:	68fb      	ldr	r3, [r7, #12]
 8008f2a:	2b00      	cmp	r3, #0
 8008f2c:	d01d      	beq.n	8008f6a <RTC_SetAlarm+0xba>
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8008f2e:	687b      	ldr	r3, [r7, #4]
 8008f30:	781b      	ldrb	r3, [r3, #0]
 8008f32:	ea4f 4203 	mov.w	r2, r3, lsl #16
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 8008f36:	687b      	ldr	r3, [r7, #4]
 8008f38:	785b      	ldrb	r3, [r3, #1]
 8008f3a:	ea4f 2303 	mov.w	r3, r3, lsl #8
  }

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8008f3e:	431a      	orrs	r2, r3
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
 8008f40:	687b      	ldr	r3, [r7, #4]
 8008f42:	789b      	ldrb	r3, [r3, #2]

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 8008f44:	431a      	orrs	r2, r3
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 8008f46:	687b      	ldr	r3, [r7, #4]
 8008f48:	78db      	ldrb	r3, [r3, #3]
 8008f4a:	ea4f 4303 	mov.w	r3, r3, lsl #16
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
 8008f4e:	431a      	orrs	r2, r3
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 8008f50:	687b      	ldr	r3, [r7, #4]
 8008f52:	7b1b      	ldrb	r3, [r3, #12]
 8008f54:	ea4f 6303 	mov.w	r3, r3, lsl #24
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 8008f58:	431a      	orrs	r2, r3
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
 8008f5a:	687b      	ldr	r3, [r7, #4]
 8008f5c:	689b      	ldr	r3, [r3, #8]
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 8008f5e:	431a      	orrs	r2, r3
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
 8008f60:	687b      	ldr	r3, [r7, #4]
 8008f62:	685b      	ldr	r3, [r3, #4]
  }

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8008f64:	4313      	orrs	r3, r2
 8008f66:	617b      	str	r3, [r7, #20]
 8008f68:	e02f      	b.n	8008fca <RTC_SetAlarm+0x11a>
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8008f6a:	687b      	ldr	r3, [r7, #4]
 8008f6c:	781b      	ldrb	r3, [r3, #0]
 8008f6e:	4618      	mov	r0, r3
 8008f70:	f000 fed0 	bl	8009d14 <RTC_ByteToBcd2>
 8008f74:	4603      	mov	r3, r0
 8008f76:	ea4f 4403 	mov.w	r4, r3, lsl #16
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 8008f7a:	687b      	ldr	r3, [r7, #4]
 8008f7c:	785b      	ldrb	r3, [r3, #1]
 8008f7e:	4618      	mov	r0, r3
 8008f80:	f000 fec8 	bl	8009d14 <RTC_ByteToBcd2>
 8008f84:	4603      	mov	r3, r0
 8008f86:	ea4f 2303 	mov.w	r3, r3, lsl #8
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8008f8a:	431c      	orrs	r4, r3
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
 8008f8c:	687b      	ldr	r3, [r7, #4]
 8008f8e:	789b      	ldrb	r3, [r3, #2]
 8008f90:	4618      	mov	r0, r3
 8008f92:	f000 febf 	bl	8009d14 <RTC_ByteToBcd2>
 8008f96:	4603      	mov	r3, r0
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 8008f98:	ea44 0203 	orr.w	r2, r4, r3
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 8008f9c:	687b      	ldr	r3, [r7, #4]
 8008f9e:	78db      	ldrb	r3, [r3, #3]
 8008fa0:	ea4f 4303 	mov.w	r3, r3, lsl #16
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
 8008fa4:	ea42 0403 	orr.w	r4, r2, r3
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 8008fa8:	687b      	ldr	r3, [r7, #4]
 8008faa:	7b1b      	ldrb	r3, [r3, #12]
 8008fac:	4618      	mov	r0, r3
 8008fae:	f000 feb1 	bl	8009d14 <RTC_ByteToBcd2>
 8008fb2:	4603      	mov	r3, r0
 8008fb4:	ea4f 6303 	mov.w	r3, r3, lsl #24
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 8008fb8:	ea44 0203 	orr.w	r2, r4, r3
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
 8008fbc:	687b      	ldr	r3, [r7, #4]
 8008fbe:	689b      	ldr	r3, [r3, #8]
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 8008fc0:	431a      	orrs	r2, r3
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
 8008fc2:	687b      	ldr	r3, [r7, #4]
 8008fc4:	685b      	ldr	r3, [r3, #4]
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8008fc6:	4313      	orrs	r3, r2
 8008fc8:	617b      	str	r3, [r7, #20]
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  } 

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8008fca:	4b0d      	ldr	r3, [pc, #52]	; (8009000 <RTC_SetAlarm+0x150>)
 8008fcc:	f04f 02ca 	mov.w	r2, #202	; 0xca
 8008fd0:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8008fd2:	4b0b      	ldr	r3, [pc, #44]	; (8009000 <RTC_SetAlarm+0x150>)
 8008fd4:	f04f 0253 	mov.w	r2, #83	; 0x53
 8008fd8:	625a      	str	r2, [r3, #36]	; 0x24

  /* Configure the Alarm register */
  if (RTC_Alarm == RTC_Alarm_A)
 8008fda:	68bb      	ldr	r3, [r7, #8]
 8008fdc:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8008fe0:	d103      	bne.n	8008fea <RTC_SetAlarm+0x13a>
  {
    RTC->ALRMAR = (uint32_t)tmpreg;
 8008fe2:	4b07      	ldr	r3, [pc, #28]	; (8009000 <RTC_SetAlarm+0x150>)
 8008fe4:	697a      	ldr	r2, [r7, #20]
 8008fe6:	61da      	str	r2, [r3, #28]
 8008fe8:	e002      	b.n	8008ff0 <RTC_SetAlarm+0x140>
  }
  else
  {
    RTC->ALRMBR = (uint32_t)tmpreg;
 8008fea:	4b05      	ldr	r3, [pc, #20]	; (8009000 <RTC_SetAlarm+0x150>)
 8008fec:	697a      	ldr	r2, [r7, #20]
 8008fee:	621a      	str	r2, [r3, #32]
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;   
 8008ff0:	4b03      	ldr	r3, [pc, #12]	; (8009000 <RTC_SetAlarm+0x150>)
 8008ff2:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8008ff6:	625a      	str	r2, [r3, #36]	; 0x24
}
 8008ff8:	f107 071c 	add.w	r7, r7, #28
 8008ffc:	46bd      	mov	sp, r7
 8008ffe:	bd90      	pop	{r4, r7, pc}
 8009000:	40002800 	.word	0x40002800

08009004 <RTC_AlarmStructInit>:
  * @param  RTC_AlarmStruct: pointer to a @ref RTC_AlarmTypeDef structure which
  *         will be initialized.
  * @retval None
  */
void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
{
 8009004:	b480      	push	{r7}
 8009006:	b083      	sub	sp, #12
 8009008:	af00      	add	r7, sp, #0
 800900a:	6078      	str	r0, [r7, #4]
  /* Alarm Time Settings : Time = 00h:00mn:00sec */
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
 800900c:	687b      	ldr	r3, [r7, #4]
 800900e:	f04f 0200 	mov.w	r2, #0
 8009012:	70da      	strb	r2, [r3, #3]
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
 8009014:	687b      	ldr	r3, [r7, #4]
 8009016:	f04f 0200 	mov.w	r2, #0
 800901a:	701a      	strb	r2, [r3, #0]
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
 800901c:	687b      	ldr	r3, [r7, #4]
 800901e:	f04f 0200 	mov.w	r2, #0
 8009022:	705a      	strb	r2, [r3, #1]
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
 8009024:	687b      	ldr	r3, [r7, #4]
 8009026:	f04f 0200 	mov.w	r2, #0
 800902a:	709a      	strb	r2, [r3, #2]

  /* Alarm Date Settings : Date = 1st day of the month */
  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
 800902c:	687b      	ldr	r3, [r7, #4]
 800902e:	f04f 0200 	mov.w	r2, #0
 8009032:	609a      	str	r2, [r3, #8]
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
 8009034:	687b      	ldr	r3, [r7, #4]
 8009036:	f04f 0201 	mov.w	r2, #1
 800903a:	731a      	strb	r2, [r3, #12]

  /* Alarm Masks Settings : Mask =  all fields are not masked */
  RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
 800903c:	687b      	ldr	r3, [r7, #4]
 800903e:	f04f 0200 	mov.w	r2, #0
 8009042:	605a      	str	r2, [r3, #4]
}
 8009044:	f107 070c 	add.w	r7, r7, #12
 8009048:	46bd      	mov	sp, r7
 800904a:	bc80      	pop	{r7}
 800904c:	4770      	bx	lr
 800904e:	bf00      	nop

08009050 <RTC_GetAlarm>:
  * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that will 
  *                          contains the output alarm configuration values.     
  * @retval None
  */
void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
{
 8009050:	b580      	push	{r7, lr}
 8009052:	b086      	sub	sp, #24
 8009054:	af00      	add	r7, sp, #0
 8009056:	60f8      	str	r0, [r7, #12]
 8009058:	60b9      	str	r1, [r7, #8]
 800905a:	607a      	str	r2, [r7, #4]
  uint32_t tmpreg = 0;
 800905c:	f04f 0300 	mov.w	r3, #0
 8009060:	617b      	str	r3, [r7, #20]
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  assert_param(IS_RTC_ALARM(RTC_Alarm)); 

  /* Get the RTC_ALRMxR register */
  if (RTC_Alarm == RTC_Alarm_A)
 8009062:	68bb      	ldr	r3, [r7, #8]
 8009064:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8009068:	d103      	bne.n	8009072 <RTC_GetAlarm+0x22>
  {
    tmpreg = (uint32_t)(RTC->ALRMAR);
 800906a:	4b31      	ldr	r3, [pc, #196]	; (8009130 <RTC_GetAlarm+0xe0>)
 800906c:	69db      	ldr	r3, [r3, #28]
 800906e:	617b      	str	r3, [r7, #20]
 8009070:	e002      	b.n	8009078 <RTC_GetAlarm+0x28>
  }
  else
  {
    tmpreg = (uint32_t)(RTC->ALRMBR);
 8009072:	4b2f      	ldr	r3, [pc, #188]	; (8009130 <RTC_GetAlarm+0xe0>)
 8009074:	6a1b      	ldr	r3, [r3, #32]
 8009076:	617b      	str	r3, [r7, #20]
  }

  /* Fill the structure with the read parameters */
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
 8009078:	697b      	ldr	r3, [r7, #20]
 800907a:	f403 137c 	and.w	r3, r3, #4128768	; 0x3f0000
 800907e:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8009082:	b2da      	uxtb	r2, r3
 8009084:	687b      	ldr	r3, [r7, #4]
 8009086:	701a      	strb	r2, [r3, #0]
                                                     RTC_ALRMAR_HU)) >> 16);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
 8009088:	697b      	ldr	r3, [r7, #20]
 800908a:	f403 43fe 	and.w	r3, r3, #32512	; 0x7f00
 800908e:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8009092:	b2da      	uxtb	r2, r3
 8009094:	687b      	ldr	r3, [r7, #4]
 8009096:	705a      	strb	r2, [r3, #1]
                                                     RTC_ALRMAR_MNU)) >> 8);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
 8009098:	697b      	ldr	r3, [r7, #20]
 800909a:	b2db      	uxtb	r3, r3
 800909c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80090a0:	b2da      	uxtb	r2, r3
 80090a2:	687b      	ldr	r3, [r7, #4]
 80090a4:	709a      	strb	r2, [r3, #2]
                                                     RTC_ALRMAR_SU));
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
 80090a6:	697b      	ldr	r3, [r7, #20]
 80090a8:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80090ac:	ea4f 4313 	mov.w	r3, r3, lsr #16
 80090b0:	b2da      	uxtb	r2, r3
 80090b2:	687b      	ldr	r3, [r7, #4]
 80090b4:	70da      	strb	r2, [r3, #3]
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
 80090b6:	697b      	ldr	r3, [r7, #20]
 80090b8:	f003 537c 	and.w	r3, r3, #1056964608	; 0x3f000000
 80090bc:	ea4f 6313 	mov.w	r3, r3, lsr #24
 80090c0:	b2da      	uxtb	r2, r3
 80090c2:	687b      	ldr	r3, [r7, #4]
 80090c4:	731a      	strb	r2, [r3, #12]
  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
 80090c6:	697b      	ldr	r3, [r7, #20]
 80090c8:	f003 4280 	and.w	r2, r3, #1073741824	; 0x40000000
 80090cc:	687b      	ldr	r3, [r7, #4]
 80090ce:	609a      	str	r2, [r3, #8]
  RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
 80090d0:	697b      	ldr	r3, [r7, #20]
 80090d2:	f003 3280 	and.w	r2, r3, #2155905152	; 0x80808080
 80090d6:	687b      	ldr	r3, [r7, #4]
 80090d8:	605a      	str	r2, [r3, #4]

  if (RTC_Format == RTC_Format_BIN)
 80090da:	68fb      	ldr	r3, [r7, #12]
 80090dc:	2b00      	cmp	r3, #0
 80090de:	d123      	bne.n	8009128 <RTC_GetAlarm+0xd8>
  {
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
 80090e0:	687b      	ldr	r3, [r7, #4]
 80090e2:	781b      	ldrb	r3, [r3, #0]
 80090e4:	4618      	mov	r0, r3
 80090e6:	f000 fe37 	bl	8009d58 <RTC_Bcd2ToByte>
 80090ea:	4603      	mov	r3, r0
 80090ec:	461a      	mov	r2, r3
 80090ee:	687b      	ldr	r3, [r7, #4]
 80090f0:	701a      	strb	r2, [r3, #0]
                                                        RTC_AlarmTime.RTC_Hours);
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
 80090f2:	687b      	ldr	r3, [r7, #4]
 80090f4:	785b      	ldrb	r3, [r3, #1]
 80090f6:	4618      	mov	r0, r3
 80090f8:	f000 fe2e 	bl	8009d58 <RTC_Bcd2ToByte>
 80090fc:	4603      	mov	r3, r0
 80090fe:	461a      	mov	r2, r3
 8009100:	687b      	ldr	r3, [r7, #4]
 8009102:	705a      	strb	r2, [r3, #1]
                                                        RTC_AlarmTime.RTC_Minutes);
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
 8009104:	687b      	ldr	r3, [r7, #4]
 8009106:	789b      	ldrb	r3, [r3, #2]
 8009108:	4618      	mov	r0, r3
 800910a:	f000 fe25 	bl	8009d58 <RTC_Bcd2ToByte>
 800910e:	4603      	mov	r3, r0
 8009110:	461a      	mov	r2, r3
 8009112:	687b      	ldr	r3, [r7, #4]
 8009114:	709a      	strb	r2, [r3, #2]
                                                        RTC_AlarmTime.RTC_Seconds);
    RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
 8009116:	687b      	ldr	r3, [r7, #4]
 8009118:	7b1b      	ldrb	r3, [r3, #12]
 800911a:	4618      	mov	r0, r3
 800911c:	f000 fe1c 	bl	8009d58 <RTC_Bcd2ToByte>
 8009120:	4603      	mov	r3, r0
 8009122:	461a      	mov	r2, r3
 8009124:	687b      	ldr	r3, [r7, #4]
 8009126:	731a      	strb	r2, [r3, #12]
  }  
}
 8009128:	f107 0718 	add.w	r7, r7, #24
 800912c:	46bd      	mov	sp, r7
 800912e:	bd80      	pop	{r7, pc}
 8009130:	40002800 	.word	0x40002800

08009134 <RTC_AlarmCmd>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Alarm is enabled/disabled
  *          - ERROR: RTC Alarm is not enabled/disabled  
  */
ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
{
 8009134:	b480      	push	{r7}
 8009136:	b087      	sub	sp, #28
 8009138:	af00      	add	r7, sp, #0
 800913a:	6078      	str	r0, [r7, #4]
 800913c:	460b      	mov	r3, r1
 800913e:	70fb      	strb	r3, [r7, #3]
  __IO uint32_t alarmcounter = 0x00;
 8009140:	f04f 0300 	mov.w	r3, #0
 8009144:	60fb      	str	r3, [r7, #12]
  uint32_t alarmstatus = 0x00;
 8009146:	f04f 0300 	mov.w	r3, #0
 800914a:	613b      	str	r3, [r7, #16]
  ErrorStatus status = ERROR;
 800914c:	f04f 0300 	mov.w	r3, #0
 8009150:	75fb      	strb	r3, [r7, #23]
  /* Check the parameters */
  assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8009152:	4b24      	ldr	r3, [pc, #144]	; (80091e4 <RTC_AlarmCmd+0xb0>)
 8009154:	f04f 02ca 	mov.w	r2, #202	; 0xca
 8009158:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800915a:	4b22      	ldr	r3, [pc, #136]	; (80091e4 <RTC_AlarmCmd+0xb0>)
 800915c:	f04f 0253 	mov.w	r2, #83	; 0x53
 8009160:	625a      	str	r2, [r3, #36]	; 0x24

  /* Configure the Alarm state */
  if (NewState != DISABLE)
 8009162:	78fb      	ldrb	r3, [r7, #3]
 8009164:	2b00      	cmp	r3, #0
 8009166:	d009      	beq.n	800917c <RTC_AlarmCmd+0x48>
  {
    RTC->CR |= (uint32_t)RTC_Alarm;
 8009168:	4b1e      	ldr	r3, [pc, #120]	; (80091e4 <RTC_AlarmCmd+0xb0>)
 800916a:	4a1e      	ldr	r2, [pc, #120]	; (80091e4 <RTC_AlarmCmd+0xb0>)
 800916c:	6891      	ldr	r1, [r2, #8]
 800916e:	687a      	ldr	r2, [r7, #4]
 8009170:	430a      	orrs	r2, r1
 8009172:	609a      	str	r2, [r3, #8]

    status = SUCCESS;    
 8009174:	f04f 0301 	mov.w	r3, #1
 8009178:	75fb      	strb	r3, [r7, #23]
 800917a:	e028      	b.n	80091ce <RTC_AlarmCmd+0x9a>
  }
  else
  { 
    /* Disable the Alarm in RTC_CR register */
    RTC->CR &= (uint32_t)~RTC_Alarm;
 800917c:	4b19      	ldr	r3, [pc, #100]	; (80091e4 <RTC_AlarmCmd+0xb0>)
 800917e:	4a19      	ldr	r2, [pc, #100]	; (80091e4 <RTC_AlarmCmd+0xb0>)
 8009180:	6891      	ldr	r1, [r2, #8]
 8009182:	687a      	ldr	r2, [r7, #4]
 8009184:	ea6f 0202 	mvn.w	r2, r2
 8009188:	400a      	ands	r2, r1
 800918a:	609a      	str	r2, [r3, #8]
   
    /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
    do
    {
      alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
 800918c:	4b15      	ldr	r3, [pc, #84]	; (80091e4 <RTC_AlarmCmd+0xb0>)
 800918e:	68da      	ldr	r2, [r3, #12]
 8009190:	687b      	ldr	r3, [r7, #4]
 8009192:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8009196:	4013      	ands	r3, r2
 8009198:	613b      	str	r3, [r7, #16]
      alarmcounter++;  
 800919a:	68fb      	ldr	r3, [r7, #12]
 800919c:	f103 0301 	add.w	r3, r3, #1
 80091a0:	60fb      	str	r3, [r7, #12]
    } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
 80091a2:	68fb      	ldr	r3, [r7, #12]
 80091a4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80091a8:	d002      	beq.n	80091b0 <RTC_AlarmCmd+0x7c>
 80091aa:	693b      	ldr	r3, [r7, #16]
 80091ac:	2b00      	cmp	r3, #0
 80091ae:	d0ed      	beq.n	800918c <RTC_AlarmCmd+0x58>
    
    if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
 80091b0:	4b0c      	ldr	r3, [pc, #48]	; (80091e4 <RTC_AlarmCmd+0xb0>)
 80091b2:	68da      	ldr	r2, [r3, #12]
 80091b4:	687b      	ldr	r3, [r7, #4]
 80091b6:	ea4f 2313 	mov.w	r3, r3, lsr #8
 80091ba:	4013      	ands	r3, r2
 80091bc:	2b00      	cmp	r3, #0
 80091be:	d103      	bne.n	80091c8 <RTC_AlarmCmd+0x94>
    {
      status = ERROR;
 80091c0:	f04f 0300 	mov.w	r3, #0
 80091c4:	75fb      	strb	r3, [r7, #23]
 80091c6:	e002      	b.n	80091ce <RTC_AlarmCmd+0x9a>
    } 
    else
    {
      status = SUCCESS;
 80091c8:	f04f 0301 	mov.w	r3, #1
 80091cc:	75fb      	strb	r3, [r7, #23]
    }        
  } 

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 80091ce:	4b05      	ldr	r3, [pc, #20]	; (80091e4 <RTC_AlarmCmd+0xb0>)
 80091d0:	f04f 02ff 	mov.w	r2, #255	; 0xff
 80091d4:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
 80091d6:	7dfb      	ldrb	r3, [r7, #23]
}
 80091d8:	4618      	mov	r0, r3
 80091da:	f107 071c 	add.w	r7, r7, #28
 80091de:	46bd      	mov	sp, r7
 80091e0:	bc80      	pop	{r7}
 80091e2:	4770      	bx	lr
 80091e4:	40002800 	.word	0x40002800

080091e8 <RTC_AlarmSubSecondConfig>:
  *     @arg RTC_AlarmSubSecondMask_None   : SS[14:0] are compared and must match
  *                                          to activate alarm
  * @retval None
  */
void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_AlarmSubSecondMask)
{
 80091e8:	b480      	push	{r7}
 80091ea:	b087      	sub	sp, #28
 80091ec:	af00      	add	r7, sp, #0
 80091ee:	60f8      	str	r0, [r7, #12]
 80091f0:	60b9      	str	r1, [r7, #8]
 80091f2:	607a      	str	r2, [r7, #4]
  uint32_t tmpreg = 0;
 80091f4:	f04f 0300 	mov.w	r3, #0
 80091f8:	617b      	str	r3, [r7, #20]
  assert_param(IS_RTC_ALARM(RTC_Alarm));
  assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
  assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80091fa:	4b10      	ldr	r3, [pc, #64]	; (800923c <RTC_AlarmSubSecondConfig+0x54>)
 80091fc:	f04f 02ca 	mov.w	r2, #202	; 0xca
 8009200:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8009202:	4b0e      	ldr	r3, [pc, #56]	; (800923c <RTC_AlarmSubSecondConfig+0x54>)
 8009204:	f04f 0253 	mov.w	r2, #83	; 0x53
 8009208:	625a      	str	r2, [r3, #36]	; 0x24
  
  /* Configure the Alarm A or Alarm B SubSecond registers */
  tmpreg = (uint32_t) (uint32_t)(RTC_AlarmSubSecondValue) | (uint32_t)(RTC_AlarmSubSecondMask);
 800920a:	68ba      	ldr	r2, [r7, #8]
 800920c:	687b      	ldr	r3, [r7, #4]
 800920e:	4313      	orrs	r3, r2
 8009210:	617b      	str	r3, [r7, #20]
  
  if (RTC_Alarm == RTC_Alarm_A)
 8009212:	68fb      	ldr	r3, [r7, #12]
 8009214:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8009218:	d103      	bne.n	8009222 <RTC_AlarmSubSecondConfig+0x3a>
  {
    /* Configure the AlarmA SubSecond register */
    RTC->ALRMASSR = tmpreg;
 800921a:	4b08      	ldr	r3, [pc, #32]	; (800923c <RTC_AlarmSubSecondConfig+0x54>)
 800921c:	697a      	ldr	r2, [r7, #20]
 800921e:	645a      	str	r2, [r3, #68]	; 0x44
 8009220:	e002      	b.n	8009228 <RTC_AlarmSubSecondConfig+0x40>
  }
  else
  {
    /* Configure the Alarm B SubSecond register */
    RTC->ALRMBSSR = tmpreg;
 8009222:	4b06      	ldr	r3, [pc, #24]	; (800923c <RTC_AlarmSubSecondConfig+0x54>)
 8009224:	697a      	ldr	r2, [r7, #20]
 8009226:	649a      	str	r2, [r3, #72]	; 0x48
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8009228:	4b04      	ldr	r3, [pc, #16]	; (800923c <RTC_AlarmSubSecondConfig+0x54>)
 800922a:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800922e:	625a      	str	r2, [r3, #36]	; 0x24

}
 8009230:	f107 071c 	add.w	r7, r7, #28
 8009234:	46bd      	mov	sp, r7
 8009236:	bc80      	pop	{r7}
 8009238:	4770      	bx	lr
 800923a:	bf00      	nop
 800923c:	40002800 	.word	0x40002800

08009240 <RTC_GetAlarmSubSecond>:
  *     @arg RTC_Alarm_B: to select Alarm B
  * @param  None
  * @retval RTC Alarm Subseconds value.
  */
uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm)
{
 8009240:	b480      	push	{r7}
 8009242:	b085      	sub	sp, #20
 8009244:	af00      	add	r7, sp, #0
 8009246:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8009248:	f04f 0300 	mov.w	r3, #0
 800924c:	60fb      	str	r3, [r7, #12]
  
  /* Get the RTC_ALRMxR register */
  if (RTC_Alarm == RTC_Alarm_A)
 800924e:	687b      	ldr	r3, [r7, #4]
 8009250:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8009254:	d107      	bne.n	8009266 <RTC_GetAlarmSubSecond+0x26>
  {
    tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
 8009256:	4b0b      	ldr	r3, [pc, #44]	; (8009284 <RTC_GetAlarmSubSecond+0x44>)
 8009258:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800925a:	ea4f 4343 	mov.w	r3, r3, lsl #17
 800925e:	ea4f 4353 	mov.w	r3, r3, lsr #17
 8009262:	60fb      	str	r3, [r7, #12]
 8009264:	e006      	b.n	8009274 <RTC_GetAlarmSubSecond+0x34>
  }
  else
  {
    tmpreg = (uint32_t)((RTC->ALRMBSSR) & RTC_ALRMBSSR_SS);
 8009266:	4b07      	ldr	r3, [pc, #28]	; (8009284 <RTC_GetAlarmSubSecond+0x44>)
 8009268:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800926a:	ea4f 4343 	mov.w	r3, r3, lsl #17
 800926e:	ea4f 4353 	mov.w	r3, r3, lsr #17
 8009272:	60fb      	str	r3, [r7, #12]
  } 
  
  return (tmpreg);
 8009274:	68fb      	ldr	r3, [r7, #12]
}
 8009276:	4618      	mov	r0, r3
 8009278:	f107 0714 	add.w	r7, r7, #20
 800927c:	46bd      	mov	sp, r7
 800927e:	bc80      	pop	{r7}
 8009280:	4770      	bx	lr
 8009282:	bf00      	nop
 8009284:	40002800 	.word	0x40002800

08009288 <RTC_WakeUpClockConfig>:
  *            @arg RTC_WakeUpClock_CK_SPRE_16bits: RTC Wakeup Counter Clock = CK_SPRE
  *            @arg RTC_WakeUpClock_CK_SPRE_17bits: RTC Wakeup Counter Clock = CK_SPRE
  * @retval None
  */
void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock)
{
 8009288:	b480      	push	{r7}
 800928a:	b083      	sub	sp, #12
 800928c:	af00      	add	r7, sp, #0
 800928e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8009290:	4b0e      	ldr	r3, [pc, #56]	; (80092cc <RTC_WakeUpClockConfig+0x44>)
 8009292:	f04f 02ca 	mov.w	r2, #202	; 0xca
 8009296:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8009298:	4b0c      	ldr	r3, [pc, #48]	; (80092cc <RTC_WakeUpClockConfig+0x44>)
 800929a:	f04f 0253 	mov.w	r2, #83	; 0x53
 800929e:	625a      	str	r2, [r3, #36]	; 0x24

  /* Clear the Wakeup Timer clock source bits in CR register */
  RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
 80092a0:	4b0a      	ldr	r3, [pc, #40]	; (80092cc <RTC_WakeUpClockConfig+0x44>)
 80092a2:	4a0a      	ldr	r2, [pc, #40]	; (80092cc <RTC_WakeUpClockConfig+0x44>)
 80092a4:	6892      	ldr	r2, [r2, #8]
 80092a6:	f022 0207 	bic.w	r2, r2, #7
 80092aa:	609a      	str	r2, [r3, #8]

  /* Configure the clock source */
  RTC->CR |= (uint32_t)RTC_WakeUpClock;
 80092ac:	4b07      	ldr	r3, [pc, #28]	; (80092cc <RTC_WakeUpClockConfig+0x44>)
 80092ae:	4a07      	ldr	r2, [pc, #28]	; (80092cc <RTC_WakeUpClockConfig+0x44>)
 80092b0:	6891      	ldr	r1, [r2, #8]
 80092b2:	687a      	ldr	r2, [r7, #4]
 80092b4:	430a      	orrs	r2, r1
 80092b6:	609a      	str	r2, [r3, #8]
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 80092b8:	4b04      	ldr	r3, [pc, #16]	; (80092cc <RTC_WakeUpClockConfig+0x44>)
 80092ba:	f04f 02ff 	mov.w	r2, #255	; 0xff
 80092be:	625a      	str	r2, [r3, #36]	; 0x24
}
 80092c0:	f107 070c 	add.w	r7, r7, #12
 80092c4:	46bd      	mov	sp, r7
 80092c6:	bc80      	pop	{r7}
 80092c8:	4770      	bx	lr
 80092ca:	bf00      	nop
 80092cc:	40002800 	.word	0x40002800

080092d0 <RTC_SetWakeUpCounter>:
  * @param  RTC_WakeUpCounter: specifies the WakeUp counter.
  *          This parameter can be a value from 0x0000 to 0xFFFF. 
  * @retval None
  */
void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter)
{
 80092d0:	b480      	push	{r7}
 80092d2:	b083      	sub	sp, #12
 80092d4:	af00      	add	r7, sp, #0
 80092d6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80092d8:	4b09      	ldr	r3, [pc, #36]	; (8009300 <RTC_SetWakeUpCounter+0x30>)
 80092da:	f04f 02ca 	mov.w	r2, #202	; 0xca
 80092de:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80092e0:	4b07      	ldr	r3, [pc, #28]	; (8009300 <RTC_SetWakeUpCounter+0x30>)
 80092e2:	f04f 0253 	mov.w	r2, #83	; 0x53
 80092e6:	625a      	str	r2, [r3, #36]	; 0x24
  
  /* Configure the Wakeup Timer counter */
  RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
 80092e8:	4b05      	ldr	r3, [pc, #20]	; (8009300 <RTC_SetWakeUpCounter+0x30>)
 80092ea:	687a      	ldr	r2, [r7, #4]
 80092ec:	615a      	str	r2, [r3, #20]
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 80092ee:	4b04      	ldr	r3, [pc, #16]	; (8009300 <RTC_SetWakeUpCounter+0x30>)
 80092f0:	f04f 02ff 	mov.w	r2, #255	; 0xff
 80092f4:	625a      	str	r2, [r3, #36]	; 0x24
}
 80092f6:	f107 070c 	add.w	r7, r7, #12
 80092fa:	46bd      	mov	sp, r7
 80092fc:	bc80      	pop	{r7}
 80092fe:	4770      	bx	lr
 8009300:	40002800 	.word	0x40002800

08009304 <RTC_GetWakeUpCounter>:
  * @brief  Returns the RTC WakeUp timer counter value.
  * @param  None
  * @retval The RTC WakeUp Counter value.
  */
uint32_t RTC_GetWakeUpCounter(void)
{
 8009304:	b480      	push	{r7}
 8009306:	af00      	add	r7, sp, #0
  /* Get the counter value */
  return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
 8009308:	4b04      	ldr	r3, [pc, #16]	; (800931c <RTC_GetWakeUpCounter+0x18>)
 800930a:	695b      	ldr	r3, [r3, #20]
 800930c:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8009310:	ea4f 4313 	mov.w	r3, r3, lsr #16
}
 8009314:	4618      	mov	r0, r3
 8009316:	46bd      	mov	sp, r7
 8009318:	bc80      	pop	{r7}
 800931a:	4770      	bx	lr
 800931c:	40002800 	.word	0x40002800

08009320 <RTC_WakeUpCmd>:
  * @param  NewState: new state of the WakeUp timer.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
{
 8009320:	b480      	push	{r7}
 8009322:	b087      	sub	sp, #28
 8009324:	af00      	add	r7, sp, #0
 8009326:	4603      	mov	r3, r0
 8009328:	71fb      	strb	r3, [r7, #7]
  __IO uint32_t wutcounter = 0x00;
 800932a:	f04f 0300 	mov.w	r3, #0
 800932e:	60fb      	str	r3, [r7, #12]
  uint32_t wutwfstatus = 0x00;
 8009330:	f04f 0300 	mov.w	r3, #0
 8009334:	613b      	str	r3, [r7, #16]
  ErrorStatus status = ERROR;
 8009336:	f04f 0300 	mov.w	r3, #0
 800933a:	75fb      	strb	r3, [r7, #23]
  
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 800933c:	4b21      	ldr	r3, [pc, #132]	; (80093c4 <RTC_WakeUpCmd+0xa4>)
 800933e:	f04f 02ca 	mov.w	r2, #202	; 0xca
 8009342:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8009344:	4b1f      	ldr	r3, [pc, #124]	; (80093c4 <RTC_WakeUpCmd+0xa4>)
 8009346:	f04f 0253 	mov.w	r2, #83	; 0x53
 800934a:	625a      	str	r2, [r3, #36]	; 0x24

  if (NewState != DISABLE)
 800934c:	79fb      	ldrb	r3, [r7, #7]
 800934e:	2b00      	cmp	r3, #0
 8009350:	d009      	beq.n	8009366 <RTC_WakeUpCmd+0x46>
  {
    /* Enable the Wakeup Timer */
    RTC->CR |= (uint32_t)RTC_CR_WUTE;
 8009352:	4b1c      	ldr	r3, [pc, #112]	; (80093c4 <RTC_WakeUpCmd+0xa4>)
 8009354:	4a1b      	ldr	r2, [pc, #108]	; (80093c4 <RTC_WakeUpCmd+0xa4>)
 8009356:	6892      	ldr	r2, [r2, #8]
 8009358:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800935c:	609a      	str	r2, [r3, #8]
    status = SUCCESS;    
 800935e:	f04f 0301 	mov.w	r3, #1
 8009362:	75fb      	strb	r3, [r7, #23]
 8009364:	e022      	b.n	80093ac <RTC_WakeUpCmd+0x8c>
  }
  else
  {
    /* Disable the Wakeup Timer */
    RTC->CR &= (uint32_t)~RTC_CR_WUTE;
 8009366:	4b17      	ldr	r3, [pc, #92]	; (80093c4 <RTC_WakeUpCmd+0xa4>)
 8009368:	4a16      	ldr	r2, [pc, #88]	; (80093c4 <RTC_WakeUpCmd+0xa4>)
 800936a:	6892      	ldr	r2, [r2, #8]
 800936c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8009370:	609a      	str	r2, [r3, #8]
    /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
    do
    {
      wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
 8009372:	4b14      	ldr	r3, [pc, #80]	; (80093c4 <RTC_WakeUpCmd+0xa4>)
 8009374:	68db      	ldr	r3, [r3, #12]
 8009376:	f003 0304 	and.w	r3, r3, #4
 800937a:	613b      	str	r3, [r7, #16]
      wutcounter++;  
 800937c:	68fb      	ldr	r3, [r7, #12]
 800937e:	f103 0301 	add.w	r3, r3, #1
 8009382:	60fb      	str	r3, [r7, #12]
    } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
 8009384:	68fb      	ldr	r3, [r7, #12]
 8009386:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800938a:	d002      	beq.n	8009392 <RTC_WakeUpCmd+0x72>
 800938c:	693b      	ldr	r3, [r7, #16]
 800938e:	2b00      	cmp	r3, #0
 8009390:	d0ef      	beq.n	8009372 <RTC_WakeUpCmd+0x52>
    
    if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
 8009392:	4b0c      	ldr	r3, [pc, #48]	; (80093c4 <RTC_WakeUpCmd+0xa4>)
 8009394:	68db      	ldr	r3, [r3, #12]
 8009396:	f003 0304 	and.w	r3, r3, #4
 800939a:	2b00      	cmp	r3, #0
 800939c:	d103      	bne.n	80093a6 <RTC_WakeUpCmd+0x86>
    {
      status = ERROR;
 800939e:	f04f 0300 	mov.w	r3, #0
 80093a2:	75fb      	strb	r3, [r7, #23]
 80093a4:	e002      	b.n	80093ac <RTC_WakeUpCmd+0x8c>
    }
    else
    {
      status = SUCCESS;
 80093a6:	f04f 0301 	mov.w	r3, #1
 80093aa:	75fb      	strb	r3, [r7, #23]
    }    
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 80093ac:	4b05      	ldr	r3, [pc, #20]	; (80093c4 <RTC_WakeUpCmd+0xa4>)
 80093ae:	f04f 02ff 	mov.w	r2, #255	; 0xff
 80093b2:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
 80093b4:	7dfb      	ldrb	r3, [r7, #23]
}
 80093b6:	4618      	mov	r0, r3
 80093b8:	f107 071c 	add.w	r7, r7, #28
 80093bc:	46bd      	mov	sp, r7
 80093be:	bc80      	pop	{r7}
 80093c0:	4770      	bx	lr
 80093c2:	bf00      	nop
 80093c4:	40002800 	.word	0x40002800

080093c8 <RTC_DayLightSavingConfig>:
  *            @arg RTC_StoreOperation_Reset: BCK Bit Reset
  *            @arg RTC_StoreOperation_Set: BCK Bit Set
  * @retval None
  */
void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
{
 80093c8:	b480      	push	{r7}
 80093ca:	b083      	sub	sp, #12
 80093cc:	af00      	add	r7, sp, #0
 80093ce:	6078      	str	r0, [r7, #4]
 80093d0:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
  assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80093d2:	4b0f      	ldr	r3, [pc, #60]	; (8009410 <RTC_DayLightSavingConfig+0x48>)
 80093d4:	f04f 02ca 	mov.w	r2, #202	; 0xca
 80093d8:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80093da:	4b0d      	ldr	r3, [pc, #52]	; (8009410 <RTC_DayLightSavingConfig+0x48>)
 80093dc:	f04f 0253 	mov.w	r2, #83	; 0x53
 80093e0:	625a      	str	r2, [r3, #36]	; 0x24

  /* Clear the bits to be configured */
  RTC->CR &= (uint32_t)~(RTC_CR_BCK);
 80093e2:	4b0b      	ldr	r3, [pc, #44]	; (8009410 <RTC_DayLightSavingConfig+0x48>)
 80093e4:	4a0a      	ldr	r2, [pc, #40]	; (8009410 <RTC_DayLightSavingConfig+0x48>)
 80093e6:	6892      	ldr	r2, [r2, #8]
 80093e8:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80093ec:	609a      	str	r2, [r3, #8]

  /* Configure the RTC_CR register */
  RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
 80093ee:	4b08      	ldr	r3, [pc, #32]	; (8009410 <RTC_DayLightSavingConfig+0x48>)
 80093f0:	4a07      	ldr	r2, [pc, #28]	; (8009410 <RTC_DayLightSavingConfig+0x48>)
 80093f2:	6891      	ldr	r1, [r2, #8]
 80093f4:	6878      	ldr	r0, [r7, #4]
 80093f6:	683a      	ldr	r2, [r7, #0]
 80093f8:	4302      	orrs	r2, r0
 80093fa:	430a      	orrs	r2, r1
 80093fc:	609a      	str	r2, [r3, #8]

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 80093fe:	4b04      	ldr	r3, [pc, #16]	; (8009410 <RTC_DayLightSavingConfig+0x48>)
 8009400:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8009404:	625a      	str	r2, [r3, #36]	; 0x24
}
 8009406:	f107 070c 	add.w	r7, r7, #12
 800940a:	46bd      	mov	sp, r7
 800940c:	bc80      	pop	{r7}
 800940e:	4770      	bx	lr
 8009410:	40002800 	.word	0x40002800

08009414 <RTC_GetStoreOperation>:
  * @retval RTC Day Light Saving stored operation.
  *          - RTC_StoreOperation_Reset
  *          - RTC_StoreOperation_Set       
  */
uint32_t RTC_GetStoreOperation(void)
{
 8009414:	b480      	push	{r7}
 8009416:	af00      	add	r7, sp, #0
  return (RTC->CR & RTC_CR_BCK);
 8009418:	4b03      	ldr	r3, [pc, #12]	; (8009428 <RTC_GetStoreOperation+0x14>)
 800941a:	689b      	ldr	r3, [r3, #8]
 800941c:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
}
 8009420:	4618      	mov	r0, r3
 8009422:	46bd      	mov	sp, r7
 8009424:	bc80      	pop	{r7}
 8009426:	4770      	bx	lr
 8009428:	40002800 	.word	0x40002800

0800942c <RTC_OutputConfig>:
  *            @arg RTC_OutputPolarity_Low: The output pin is low when the 
  *                                 ALRAF/ALRBF/WUTF is high (depending on OSEL)
  * @retval None
  */
void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
{
 800942c:	b480      	push	{r7}
 800942e:	b083      	sub	sp, #12
 8009430:	af00      	add	r7, sp, #0
 8009432:	6078      	str	r0, [r7, #4]
 8009434:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_RTC_OUTPUT(RTC_Output));
  assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8009436:	4b0f      	ldr	r3, [pc, #60]	; (8009474 <RTC_OutputConfig+0x48>)
 8009438:	f04f 02ca 	mov.w	r2, #202	; 0xca
 800943c:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800943e:	4b0d      	ldr	r3, [pc, #52]	; (8009474 <RTC_OutputConfig+0x48>)
 8009440:	f04f 0253 	mov.w	r2, #83	; 0x53
 8009444:	625a      	str	r2, [r3, #36]	; 0x24

  /* Clear the bits to be configured */
  RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
 8009446:	4b0b      	ldr	r3, [pc, #44]	; (8009474 <RTC_OutputConfig+0x48>)
 8009448:	4a0a      	ldr	r2, [pc, #40]	; (8009474 <RTC_OutputConfig+0x48>)
 800944a:	6892      	ldr	r2, [r2, #8]
 800944c:	f422 02e0 	bic.w	r2, r2, #7340032	; 0x700000
 8009450:	609a      	str	r2, [r3, #8]

  /* Configure the output selection and polarity */
  RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
 8009452:	4b08      	ldr	r3, [pc, #32]	; (8009474 <RTC_OutputConfig+0x48>)
 8009454:	4a07      	ldr	r2, [pc, #28]	; (8009474 <RTC_OutputConfig+0x48>)
 8009456:	6891      	ldr	r1, [r2, #8]
 8009458:	6878      	ldr	r0, [r7, #4]
 800945a:	683a      	ldr	r2, [r7, #0]
 800945c:	4302      	orrs	r2, r0
 800945e:	430a      	orrs	r2, r1
 8009460:	609a      	str	r2, [r3, #8]

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8009462:	4b04      	ldr	r3, [pc, #16]	; (8009474 <RTC_OutputConfig+0x48>)
 8009464:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8009468:	625a      	str	r2, [r3, #36]	; 0x24
}
 800946a:	f107 070c 	add.w	r7, r7, #12
 800946e:	46bd      	mov	sp, r7
 8009470:	bc80      	pop	{r7}
 8009472:	4770      	bx	lr
 8009474:	40002800 	.word	0x40002800

08009478 <RTC_CoarseCalibConfig>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Coarse calibration are initialized
  *          - ERROR: RTC Coarse calibration are not initialized     
  */
ErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value)
{
 8009478:	b580      	push	{r7, lr}
 800947a:	b084      	sub	sp, #16
 800947c:	af00      	add	r7, sp, #0
 800947e:	6078      	str	r0, [r7, #4]
 8009480:	6039      	str	r1, [r7, #0]
  ErrorStatus status = ERROR;
 8009482:	f04f 0300 	mov.w	r3, #0
 8009486:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_RTC_CALIB_SIGN(RTC_CalibSign));
  assert_param(IS_RTC_CALIB_VALUE(Value)); 

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8009488:	4b12      	ldr	r3, [pc, #72]	; (80094d4 <RTC_CoarseCalibConfig+0x5c>)
 800948a:	f04f 02ca 	mov.w	r2, #202	; 0xca
 800948e:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8009490:	4b10      	ldr	r3, [pc, #64]	; (80094d4 <RTC_CoarseCalibConfig+0x5c>)
 8009492:	f04f 0253 	mov.w	r2, #83	; 0x53
 8009496:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 8009498:	f7ff fa02 	bl	80088a0 <RTC_EnterInitMode>
 800949c:	4603      	mov	r3, r0
 800949e:	2b00      	cmp	r3, #0
 80094a0:	d103      	bne.n	80094aa <RTC_CoarseCalibConfig+0x32>
  {
    status = ERROR;
 80094a2:	f04f 0300 	mov.w	r3, #0
 80094a6:	73fb      	strb	r3, [r7, #15]
 80094a8:	e009      	b.n	80094be <RTC_CoarseCalibConfig+0x46>
  } 
  else
  {
    /* Set the coarse calibration value */
    RTC->CALIBR = (uint32_t)(RTC_CalibSign | Value);
 80094aa:	4b0a      	ldr	r3, [pc, #40]	; (80094d4 <RTC_CoarseCalibConfig+0x5c>)
 80094ac:	6879      	ldr	r1, [r7, #4]
 80094ae:	683a      	ldr	r2, [r7, #0]
 80094b0:	430a      	orrs	r2, r1
 80094b2:	619a      	str	r2, [r3, #24]
    /* Exit Initialization mode */
    RTC_ExitInitMode();
 80094b4:	f7ff fa34 	bl	8008920 <RTC_ExitInitMode>
    
    status = SUCCESS;
 80094b8:	f04f 0301 	mov.w	r3, #1
 80094bc:	73fb      	strb	r3, [r7, #15]
  } 

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 80094be:	4b05      	ldr	r3, [pc, #20]	; (80094d4 <RTC_CoarseCalibConfig+0x5c>)
 80094c0:	f04f 02ff 	mov.w	r2, #255	; 0xff
 80094c4:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
 80094c6:	7bfb      	ldrb	r3, [r7, #15]
}
 80094c8:	4618      	mov	r0, r3
 80094ca:	f107 0710 	add.w	r7, r7, #16
 80094ce:	46bd      	mov	sp, r7
 80094d0:	bd80      	pop	{r7, pc}
 80094d2:	bf00      	nop
 80094d4:	40002800 	.word	0x40002800

080094d8 <RTC_CoarseCalibCmd>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Coarse calibration are enabled/disabled
  *          - ERROR: RTC Coarse calibration are not enabled/disabled    
  */
ErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState)
{
 80094d8:	b580      	push	{r7, lr}
 80094da:	b084      	sub	sp, #16
 80094dc:	af00      	add	r7, sp, #0
 80094de:	4603      	mov	r3, r0
 80094e0:	71fb      	strb	r3, [r7, #7]
  ErrorStatus status = ERROR;
 80094e2:	f04f 0300 	mov.w	r3, #0
 80094e6:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80094e8:	4b17      	ldr	r3, [pc, #92]	; (8009548 <RTC_CoarseCalibCmd+0x70>)
 80094ea:	f04f 02ca 	mov.w	r2, #202	; 0xca
 80094ee:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80094f0:	4b15      	ldr	r3, [pc, #84]	; (8009548 <RTC_CoarseCalibCmd+0x70>)
 80094f2:	f04f 0253 	mov.w	r2, #83	; 0x53
 80094f6:	625a      	str	r2, [r3, #36]	; 0x24
  
  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 80094f8:	f7ff f9d2 	bl	80088a0 <RTC_EnterInitMode>
 80094fc:	4603      	mov	r3, r0
 80094fe:	2b00      	cmp	r3, #0
 8009500:	d103      	bne.n	800950a <RTC_CoarseCalibCmd+0x32>
  {
    status =  ERROR;
 8009502:	f04f 0300 	mov.w	r3, #0
 8009506:	73fb      	strb	r3, [r7, #15]
 8009508:	e014      	b.n	8009534 <RTC_CoarseCalibCmd+0x5c>
  }
  else
  {
    if (NewState != DISABLE)
 800950a:	79fb      	ldrb	r3, [r7, #7]
 800950c:	2b00      	cmp	r3, #0
 800950e:	d006      	beq.n	800951e <RTC_CoarseCalibCmd+0x46>
    {
      /* Enable the Coarse Calibration */
      RTC->CR |= (uint32_t)RTC_CR_DCE;
 8009510:	4b0d      	ldr	r3, [pc, #52]	; (8009548 <RTC_CoarseCalibCmd+0x70>)
 8009512:	4a0d      	ldr	r2, [pc, #52]	; (8009548 <RTC_CoarseCalibCmd+0x70>)
 8009514:	6892      	ldr	r2, [r2, #8]
 8009516:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800951a:	609a      	str	r2, [r3, #8]
 800951c:	e005      	b.n	800952a <RTC_CoarseCalibCmd+0x52>
    }
    else
    { 
      /* Disable the Coarse Calibration */
      RTC->CR &= (uint32_t)~RTC_CR_DCE;
 800951e:	4b0a      	ldr	r3, [pc, #40]	; (8009548 <RTC_CoarseCalibCmd+0x70>)
 8009520:	4a09      	ldr	r2, [pc, #36]	; (8009548 <RTC_CoarseCalibCmd+0x70>)
 8009522:	6892      	ldr	r2, [r2, #8]
 8009524:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8009528:	609a      	str	r2, [r3, #8]
    }
    /* Exit Initialization mode */
    RTC_ExitInitMode();
 800952a:	f7ff f9f9 	bl	8008920 <RTC_ExitInitMode>
    
    status = SUCCESS;
 800952e:	f04f 0301 	mov.w	r3, #1
 8009532:	73fb      	strb	r3, [r7, #15]
  } 
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8009534:	4b04      	ldr	r3, [pc, #16]	; (8009548 <RTC_CoarseCalibCmd+0x70>)
 8009536:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800953a:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
 800953c:	7bfb      	ldrb	r3, [r7, #15]
}
 800953e:	4618      	mov	r0, r3
 8009540:	f107 0710 	add.w	r7, r7, #16
 8009544:	46bd      	mov	sp, r7
 8009546:	bd80      	pop	{r7, pc}
 8009548:	40002800 	.word	0x40002800

0800954c <RTC_CalibOutputCmd>:
  * @param  NewState: new state of the digital calibration Output.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_CalibOutputCmd(FunctionalState NewState)
{
 800954c:	b480      	push	{r7}
 800954e:	b083      	sub	sp, #12
 8009550:	af00      	add	r7, sp, #0
 8009552:	4603      	mov	r3, r0
 8009554:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8009556:	4b10      	ldr	r3, [pc, #64]	; (8009598 <RTC_CalibOutputCmd+0x4c>)
 8009558:	f04f 02ca 	mov.w	r2, #202	; 0xca
 800955c:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800955e:	4b0e      	ldr	r3, [pc, #56]	; (8009598 <RTC_CalibOutputCmd+0x4c>)
 8009560:	f04f 0253 	mov.w	r2, #83	; 0x53
 8009564:	625a      	str	r2, [r3, #36]	; 0x24
  
  if (NewState != DISABLE)
 8009566:	79fb      	ldrb	r3, [r7, #7]
 8009568:	2b00      	cmp	r3, #0
 800956a:	d006      	beq.n	800957a <RTC_CalibOutputCmd+0x2e>
  {
    /* Enable the RTC clock output */
    RTC->CR |= (uint32_t)RTC_CR_COE;
 800956c:	4b0a      	ldr	r3, [pc, #40]	; (8009598 <RTC_CalibOutputCmd+0x4c>)
 800956e:	4a0a      	ldr	r2, [pc, #40]	; (8009598 <RTC_CalibOutputCmd+0x4c>)
 8009570:	6892      	ldr	r2, [r2, #8]
 8009572:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 8009576:	609a      	str	r2, [r3, #8]
 8009578:	e005      	b.n	8009586 <RTC_CalibOutputCmd+0x3a>
  }
  else
  { 
    /* Disable the RTC clock output */
    RTC->CR &= (uint32_t)~RTC_CR_COE;
 800957a:	4b07      	ldr	r3, [pc, #28]	; (8009598 <RTC_CalibOutputCmd+0x4c>)
 800957c:	4a06      	ldr	r2, [pc, #24]	; (8009598 <RTC_CalibOutputCmd+0x4c>)
 800957e:	6892      	ldr	r2, [r2, #8]
 8009580:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 8009584:	609a      	str	r2, [r3, #8]
  }
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8009586:	4b04      	ldr	r3, [pc, #16]	; (8009598 <RTC_CalibOutputCmd+0x4c>)
 8009588:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800958c:	625a      	str	r2, [r3, #36]	; 0x24
}
 800958e:	f107 070c 	add.w	r7, r7, #12
 8009592:	46bd      	mov	sp, r7
 8009594:	bc80      	pop	{r7}
 8009596:	4770      	bx	lr
 8009598:	40002800 	.word	0x40002800

0800959c <RTC_CalibOutputConfig>:
  *     @arg RTC_CalibOutput_512Hz: A signal has a regular waveform at 512Hz. 
  *     @arg RTC_CalibOutput_1Hz  : A signal has a regular waveform at 1Hz.
  * @retval None
*/
void RTC_CalibOutputConfig(uint32_t RTC_CalibOutput)
{
 800959c:	b480      	push	{r7}
 800959e:	b083      	sub	sp, #12
 80095a0:	af00      	add	r7, sp, #0
 80095a2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_CALIB_OUTPUT(RTC_CalibOutput));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80095a4:	4b0e      	ldr	r3, [pc, #56]	; (80095e0 <RTC_CalibOutputConfig+0x44>)
 80095a6:	f04f 02ca 	mov.w	r2, #202	; 0xca
 80095aa:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80095ac:	4b0c      	ldr	r3, [pc, #48]	; (80095e0 <RTC_CalibOutputConfig+0x44>)
 80095ae:	f04f 0253 	mov.w	r2, #83	; 0x53
 80095b2:	625a      	str	r2, [r3, #36]	; 0x24
  
  /*clear flags before config*/
  RTC->CR &= (uint32_t)~(RTC_CR_COSEL);
 80095b4:	4b0a      	ldr	r3, [pc, #40]	; (80095e0 <RTC_CalibOutputConfig+0x44>)
 80095b6:	4a0a      	ldr	r2, [pc, #40]	; (80095e0 <RTC_CalibOutputConfig+0x44>)
 80095b8:	6892      	ldr	r2, [r2, #8]
 80095ba:	f422 2200 	bic.w	r2, r2, #524288	; 0x80000
 80095be:	609a      	str	r2, [r3, #8]

  /* Configure the RTC_CR register */
  RTC->CR |= (uint32_t)RTC_CalibOutput;
 80095c0:	4b07      	ldr	r3, [pc, #28]	; (80095e0 <RTC_CalibOutputConfig+0x44>)
 80095c2:	4a07      	ldr	r2, [pc, #28]	; (80095e0 <RTC_CalibOutputConfig+0x44>)
 80095c4:	6891      	ldr	r1, [r2, #8]
 80095c6:	687a      	ldr	r2, [r7, #4]
 80095c8:	430a      	orrs	r2, r1
 80095ca:	609a      	str	r2, [r3, #8]

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 80095cc:	4b04      	ldr	r3, [pc, #16]	; (80095e0 <RTC_CalibOutputConfig+0x44>)
 80095ce:	f04f 02ff 	mov.w	r2, #255	; 0xff
 80095d2:	625a      	str	r2, [r3, #36]	; 0x24
}
 80095d4:	f107 070c 	add.w	r7, r7, #12
 80095d8:	46bd      	mov	sp, r7
 80095da:	bc80      	pop	{r7}
 80095dc:	4770      	bx	lr
 80095de:	bf00      	nop
 80095e0:	40002800 	.word	0x40002800

080095e4 <RTC_SmoothCalibConfig>:
  *          - ERROR: RTC Calib registers are not configured
*/
ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
                                  uint32_t RTC_SmoothCalibPlusPulses,
                                  uint32_t RTC_SmouthCalibMinusPulsesValue)
{
 80095e4:	b480      	push	{r7}
 80095e6:	b087      	sub	sp, #28
 80095e8:	af00      	add	r7, sp, #0
 80095ea:	60f8      	str	r0, [r7, #12]
 80095ec:	60b9      	str	r1, [r7, #8]
 80095ee:	607a      	str	r2, [r7, #4]
  ErrorStatus status = ERROR;
 80095f0:	f04f 0300 	mov.w	r3, #0
 80095f4:	75fb      	strb	r3, [r7, #23]
  uint32_t recalpfcount = 0;
 80095f6:	f04f 0300 	mov.w	r3, #0
 80095fa:	613b      	str	r3, [r7, #16]
  assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
  assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
  assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80095fc:	4b1d      	ldr	r3, [pc, #116]	; (8009674 <RTC_SmoothCalibConfig+0x90>)
 80095fe:	f04f 02ca 	mov.w	r2, #202	; 0xca
 8009602:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8009604:	4b1b      	ldr	r3, [pc, #108]	; (8009674 <RTC_SmoothCalibConfig+0x90>)
 8009606:	f04f 0253 	mov.w	r2, #83	; 0x53
 800960a:	625a      	str	r2, [r3, #36]	; 0x24
  
  /* check if a calibration is pending*/
  if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
 800960c:	4b19      	ldr	r3, [pc, #100]	; (8009674 <RTC_SmoothCalibConfig+0x90>)
 800960e:	68db      	ldr	r3, [r3, #12]
 8009610:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8009614:	2b00      	cmp	r3, #0
 8009616:	d00e      	beq.n	8009636 <RTC_SmoothCalibConfig+0x52>
  {
    /* wait until the Calibration is completed*/
    while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
 8009618:	e003      	b.n	8009622 <RTC_SmoothCalibConfig+0x3e>
    {
      recalpfcount++;
 800961a:	693b      	ldr	r3, [r7, #16]
 800961c:	f103 0301 	add.w	r3, r3, #1
 8009620:	613b      	str	r3, [r7, #16]
  
  /* check if a calibration is pending*/
  if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
  {
    /* wait until the Calibration is completed*/
    while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
 8009622:	4b14      	ldr	r3, [pc, #80]	; (8009674 <RTC_SmoothCalibConfig+0x90>)
 8009624:	68db      	ldr	r3, [r3, #12]
 8009626:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800962a:	2b00      	cmp	r3, #0
 800962c:	d003      	beq.n	8009636 <RTC_SmoothCalibConfig+0x52>
 800962e:	693b      	ldr	r3, [r7, #16]
 8009630:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8009634:	d1f1      	bne.n	800961a <RTC_SmoothCalibConfig+0x36>
      recalpfcount++;
    }
  }

  /* check if the calibration pending is completed or if there is no calibration operation at all*/
  if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
 8009636:	4b0f      	ldr	r3, [pc, #60]	; (8009674 <RTC_SmoothCalibConfig+0x90>)
 8009638:	68db      	ldr	r3, [r3, #12]
 800963a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800963e:	2b00      	cmp	r3, #0
 8009640:	d10a      	bne.n	8009658 <RTC_SmoothCalibConfig+0x74>
  {
    /* Configure the Smooth calibration settings */
    RTC->CALR = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | (uint32_t)RTC_SmouthCalibMinusPulsesValue);
 8009642:	4b0c      	ldr	r3, [pc, #48]	; (8009674 <RTC_SmoothCalibConfig+0x90>)
 8009644:	68f9      	ldr	r1, [r7, #12]
 8009646:	68ba      	ldr	r2, [r7, #8]
 8009648:	4311      	orrs	r1, r2
 800964a:	687a      	ldr	r2, [r7, #4]
 800964c:	430a      	orrs	r2, r1
 800964e:	63da      	str	r2, [r3, #60]	; 0x3c

    status = SUCCESS;
 8009650:	f04f 0301 	mov.w	r3, #1
 8009654:	75fb      	strb	r3, [r7, #23]
 8009656:	e002      	b.n	800965e <RTC_SmoothCalibConfig+0x7a>
  }
  else
  {
    status = ERROR;
 8009658:	f04f 0300 	mov.w	r3, #0
 800965c:	75fb      	strb	r3, [r7, #23]
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 800965e:	4b05      	ldr	r3, [pc, #20]	; (8009674 <RTC_SmoothCalibConfig+0x90>)
 8009660:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8009664:	625a      	str	r2, [r3, #36]	; 0x24
  
  return (ErrorStatus)(status);
 8009666:	7dfb      	ldrb	r3, [r7, #23]
}
 8009668:	4618      	mov	r0, r3
 800966a:	f107 071c 	add.w	r7, r7, #28
 800966e:	46bd      	mov	sp, r7
 8009670:	bc80      	pop	{r7}
 8009672:	4770      	bx	lr
 8009674:	40002800 	.word	0x40002800

08009678 <RTC_TimeStampCmd>:
  * @param  NewState: new state of the TimeStamp.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
{
 8009678:	b480      	push	{r7}
 800967a:	b085      	sub	sp, #20
 800967c:	af00      	add	r7, sp, #0
 800967e:	6078      	str	r0, [r7, #4]
 8009680:	460b      	mov	r3, r1
 8009682:	70fb      	strb	r3, [r7, #3]
  uint32_t tmpreg = 0;
 8009684:	f04f 0300 	mov.w	r3, #0
 8009688:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Get the RTC_CR register and clear the bits to be configured */
  tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
 800968a:	4b14      	ldr	r3, [pc, #80]	; (80096dc <RTC_TimeStampCmd+0x64>)
 800968c:	689b      	ldr	r3, [r3, #8]
 800968e:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8009692:	f023 0308 	bic.w	r3, r3, #8
 8009696:	60fb      	str	r3, [r7, #12]

  /* Get the new configuration */
  if (NewState != DISABLE)
 8009698:	78fb      	ldrb	r3, [r7, #3]
 800969a:	2b00      	cmp	r3, #0
 800969c:	d006      	beq.n	80096ac <RTC_TimeStampCmd+0x34>
  {
    tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
 800969e:	687a      	ldr	r2, [r7, #4]
 80096a0:	68fb      	ldr	r3, [r7, #12]
 80096a2:	4313      	orrs	r3, r2
 80096a4:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80096a8:	60fb      	str	r3, [r7, #12]
 80096aa:	e003      	b.n	80096b4 <RTC_TimeStampCmd+0x3c>
  }
  else
  {
    tmpreg |= (uint32_t)(RTC_TimeStampEdge);
 80096ac:	68fa      	ldr	r2, [r7, #12]
 80096ae:	687b      	ldr	r3, [r7, #4]
 80096b0:	4313      	orrs	r3, r2
 80096b2:	60fb      	str	r3, [r7, #12]
  }

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80096b4:	4b09      	ldr	r3, [pc, #36]	; (80096dc <RTC_TimeStampCmd+0x64>)
 80096b6:	f04f 02ca 	mov.w	r2, #202	; 0xca
 80096ba:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80096bc:	4b07      	ldr	r3, [pc, #28]	; (80096dc <RTC_TimeStampCmd+0x64>)
 80096be:	f04f 0253 	mov.w	r2, #83	; 0x53
 80096c2:	625a      	str	r2, [r3, #36]	; 0x24

  /* Configure the Time Stamp TSEDGE and Enable bits */
  RTC->CR = (uint32_t)tmpreg;
 80096c4:	4b05      	ldr	r3, [pc, #20]	; (80096dc <RTC_TimeStampCmd+0x64>)
 80096c6:	68fa      	ldr	r2, [r7, #12]
 80096c8:	609a      	str	r2, [r3, #8]

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 80096ca:	4b04      	ldr	r3, [pc, #16]	; (80096dc <RTC_TimeStampCmd+0x64>)
 80096cc:	f04f 02ff 	mov.w	r2, #255	; 0xff
 80096d0:	625a      	str	r2, [r3, #36]	; 0x24
}
 80096d2:	f107 0714 	add.w	r7, r7, #20
 80096d6:	46bd      	mov	sp, r7
 80096d8:	bc80      	pop	{r7}
 80096da:	4770      	bx	lr
 80096dc:	40002800 	.word	0x40002800

080096e0 <RTC_GetTimeStamp>:
  *                             contains the TimeStamp date values.     
  * @retval None
  */
void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
                                      RTC_DateTypeDef* RTC_StampDateStruct)
{
 80096e0:	b580      	push	{r7, lr}
 80096e2:	b086      	sub	sp, #24
 80096e4:	af00      	add	r7, sp, #0
 80096e6:	60f8      	str	r0, [r7, #12]
 80096e8:	60b9      	str	r1, [r7, #8]
 80096ea:	607a      	str	r2, [r7, #4]
  uint32_t tmptime = 0, tmpdate = 0;
 80096ec:	f04f 0300 	mov.w	r3, #0
 80096f0:	617b      	str	r3, [r7, #20]
 80096f2:	f04f 0300 	mov.w	r3, #0
 80096f6:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));

  /* Get the TimeStamp time and date registers values */
  tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
 80096f8:	4b42      	ldr	r3, [pc, #264]	; (8009804 <RTC_GetTimeStamp+0x124>)
 80096fa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80096fc:	f003 337f 	and.w	r3, r3, #2139062143	; 0x7f7f7f7f
 8009700:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8009704:	617b      	str	r3, [r7, #20]
  tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
 8009706:	4b3f      	ldr	r3, [pc, #252]	; (8009804 <RTC_GetTimeStamp+0x124>)
 8009708:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800970a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800970e:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8009712:	613b      	str	r3, [r7, #16]

  /* Fill the Time structure fields with the read parameters */
  RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8009714:	697b      	ldr	r3, [r7, #20]
 8009716:	f403 137c 	and.w	r3, r3, #4128768	; 0x3f0000
 800971a:	ea4f 4313 	mov.w	r3, r3, lsr #16
 800971e:	b2da      	uxtb	r2, r3
 8009720:	68bb      	ldr	r3, [r7, #8]
 8009722:	701a      	strb	r2, [r3, #0]
  RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
 8009724:	697b      	ldr	r3, [r7, #20]
 8009726:	f403 43fe 	and.w	r3, r3, #32512	; 0x7f00
 800972a:	ea4f 2313 	mov.w	r3, r3, lsr #8
 800972e:	b2da      	uxtb	r2, r3
 8009730:	68bb      	ldr	r3, [r7, #8]
 8009732:	705a      	strb	r2, [r3, #1]
  RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
 8009734:	697b      	ldr	r3, [r7, #20]
 8009736:	b2db      	uxtb	r3, r3
 8009738:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800973c:	b2da      	uxtb	r2, r3
 800973e:	68bb      	ldr	r3, [r7, #8]
 8009740:	709a      	strb	r2, [r3, #2]
  RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
 8009742:	697b      	ldr	r3, [r7, #20]
 8009744:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8009748:	ea4f 4313 	mov.w	r3, r3, lsr #16
 800974c:	b2da      	uxtb	r2, r3
 800974e:	68bb      	ldr	r3, [r7, #8]
 8009750:	70da      	strb	r2, [r3, #3]

  /* Fill the Date structure fields with the read parameters */
  RTC_StampDateStruct->RTC_Year = 0;
 8009752:	687b      	ldr	r3, [r7, #4]
 8009754:	f04f 0200 	mov.w	r2, #0
 8009758:	70da      	strb	r2, [r3, #3]
  RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 800975a:	693b      	ldr	r3, [r7, #16]
 800975c:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
 8009760:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8009764:	b2da      	uxtb	r2, r3
 8009766:	687b      	ldr	r3, [r7, #4]
 8009768:	705a      	strb	r2, [r3, #1]
  RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
 800976a:	693b      	ldr	r3, [r7, #16]
 800976c:	b2db      	uxtb	r3, r3
 800976e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8009772:	b2da      	uxtb	r2, r3
 8009774:	687b      	ldr	r3, [r7, #4]
 8009776:	709a      	strb	r2, [r3, #2]
  RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
 8009778:	693b      	ldr	r3, [r7, #16]
 800977a:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 800977e:	ea4f 3353 	mov.w	r3, r3, lsr #13
 8009782:	b2da      	uxtb	r2, r3
 8009784:	687b      	ldr	r3, [r7, #4]
 8009786:	701a      	strb	r2, [r3, #0]

  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
 8009788:	68fb      	ldr	r3, [r7, #12]
 800978a:	2b00      	cmp	r3, #0
 800978c:	d135      	bne.n	80097fa <RTC_GetTimeStamp+0x11a>
  {
    /* Convert the Time structure parameters to Binary format */
    RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
 800978e:	68bb      	ldr	r3, [r7, #8]
 8009790:	781b      	ldrb	r3, [r3, #0]
 8009792:	4618      	mov	r0, r3
 8009794:	f000 fae0 	bl	8009d58 <RTC_Bcd2ToByte>
 8009798:	4603      	mov	r3, r0
 800979a:	461a      	mov	r2, r3
 800979c:	68bb      	ldr	r3, [r7, #8]
 800979e:	701a      	strb	r2, [r3, #0]
    RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
 80097a0:	68bb      	ldr	r3, [r7, #8]
 80097a2:	785b      	ldrb	r3, [r3, #1]
 80097a4:	4618      	mov	r0, r3
 80097a6:	f000 fad7 	bl	8009d58 <RTC_Bcd2ToByte>
 80097aa:	4603      	mov	r3, r0
 80097ac:	461a      	mov	r2, r3
 80097ae:	68bb      	ldr	r3, [r7, #8]
 80097b0:	705a      	strb	r2, [r3, #1]
    RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
 80097b2:	68bb      	ldr	r3, [r7, #8]
 80097b4:	789b      	ldrb	r3, [r3, #2]
 80097b6:	4618      	mov	r0, r3
 80097b8:	f000 face 	bl	8009d58 <RTC_Bcd2ToByte>
 80097bc:	4603      	mov	r3, r0
 80097be:	461a      	mov	r2, r3
 80097c0:	68bb      	ldr	r3, [r7, #8]
 80097c2:	709a      	strb	r2, [r3, #2]

    /* Convert the Date structure parameters to Binary format */
    RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
 80097c4:	687b      	ldr	r3, [r7, #4]
 80097c6:	785b      	ldrb	r3, [r3, #1]
 80097c8:	4618      	mov	r0, r3
 80097ca:	f000 fac5 	bl	8009d58 <RTC_Bcd2ToByte>
 80097ce:	4603      	mov	r3, r0
 80097d0:	461a      	mov	r2, r3
 80097d2:	687b      	ldr	r3, [r7, #4]
 80097d4:	705a      	strb	r2, [r3, #1]
    RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
 80097d6:	687b      	ldr	r3, [r7, #4]
 80097d8:	789b      	ldrb	r3, [r3, #2]
 80097da:	4618      	mov	r0, r3
 80097dc:	f000 fabc 	bl	8009d58 <RTC_Bcd2ToByte>
 80097e0:	4603      	mov	r3, r0
 80097e2:	461a      	mov	r2, r3
 80097e4:	687b      	ldr	r3, [r7, #4]
 80097e6:	709a      	strb	r2, [r3, #2]
    RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
 80097e8:	687b      	ldr	r3, [r7, #4]
 80097ea:	781b      	ldrb	r3, [r3, #0]
 80097ec:	4618      	mov	r0, r3
 80097ee:	f000 fab3 	bl	8009d58 <RTC_Bcd2ToByte>
 80097f2:	4603      	mov	r3, r0
 80097f4:	461a      	mov	r2, r3
 80097f6:	687b      	ldr	r3, [r7, #4]
 80097f8:	701a      	strb	r2, [r3, #0]
  }
}
 80097fa:	f107 0718 	add.w	r7, r7, #24
 80097fe:	46bd      	mov	sp, r7
 8009800:	bd80      	pop	{r7, pc}
 8009802:	bf00      	nop
 8009804:	40002800 	.word	0x40002800

08009808 <RTC_GetTimeStampSubSecond>:
  * @brief  Get the RTC timestamp Subseconds value.
  * @param  None
  * @retval RTC current timestamp Subseconds value.
  */
uint32_t RTC_GetTimeStampSubSecond(void)
{
 8009808:	b480      	push	{r7}
 800980a:	af00      	add	r7, sp, #0
  /* Get timestamp subseconds values from the correspondent registers */
  return (uint32_t)(RTC->TSSSR);
 800980c:	4b02      	ldr	r3, [pc, #8]	; (8009818 <RTC_GetTimeStampSubSecond+0x10>)
 800980e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
}
 8009810:	4618      	mov	r0, r3
 8009812:	46bd      	mov	sp, r7
 8009814:	bc80      	pop	{r7}
 8009816:	4770      	bx	lr
 8009818:	40002800 	.word	0x40002800

0800981c <RTC_TamperTriggerConfig>:
  *     @arg RTC_TamperTrigger_LowLevel: Low Level of the tamper pin causes tamper event.
  *     @arg RTC_TamperTrigger_HighLevel: High Level of the tamper pin causes tamper event.
  * @retval None
  */
void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
{
 800981c:	b480      	push	{r7}
 800981e:	b083      	sub	sp, #12
 8009820:	af00      	add	r7, sp, #0
 8009822:	6078      	str	r0, [r7, #4]
 8009824:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
  assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
 
  if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
 8009826:	683b      	ldr	r3, [r7, #0]
 8009828:	2b00      	cmp	r3, #0
 800982a:	d10a      	bne.n	8009842 <RTC_TamperTriggerConfig+0x26>
  {  
    /* Configure the RTC_TAFCR register */
    RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
 800982c:	4b0b      	ldr	r3, [pc, #44]	; (800985c <RTC_TamperTriggerConfig+0x40>)
 800982e:	4a0b      	ldr	r2, [pc, #44]	; (800985c <RTC_TamperTriggerConfig+0x40>)
 8009830:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8009832:	687a      	ldr	r2, [r7, #4]
 8009834:	ea4f 0242 	mov.w	r2, r2, lsl #1
 8009838:	ea6f 0202 	mvn.w	r2, r2
 800983c:	400a      	ands	r2, r1
 800983e:	641a      	str	r2, [r3, #64]	; 0x40
 8009840:	e007      	b.n	8009852 <RTC_TamperTriggerConfig+0x36>
  }
  else
  { 
    /* Configure the RTC_TAFCR register */
    RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
 8009842:	4b06      	ldr	r3, [pc, #24]	; (800985c <RTC_TamperTriggerConfig+0x40>)
 8009844:	4a05      	ldr	r2, [pc, #20]	; (800985c <RTC_TamperTriggerConfig+0x40>)
 8009846:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8009848:	687a      	ldr	r2, [r7, #4]
 800984a:	ea4f 0242 	mov.w	r2, r2, lsl #1
 800984e:	430a      	orrs	r2, r1
 8009850:	641a      	str	r2, [r3, #64]	; 0x40
  }  
}
 8009852:	f107 070c 	add.w	r7, r7, #12
 8009856:	46bd      	mov	sp, r7
 8009858:	bc80      	pop	{r7}
 800985a:	4770      	bx	lr
 800985c:	40002800 	.word	0x40002800

08009860 <RTC_TamperCmd>:
  * @param  NewState: new state of the tamper pin.
  *          This parameter can be: ENABLE or DISABLE.                   
  * @retval None
  */
void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
{
 8009860:	b480      	push	{r7}
 8009862:	b083      	sub	sp, #12
 8009864:	af00      	add	r7, sp, #0
 8009866:	6078      	str	r0, [r7, #4]
 8009868:	460b      	mov	r3, r1
 800986a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER(RTC_Tamper));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800986c:	78fb      	ldrb	r3, [r7, #3]
 800986e:	2b00      	cmp	r3, #0
 8009870:	d006      	beq.n	8009880 <RTC_TamperCmd+0x20>
  {
    /* Enable the selected Tamper pin */
    RTC->TAFCR |= (uint32_t)RTC_Tamper;
 8009872:	4b0a      	ldr	r3, [pc, #40]	; (800989c <RTC_TamperCmd+0x3c>)
 8009874:	4a09      	ldr	r2, [pc, #36]	; (800989c <RTC_TamperCmd+0x3c>)
 8009876:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8009878:	687a      	ldr	r2, [r7, #4]
 800987a:	430a      	orrs	r2, r1
 800987c:	641a      	str	r2, [r3, #64]	; 0x40
 800987e:	e007      	b.n	8009890 <RTC_TamperCmd+0x30>
  }
  else
  {
    /* Disable the selected Tamper pin */
    RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
 8009880:	4b06      	ldr	r3, [pc, #24]	; (800989c <RTC_TamperCmd+0x3c>)
 8009882:	4a06      	ldr	r2, [pc, #24]	; (800989c <RTC_TamperCmd+0x3c>)
 8009884:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8009886:	687a      	ldr	r2, [r7, #4]
 8009888:	ea6f 0202 	mvn.w	r2, r2
 800988c:	400a      	ands	r2, r1
 800988e:	641a      	str	r2, [r3, #64]	; 0x40
  }  
}
 8009890:	f107 070c 	add.w	r7, r7, #12
 8009894:	46bd      	mov	sp, r7
 8009896:	bc80      	pop	{r7}
 8009898:	4770      	bx	lr
 800989a:	bf00      	nop
 800989c:	40002800 	.word	0x40002800

080098a0 <RTC_TamperFilterConfig>:
  *     @arg RTC_TamperFilter_8Sample: Tamper is activated after 8 consecutive 
  *                                    samples at the active level 
  * @retval None
  */
void RTC_TamperFilterConfig(uint32_t RTC_TamperFilter)
{
 80098a0:	b480      	push	{r7}
 80098a2:	b083      	sub	sp, #12
 80098a4:	af00      	add	r7, sp, #0
 80098a6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
   
  /* Clear TAMPFLT[1:0] bits in the RTC_TAFCR register */
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);
 80098a8:	4b08      	ldr	r3, [pc, #32]	; (80098cc <RTC_TamperFilterConfig+0x2c>)
 80098aa:	4a08      	ldr	r2, [pc, #32]	; (80098cc <RTC_TamperFilterConfig+0x2c>)
 80098ac:	6c12      	ldr	r2, [r2, #64]	; 0x40
 80098ae:	f422 52c0 	bic.w	r2, r2, #6144	; 0x1800
 80098b2:	641a      	str	r2, [r3, #64]	; 0x40

  /* Configure the RTC_TAFCR register */
  RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
 80098b4:	4b05      	ldr	r3, [pc, #20]	; (80098cc <RTC_TamperFilterConfig+0x2c>)
 80098b6:	4a05      	ldr	r2, [pc, #20]	; (80098cc <RTC_TamperFilterConfig+0x2c>)
 80098b8:	6c11      	ldr	r1, [r2, #64]	; 0x40
 80098ba:	687a      	ldr	r2, [r7, #4]
 80098bc:	430a      	orrs	r2, r1
 80098be:	641a      	str	r2, [r3, #64]	; 0x40
}
 80098c0:	f107 070c 	add.w	r7, r7, #12
 80098c4:	46bd      	mov	sp, r7
 80098c6:	bc80      	pop	{r7}
 80098c8:	4770      	bx	lr
 80098ca:	bf00      	nop
 80098cc:	40002800 	.word	0x40002800

080098d0 <RTC_TamperSamplingFreqConfig>:
  *     @arg RTC_TamperSamplingFreq_RTCCLK_Div256: Each of the tamper inputs are sampled
  *                                           with a frequency =  RTCCLK / 256  
  * @retval None
  */
void RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq)
{
 80098d0:	b480      	push	{r7}
 80098d2:	b083      	sub	sp, #12
 80098d4:	af00      	add	r7, sp, #0
 80098d6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
 
  /* Clear TAMPFREQ[2:0] bits in the RTC_TAFCR register */
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);
 80098d8:	4b08      	ldr	r3, [pc, #32]	; (80098fc <RTC_TamperSamplingFreqConfig+0x2c>)
 80098da:	4a08      	ldr	r2, [pc, #32]	; (80098fc <RTC_TamperSamplingFreqConfig+0x2c>)
 80098dc:	6c12      	ldr	r2, [r2, #64]	; 0x40
 80098de:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 80098e2:	641a      	str	r2, [r3, #64]	; 0x40

  /* Configure the RTC_TAFCR register */
  RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
 80098e4:	4b05      	ldr	r3, [pc, #20]	; (80098fc <RTC_TamperSamplingFreqConfig+0x2c>)
 80098e6:	4a05      	ldr	r2, [pc, #20]	; (80098fc <RTC_TamperSamplingFreqConfig+0x2c>)
 80098e8:	6c11      	ldr	r1, [r2, #64]	; 0x40
 80098ea:	687a      	ldr	r2, [r7, #4]
 80098ec:	430a      	orrs	r2, r1
 80098ee:	641a      	str	r2, [r3, #64]	; 0x40
}
 80098f0:	f107 070c 	add.w	r7, r7, #12
 80098f4:	46bd      	mov	sp, r7
 80098f6:	bc80      	pop	{r7}
 80098f8:	4770      	bx	lr
 80098fa:	bf00      	nop
 80098fc:	40002800 	.word	0x40002800

08009900 <RTC_TamperPinsPrechargeDuration>:
  *     @arg RTC_TamperPrechargeDuration_4RTCCLK: Tamper pins are pre-charged before sampling during 4 RTCCLK cycle    
  *     @arg RTC_TamperPrechargeDuration_8RTCCLK: Tamper pins are pre-charged before sampling during 8 RTCCLK cycle
  * @retval None
  */
void RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration)
{
 8009900:	b480      	push	{r7}
 8009902:	b083      	sub	sp, #12
 8009904:	af00      	add	r7, sp, #0
 8009906:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(RTC_TamperPrechargeDuration));
   
  /* Clear TAMPPRCH[1:0] bits in the RTC_TAFCR register */
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);
 8009908:	4b08      	ldr	r3, [pc, #32]	; (800992c <RTC_TamperPinsPrechargeDuration+0x2c>)
 800990a:	4a08      	ldr	r2, [pc, #32]	; (800992c <RTC_TamperPinsPrechargeDuration+0x2c>)
 800990c:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800990e:	f422 42c0 	bic.w	r2, r2, #24576	; 0x6000
 8009912:	641a      	str	r2, [r3, #64]	; 0x40

  /* Configure the RTC_TAFCR register */
  RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
 8009914:	4b05      	ldr	r3, [pc, #20]	; (800992c <RTC_TamperPinsPrechargeDuration+0x2c>)
 8009916:	4a05      	ldr	r2, [pc, #20]	; (800992c <RTC_TamperPinsPrechargeDuration+0x2c>)
 8009918:	6c11      	ldr	r1, [r2, #64]	; 0x40
 800991a:	687a      	ldr	r2, [r7, #4]
 800991c:	430a      	orrs	r2, r1
 800991e:	641a      	str	r2, [r3, #64]	; 0x40
}
 8009920:	f107 070c 	add.w	r7, r7, #12
 8009924:	46bd      	mov	sp, r7
 8009926:	bc80      	pop	{r7}
 8009928:	4770      	bx	lr
 800992a:	bf00      	nop
 800992c:	40002800 	.word	0x40002800

08009930 <RTC_TimeStampOnTamperDetectionCmd>:
  * @param  NewState: new state of the timestamp on tamper event.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
{
 8009930:	b480      	push	{r7}
 8009932:	b083      	sub	sp, #12
 8009934:	af00      	add	r7, sp, #0
 8009936:	4603      	mov	r3, r0
 8009938:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
   
  if (NewState != DISABLE)
 800993a:	79fb      	ldrb	r3, [r7, #7]
 800993c:	2b00      	cmp	r3, #0
 800993e:	d006      	beq.n	800994e <RTC_TimeStampOnTamperDetectionCmd+0x1e>
  {
    /* Save timestamp on tamper detection event */
    RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
 8009940:	4b08      	ldr	r3, [pc, #32]	; (8009964 <RTC_TimeStampOnTamperDetectionCmd+0x34>)
 8009942:	4a08      	ldr	r2, [pc, #32]	; (8009964 <RTC_TimeStampOnTamperDetectionCmd+0x34>)
 8009944:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8009946:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800994a:	641a      	str	r2, [r3, #64]	; 0x40
 800994c:	e005      	b.n	800995a <RTC_TimeStampOnTamperDetectionCmd+0x2a>
  }
  else
  {
    /* Tamper detection does not cause a timestamp to be saved */
    RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
 800994e:	4b05      	ldr	r3, [pc, #20]	; (8009964 <RTC_TimeStampOnTamperDetectionCmd+0x34>)
 8009950:	4a04      	ldr	r2, [pc, #16]	; (8009964 <RTC_TimeStampOnTamperDetectionCmd+0x34>)
 8009952:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8009954:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8009958:	641a      	str	r2, [r3, #64]	; 0x40
  }
}
 800995a:	f107 070c 	add.w	r7, r7, #12
 800995e:	46bd      	mov	sp, r7
 8009960:	bc80      	pop	{r7}
 8009962:	4770      	bx	lr
 8009964:	40002800 	.word	0x40002800

08009968 <RTC_TamperPullUpCmd>:
  * @param  NewState: new state of tamper pull up.
  *   This parameter can be: ENABLE or DISABLE.                   
  * @retval None
  */
void RTC_TamperPullUpCmd(FunctionalState NewState)
{
 8009968:	b480      	push	{r7}
 800996a:	b083      	sub	sp, #12
 800996c:	af00      	add	r7, sp, #0
 800996e:	4603      	mov	r3, r0
 8009970:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
 if (NewState != DISABLE)
 8009972:	79fb      	ldrb	r3, [r7, #7]
 8009974:	2b00      	cmp	r3, #0
 8009976:	d006      	beq.n	8009986 <RTC_TamperPullUpCmd+0x1e>
  {
    /* Enable precharge of the selected Tamper pin */
    RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
 8009978:	4b08      	ldr	r3, [pc, #32]	; (800999c <RTC_TamperPullUpCmd+0x34>)
 800997a:	4a08      	ldr	r2, [pc, #32]	; (800999c <RTC_TamperPullUpCmd+0x34>)
 800997c:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800997e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8009982:	641a      	str	r2, [r3, #64]	; 0x40
 8009984:	e005      	b.n	8009992 <RTC_TamperPullUpCmd+0x2a>
  }
  else
  {
    /* Disable precharge of the selected Tamper pin */
    RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
 8009986:	4b05      	ldr	r3, [pc, #20]	; (800999c <RTC_TamperPullUpCmd+0x34>)
 8009988:	4a04      	ldr	r2, [pc, #16]	; (800999c <RTC_TamperPullUpCmd+0x34>)
 800998a:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800998c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8009990:	641a      	str	r2, [r3, #64]	; 0x40
  } 
}
 8009992:	f107 070c 	add.w	r7, r7, #12
 8009996:	46bd      	mov	sp, r7
 8009998:	bc80      	pop	{r7}
 800999a:	4770      	bx	lr
 800999c:	40002800 	.word	0x40002800

080099a0 <RTC_WriteBackupRegister>:
  *                          specify the register.
  * @param  Data: Data to be written in the specified RTC Backup data register.                     
  * @retval None
  */
void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
{
 80099a0:	b480      	push	{r7}
 80099a2:	b085      	sub	sp, #20
 80099a4:	af00      	add	r7, sp, #0
 80099a6:	6078      	str	r0, [r7, #4]
 80099a8:	6039      	str	r1, [r7, #0]
  __IO uint32_t tmp = 0;
 80099aa:	f04f 0300 	mov.w	r3, #0
 80099ae:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_RTC_BKP(RTC_BKP_DR));

  tmp = RTC_BASE + 0x50;
 80099b0:	4b07      	ldr	r3, [pc, #28]	; (80099d0 <RTC_WriteBackupRegister+0x30>)
 80099b2:	60fb      	str	r3, [r7, #12]
  tmp += (RTC_BKP_DR * 4);
 80099b4:	687b      	ldr	r3, [r7, #4]
 80099b6:	ea4f 0283 	mov.w	r2, r3, lsl #2
 80099ba:	68fb      	ldr	r3, [r7, #12]
 80099bc:	18d3      	adds	r3, r2, r3
 80099be:	60fb      	str	r3, [r7, #12]

  /* Write the specified register */
  *(__IO uint32_t *)tmp = (uint32_t)Data;
 80099c0:	68fb      	ldr	r3, [r7, #12]
 80099c2:	683a      	ldr	r2, [r7, #0]
 80099c4:	601a      	str	r2, [r3, #0]
}
 80099c6:	f107 0714 	add.w	r7, r7, #20
 80099ca:	46bd      	mov	sp, r7
 80099cc:	bc80      	pop	{r7}
 80099ce:	4770      	bx	lr
 80099d0:	40002850 	.word	0x40002850

080099d4 <RTC_ReadBackupRegister>:
  *          This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
  *                          specify the register.                   
  * @retval None
  */
uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
{
 80099d4:	b480      	push	{r7}
 80099d6:	b085      	sub	sp, #20
 80099d8:	af00      	add	r7, sp, #0
 80099da:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmp = 0;
 80099dc:	f04f 0300 	mov.w	r3, #0
 80099e0:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_RTC_BKP(RTC_BKP_DR));

  tmp = RTC_BASE + 0x50;
 80099e2:	4b08      	ldr	r3, [pc, #32]	; (8009a04 <RTC_ReadBackupRegister+0x30>)
 80099e4:	60fb      	str	r3, [r7, #12]
  tmp += (RTC_BKP_DR * 4);
 80099e6:	687b      	ldr	r3, [r7, #4]
 80099e8:	ea4f 0283 	mov.w	r2, r3, lsl #2
 80099ec:	68fb      	ldr	r3, [r7, #12]
 80099ee:	18d3      	adds	r3, r2, r3
 80099f0:	60fb      	str	r3, [r7, #12]
  
  /* Read the specified register */
  return (*(__IO uint32_t *)tmp);
 80099f2:	68fb      	ldr	r3, [r7, #12]
 80099f4:	681b      	ldr	r3, [r3, #0]
}
 80099f6:	4618      	mov	r0, r3
 80099f8:	f107 0714 	add.w	r7, r7, #20
 80099fc:	46bd      	mov	sp, r7
 80099fe:	bc80      	pop	{r7}
 8009a00:	4770      	bx	lr
 8009a02:	bf00      	nop
 8009a04:	40002850 	.word	0x40002850

08009a08 <RTC_TamperPinSelection>:
  *            @arg RTC_TamperPin_PC13: PC13 is selected as RTC Tamper Pin.
  *            @arg RTC_TamperPin_PI8: PI8 is selected as RTC Tamper Pin.    
  * @retval None
  */
void RTC_TamperPinSelection(uint32_t RTC_TamperPin)
{
 8009a08:	b480      	push	{r7}
 8009a0a:	b083      	sub	sp, #12
 8009a0c:	af00      	add	r7, sp, #0
 8009a0e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_PIN(RTC_TamperPin));
  
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPINSEL);
 8009a10:	4b08      	ldr	r3, [pc, #32]	; (8009a34 <RTC_TamperPinSelection+0x2c>)
 8009a12:	4a08      	ldr	r2, [pc, #32]	; (8009a34 <RTC_TamperPinSelection+0x2c>)
 8009a14:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8009a16:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8009a1a:	641a      	str	r2, [r3, #64]	; 0x40
  RTC->TAFCR |= (uint32_t)(RTC_TamperPin);  
 8009a1c:	4b05      	ldr	r3, [pc, #20]	; (8009a34 <RTC_TamperPinSelection+0x2c>)
 8009a1e:	4a05      	ldr	r2, [pc, #20]	; (8009a34 <RTC_TamperPinSelection+0x2c>)
 8009a20:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8009a22:	687a      	ldr	r2, [r7, #4]
 8009a24:	430a      	orrs	r2, r1
 8009a26:	641a      	str	r2, [r3, #64]	; 0x40
}
 8009a28:	f107 070c 	add.w	r7, r7, #12
 8009a2c:	46bd      	mov	sp, r7
 8009a2e:	bc80      	pop	{r7}
 8009a30:	4770      	bx	lr
 8009a32:	bf00      	nop
 8009a34:	40002800 	.word	0x40002800

08009a38 <RTC_TimeStampPinSelection>:
  *            @arg RTC_TimeStampPin_PC13: PC13 is selected as RTC TimeStamp Pin.
  *            @arg RTC_TimeStampPin_PI8: PI8 is selected as RTC TimeStamp Pin.    
  * @retval None
  */
void RTC_TimeStampPinSelection(uint32_t RTC_TimeStampPin)
{
 8009a38:	b480      	push	{r7}
 8009a3a:	b083      	sub	sp, #12
 8009a3c:	af00      	add	r7, sp, #0
 8009a3e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
  
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TSINSEL);
 8009a40:	4b08      	ldr	r3, [pc, #32]	; (8009a64 <RTC_TimeStampPinSelection+0x2c>)
 8009a42:	4a08      	ldr	r2, [pc, #32]	; (8009a64 <RTC_TimeStampPinSelection+0x2c>)
 8009a44:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8009a46:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 8009a4a:	641a      	str	r2, [r3, #64]	; 0x40
  RTC->TAFCR |= (uint32_t)(RTC_TimeStampPin);  
 8009a4c:	4b05      	ldr	r3, [pc, #20]	; (8009a64 <RTC_TimeStampPinSelection+0x2c>)
 8009a4e:	4a05      	ldr	r2, [pc, #20]	; (8009a64 <RTC_TimeStampPinSelection+0x2c>)
 8009a50:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8009a52:	687a      	ldr	r2, [r7, #4]
 8009a54:	430a      	orrs	r2, r1
 8009a56:	641a      	str	r2, [r3, #64]	; 0x40
}
 8009a58:	f107 070c 	add.w	r7, r7, #12
 8009a5c:	46bd      	mov	sp, r7
 8009a5e:	bc80      	pop	{r7}
 8009a60:	4770      	bx	lr
 8009a62:	bf00      	nop
 8009a64:	40002800 	.word	0x40002800

08009a68 <RTC_OutputTypeConfig>:
  *            @arg RTC_OutputType_PushPull:  RTC Output (PC13) is configured in 
  *                                    Push Pull mode.    
  * @retval None
  */
void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
{
 8009a68:	b480      	push	{r7}
 8009a6a:	b083      	sub	sp, #12
 8009a6c:	af00      	add	r7, sp, #0
 8009a6e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
  
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
 8009a70:	4b08      	ldr	r3, [pc, #32]	; (8009a94 <RTC_OutputTypeConfig+0x2c>)
 8009a72:	4a08      	ldr	r2, [pc, #32]	; (8009a94 <RTC_OutputTypeConfig+0x2c>)
 8009a74:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8009a76:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8009a7a:	641a      	str	r2, [r3, #64]	; 0x40
  RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
 8009a7c:	4b05      	ldr	r3, [pc, #20]	; (8009a94 <RTC_OutputTypeConfig+0x2c>)
 8009a7e:	4a05      	ldr	r2, [pc, #20]	; (8009a94 <RTC_OutputTypeConfig+0x2c>)
 8009a80:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8009a82:	687a      	ldr	r2, [r7, #4]
 8009a84:	430a      	orrs	r2, r1
 8009a86:	641a      	str	r2, [r3, #64]	; 0x40
}
 8009a88:	f107 070c 	add.w	r7, r7, #12
 8009a8c:	46bd      	mov	sp, r7
 8009a8e:	bc80      	pop	{r7}
 8009a90:	4770      	bx	lr
 8009a92:	bf00      	nop
 8009a94:	40002800 	.word	0x40002800

08009a98 <RTC_SynchroShiftConfig>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Shift registers are configured
  *          - ERROR: RTC Shift registers are not configured
*/
ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS)
{
 8009a98:	b580      	push	{r7, lr}
 8009a9a:	b084      	sub	sp, #16
 8009a9c:	af00      	add	r7, sp, #0
 8009a9e:	6078      	str	r0, [r7, #4]
 8009aa0:	6039      	str	r1, [r7, #0]
  ErrorStatus status = ERROR;
 8009aa2:	f04f 0300 	mov.w	r3, #0
 8009aa6:	73fb      	strb	r3, [r7, #15]
  uint32_t shpfcount = 0;
 8009aa8:	f04f 0300 	mov.w	r3, #0
 8009aac:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
  assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8009aae:	4b26      	ldr	r3, [pc, #152]	; (8009b48 <RTC_SynchroShiftConfig+0xb0>)
 8009ab0:	f04f 02ca 	mov.w	r2, #202	; 0xca
 8009ab4:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8009ab6:	4b24      	ldr	r3, [pc, #144]	; (8009b48 <RTC_SynchroShiftConfig+0xb0>)
 8009ab8:	f04f 0253 	mov.w	r2, #83	; 0x53
 8009abc:	625a      	str	r2, [r3, #36]	; 0x24
  
  /* Check if a Shift is pending*/
  if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
 8009abe:	4b22      	ldr	r3, [pc, #136]	; (8009b48 <RTC_SynchroShiftConfig+0xb0>)
 8009ac0:	68db      	ldr	r3, [r3, #12]
 8009ac2:	f003 0308 	and.w	r3, r3, #8
 8009ac6:	2b00      	cmp	r3, #0
 8009ac8:	d00e      	beq.n	8009ae8 <RTC_SynchroShiftConfig+0x50>
  {
    /* Wait until the shift is completed*/
    while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
 8009aca:	e003      	b.n	8009ad4 <RTC_SynchroShiftConfig+0x3c>
    {
      shpfcount++;
 8009acc:	68bb      	ldr	r3, [r7, #8]
 8009ace:	f103 0301 	add.w	r3, r3, #1
 8009ad2:	60bb      	str	r3, [r7, #8]
  
  /* Check if a Shift is pending*/
  if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
  {
    /* Wait until the shift is completed*/
    while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
 8009ad4:	4b1c      	ldr	r3, [pc, #112]	; (8009b48 <RTC_SynchroShiftConfig+0xb0>)
 8009ad6:	68db      	ldr	r3, [r3, #12]
 8009ad8:	f003 0308 	and.w	r3, r3, #8
 8009adc:	2b00      	cmp	r3, #0
 8009ade:	d003      	beq.n	8009ae8 <RTC_SynchroShiftConfig+0x50>
 8009ae0:	68bb      	ldr	r3, [r7, #8]
 8009ae2:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8009ae6:	d1f1      	bne.n	8009acc <RTC_SynchroShiftConfig+0x34>
      shpfcount++;
    }
  }

  /* Check if the Shift pending is completed or if there is no Shift operation at all*/
  if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
 8009ae8:	4b17      	ldr	r3, [pc, #92]	; (8009b48 <RTC_SynchroShiftConfig+0xb0>)
 8009aea:	68db      	ldr	r3, [r3, #12]
 8009aec:	f003 0308 	and.w	r3, r3, #8
 8009af0:	2b00      	cmp	r3, #0
 8009af2:	d11b      	bne.n	8009b2c <RTC_SynchroShiftConfig+0x94>
  {
    /* check if the reference clock detection is disabled */
    if((RTC->CR & RTC_CR_REFCKON) == RESET)
 8009af4:	4b14      	ldr	r3, [pc, #80]	; (8009b48 <RTC_SynchroShiftConfig+0xb0>)
 8009af6:	689b      	ldr	r3, [r3, #8]
 8009af8:	f003 0310 	and.w	r3, r3, #16
 8009afc:	2b00      	cmp	r3, #0
 8009afe:	d111      	bne.n	8009b24 <RTC_SynchroShiftConfig+0x8c>
    {
      /* Configure the Shift settings */
      RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
 8009b00:	4b11      	ldr	r3, [pc, #68]	; (8009b48 <RTC_SynchroShiftConfig+0xb0>)
 8009b02:	6839      	ldr	r1, [r7, #0]
 8009b04:	687a      	ldr	r2, [r7, #4]
 8009b06:	430a      	orrs	r2, r1
 8009b08:	62da      	str	r2, [r3, #44]	; 0x2c
    
      if(RTC_WaitForSynchro() == ERROR)
 8009b0a:	f7fe ff17 	bl	800893c <RTC_WaitForSynchro>
 8009b0e:	4603      	mov	r3, r0
 8009b10:	2b00      	cmp	r3, #0
 8009b12:	d103      	bne.n	8009b1c <RTC_SynchroShiftConfig+0x84>
      {
        status = ERROR;
 8009b14:	f04f 0300 	mov.w	r3, #0
 8009b18:	73fb      	strb	r3, [r7, #15]
 8009b1a:	e00a      	b.n	8009b32 <RTC_SynchroShiftConfig+0x9a>
      }
      else
      {
        status = SUCCESS;
 8009b1c:	f04f 0301 	mov.w	r3, #1
 8009b20:	73fb      	strb	r3, [r7, #15]
 8009b22:	e006      	b.n	8009b32 <RTC_SynchroShiftConfig+0x9a>
      }
    }
    else
    {
      status = ERROR;
 8009b24:	f04f 0300 	mov.w	r3, #0
 8009b28:	73fb      	strb	r3, [r7, #15]
 8009b2a:	e002      	b.n	8009b32 <RTC_SynchroShiftConfig+0x9a>
    }
  }
  else
  {
    status = ERROR;
 8009b2c:	f04f 0300 	mov.w	r3, #0
 8009b30:	73fb      	strb	r3, [r7, #15]
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8009b32:	4b05      	ldr	r3, [pc, #20]	; (8009b48 <RTC_SynchroShiftConfig+0xb0>)
 8009b34:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8009b38:	625a      	str	r2, [r3, #36]	; 0x24
  
  return (ErrorStatus)(status);
 8009b3a:	7bfb      	ldrb	r3, [r7, #15]
}
 8009b3c:	4618      	mov	r0, r3
 8009b3e:	f107 0710 	add.w	r7, r7, #16
 8009b42:	46bd      	mov	sp, r7
 8009b44:	bd80      	pop	{r7, pc}
 8009b46:	bf00      	nop
 8009b48:	40002800 	.word	0x40002800

08009b4c <RTC_ITConfig>:
  * @param  NewState: new state of the specified RTC interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
{
 8009b4c:	b480      	push	{r7}
 8009b4e:	b083      	sub	sp, #12
 8009b50:	af00      	add	r7, sp, #0
 8009b52:	6078      	str	r0, [r7, #4]
 8009b54:	460b      	mov	r3, r1
 8009b56:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RTC_CONFIG_IT(RTC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8009b58:	4b1c      	ldr	r3, [pc, #112]	; (8009bcc <RTC_ITConfig+0x80>)
 8009b5a:	f04f 02ca 	mov.w	r2, #202	; 0xca
 8009b5e:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8009b60:	4b1a      	ldr	r3, [pc, #104]	; (8009bcc <RTC_ITConfig+0x80>)
 8009b62:	f04f 0253 	mov.w	r2, #83	; 0x53
 8009b66:	625a      	str	r2, [r3, #36]	; 0x24

  if (NewState != DISABLE)
 8009b68:	78fb      	ldrb	r3, [r7, #3]
 8009b6a:	2b00      	cmp	r3, #0
 8009b6c:	d010      	beq.n	8009b90 <RTC_ITConfig+0x44>
  {
    /* Configure the Interrupts in the RTC_CR register */
    RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
 8009b6e:	4b17      	ldr	r3, [pc, #92]	; (8009bcc <RTC_ITConfig+0x80>)
 8009b70:	4a16      	ldr	r2, [pc, #88]	; (8009bcc <RTC_ITConfig+0x80>)
 8009b72:	6891      	ldr	r1, [r2, #8]
 8009b74:	687a      	ldr	r2, [r7, #4]
 8009b76:	f022 0204 	bic.w	r2, r2, #4
 8009b7a:	430a      	orrs	r2, r1
 8009b7c:	609a      	str	r2, [r3, #8]
    /* Configure the Tamper Interrupt in the RTC_TAFCR */
    RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
 8009b7e:	4b13      	ldr	r3, [pc, #76]	; (8009bcc <RTC_ITConfig+0x80>)
 8009b80:	4a12      	ldr	r2, [pc, #72]	; (8009bcc <RTC_ITConfig+0x80>)
 8009b82:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8009b84:	687a      	ldr	r2, [r7, #4]
 8009b86:	f002 0204 	and.w	r2, r2, #4
 8009b8a:	430a      	orrs	r2, r1
 8009b8c:	641a      	str	r2, [r3, #64]	; 0x40
 8009b8e:	e013      	b.n	8009bb8 <RTC_ITConfig+0x6c>
  }
  else
  {
    /* Configure the Interrupts in the RTC_CR register */
    RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
 8009b90:	4b0e      	ldr	r3, [pc, #56]	; (8009bcc <RTC_ITConfig+0x80>)
 8009b92:	4a0e      	ldr	r2, [pc, #56]	; (8009bcc <RTC_ITConfig+0x80>)
 8009b94:	6891      	ldr	r1, [r2, #8]
 8009b96:	687a      	ldr	r2, [r7, #4]
 8009b98:	f022 0204 	bic.w	r2, r2, #4
 8009b9c:	ea6f 0202 	mvn.w	r2, r2
 8009ba0:	400a      	ands	r2, r1
 8009ba2:	609a      	str	r2, [r3, #8]
    /* Configure the Tamper Interrupt in the RTC_TAFCR */
    RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
 8009ba4:	4b09      	ldr	r3, [pc, #36]	; (8009bcc <RTC_ITConfig+0x80>)
 8009ba6:	4a09      	ldr	r2, [pc, #36]	; (8009bcc <RTC_ITConfig+0x80>)
 8009ba8:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8009baa:	687a      	ldr	r2, [r7, #4]
 8009bac:	f002 0204 	and.w	r2, r2, #4
 8009bb0:	ea6f 0202 	mvn.w	r2, r2
 8009bb4:	400a      	ands	r2, r1
 8009bb6:	641a      	str	r2, [r3, #64]	; 0x40
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8009bb8:	4b04      	ldr	r3, [pc, #16]	; (8009bcc <RTC_ITConfig+0x80>)
 8009bba:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8009bbe:	625a      	str	r2, [r3, #36]	; 0x24
}
 8009bc0:	f107 070c 	add.w	r7, r7, #12
 8009bc4:	46bd      	mov	sp, r7
 8009bc6:	bc80      	pop	{r7}
 8009bc8:	4770      	bx	lr
 8009bca:	bf00      	nop
 8009bcc:	40002800 	.word	0x40002800

08009bd0 <RTC_GetFlagStatus>:
  *            @arg RTC_FLAG_ALRBWF: Alarm B Write flag
  *            @arg RTC_FLAG_ALRAWF: Alarm A write flag
  * @retval The new state of RTC_FLAG (SET or RESET).
  */
FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
{
 8009bd0:	b480      	push	{r7}
 8009bd2:	b085      	sub	sp, #20
 8009bd4:	af00      	add	r7, sp, #0
 8009bd6:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
 8009bd8:	f04f 0300 	mov.w	r3, #0
 8009bdc:	73fb      	strb	r3, [r7, #15]
  uint32_t tmpreg = 0;
 8009bde:	f04f 0300 	mov.w	r3, #0
 8009be2:	60bb      	str	r3, [r7, #8]
  
  /* Check the parameters */
  assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
  
  /* Get all the flags */
  tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
 8009be4:	4b0c      	ldr	r3, [pc, #48]	; (8009c18 <RTC_GetFlagStatus+0x48>)
 8009be6:	68da      	ldr	r2, [r3, #12]
 8009be8:	f643 7377 	movw	r3, #16247	; 0x3f77
 8009bec:	4013      	ands	r3, r2
 8009bee:	60bb      	str	r3, [r7, #8]
  
  /* Return the status of the flag */
  if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
 8009bf0:	68ba      	ldr	r2, [r7, #8]
 8009bf2:	687b      	ldr	r3, [r7, #4]
 8009bf4:	4013      	ands	r3, r2
 8009bf6:	2b00      	cmp	r3, #0
 8009bf8:	d003      	beq.n	8009c02 <RTC_GetFlagStatus+0x32>
  {
    bitstatus = SET;
 8009bfa:	f04f 0301 	mov.w	r3, #1
 8009bfe:	73fb      	strb	r3, [r7, #15]
 8009c00:	e002      	b.n	8009c08 <RTC_GetFlagStatus+0x38>
  }
  else
  {
    bitstatus = RESET;
 8009c02:	f04f 0300 	mov.w	r3, #0
 8009c06:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 8009c08:	7bfb      	ldrb	r3, [r7, #15]
}
 8009c0a:	4618      	mov	r0, r3
 8009c0c:	f107 0714 	add.w	r7, r7, #20
 8009c10:	46bd      	mov	sp, r7
 8009c12:	bc80      	pop	{r7}
 8009c14:	4770      	bx	lr
 8009c16:	bf00      	nop
 8009c18:	40002800 	.word	0x40002800

08009c1c <RTC_ClearFlag>:
  *            @arg RTC_FLAG_ALRAF: Alarm A flag
  *            @arg RTC_FLAG_RSF: Registers Synchronized flag
  * @retval None
  */
void RTC_ClearFlag(uint32_t RTC_FLAG)
{
 8009c1c:	b480      	push	{r7}
 8009c1e:	b083      	sub	sp, #12
 8009c20:	af00      	add	r7, sp, #0
 8009c22:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));

  /* Clear the Flags in the RTC_ISR register */
  RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));  
 8009c24:	4a0a      	ldr	r2, [pc, #40]	; (8009c50 <RTC_ClearFlag+0x34>)
 8009c26:	687b      	ldr	r3, [r7, #4]
 8009c28:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8009c2c:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8009c30:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8009c34:	ea6f 0103 	mvn.w	r1, r3
 8009c38:	4b05      	ldr	r3, [pc, #20]	; (8009c50 <RTC_ClearFlag+0x34>)
 8009c3a:	68db      	ldr	r3, [r3, #12]
 8009c3c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8009c40:	430b      	orrs	r3, r1
 8009c42:	60d3      	str	r3, [r2, #12]
}
 8009c44:	f107 070c 	add.w	r7, r7, #12
 8009c48:	46bd      	mov	sp, r7
 8009c4a:	bc80      	pop	{r7}
 8009c4c:	4770      	bx	lr
 8009c4e:	bf00      	nop
 8009c50:	40002800 	.word	0x40002800

08009c54 <RTC_GetITStatus>:
  *            @arg RTC_IT_ALRA: Alarm A interrupt 
  *            @arg RTC_IT_TAMP1: Tamper 1 event interrupt 
  * @retval The new state of RTC_IT (SET or RESET).
  */
ITStatus RTC_GetITStatus(uint32_t RTC_IT)
{
 8009c54:	b480      	push	{r7}
 8009c56:	b087      	sub	sp, #28
 8009c58:	af00      	add	r7, sp, #0
 8009c5a:	6078      	str	r0, [r7, #4]
  ITStatus bitstatus = RESET;
 8009c5c:	f04f 0300 	mov.w	r3, #0
 8009c60:	75fb      	strb	r3, [r7, #23]
  uint32_t tmpreg = 0, enablestatus = 0;
 8009c62:	f04f 0300 	mov.w	r3, #0
 8009c66:	613b      	str	r3, [r7, #16]
 8009c68:	f04f 0300 	mov.w	r3, #0
 8009c6c:	60fb      	str	r3, [r7, #12]
 
  /* Check the parameters */
  assert_param(IS_RTC_GET_IT(RTC_IT));
  
  /* Get the TAMPER Interrupt enable bit and pending bit */
  tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
 8009c6e:	4b17      	ldr	r3, [pc, #92]	; (8009ccc <RTC_GetITStatus+0x78>)
 8009c70:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009c72:	f003 0304 	and.w	r3, r3, #4
 8009c76:	613b      	str	r3, [r7, #16]
 
  /* Get the Interrupt enable Status */
  enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & (RTC_IT >> 15)));
 8009c78:	4b14      	ldr	r3, [pc, #80]	; (8009ccc <RTC_GetITStatus+0x78>)
 8009c7a:	689a      	ldr	r2, [r3, #8]
 8009c7c:	687b      	ldr	r3, [r7, #4]
 8009c7e:	401a      	ands	r2, r3
 8009c80:	687b      	ldr	r3, [r7, #4]
 8009c82:	ea4f 31d3 	mov.w	r1, r3, lsr #15
 8009c86:	693b      	ldr	r3, [r7, #16]
 8009c88:	400b      	ands	r3, r1
 8009c8a:	4313      	orrs	r3, r2
 8009c8c:	60fb      	str	r3, [r7, #12]
  
  /* Get the Interrupt pending bit */
  tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
 8009c8e:	4b0f      	ldr	r3, [pc, #60]	; (8009ccc <RTC_GetITStatus+0x78>)
 8009c90:	68da      	ldr	r2, [r3, #12]
 8009c92:	687b      	ldr	r3, [r7, #4]
 8009c94:	ea4f 1313 	mov.w	r3, r3, lsr #4
 8009c98:	4013      	ands	r3, r2
 8009c9a:	613b      	str	r3, [r7, #16]
  
  /* Get the status of the Interrupt */
  if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
 8009c9c:	68fb      	ldr	r3, [r7, #12]
 8009c9e:	2b00      	cmp	r3, #0
 8009ca0:	d00a      	beq.n	8009cb8 <RTC_GetITStatus+0x64>
 8009ca2:	693b      	ldr	r3, [r7, #16]
 8009ca4:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8009ca8:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8009cac:	2b00      	cmp	r3, #0
 8009cae:	d003      	beq.n	8009cb8 <RTC_GetITStatus+0x64>
  {
    bitstatus = SET;
 8009cb0:	f04f 0301 	mov.w	r3, #1
 8009cb4:	75fb      	strb	r3, [r7, #23]
 8009cb6:	e002      	b.n	8009cbe <RTC_GetITStatus+0x6a>
  }
  else
  {
    bitstatus = RESET;
 8009cb8:	f04f 0300 	mov.w	r3, #0
 8009cbc:	75fb      	strb	r3, [r7, #23]
  }
  return bitstatus;
 8009cbe:	7dfb      	ldrb	r3, [r7, #23]
}
 8009cc0:	4618      	mov	r0, r3
 8009cc2:	f107 071c 	add.w	r7, r7, #28
 8009cc6:	46bd      	mov	sp, r7
 8009cc8:	bc80      	pop	{r7}
 8009cca:	4770      	bx	lr
 8009ccc:	40002800 	.word	0x40002800

08009cd0 <RTC_ClearITPendingBit>:
  *            @arg RTC_IT_ALRA: Alarm A interrupt 
  *            @arg RTC_IT_TAMP1: Tamper 1 event interrupt 
  * @retval None
  */
void RTC_ClearITPendingBit(uint32_t RTC_IT)
{
 8009cd0:	b480      	push	{r7}
 8009cd2:	b085      	sub	sp, #20
 8009cd4:	af00      	add	r7, sp, #0
 8009cd6:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8009cd8:	f04f 0300 	mov.w	r3, #0
 8009cdc:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RTC_CLEAR_IT(RTC_IT));

  /* Get the RTC_ISR Interrupt pending bits mask */
  tmpreg = (uint32_t)(RTC_IT >> 4);
 8009cde:	687b      	ldr	r3, [r7, #4]
 8009ce0:	ea4f 1313 	mov.w	r3, r3, lsr #4
 8009ce4:	60fb      	str	r3, [r7, #12]

  /* Clear the interrupt pending bits in the RTC_ISR register */
  RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
 8009ce6:	4a0a      	ldr	r2, [pc, #40]	; (8009d10 <RTC_ClearITPendingBit+0x40>)
 8009ce8:	68fb      	ldr	r3, [r7, #12]
 8009cea:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8009cee:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8009cf2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8009cf6:	ea6f 0103 	mvn.w	r1, r3
 8009cfa:	4b05      	ldr	r3, [pc, #20]	; (8009d10 <RTC_ClearITPendingBit+0x40>)
 8009cfc:	68db      	ldr	r3, [r3, #12]
 8009cfe:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8009d02:	430b      	orrs	r3, r1
 8009d04:	60d3      	str	r3, [r2, #12]
}
 8009d06:	f107 0714 	add.w	r7, r7, #20
 8009d0a:	46bd      	mov	sp, r7
 8009d0c:	bc80      	pop	{r7}
 8009d0e:	4770      	bx	lr
 8009d10:	40002800 	.word	0x40002800

08009d14 <RTC_ByteToBcd2>:
  * @brief  Converts a 2 digit decimal to BCD format.
  * @param  Value: Byte to be converted.
  * @retval Converted byte
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
 8009d14:	b480      	push	{r7}
 8009d16:	b085      	sub	sp, #20
 8009d18:	af00      	add	r7, sp, #0
 8009d1a:	4603      	mov	r3, r0
 8009d1c:	71fb      	strb	r3, [r7, #7]
  uint8_t bcdhigh = 0;
 8009d1e:	f04f 0300 	mov.w	r3, #0
 8009d22:	73fb      	strb	r3, [r7, #15]
  
  while (Value >= 10)
 8009d24:	e007      	b.n	8009d36 <RTC_ByteToBcd2+0x22>
  {
    bcdhigh++;
 8009d26:	7bfb      	ldrb	r3, [r7, #15]
 8009d28:	f103 0301 	add.w	r3, r3, #1
 8009d2c:	73fb      	strb	r3, [r7, #15]
    Value -= 10;
 8009d2e:	79fb      	ldrb	r3, [r7, #7]
 8009d30:	f1a3 030a 	sub.w	r3, r3, #10
 8009d34:	71fb      	strb	r3, [r7, #7]
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 8009d36:	79fb      	ldrb	r3, [r7, #7]
 8009d38:	2b09      	cmp	r3, #9
 8009d3a:	d8f4      	bhi.n	8009d26 <RTC_ByteToBcd2+0x12>
  {
    bcdhigh++;
    Value -= 10;
  }
  
  return  ((uint8_t)(bcdhigh << 4) | Value);
 8009d3c:	7bfb      	ldrb	r3, [r7, #15]
 8009d3e:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8009d42:	b2da      	uxtb	r2, r3
 8009d44:	79fb      	ldrb	r3, [r7, #7]
 8009d46:	4313      	orrs	r3, r2
 8009d48:	b2db      	uxtb	r3, r3
}
 8009d4a:	4618      	mov	r0, r3
 8009d4c:	f107 0714 	add.w	r7, r7, #20
 8009d50:	46bd      	mov	sp, r7
 8009d52:	bc80      	pop	{r7}
 8009d54:	4770      	bx	lr
 8009d56:	bf00      	nop

08009d58 <RTC_Bcd2ToByte>:
  * @brief  Convert from 2 digit BCD to Binary.
  * @param  Value: BCD value to be converted.
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
 8009d58:	b480      	push	{r7}
 8009d5a:	b085      	sub	sp, #20
 8009d5c:	af00      	add	r7, sp, #0
 8009d5e:	4603      	mov	r3, r0
 8009d60:	71fb      	strb	r3, [r7, #7]
  uint8_t tmp = 0;
 8009d62:	f04f 0300 	mov.w	r3, #0
 8009d66:	73fb      	strb	r3, [r7, #15]
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8009d68:	79fb      	ldrb	r3, [r7, #7]
 8009d6a:	ea4f 1313 	mov.w	r3, r3, lsr #4
 8009d6e:	b2db      	uxtb	r3, r3
 8009d70:	461a      	mov	r2, r3
 8009d72:	ea4f 0282 	mov.w	r2, r2, lsl #2
 8009d76:	18d3      	adds	r3, r2, r3
 8009d78:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8009d7c:	73fb      	strb	r3, [r7, #15]
  return (tmp + (Value & (uint8_t)0x0F));
 8009d7e:	79fb      	ldrb	r3, [r7, #7]
 8009d80:	f003 030f 	and.w	r3, r3, #15
 8009d84:	b2da      	uxtb	r2, r3
 8009d86:	7bfb      	ldrb	r3, [r7, #15]
 8009d88:	18d3      	adds	r3, r2, r3
 8009d8a:	b2db      	uxtb	r3, r3
}
 8009d8c:	4618      	mov	r0, r3
 8009d8e:	f107 0714 	add.w	r7, r7, #20
 8009d92:	46bd      	mov	sp, r7
 8009d94:	bc80      	pop	{r7}
 8009d96:	4770      	bx	lr

08009d98 <SYSCFG_DeInit>:
  *   registers to their default reset values.
  * @param  None
  * @retval None
  */
void SYSCFG_DeInit(void)
{
 8009d98:	b580      	push	{r7, lr}
 8009d9a:	af00      	add	r7, sp, #0
   RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 8009d9c:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8009da0:	f04f 0101 	mov.w	r1, #1
 8009da4:	f7fe fb24 	bl	80083f0 <RCC_APB2PeriphResetCmd>
   RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, DISABLE);
 8009da8:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8009dac:	f04f 0100 	mov.w	r1, #0
 8009db0:	f7fe fb1e 	bl	80083f0 <RCC_APB2PeriphResetCmd>
}
 8009db4:	bd80      	pop	{r7, pc}
 8009db6:	bf00      	nop

08009db8 <SYSCFG_MemoryRemapConfig>:
  *            @arg SYSCFG_MemoryRemap_FSMC:        FSMC (Bank1 (NOR/PSRAM 1 and 2) mapped at 0x00000000
  *            @arg SYSCFG_MemoryRemap_SRAM:        Embedded SRAM (112kB) mapped at 0x00000000
  * @retval None
  */
void SYSCFG_MemoryRemapConfig(uint8_t SYSCFG_MemoryRemap)
{
 8009db8:	b480      	push	{r7}
 8009dba:	b083      	sub	sp, #12
 8009dbc:	af00      	add	r7, sp, #0
 8009dbe:	4603      	mov	r3, r0
 8009dc0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_SYSCFG_MEMORY_REMAP_CONFING(SYSCFG_MemoryRemap));

  SYSCFG->MEMRMP = SYSCFG_MemoryRemap;
 8009dc2:	4b04      	ldr	r3, [pc, #16]	; (8009dd4 <SYSCFG_MemoryRemapConfig+0x1c>)
 8009dc4:	79fa      	ldrb	r2, [r7, #7]
 8009dc6:	601a      	str	r2, [r3, #0]
}
 8009dc8:	f107 070c 	add.w	r7, r7, #12
 8009dcc:	46bd      	mov	sp, r7
 8009dce:	bc80      	pop	{r7}
 8009dd0:	4770      	bx	lr
 8009dd2:	bf00      	nop
 8009dd4:	40013800 	.word	0x40013800

08009dd8 <SYSCFG_EXTILineConfig>:
  *           This parameter can be EXTI_PinSourcex where x can be (0..15, except
  *           for EXTI_PortSourceGPIOI x can be (0..11).
  * @retval None
  */
void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)
{
 8009dd8:	b490      	push	{r4, r7}
 8009dda:	b084      	sub	sp, #16
 8009ddc:	af00      	add	r7, sp, #0
 8009dde:	4602      	mov	r2, r0
 8009de0:	460b      	mov	r3, r1
 8009de2:	71fa      	strb	r2, [r7, #7]
 8009de4:	71bb      	strb	r3, [r7, #6]
  uint32_t tmp = 0x00;
 8009de6:	f04f 0300 	mov.w	r3, #0
 8009dea:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));

  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
 8009dec:	79bb      	ldrb	r3, [r7, #6]
 8009dee:	f003 0303 	and.w	r3, r3, #3
 8009df2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8009df6:	f04f 020f 	mov.w	r2, #15
 8009dfa:	fa02 f303 	lsl.w	r3, r2, r3
 8009dfe:	60fb      	str	r3, [r7, #12]
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
 8009e00:	4b1a      	ldr	r3, [pc, #104]	; (8009e6c <SYSCFG_EXTILineConfig+0x94>)
 8009e02:	79ba      	ldrb	r2, [r7, #6]
 8009e04:	ea4f 0292 	mov.w	r2, r2, lsr #2
 8009e08:	b2d2      	uxtb	r2, r2
 8009e0a:	4918      	ldr	r1, [pc, #96]	; (8009e6c <SYSCFG_EXTILineConfig+0x94>)
 8009e0c:	79b8      	ldrb	r0, [r7, #6]
 8009e0e:	ea4f 0090 	mov.w	r0, r0, lsr #2
 8009e12:	b2c0      	uxtb	r0, r0
 8009e14:	f100 0002 	add.w	r0, r0, #2
 8009e18:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
 8009e1c:	68f9      	ldr	r1, [r7, #12]
 8009e1e:	ea6f 0101 	mvn.w	r1, r1
 8009e22:	4001      	ands	r1, r0
 8009e24:	f102 0202 	add.w	r2, r2, #2
 8009e28:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] |= (((uint32_t)EXTI_PortSourceGPIOx) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03)));
 8009e2c:	4b0f      	ldr	r3, [pc, #60]	; (8009e6c <SYSCFG_EXTILineConfig+0x94>)
 8009e2e:	79ba      	ldrb	r2, [r7, #6]
 8009e30:	ea4f 0292 	mov.w	r2, r2, lsr #2
 8009e34:	b2d2      	uxtb	r2, r2
 8009e36:	490d      	ldr	r1, [pc, #52]	; (8009e6c <SYSCFG_EXTILineConfig+0x94>)
 8009e38:	79b8      	ldrb	r0, [r7, #6]
 8009e3a:	ea4f 0090 	mov.w	r0, r0, lsr #2
 8009e3e:	b2c0      	uxtb	r0, r0
 8009e40:	f100 0002 	add.w	r0, r0, #2
 8009e44:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
 8009e48:	79fc      	ldrb	r4, [r7, #7]
 8009e4a:	79b9      	ldrb	r1, [r7, #6]
 8009e4c:	f001 0103 	and.w	r1, r1, #3
 8009e50:	ea4f 0181 	mov.w	r1, r1, lsl #2
 8009e54:	fa04 f101 	lsl.w	r1, r4, r1
 8009e58:	4301      	orrs	r1, r0
 8009e5a:	f102 0202 	add.w	r2, r2, #2
 8009e5e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8009e62:	f107 0710 	add.w	r7, r7, #16
 8009e66:	46bd      	mov	sp, r7
 8009e68:	bc90      	pop	{r4, r7}
 8009e6a:	4770      	bx	lr
 8009e6c:	40013800 	.word	0x40013800

08009e70 <SYSCFG_ETH_MediaInterfaceConfig>:
  *            @arg SYSCFG_ETH_MediaInterface_MII: MII mode selected
  *            @arg SYSCFG_ETH_MediaInterface_RMII: RMII mode selected 
  * @retval None 
  */
void SYSCFG_ETH_MediaInterfaceConfig(uint32_t SYSCFG_ETH_MediaInterface) 
{ 
 8009e70:	b480      	push	{r7}
 8009e72:	b083      	sub	sp, #12
 8009e74:	af00      	add	r7, sp, #0
 8009e76:	6078      	str	r0, [r7, #4]
  assert_param(IS_SYSCFG_ETH_MEDIA_INTERFACE(SYSCFG_ETH_MediaInterface)); 
  /* Configure MII_RMII selection bit */ 
  *(__IO uint32_t *) PMC_MII_RMII_SEL_BB = SYSCFG_ETH_MediaInterface; 
 8009e78:	4b03      	ldr	r3, [pc, #12]	; (8009e88 <SYSCFG_ETH_MediaInterfaceConfig+0x18>)
 8009e7a:	687a      	ldr	r2, [r7, #4]
 8009e7c:	601a      	str	r2, [r3, #0]
}
 8009e7e:	f107 070c 	add.w	r7, r7, #12
 8009e82:	46bd      	mov	sp, r7
 8009e84:	bc80      	pop	{r7}
 8009e86:	4770      	bx	lr
 8009e88:	422700dc 	.word	0x422700dc

08009e8c <SYSCFG_CompensationCellCmd>:
  *            @arg ENABLE: I/O compensation cell enabled  
  *            @arg DISABLE: I/O compensation cell power-down mode  
  * @retval None
  */
void SYSCFG_CompensationCellCmd(FunctionalState NewState)
{
 8009e8c:	b480      	push	{r7}
 8009e8e:	b083      	sub	sp, #12
 8009e90:	af00      	add	r7, sp, #0
 8009e92:	4603      	mov	r3, r0
 8009e94:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CMPCR_CMP_PD_BB = (uint32_t)NewState;
 8009e96:	4b04      	ldr	r3, [pc, #16]	; (8009ea8 <SYSCFG_CompensationCellCmd+0x1c>)
 8009e98:	79fa      	ldrb	r2, [r7, #7]
 8009e9a:	601a      	str	r2, [r3, #0]
}
 8009e9c:	f107 070c 	add.w	r7, r7, #12
 8009ea0:	46bd      	mov	sp, r7
 8009ea2:	bc80      	pop	{r7}
 8009ea4:	4770      	bx	lr
 8009ea6:	bf00      	nop
 8009ea8:	42270400 	.word	0x42270400

08009eac <SYSCFG_GetCompensationCellStatus>:
  * @brief  Checks whether the I/O Compensation Cell ready flag is set or not.
  * @param  None
  * @retval The new state of the I/O Compensation Cell ready flag (SET or RESET)
  */
FlagStatus SYSCFG_GetCompensationCellStatus(void)
{
 8009eac:	b480      	push	{r7}
 8009eae:	b083      	sub	sp, #12
 8009eb0:	af00      	add	r7, sp, #0
  FlagStatus bitstatus = RESET;
 8009eb2:	f04f 0300 	mov.w	r3, #0
 8009eb6:	71fb      	strb	r3, [r7, #7]
    
  if ((SYSCFG->CMPCR & SYSCFG_CMPCR_READY ) != (uint32_t)RESET)
 8009eb8:	4b09      	ldr	r3, [pc, #36]	; (8009ee0 <SYSCFG_GetCompensationCellStatus+0x34>)
 8009eba:	6a1b      	ldr	r3, [r3, #32]
 8009ebc:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8009ec0:	2b00      	cmp	r3, #0
 8009ec2:	d003      	beq.n	8009ecc <SYSCFG_GetCompensationCellStatus+0x20>
  {
    bitstatus = SET;
 8009ec4:	f04f 0301 	mov.w	r3, #1
 8009ec8:	71fb      	strb	r3, [r7, #7]
 8009eca:	e002      	b.n	8009ed2 <SYSCFG_GetCompensationCellStatus+0x26>
  }
  else
  {
    bitstatus = RESET;
 8009ecc:	f04f 0300 	mov.w	r3, #0
 8009ed0:	71fb      	strb	r3, [r7, #7]
  }
  return bitstatus;
 8009ed2:	79fb      	ldrb	r3, [r7, #7]
}
 8009ed4:	4618      	mov	r0, r3
 8009ed6:	f107 070c 	add.w	r7, r7, #12
 8009eda:	46bd      	mov	sp, r7
 8009edc:	bc80      	pop	{r7}
 8009ede:	4770      	bx	lr
 8009ee0:	40013800 	.word	0x40013800

08009ee4 <TIM_DeInit>:
  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
  * @retval None

  */
void TIM_DeInit(TIM_TypeDef* TIMx)
{
 8009ee4:	b580      	push	{r7, lr}
 8009ee6:	b082      	sub	sp, #8
 8009ee8:	af00      	add	r7, sp, #0
 8009eea:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
 
  if (TIMx == TIM1)
 8009eec:	687a      	ldr	r2, [r7, #4]
 8009eee:	4b78      	ldr	r3, [pc, #480]	; (800a0d0 <TIM_DeInit+0x1ec>)
 8009ef0:	429a      	cmp	r2, r3
 8009ef2:	d10c      	bne.n	8009f0e <TIM_DeInit+0x2a>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
 8009ef4:	f04f 0001 	mov.w	r0, #1
 8009ef8:	f04f 0101 	mov.w	r1, #1
 8009efc:	f7fe fa78 	bl	80083f0 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
 8009f00:	f04f 0001 	mov.w	r0, #1
 8009f04:	f04f 0100 	mov.w	r1, #0
 8009f08:	f7fe fa72 	bl	80083f0 <RCC_APB2PeriphResetCmd>
 8009f0c:	e0db      	b.n	800a0c6 <TIM_DeInit+0x1e2>
  } 
  else if (TIMx == TIM2) 
 8009f0e:	687b      	ldr	r3, [r7, #4]
 8009f10:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8009f14:	d10c      	bne.n	8009f30 <TIM_DeInit+0x4c>
  {     
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
 8009f16:	f04f 0001 	mov.w	r0, #1
 8009f1a:	f04f 0101 	mov.w	r1, #1
 8009f1e:	f7fe fa47 	bl	80083b0 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
 8009f22:	f04f 0001 	mov.w	r0, #1
 8009f26:	f04f 0100 	mov.w	r1, #0
 8009f2a:	f7fe fa41 	bl	80083b0 <RCC_APB1PeriphResetCmd>
 8009f2e:	e0ca      	b.n	800a0c6 <TIM_DeInit+0x1e2>
  }  
  else if (TIMx == TIM3)
 8009f30:	687a      	ldr	r2, [r7, #4]
 8009f32:	4b68      	ldr	r3, [pc, #416]	; (800a0d4 <TIM_DeInit+0x1f0>)
 8009f34:	429a      	cmp	r2, r3
 8009f36:	d10c      	bne.n	8009f52 <TIM_DeInit+0x6e>
  { 
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
 8009f38:	f04f 0002 	mov.w	r0, #2
 8009f3c:	f04f 0101 	mov.w	r1, #1
 8009f40:	f7fe fa36 	bl	80083b0 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
 8009f44:	f04f 0002 	mov.w	r0, #2
 8009f48:	f04f 0100 	mov.w	r1, #0
 8009f4c:	f7fe fa30 	bl	80083b0 <RCC_APB1PeriphResetCmd>
 8009f50:	e0b9      	b.n	800a0c6 <TIM_DeInit+0x1e2>
  }  
  else if (TIMx == TIM4)
 8009f52:	687a      	ldr	r2, [r7, #4]
 8009f54:	4b60      	ldr	r3, [pc, #384]	; (800a0d8 <TIM_DeInit+0x1f4>)
 8009f56:	429a      	cmp	r2, r3
 8009f58:	d10c      	bne.n	8009f74 <TIM_DeInit+0x90>
  { 
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
 8009f5a:	f04f 0004 	mov.w	r0, #4
 8009f5e:	f04f 0101 	mov.w	r1, #1
 8009f62:	f7fe fa25 	bl	80083b0 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
 8009f66:	f04f 0004 	mov.w	r0, #4
 8009f6a:	f04f 0100 	mov.w	r1, #0
 8009f6e:	f7fe fa1f 	bl	80083b0 <RCC_APB1PeriphResetCmd>
 8009f72:	e0a8      	b.n	800a0c6 <TIM_DeInit+0x1e2>
  }  
  else if (TIMx == TIM5)
 8009f74:	687a      	ldr	r2, [r7, #4]
 8009f76:	4b59      	ldr	r3, [pc, #356]	; (800a0dc <TIM_DeInit+0x1f8>)
 8009f78:	429a      	cmp	r2, r3
 8009f7a:	d10c      	bne.n	8009f96 <TIM_DeInit+0xb2>
  {      
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
 8009f7c:	f04f 0008 	mov.w	r0, #8
 8009f80:	f04f 0101 	mov.w	r1, #1
 8009f84:	f7fe fa14 	bl	80083b0 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
 8009f88:	f04f 0008 	mov.w	r0, #8
 8009f8c:	f04f 0100 	mov.w	r1, #0
 8009f90:	f7fe fa0e 	bl	80083b0 <RCC_APB1PeriphResetCmd>
 8009f94:	e097      	b.n	800a0c6 <TIM_DeInit+0x1e2>
  }  
  else if (TIMx == TIM6)  
 8009f96:	687a      	ldr	r2, [r7, #4]
 8009f98:	4b51      	ldr	r3, [pc, #324]	; (800a0e0 <TIM_DeInit+0x1fc>)
 8009f9a:	429a      	cmp	r2, r3
 8009f9c:	d10c      	bne.n	8009fb8 <TIM_DeInit+0xd4>
  {    
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
 8009f9e:	f04f 0010 	mov.w	r0, #16
 8009fa2:	f04f 0101 	mov.w	r1, #1
 8009fa6:	f7fe fa03 	bl	80083b0 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
 8009faa:	f04f 0010 	mov.w	r0, #16
 8009fae:	f04f 0100 	mov.w	r1, #0
 8009fb2:	f7fe f9fd 	bl	80083b0 <RCC_APB1PeriphResetCmd>
 8009fb6:	e086      	b.n	800a0c6 <TIM_DeInit+0x1e2>
  }  
  else if (TIMx == TIM7)
 8009fb8:	687a      	ldr	r2, [r7, #4]
 8009fba:	4b4a      	ldr	r3, [pc, #296]	; (800a0e4 <TIM_DeInit+0x200>)
 8009fbc:	429a      	cmp	r2, r3
 8009fbe:	d10c      	bne.n	8009fda <TIM_DeInit+0xf6>
  {      
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
 8009fc0:	f04f 0020 	mov.w	r0, #32
 8009fc4:	f04f 0101 	mov.w	r1, #1
 8009fc8:	f7fe f9f2 	bl	80083b0 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
 8009fcc:	f04f 0020 	mov.w	r0, #32
 8009fd0:	f04f 0100 	mov.w	r1, #0
 8009fd4:	f7fe f9ec 	bl	80083b0 <RCC_APB1PeriphResetCmd>
 8009fd8:	e075      	b.n	800a0c6 <TIM_DeInit+0x1e2>
  }  
  else if (TIMx == TIM8)
 8009fda:	687a      	ldr	r2, [r7, #4]
 8009fdc:	4b42      	ldr	r3, [pc, #264]	; (800a0e8 <TIM_DeInit+0x204>)
 8009fde:	429a      	cmp	r2, r3
 8009fe0:	d10c      	bne.n	8009ffc <TIM_DeInit+0x118>
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
 8009fe2:	f04f 0002 	mov.w	r0, #2
 8009fe6:	f04f 0101 	mov.w	r1, #1
 8009fea:	f7fe fa01 	bl	80083f0 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
 8009fee:	f04f 0002 	mov.w	r0, #2
 8009ff2:	f04f 0100 	mov.w	r1, #0
 8009ff6:	f7fe f9fb 	bl	80083f0 <RCC_APB2PeriphResetCmd>
 8009ffa:	e064      	b.n	800a0c6 <TIM_DeInit+0x1e2>
  }  
  else if (TIMx == TIM9)
 8009ffc:	687a      	ldr	r2, [r7, #4]
 8009ffe:	4b3b      	ldr	r3, [pc, #236]	; (800a0ec <TIM_DeInit+0x208>)
 800a000:	429a      	cmp	r2, r3
 800a002:	d10c      	bne.n	800a01e <TIM_DeInit+0x13a>
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
 800a004:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 800a008:	f04f 0101 	mov.w	r1, #1
 800a00c:	f7fe f9f0 	bl	80083f0 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
 800a010:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 800a014:	f04f 0100 	mov.w	r1, #0
 800a018:	f7fe f9ea 	bl	80083f0 <RCC_APB2PeriphResetCmd>
 800a01c:	e053      	b.n	800a0c6 <TIM_DeInit+0x1e2>
   }  
  else if (TIMx == TIM10)
 800a01e:	687a      	ldr	r2, [r7, #4]
 800a020:	4b33      	ldr	r3, [pc, #204]	; (800a0f0 <TIM_DeInit+0x20c>)
 800a022:	429a      	cmp	r2, r3
 800a024:	d10c      	bne.n	800a040 <TIM_DeInit+0x15c>
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
 800a026:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800a02a:	f04f 0101 	mov.w	r1, #1
 800a02e:	f7fe f9df 	bl	80083f0 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
 800a032:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800a036:	f04f 0100 	mov.w	r1, #0
 800a03a:	f7fe f9d9 	bl	80083f0 <RCC_APB2PeriphResetCmd>
 800a03e:	e042      	b.n	800a0c6 <TIM_DeInit+0x1e2>
  }  
  else if (TIMx == TIM11) 
 800a040:	687a      	ldr	r2, [r7, #4]
 800a042:	4b2c      	ldr	r3, [pc, #176]	; (800a0f4 <TIM_DeInit+0x210>)
 800a044:	429a      	cmp	r2, r3
 800a046:	d10c      	bne.n	800a062 <TIM_DeInit+0x17e>
  {     
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
 800a048:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 800a04c:	f04f 0101 	mov.w	r1, #1
 800a050:	f7fe f9ce 	bl	80083f0 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
 800a054:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 800a058:	f04f 0100 	mov.w	r1, #0
 800a05c:	f7fe f9c8 	bl	80083f0 <RCC_APB2PeriphResetCmd>
 800a060:	e031      	b.n	800a0c6 <TIM_DeInit+0x1e2>
  }  
  else if (TIMx == TIM12)
 800a062:	687a      	ldr	r2, [r7, #4]
 800a064:	4b24      	ldr	r3, [pc, #144]	; (800a0f8 <TIM_DeInit+0x214>)
 800a066:	429a      	cmp	r2, r3
 800a068:	d10c      	bne.n	800a084 <TIM_DeInit+0x1a0>
  {      
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
 800a06a:	f04f 0040 	mov.w	r0, #64	; 0x40
 800a06e:	f04f 0101 	mov.w	r1, #1
 800a072:	f7fe f99d 	bl	80083b0 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
 800a076:	f04f 0040 	mov.w	r0, #64	; 0x40
 800a07a:	f04f 0100 	mov.w	r1, #0
 800a07e:	f7fe f997 	bl	80083b0 <RCC_APB1PeriphResetCmd>
 800a082:	e020      	b.n	800a0c6 <TIM_DeInit+0x1e2>
  }  
  else if (TIMx == TIM13) 
 800a084:	687a      	ldr	r2, [r7, #4]
 800a086:	4b1d      	ldr	r3, [pc, #116]	; (800a0fc <TIM_DeInit+0x218>)
 800a088:	429a      	cmp	r2, r3
 800a08a:	d10c      	bne.n	800a0a6 <TIM_DeInit+0x1c2>
  {       
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
 800a08c:	f04f 0080 	mov.w	r0, #128	; 0x80
 800a090:	f04f 0101 	mov.w	r1, #1
 800a094:	f7fe f98c 	bl	80083b0 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
 800a098:	f04f 0080 	mov.w	r0, #128	; 0x80
 800a09c:	f04f 0100 	mov.w	r1, #0
 800a0a0:	f7fe f986 	bl	80083b0 <RCC_APB1PeriphResetCmd>
 800a0a4:	e00f      	b.n	800a0c6 <TIM_DeInit+0x1e2>
  }  
  else
  { 
    if (TIMx == TIM14) 
 800a0a6:	687a      	ldr	r2, [r7, #4]
 800a0a8:	4b15      	ldr	r3, [pc, #84]	; (800a100 <TIM_DeInit+0x21c>)
 800a0aa:	429a      	cmp	r2, r3
 800a0ac:	d10b      	bne.n	800a0c6 <TIM_DeInit+0x1e2>
    {     
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
 800a0ae:	f44f 7080 	mov.w	r0, #256	; 0x100
 800a0b2:	f04f 0101 	mov.w	r1, #1
 800a0b6:	f7fe f97b 	bl	80083b0 <RCC_APB1PeriphResetCmd>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
 800a0ba:	f44f 7080 	mov.w	r0, #256	; 0x100
 800a0be:	f04f 0100 	mov.w	r1, #0
 800a0c2:	f7fe f975 	bl	80083b0 <RCC_APB1PeriphResetCmd>
    }   
  }
}
 800a0c6:	f107 0708 	add.w	r7, r7, #8
 800a0ca:	46bd      	mov	sp, r7
 800a0cc:	bd80      	pop	{r7, pc}
 800a0ce:	bf00      	nop
 800a0d0:	40010000 	.word	0x40010000
 800a0d4:	40000400 	.word	0x40000400
 800a0d8:	40000800 	.word	0x40000800
 800a0dc:	40000c00 	.word	0x40000c00
 800a0e0:	40001000 	.word	0x40001000
 800a0e4:	40001400 	.word	0x40001400
 800a0e8:	40010400 	.word	0x40010400
 800a0ec:	40014000 	.word	0x40014000
 800a0f0:	40014400 	.word	0x40014400
 800a0f4:	40014800 	.word	0x40014800
 800a0f8:	40001800 	.word	0x40001800
 800a0fc:	40001c00 	.word	0x40001c00
 800a100:	40002000 	.word	0x40002000

0800a104 <TIM_TimeBaseInit>:
  * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef structure
  *         that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
 800a104:	b480      	push	{r7}
 800a106:	b085      	sub	sp, #20
 800a108:	af00      	add	r7, sp, #0
 800a10a:	6078      	str	r0, [r7, #4]
 800a10c:	6039      	str	r1, [r7, #0]
  uint16_t tmpcr1 = 0;
 800a10e:	f04f 0300 	mov.w	r3, #0
 800a112:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 800a114:	687b      	ldr	r3, [r7, #4]
 800a116:	881b      	ldrh	r3, [r3, #0]
 800a118:	81fb      	strh	r3, [r7, #14]

  if((TIMx == TIM1) || (TIMx == TIM8)||
 800a11a:	687a      	ldr	r2, [r7, #4]
 800a11c:	4b28      	ldr	r3, [pc, #160]	; (800a1c0 <TIM_TimeBaseInit+0xbc>)
 800a11e:	429a      	cmp	r2, r3
 800a120:	d013      	beq.n	800a14a <TIM_TimeBaseInit+0x46>
 800a122:	687a      	ldr	r2, [r7, #4]
 800a124:	4b27      	ldr	r3, [pc, #156]	; (800a1c4 <TIM_TimeBaseInit+0xc0>)
 800a126:	429a      	cmp	r2, r3
 800a128:	d00f      	beq.n	800a14a <TIM_TimeBaseInit+0x46>
 800a12a:	687b      	ldr	r3, [r7, #4]
 800a12c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800a130:	d00b      	beq.n	800a14a <TIM_TimeBaseInit+0x46>
     (TIMx == TIM2) || (TIMx == TIM3)||
 800a132:	687a      	ldr	r2, [r7, #4]
 800a134:	4b24      	ldr	r3, [pc, #144]	; (800a1c8 <TIM_TimeBaseInit+0xc4>)
 800a136:	429a      	cmp	r2, r3
 800a138:	d007      	beq.n	800a14a <TIM_TimeBaseInit+0x46>
 800a13a:	687a      	ldr	r2, [r7, #4]
 800a13c:	4b23      	ldr	r3, [pc, #140]	; (800a1cc <TIM_TimeBaseInit+0xc8>)
 800a13e:	429a      	cmp	r2, r3
 800a140:	d003      	beq.n	800a14a <TIM_TimeBaseInit+0x46>
     (TIMx == TIM4) || (TIMx == TIM5)) 
 800a142:	687a      	ldr	r2, [r7, #4]
 800a144:	4b22      	ldr	r3, [pc, #136]	; (800a1d0 <TIM_TimeBaseInit+0xcc>)
 800a146:	429a      	cmp	r2, r3
 800a148:	d108      	bne.n	800a15c <TIM_TimeBaseInit+0x58>
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
 800a14a:	89fb      	ldrh	r3, [r7, #14]
 800a14c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800a150:	81fb      	strh	r3, [r7, #14]
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 800a152:	683b      	ldr	r3, [r7, #0]
 800a154:	885a      	ldrh	r2, [r3, #2]
 800a156:	89fb      	ldrh	r3, [r7, #14]
 800a158:	4313      	orrs	r3, r2
 800a15a:	81fb      	strh	r3, [r7, #14]
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
 800a15c:	687a      	ldr	r2, [r7, #4]
 800a15e:	4b1d      	ldr	r3, [pc, #116]	; (800a1d4 <TIM_TimeBaseInit+0xd0>)
 800a160:	429a      	cmp	r2, r3
 800a162:	d00c      	beq.n	800a17e <TIM_TimeBaseInit+0x7a>
 800a164:	687a      	ldr	r2, [r7, #4]
 800a166:	4b1c      	ldr	r3, [pc, #112]	; (800a1d8 <TIM_TimeBaseInit+0xd4>)
 800a168:	429a      	cmp	r2, r3
 800a16a:	d008      	beq.n	800a17e <TIM_TimeBaseInit+0x7a>
  {
    /* Set the clock division */
    tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
 800a16c:	89fb      	ldrh	r3, [r7, #14]
 800a16e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800a172:	81fb      	strh	r3, [r7, #14]
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 800a174:	683b      	ldr	r3, [r7, #0]
 800a176:	891a      	ldrh	r2, [r3, #8]
 800a178:	89fb      	ldrh	r3, [r7, #14]
 800a17a:	4313      	orrs	r3, r2
 800a17c:	81fb      	strh	r3, [r7, #14]
  }

  TIMx->CR1 = tmpcr1;
 800a17e:	687b      	ldr	r3, [r7, #4]
 800a180:	89fa      	ldrh	r2, [r7, #14]
 800a182:	801a      	strh	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 800a184:	683b      	ldr	r3, [r7, #0]
 800a186:	685a      	ldr	r2, [r3, #4]
 800a188:	687b      	ldr	r3, [r7, #4]
 800a18a:	62da      	str	r2, [r3, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 800a18c:	683b      	ldr	r3, [r7, #0]
 800a18e:	881a      	ldrh	r2, [r3, #0]
 800a190:	687b      	ldr	r3, [r7, #4]
 800a192:	851a      	strh	r2, [r3, #40]	; 0x28
    
  if ((TIMx == TIM1) || (TIMx == TIM8))  
 800a194:	687a      	ldr	r2, [r7, #4]
 800a196:	4b0a      	ldr	r3, [pc, #40]	; (800a1c0 <TIM_TimeBaseInit+0xbc>)
 800a198:	429a      	cmp	r2, r3
 800a19a:	d003      	beq.n	800a1a4 <TIM_TimeBaseInit+0xa0>
 800a19c:	687a      	ldr	r2, [r7, #4]
 800a19e:	4b09      	ldr	r3, [pc, #36]	; (800a1c4 <TIM_TimeBaseInit+0xc0>)
 800a1a0:	429a      	cmp	r2, r3
 800a1a2:	d104      	bne.n	800a1ae <TIM_TimeBaseInit+0xaa>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
 800a1a4:	683b      	ldr	r3, [r7, #0]
 800a1a6:	7a9b      	ldrb	r3, [r3, #10]
 800a1a8:	461a      	mov	r2, r3
 800a1aa:	687b      	ldr	r3, [r7, #4]
 800a1ac:	861a      	strh	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediatly */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;          
 800a1ae:	687b      	ldr	r3, [r7, #4]
 800a1b0:	f04f 0201 	mov.w	r2, #1
 800a1b4:	829a      	strh	r2, [r3, #20]
}
 800a1b6:	f107 0714 	add.w	r7, r7, #20
 800a1ba:	46bd      	mov	sp, r7
 800a1bc:	bc80      	pop	{r7}
 800a1be:	4770      	bx	lr
 800a1c0:	40010000 	.word	0x40010000
 800a1c4:	40010400 	.word	0x40010400
 800a1c8:	40000400 	.word	0x40000400
 800a1cc:	40000800 	.word	0x40000800
 800a1d0:	40000c00 	.word	0x40000c00
 800a1d4:	40001000 	.word	0x40001000
 800a1d8:	40001400 	.word	0x40001400

0800a1dc <TIM_TimeBaseStructInit>:
  * @param  TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
  *         structure which will be initialized.
  * @retval None
  */
void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
 800a1dc:	b480      	push	{r7}
 800a1de:	b083      	sub	sp, #12
 800a1e0:	af00      	add	r7, sp, #0
 800a1e2:	6078      	str	r0, [r7, #4]
  /* Set the default configuration */
  TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
 800a1e4:	687b      	ldr	r3, [r7, #4]
 800a1e6:	f04f 32ff 	mov.w	r2, #4294967295
 800a1ea:	605a      	str	r2, [r3, #4]
  TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
 800a1ec:	687b      	ldr	r3, [r7, #4]
 800a1ee:	f04f 0200 	mov.w	r2, #0
 800a1f2:	801a      	strh	r2, [r3, #0]
  TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
 800a1f4:	687b      	ldr	r3, [r7, #4]
 800a1f6:	f04f 0200 	mov.w	r2, #0
 800a1fa:	811a      	strh	r2, [r3, #8]
  TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
 800a1fc:	687b      	ldr	r3, [r7, #4]
 800a1fe:	f04f 0200 	mov.w	r2, #0
 800a202:	805a      	strh	r2, [r3, #2]
  TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
 800a204:	687b      	ldr	r3, [r7, #4]
 800a206:	f04f 0200 	mov.w	r2, #0
 800a20a:	729a      	strb	r2, [r3, #10]
}
 800a20c:	f107 070c 	add.w	r7, r7, #12
 800a210:	46bd      	mov	sp, r7
 800a212:	bc80      	pop	{r7}
 800a214:	4770      	bx	lr
 800a216:	bf00      	nop

0800a218 <TIM_PrescalerConfig>:
  *            @arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event.
  *            @arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediatly.
  * @retval None
  */
void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
{
 800a218:	b480      	push	{r7}
 800a21a:	b083      	sub	sp, #12
 800a21c:	af00      	add	r7, sp, #0
 800a21e:	6078      	str	r0, [r7, #4]
 800a220:	4613      	mov	r3, r2
 800a222:	460a      	mov	r2, r1
 800a224:	807a      	strh	r2, [r7, #2]
 800a226:	803b      	strh	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
  /* Set the Prescaler value */
  TIMx->PSC = Prescaler;
 800a228:	687b      	ldr	r3, [r7, #4]
 800a22a:	887a      	ldrh	r2, [r7, #2]
 800a22c:	851a      	strh	r2, [r3, #40]	; 0x28
  /* Set or reset the UG Bit */
  TIMx->EGR = TIM_PSCReloadMode;
 800a22e:	687b      	ldr	r3, [r7, #4]
 800a230:	883a      	ldrh	r2, [r7, #0]
 800a232:	829a      	strh	r2, [r3, #20]
}
 800a234:	f107 070c 	add.w	r7, r7, #12
 800a238:	46bd      	mov	sp, r7
 800a23a:	bc80      	pop	{r7}
 800a23c:	4770      	bx	lr
 800a23e:	bf00      	nop

0800a240 <TIM_CounterModeConfig>:
  *            @arg TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
  *            @arg TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
  * @retval None
  */
void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
{
 800a240:	b480      	push	{r7}
 800a242:	b085      	sub	sp, #20
 800a244:	af00      	add	r7, sp, #0
 800a246:	6078      	str	r0, [r7, #4]
 800a248:	460b      	mov	r3, r1
 800a24a:	807b      	strh	r3, [r7, #2]
  uint16_t tmpcr1 = 0;
 800a24c:	f04f 0300 	mov.w	r3, #0
 800a250:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));

  tmpcr1 = TIMx->CR1;
 800a252:	687b      	ldr	r3, [r7, #4]
 800a254:	881b      	ldrh	r3, [r3, #0]
 800a256:	81fb      	strh	r3, [r7, #14]

  /* Reset the CMS and DIR Bits */
  tmpcr1 &= (uint16_t)~(TIM_CR1_DIR | TIM_CR1_CMS);
 800a258:	89fb      	ldrh	r3, [r7, #14]
 800a25a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800a25e:	81fb      	strh	r3, [r7, #14]

  /* Set the Counter Mode */
  tmpcr1 |= TIM_CounterMode;
 800a260:	89fa      	ldrh	r2, [r7, #14]
 800a262:	887b      	ldrh	r3, [r7, #2]
 800a264:	4313      	orrs	r3, r2
 800a266:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CR1 register */
  TIMx->CR1 = tmpcr1;
 800a268:	687b      	ldr	r3, [r7, #4]
 800a26a:	89fa      	ldrh	r2, [r7, #14]
 800a26c:	801a      	strh	r2, [r3, #0]
}
 800a26e:	f107 0714 	add.w	r7, r7, #20
 800a272:	46bd      	mov	sp, r7
 800a274:	bc80      	pop	{r7}
 800a276:	4770      	bx	lr

0800a278 <TIM_SetCounter>:
  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
  * @param  Counter: specifies the Counter register new value.
  * @retval None
  */
void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
{
 800a278:	b480      	push	{r7}
 800a27a:	b083      	sub	sp, #12
 800a27c:	af00      	add	r7, sp, #0
 800a27e:	6078      	str	r0, [r7, #4]
 800a280:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
   assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Set the Counter Register value */
  TIMx->CNT = Counter;
 800a282:	687b      	ldr	r3, [r7, #4]
 800a284:	683a      	ldr	r2, [r7, #0]
 800a286:	625a      	str	r2, [r3, #36]	; 0x24
}
 800a288:	f107 070c 	add.w	r7, r7, #12
 800a28c:	46bd      	mov	sp, r7
 800a28e:	bc80      	pop	{r7}
 800a290:	4770      	bx	lr
 800a292:	bf00      	nop

0800a294 <TIM_SetAutoreload>:
  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
  * @param  Autoreload: specifies the Autoreload register new value.
  * @retval None
  */
void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
{
 800a294:	b480      	push	{r7}
 800a296:	b083      	sub	sp, #12
 800a298:	af00      	add	r7, sp, #0
 800a29a:	6078      	str	r0, [r7, #4]
 800a29c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  
  /* Set the Autoreload Register value */
  TIMx->ARR = Autoreload;
 800a29e:	687b      	ldr	r3, [r7, #4]
 800a2a0:	683a      	ldr	r2, [r7, #0]
 800a2a2:	62da      	str	r2, [r3, #44]	; 0x2c
}
 800a2a4:	f107 070c 	add.w	r7, r7, #12
 800a2a8:	46bd      	mov	sp, r7
 800a2aa:	bc80      	pop	{r7}
 800a2ac:	4770      	bx	lr
 800a2ae:	bf00      	nop

0800a2b0 <TIM_GetCounter>:
  * @brief  Gets the TIMx Counter value.
  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
  * @retval Counter Register value
  */
uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
{
 800a2b0:	b480      	push	{r7}
 800a2b2:	b083      	sub	sp, #12
 800a2b4:	af00      	add	r7, sp, #0
 800a2b6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Get the Counter Register value */
  return TIMx->CNT;
 800a2b8:	687b      	ldr	r3, [r7, #4]
 800a2ba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800a2bc:	4618      	mov	r0, r3
 800a2be:	f107 070c 	add.w	r7, r7, #12
 800a2c2:	46bd      	mov	sp, r7
 800a2c4:	bc80      	pop	{r7}
 800a2c6:	4770      	bx	lr

0800a2c8 <TIM_GetPrescaler>:
  * @brief  Gets the TIMx Prescaler value.
  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
  * @retval Prescaler Register value.
  */
uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
{
 800a2c8:	b480      	push	{r7}
 800a2ca:	b083      	sub	sp, #12
 800a2cc:	af00      	add	r7, sp, #0
 800a2ce:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Get the Prescaler Register value */
  return TIMx->PSC;
 800a2d0:	687b      	ldr	r3, [r7, #4]
 800a2d2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800a2d4:	b29b      	uxth	r3, r3
}
 800a2d6:	4618      	mov	r0, r3
 800a2d8:	f107 070c 	add.w	r7, r7, #12
 800a2dc:	46bd      	mov	sp, r7
 800a2de:	bc80      	pop	{r7}
 800a2e0:	4770      	bx	lr
 800a2e2:	bf00      	nop

0800a2e4 <TIM_UpdateDisableConfig>:
  * @param  NewState: new state of the TIMx UDIS bit
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 800a2e4:	b480      	push	{r7}
 800a2e6:	b083      	sub	sp, #12
 800a2e8:	af00      	add	r7, sp, #0
 800a2ea:	6078      	str	r0, [r7, #4]
 800a2ec:	460b      	mov	r3, r1
 800a2ee:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800a2f0:	78fb      	ldrb	r3, [r7, #3]
 800a2f2:	2b00      	cmp	r3, #0
 800a2f4:	d008      	beq.n	800a308 <TIM_UpdateDisableConfig+0x24>
  {
    /* Set the Update Disable Bit */
    TIMx->CR1 |= TIM_CR1_UDIS;
 800a2f6:	687b      	ldr	r3, [r7, #4]
 800a2f8:	881b      	ldrh	r3, [r3, #0]
 800a2fa:	b29b      	uxth	r3, r3
 800a2fc:	f043 0302 	orr.w	r3, r3, #2
 800a300:	b29a      	uxth	r2, r3
 800a302:	687b      	ldr	r3, [r7, #4]
 800a304:	801a      	strh	r2, [r3, #0]
 800a306:	e007      	b.n	800a318 <TIM_UpdateDisableConfig+0x34>
  }
  else
  {
    /* Reset the Update Disable Bit */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_UDIS;
 800a308:	687b      	ldr	r3, [r7, #4]
 800a30a:	881b      	ldrh	r3, [r3, #0]
 800a30c:	b29b      	uxth	r3, r3
 800a30e:	f023 0302 	bic.w	r3, r3, #2
 800a312:	b29a      	uxth	r2, r3
 800a314:	687b      	ldr	r3, [r7, #4]
 800a316:	801a      	strh	r2, [r3, #0]
  }
}
 800a318:	f107 070c 	add.w	r7, r7, #12
 800a31c:	46bd      	mov	sp, r7
 800a31e:	bc80      	pop	{r7}
 800a320:	4770      	bx	lr
 800a322:	bf00      	nop

0800a324 <TIM_UpdateRequestConfig>:
  *                 generation through the slave mode controller.
  *            @arg TIM_UpdateSource_Regular: Source of update is counter overflow/underflow.
  * @retval None
  */
void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
{
 800a324:	b480      	push	{r7}
 800a326:	b083      	sub	sp, #12
 800a328:	af00      	add	r7, sp, #0
 800a32a:	6078      	str	r0, [r7, #4]
 800a32c:	460b      	mov	r3, r1
 800a32e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));

  if (TIM_UpdateSource != TIM_UpdateSource_Global)
 800a330:	887b      	ldrh	r3, [r7, #2]
 800a332:	2b00      	cmp	r3, #0
 800a334:	d008      	beq.n	800a348 <TIM_UpdateRequestConfig+0x24>
  {
    /* Set the URS Bit */
    TIMx->CR1 |= TIM_CR1_URS;
 800a336:	687b      	ldr	r3, [r7, #4]
 800a338:	881b      	ldrh	r3, [r3, #0]
 800a33a:	b29b      	uxth	r3, r3
 800a33c:	f043 0304 	orr.w	r3, r3, #4
 800a340:	b29a      	uxth	r2, r3
 800a342:	687b      	ldr	r3, [r7, #4]
 800a344:	801a      	strh	r2, [r3, #0]
 800a346:	e007      	b.n	800a358 <TIM_UpdateRequestConfig+0x34>
  }
  else
  {
    /* Reset the URS Bit */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_URS;
 800a348:	687b      	ldr	r3, [r7, #4]
 800a34a:	881b      	ldrh	r3, [r3, #0]
 800a34c:	b29b      	uxth	r3, r3
 800a34e:	f023 0304 	bic.w	r3, r3, #4
 800a352:	b29a      	uxth	r2, r3
 800a354:	687b      	ldr	r3, [r7, #4]
 800a356:	801a      	strh	r2, [r3, #0]
  }
}
 800a358:	f107 070c 	add.w	r7, r7, #12
 800a35c:	46bd      	mov	sp, r7
 800a35e:	bc80      	pop	{r7}
 800a360:	4770      	bx	lr
 800a362:	bf00      	nop

0800a364 <TIM_ARRPreloadConfig>:
  * @param  NewState: new state of the TIMx peripheral Preload register
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 800a364:	b480      	push	{r7}
 800a366:	b083      	sub	sp, #12
 800a368:	af00      	add	r7, sp, #0
 800a36a:	6078      	str	r0, [r7, #4]
 800a36c:	460b      	mov	r3, r1
 800a36e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800a370:	78fb      	ldrb	r3, [r7, #3]
 800a372:	2b00      	cmp	r3, #0
 800a374:	d008      	beq.n	800a388 <TIM_ARRPreloadConfig+0x24>
  {
    /* Set the ARR Preload Bit */
    TIMx->CR1 |= TIM_CR1_ARPE;
 800a376:	687b      	ldr	r3, [r7, #4]
 800a378:	881b      	ldrh	r3, [r3, #0]
 800a37a:	b29b      	uxth	r3, r3
 800a37c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a380:	b29a      	uxth	r2, r3
 800a382:	687b      	ldr	r3, [r7, #4]
 800a384:	801a      	strh	r2, [r3, #0]
 800a386:	e007      	b.n	800a398 <TIM_ARRPreloadConfig+0x34>
  }
  else
  {
    /* Reset the ARR Preload Bit */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
 800a388:	687b      	ldr	r3, [r7, #4]
 800a38a:	881b      	ldrh	r3, [r3, #0]
 800a38c:	b29b      	uxth	r3, r3
 800a38e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800a392:	b29a      	uxth	r2, r3
 800a394:	687b      	ldr	r3, [r7, #4]
 800a396:	801a      	strh	r2, [r3, #0]
  }
}
 800a398:	f107 070c 	add.w	r7, r7, #12
 800a39c:	46bd      	mov	sp, r7
 800a39e:	bc80      	pop	{r7}
 800a3a0:	4770      	bx	lr
 800a3a2:	bf00      	nop

0800a3a4 <TIM_SelectOnePulseMode>:
  *            @arg TIM_OPMode_Single
  *            @arg TIM_OPMode_Repetitive
  * @retval None
  */
void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
{
 800a3a4:	b480      	push	{r7}
 800a3a6:	b083      	sub	sp, #12
 800a3a8:	af00      	add	r7, sp, #0
 800a3aa:	6078      	str	r0, [r7, #4]
 800a3ac:	460b      	mov	r3, r1
 800a3ae:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_OPM_MODE(TIM_OPMode));

  /* Reset the OPM Bit */
  TIMx->CR1 &= (uint16_t)~TIM_CR1_OPM;
 800a3b0:	687b      	ldr	r3, [r7, #4]
 800a3b2:	881b      	ldrh	r3, [r3, #0]
 800a3b4:	b29b      	uxth	r3, r3
 800a3b6:	f023 0308 	bic.w	r3, r3, #8
 800a3ba:	b29a      	uxth	r2, r3
 800a3bc:	687b      	ldr	r3, [r7, #4]
 800a3be:	801a      	strh	r2, [r3, #0]

  /* Configure the OPM Mode */
  TIMx->CR1 |= TIM_OPMode;
 800a3c0:	687b      	ldr	r3, [r7, #4]
 800a3c2:	881b      	ldrh	r3, [r3, #0]
 800a3c4:	b29a      	uxth	r2, r3
 800a3c6:	887b      	ldrh	r3, [r7, #2]
 800a3c8:	4313      	orrs	r3, r2
 800a3ca:	b29a      	uxth	r2, r3
 800a3cc:	687b      	ldr	r3, [r7, #4]
 800a3ce:	801a      	strh	r2, [r3, #0]
}
 800a3d0:	f107 070c 	add.w	r7, r7, #12
 800a3d4:	46bd      	mov	sp, r7
 800a3d6:	bc80      	pop	{r7}
 800a3d8:	4770      	bx	lr
 800a3da:	bf00      	nop

0800a3dc <TIM_SetClockDivision>:
  *            @arg TIM_CKD_DIV2: TDTS = 2*Tck_tim
  *            @arg TIM_CKD_DIV4: TDTS = 4*Tck_tim
  * @retval None
  */
void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
{
 800a3dc:	b480      	push	{r7}
 800a3de:	b083      	sub	sp, #12
 800a3e0:	af00      	add	r7, sp, #0
 800a3e2:	6078      	str	r0, [r7, #4]
 800a3e4:	460b      	mov	r3, r1
 800a3e6:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_CKD_DIV(TIM_CKD));

  /* Reset the CKD Bits */
  TIMx->CR1 &= (uint16_t)(~TIM_CR1_CKD);
 800a3e8:	687b      	ldr	r3, [r7, #4]
 800a3ea:	881b      	ldrh	r3, [r3, #0]
 800a3ec:	b29b      	uxth	r3, r3
 800a3ee:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800a3f2:	b29a      	uxth	r2, r3
 800a3f4:	687b      	ldr	r3, [r7, #4]
 800a3f6:	801a      	strh	r2, [r3, #0]

  /* Set the CKD value */
  TIMx->CR1 |= TIM_CKD;
 800a3f8:	687b      	ldr	r3, [r7, #4]
 800a3fa:	881b      	ldrh	r3, [r3, #0]
 800a3fc:	b29a      	uxth	r2, r3
 800a3fe:	887b      	ldrh	r3, [r7, #2]
 800a400:	4313      	orrs	r3, r2
 800a402:	b29a      	uxth	r2, r3
 800a404:	687b      	ldr	r3, [r7, #4]
 800a406:	801a      	strh	r2, [r3, #0]
}
 800a408:	f107 070c 	add.w	r7, r7, #12
 800a40c:	46bd      	mov	sp, r7
 800a40e:	bc80      	pop	{r7}
 800a410:	4770      	bx	lr
 800a412:	bf00      	nop

0800a414 <TIM_Cmd>:
  * @param  NewState: new state of the TIMx peripheral.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 800a414:	b480      	push	{r7}
 800a416:	b083      	sub	sp, #12
 800a418:	af00      	add	r7, sp, #0
 800a41a:	6078      	str	r0, [r7, #4]
 800a41c:	460b      	mov	r3, r1
 800a41e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800a420:	78fb      	ldrb	r3, [r7, #3]
 800a422:	2b00      	cmp	r3, #0
 800a424:	d008      	beq.n	800a438 <TIM_Cmd+0x24>
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 800a426:	687b      	ldr	r3, [r7, #4]
 800a428:	881b      	ldrh	r3, [r3, #0]
 800a42a:	b29b      	uxth	r3, r3
 800a42c:	f043 0301 	orr.w	r3, r3, #1
 800a430:	b29a      	uxth	r2, r3
 800a432:	687b      	ldr	r3, [r7, #4]
 800a434:	801a      	strh	r2, [r3, #0]
 800a436:	e007      	b.n	800a448 <TIM_Cmd+0x34>
  }
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
 800a438:	687b      	ldr	r3, [r7, #4]
 800a43a:	881b      	ldrh	r3, [r3, #0]
 800a43c:	b29b      	uxth	r3, r3
 800a43e:	f023 0301 	bic.w	r3, r3, #1
 800a442:	b29a      	uxth	r2, r3
 800a444:	687b      	ldr	r3, [r7, #4]
 800a446:	801a      	strh	r2, [r3, #0]
  }
}
 800a448:	f107 070c 	add.w	r7, r7, #12
 800a44c:	46bd      	mov	sp, r7
 800a44e:	bc80      	pop	{r7}
 800a450:	4770      	bx	lr
 800a452:	bf00      	nop

0800a454 <TIM_OC1Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 800a454:	b480      	push	{r7}
 800a456:	b085      	sub	sp, #20
 800a458:	af00      	add	r7, sp, #0
 800a45a:	6078      	str	r0, [r7, #4]
 800a45c:	6039      	str	r1, [r7, #0]
  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
 800a45e:	f04f 0300 	mov.w	r3, #0
 800a462:	817b      	strh	r3, [r7, #10]
 800a464:	f04f 0300 	mov.w	r3, #0
 800a468:	81fb      	strh	r3, [r7, #14]
 800a46a:	f04f 0300 	mov.w	r3, #0
 800a46e:	81bb      	strh	r3, [r7, #12]
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
 800a470:	687b      	ldr	r3, [r7, #4]
 800a472:	8c1b      	ldrh	r3, [r3, #32]
 800a474:	b29b      	uxth	r3, r3
 800a476:	f023 0301 	bic.w	r3, r3, #1
 800a47a:	b29a      	uxth	r2, r3
 800a47c:	687b      	ldr	r3, [r7, #4]
 800a47e:	841a      	strh	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800a480:	687b      	ldr	r3, [r7, #4]
 800a482:	8c1b      	ldrh	r3, [r3, #32]
 800a484:	81fb      	strh	r3, [r7, #14]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800a486:	687b      	ldr	r3, [r7, #4]
 800a488:	889b      	ldrh	r3, [r3, #4]
 800a48a:	81bb      	strh	r3, [r7, #12]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 800a48c:	687b      	ldr	r3, [r7, #4]
 800a48e:	8b1b      	ldrh	r3, [r3, #24]
 800a490:	817b      	strh	r3, [r7, #10]
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
 800a492:	897b      	ldrh	r3, [r7, #10]
 800a494:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800a498:	817b      	strh	r3, [r7, #10]
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
 800a49a:	897b      	ldrh	r3, [r7, #10]
 800a49c:	f023 0303 	bic.w	r3, r3, #3
 800a4a0:	817b      	strh	r3, [r7, #10]
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 800a4a2:	683b      	ldr	r3, [r7, #0]
 800a4a4:	881a      	ldrh	r2, [r3, #0]
 800a4a6:	897b      	ldrh	r3, [r7, #10]
 800a4a8:	4313      	orrs	r3, r2
 800a4aa:	817b      	strh	r3, [r7, #10]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC1P;
 800a4ac:	89fb      	ldrh	r3, [r7, #14]
 800a4ae:	f023 0302 	bic.w	r3, r3, #2
 800a4b2:	81fb      	strh	r3, [r7, #14]
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
 800a4b4:	683b      	ldr	r3, [r7, #0]
 800a4b6:	899a      	ldrh	r2, [r3, #12]
 800a4b8:	89fb      	ldrh	r3, [r7, #14]
 800a4ba:	4313      	orrs	r3, r2
 800a4bc:	81fb      	strh	r3, [r7, #14]
  
  /* Set the Output State */
  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
 800a4be:	683b      	ldr	r3, [r7, #0]
 800a4c0:	885a      	ldrh	r2, [r3, #2]
 800a4c2:	89fb      	ldrh	r3, [r7, #14]
 800a4c4:	4313      	orrs	r3, r2
 800a4c6:	81fb      	strh	r3, [r7, #14]
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 800a4c8:	687a      	ldr	r2, [r7, #4]
 800a4ca:	4b1e      	ldr	r3, [pc, #120]	; (800a544 <TIM_OC1Init+0xf0>)
 800a4cc:	429a      	cmp	r2, r3
 800a4ce:	d003      	beq.n	800a4d8 <TIM_OC1Init+0x84>
 800a4d0:	687a      	ldr	r2, [r7, #4]
 800a4d2:	4b1d      	ldr	r3, [pc, #116]	; (800a548 <TIM_OC1Init+0xf4>)
 800a4d4:	429a      	cmp	r2, r3
 800a4d6:	d123      	bne.n	800a520 <TIM_OC1Init+0xcc>
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
 800a4d8:	89fb      	ldrh	r3, [r7, #14]
 800a4da:	f023 0308 	bic.w	r3, r3, #8
 800a4de:	81fb      	strh	r3, [r7, #14]
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
 800a4e0:	683b      	ldr	r3, [r7, #0]
 800a4e2:	89da      	ldrh	r2, [r3, #14]
 800a4e4:	89fb      	ldrh	r3, [r7, #14]
 800a4e6:	4313      	orrs	r3, r2
 800a4e8:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC1NE;
 800a4ea:	89fb      	ldrh	r3, [r7, #14]
 800a4ec:	f023 0304 	bic.w	r3, r3, #4
 800a4f0:	81fb      	strh	r3, [r7, #14]
    
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
 800a4f2:	683b      	ldr	r3, [r7, #0]
 800a4f4:	889a      	ldrh	r2, [r3, #4]
 800a4f6:	89fb      	ldrh	r3, [r7, #14]
 800a4f8:	4313      	orrs	r3, r2
 800a4fa:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
 800a4fc:	89bb      	ldrh	r3, [r7, #12]
 800a4fe:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800a502:	81bb      	strh	r3, [r7, #12]
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
 800a504:	89bb      	ldrh	r3, [r7, #12]
 800a506:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800a50a:	81bb      	strh	r3, [r7, #12]
    /* Set the Output Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
 800a50c:	683b      	ldr	r3, [r7, #0]
 800a50e:	8a1a      	ldrh	r2, [r3, #16]
 800a510:	89bb      	ldrh	r3, [r7, #12]
 800a512:	4313      	orrs	r3, r2
 800a514:	81bb      	strh	r3, [r7, #12]
    /* Set the Output N Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
 800a516:	683b      	ldr	r3, [r7, #0]
 800a518:	8a5a      	ldrh	r2, [r3, #18]
 800a51a:	89bb      	ldrh	r3, [r7, #12]
 800a51c:	4313      	orrs	r3, r2
 800a51e:	81bb      	strh	r3, [r7, #12]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800a520:	687b      	ldr	r3, [r7, #4]
 800a522:	89ba      	ldrh	r2, [r7, #12]
 800a524:	809a      	strh	r2, [r3, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 800a526:	687b      	ldr	r3, [r7, #4]
 800a528:	897a      	ldrh	r2, [r7, #10]
 800a52a:	831a      	strh	r2, [r3, #24]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
 800a52c:	683b      	ldr	r3, [r7, #0]
 800a52e:	689a      	ldr	r2, [r3, #8]
 800a530:	687b      	ldr	r3, [r7, #4]
 800a532:	635a      	str	r2, [r3, #52]	; 0x34
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800a534:	687b      	ldr	r3, [r7, #4]
 800a536:	89fa      	ldrh	r2, [r7, #14]
 800a538:	841a      	strh	r2, [r3, #32]
}
 800a53a:	f107 0714 	add.w	r7, r7, #20
 800a53e:	46bd      	mov	sp, r7
 800a540:	bc80      	pop	{r7}
 800a542:	4770      	bx	lr
 800a544:	40010000 	.word	0x40010000
 800a548:	40010400 	.word	0x40010400

0800a54c <TIM_OC2Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 800a54c:	b480      	push	{r7}
 800a54e:	b085      	sub	sp, #20
 800a550:	af00      	add	r7, sp, #0
 800a552:	6078      	str	r0, [r7, #4]
 800a554:	6039      	str	r1, [r7, #0]
  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
 800a556:	f04f 0300 	mov.w	r3, #0
 800a55a:	817b      	strh	r3, [r7, #10]
 800a55c:	f04f 0300 	mov.w	r3, #0
 800a560:	81fb      	strh	r3, [r7, #14]
 800a562:	f04f 0300 	mov.w	r3, #0
 800a566:	81bb      	strh	r3, [r7, #12]
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
 800a568:	687b      	ldr	r3, [r7, #4]
 800a56a:	8c1b      	ldrh	r3, [r3, #32]
 800a56c:	b29b      	uxth	r3, r3
 800a56e:	f023 0310 	bic.w	r3, r3, #16
 800a572:	b29a      	uxth	r2, r3
 800a574:	687b      	ldr	r3, [r7, #4]
 800a576:	841a      	strh	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */  
  tmpccer = TIMx->CCER;
 800a578:	687b      	ldr	r3, [r7, #4]
 800a57a:	8c1b      	ldrh	r3, [r3, #32]
 800a57c:	81fb      	strh	r3, [r7, #14]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800a57e:	687b      	ldr	r3, [r7, #4]
 800a580:	889b      	ldrh	r3, [r3, #4]
 800a582:	81bb      	strh	r3, [r7, #12]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 800a584:	687b      	ldr	r3, [r7, #4]
 800a586:	8b1b      	ldrh	r3, [r3, #24]
 800a588:	817b      	strh	r3, [r7, #10]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
 800a58a:	897b      	ldrh	r3, [r7, #10]
 800a58c:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800a590:	817b      	strh	r3, [r7, #10]
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
 800a592:	897b      	ldrh	r3, [r7, #10]
 800a594:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800a598:	817b      	strh	r3, [r7, #10]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 800a59a:	683b      	ldr	r3, [r7, #0]
 800a59c:	881b      	ldrh	r3, [r3, #0]
 800a59e:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800a5a2:	b29a      	uxth	r2, r3
 800a5a4:	897b      	ldrh	r3, [r7, #10]
 800a5a6:	4313      	orrs	r3, r2
 800a5a8:	817b      	strh	r3, [r7, #10]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC2P;
 800a5aa:	89fb      	ldrh	r3, [r7, #14]
 800a5ac:	f023 0320 	bic.w	r3, r3, #32
 800a5b0:	81fb      	strh	r3, [r7, #14]
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
 800a5b2:	683b      	ldr	r3, [r7, #0]
 800a5b4:	899b      	ldrh	r3, [r3, #12]
 800a5b6:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800a5ba:	b29a      	uxth	r2, r3
 800a5bc:	89fb      	ldrh	r3, [r7, #14]
 800a5be:	4313      	orrs	r3, r2
 800a5c0:	81fb      	strh	r3, [r7, #14]
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
 800a5c2:	683b      	ldr	r3, [r7, #0]
 800a5c4:	885b      	ldrh	r3, [r3, #2]
 800a5c6:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800a5ca:	b29a      	uxth	r2, r3
 800a5cc:	89fb      	ldrh	r3, [r7, #14]
 800a5ce:	4313      	orrs	r3, r2
 800a5d0:	81fb      	strh	r3, [r7, #14]
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 800a5d2:	687a      	ldr	r2, [r7, #4]
 800a5d4:	4b24      	ldr	r3, [pc, #144]	; (800a668 <TIM_OC2Init+0x11c>)
 800a5d6:	429a      	cmp	r2, r3
 800a5d8:	d003      	beq.n	800a5e2 <TIM_OC2Init+0x96>
 800a5da:	687a      	ldr	r2, [r7, #4]
 800a5dc:	4b23      	ldr	r3, [pc, #140]	; (800a66c <TIM_OC2Init+0x120>)
 800a5de:	429a      	cmp	r2, r3
 800a5e0:	d12f      	bne.n	800a642 <TIM_OC2Init+0xf6>
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
 800a5e2:	89fb      	ldrh	r3, [r7, #14]
 800a5e4:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800a5e8:	81fb      	strh	r3, [r7, #14]
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
 800a5ea:	683b      	ldr	r3, [r7, #0]
 800a5ec:	89db      	ldrh	r3, [r3, #14]
 800a5ee:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800a5f2:	b29a      	uxth	r2, r3
 800a5f4:	89fb      	ldrh	r3, [r7, #14]
 800a5f6:	4313      	orrs	r3, r2
 800a5f8:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
 800a5fa:	89fb      	ldrh	r3, [r7, #14]
 800a5fc:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800a600:	81fb      	strh	r3, [r7, #14]
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
 800a602:	683b      	ldr	r3, [r7, #0]
 800a604:	889b      	ldrh	r3, [r3, #4]
 800a606:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800a60a:	b29a      	uxth	r2, r3
 800a60c:	89fb      	ldrh	r3, [r7, #14]
 800a60e:	4313      	orrs	r3, r2
 800a610:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
 800a612:	89bb      	ldrh	r3, [r7, #12]
 800a614:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800a618:	81bb      	strh	r3, [r7, #12]
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
 800a61a:	89bb      	ldrh	r3, [r7, #12]
 800a61c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800a620:	81bb      	strh	r3, [r7, #12]
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
 800a622:	683b      	ldr	r3, [r7, #0]
 800a624:	8a1b      	ldrh	r3, [r3, #16]
 800a626:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800a62a:	b29a      	uxth	r2, r3
 800a62c:	89bb      	ldrh	r3, [r7, #12]
 800a62e:	4313      	orrs	r3, r2
 800a630:	81bb      	strh	r3, [r7, #12]
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
 800a632:	683b      	ldr	r3, [r7, #0]
 800a634:	8a5b      	ldrh	r3, [r3, #18]
 800a636:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800a63a:	b29a      	uxth	r2, r3
 800a63c:	89bb      	ldrh	r3, [r7, #12]
 800a63e:	4313      	orrs	r3, r2
 800a640:	81bb      	strh	r3, [r7, #12]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800a642:	687b      	ldr	r3, [r7, #4]
 800a644:	89ba      	ldrh	r2, [r7, #12]
 800a646:	809a      	strh	r2, [r3, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 800a648:	687b      	ldr	r3, [r7, #4]
 800a64a:	897a      	ldrh	r2, [r7, #10]
 800a64c:	831a      	strh	r2, [r3, #24]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
 800a64e:	683b      	ldr	r3, [r7, #0]
 800a650:	689a      	ldr	r2, [r3, #8]
 800a652:	687b      	ldr	r3, [r7, #4]
 800a654:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800a656:	687b      	ldr	r3, [r7, #4]
 800a658:	89fa      	ldrh	r2, [r7, #14]
 800a65a:	841a      	strh	r2, [r3, #32]
}
 800a65c:	f107 0714 	add.w	r7, r7, #20
 800a660:	46bd      	mov	sp, r7
 800a662:	bc80      	pop	{r7}
 800a664:	4770      	bx	lr
 800a666:	bf00      	nop
 800a668:	40010000 	.word	0x40010000
 800a66c:	40010400 	.word	0x40010400

0800a670 <TIM_OC3Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 800a670:	b480      	push	{r7}
 800a672:	b085      	sub	sp, #20
 800a674:	af00      	add	r7, sp, #0
 800a676:	6078      	str	r0, [r7, #4]
 800a678:	6039      	str	r1, [r7, #0]
  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
 800a67a:	f04f 0300 	mov.w	r3, #0
 800a67e:	817b      	strh	r3, [r7, #10]
 800a680:	f04f 0300 	mov.w	r3, #0
 800a684:	81fb      	strh	r3, [r7, #14]
 800a686:	f04f 0300 	mov.w	r3, #0
 800a68a:	81bb      	strh	r3, [r7, #12]
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
 800a68c:	687b      	ldr	r3, [r7, #4]
 800a68e:	8c1b      	ldrh	r3, [r3, #32]
 800a690:	b29b      	uxth	r3, r3
 800a692:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800a696:	b29a      	uxth	r2, r3
 800a698:	687b      	ldr	r3, [r7, #4]
 800a69a:	841a      	strh	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800a69c:	687b      	ldr	r3, [r7, #4]
 800a69e:	8c1b      	ldrh	r3, [r3, #32]
 800a6a0:	81fb      	strh	r3, [r7, #14]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800a6a2:	687b      	ldr	r3, [r7, #4]
 800a6a4:	889b      	ldrh	r3, [r3, #4]
 800a6a6:	81bb      	strh	r3, [r7, #12]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 800a6a8:	687b      	ldr	r3, [r7, #4]
 800a6aa:	8b9b      	ldrh	r3, [r3, #28]
 800a6ac:	817b      	strh	r3, [r7, #10]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
 800a6ae:	897b      	ldrh	r3, [r7, #10]
 800a6b0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800a6b4:	817b      	strh	r3, [r7, #10]
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
 800a6b6:	897b      	ldrh	r3, [r7, #10]
 800a6b8:	f023 0303 	bic.w	r3, r3, #3
 800a6bc:	817b      	strh	r3, [r7, #10]
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 800a6be:	683b      	ldr	r3, [r7, #0]
 800a6c0:	881a      	ldrh	r2, [r3, #0]
 800a6c2:	897b      	ldrh	r3, [r7, #10]
 800a6c4:	4313      	orrs	r3, r2
 800a6c6:	817b      	strh	r3, [r7, #10]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC3P;
 800a6c8:	89fb      	ldrh	r3, [r7, #14]
 800a6ca:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800a6ce:	81fb      	strh	r3, [r7, #14]
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
 800a6d0:	683b      	ldr	r3, [r7, #0]
 800a6d2:	899b      	ldrh	r3, [r3, #12]
 800a6d4:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800a6d8:	b29a      	uxth	r2, r3
 800a6da:	89fb      	ldrh	r3, [r7, #14]
 800a6dc:	4313      	orrs	r3, r2
 800a6de:	81fb      	strh	r3, [r7, #14]
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
 800a6e0:	683b      	ldr	r3, [r7, #0]
 800a6e2:	885b      	ldrh	r3, [r3, #2]
 800a6e4:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800a6e8:	b29a      	uxth	r2, r3
 800a6ea:	89fb      	ldrh	r3, [r7, #14]
 800a6ec:	4313      	orrs	r3, r2
 800a6ee:	81fb      	strh	r3, [r7, #14]
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 800a6f0:	687a      	ldr	r2, [r7, #4]
 800a6f2:	4b24      	ldr	r3, [pc, #144]	; (800a784 <TIM_OC3Init+0x114>)
 800a6f4:	429a      	cmp	r2, r3
 800a6f6:	d003      	beq.n	800a700 <TIM_OC3Init+0x90>
 800a6f8:	687a      	ldr	r2, [r7, #4]
 800a6fa:	4b23      	ldr	r3, [pc, #140]	; (800a788 <TIM_OC3Init+0x118>)
 800a6fc:	429a      	cmp	r2, r3
 800a6fe:	d12f      	bne.n	800a760 <TIM_OC3Init+0xf0>
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
 800a700:	89fb      	ldrh	r3, [r7, #14]
 800a702:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800a706:	81fb      	strh	r3, [r7, #14]
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
 800a708:	683b      	ldr	r3, [r7, #0]
 800a70a:	89db      	ldrh	r3, [r3, #14]
 800a70c:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800a710:	b29a      	uxth	r2, r3
 800a712:	89fb      	ldrh	r3, [r7, #14]
 800a714:	4313      	orrs	r3, r2
 800a716:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC3NE;
 800a718:	89fb      	ldrh	r3, [r7, #14]
 800a71a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800a71e:	81fb      	strh	r3, [r7, #14]
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
 800a720:	683b      	ldr	r3, [r7, #0]
 800a722:	889b      	ldrh	r3, [r3, #4]
 800a724:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800a728:	b29a      	uxth	r2, r3
 800a72a:	89fb      	ldrh	r3, [r7, #14]
 800a72c:	4313      	orrs	r3, r2
 800a72e:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
 800a730:	89bb      	ldrh	r3, [r7, #12]
 800a732:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800a736:	81bb      	strh	r3, [r7, #12]
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
 800a738:	89bb      	ldrh	r3, [r7, #12]
 800a73a:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800a73e:	81bb      	strh	r3, [r7, #12]
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
 800a740:	683b      	ldr	r3, [r7, #0]
 800a742:	8a1b      	ldrh	r3, [r3, #16]
 800a744:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800a748:	b29a      	uxth	r2, r3
 800a74a:	89bb      	ldrh	r3, [r7, #12]
 800a74c:	4313      	orrs	r3, r2
 800a74e:	81bb      	strh	r3, [r7, #12]
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
 800a750:	683b      	ldr	r3, [r7, #0]
 800a752:	8a5b      	ldrh	r3, [r3, #18]
 800a754:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800a758:	b29a      	uxth	r2, r3
 800a75a:	89bb      	ldrh	r3, [r7, #12]
 800a75c:	4313      	orrs	r3, r2
 800a75e:	81bb      	strh	r3, [r7, #12]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800a760:	687b      	ldr	r3, [r7, #4]
 800a762:	89ba      	ldrh	r2, [r7, #12]
 800a764:	809a      	strh	r2, [r3, #4]
  
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 800a766:	687b      	ldr	r3, [r7, #4]
 800a768:	897a      	ldrh	r2, [r7, #10]
 800a76a:	839a      	strh	r2, [r3, #28]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
 800a76c:	683b      	ldr	r3, [r7, #0]
 800a76e:	689a      	ldr	r2, [r3, #8]
 800a770:	687b      	ldr	r3, [r7, #4]
 800a772:	63da      	str	r2, [r3, #60]	; 0x3c
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800a774:	687b      	ldr	r3, [r7, #4]
 800a776:	89fa      	ldrh	r2, [r7, #14]
 800a778:	841a      	strh	r2, [r3, #32]
}
 800a77a:	f107 0714 	add.w	r7, r7, #20
 800a77e:	46bd      	mov	sp, r7
 800a780:	bc80      	pop	{r7}
 800a782:	4770      	bx	lr
 800a784:	40010000 	.word	0x40010000
 800a788:	40010400 	.word	0x40010400

0800a78c <TIM_OC4Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 800a78c:	b480      	push	{r7}
 800a78e:	b085      	sub	sp, #20
 800a790:	af00      	add	r7, sp, #0
 800a792:	6078      	str	r0, [r7, #4]
 800a794:	6039      	str	r1, [r7, #0]
  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
 800a796:	f04f 0300 	mov.w	r3, #0
 800a79a:	81bb      	strh	r3, [r7, #12]
 800a79c:	f04f 0300 	mov.w	r3, #0
 800a7a0:	817b      	strh	r3, [r7, #10]
 800a7a2:	f04f 0300 	mov.w	r3, #0
 800a7a6:	81fb      	strh	r3, [r7, #14]
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
 800a7a8:	687b      	ldr	r3, [r7, #4]
 800a7aa:	8c1b      	ldrh	r3, [r3, #32]
 800a7ac:	b29b      	uxth	r3, r3
 800a7ae:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800a7b2:	b29a      	uxth	r2, r3
 800a7b4:	687b      	ldr	r3, [r7, #4]
 800a7b6:	841a      	strh	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800a7b8:	687b      	ldr	r3, [r7, #4]
 800a7ba:	8c1b      	ldrh	r3, [r3, #32]
 800a7bc:	817b      	strh	r3, [r7, #10]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800a7be:	687b      	ldr	r3, [r7, #4]
 800a7c0:	889b      	ldrh	r3, [r3, #4]
 800a7c2:	81fb      	strh	r3, [r7, #14]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 800a7c4:	687b      	ldr	r3, [r7, #4]
 800a7c6:	8b9b      	ldrh	r3, [r3, #28]
 800a7c8:	81bb      	strh	r3, [r7, #12]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
 800a7ca:	89bb      	ldrh	r3, [r7, #12]
 800a7cc:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800a7d0:	81bb      	strh	r3, [r7, #12]
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
 800a7d2:	89bb      	ldrh	r3, [r7, #12]
 800a7d4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800a7d8:	81bb      	strh	r3, [r7, #12]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 800a7da:	683b      	ldr	r3, [r7, #0]
 800a7dc:	881b      	ldrh	r3, [r3, #0]
 800a7de:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800a7e2:	b29a      	uxth	r2, r3
 800a7e4:	89bb      	ldrh	r3, [r7, #12]
 800a7e6:	4313      	orrs	r3, r2
 800a7e8:	81bb      	strh	r3, [r7, #12]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC4P;
 800a7ea:	897b      	ldrh	r3, [r7, #10]
 800a7ec:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800a7f0:	817b      	strh	r3, [r7, #10]
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
 800a7f2:	683b      	ldr	r3, [r7, #0]
 800a7f4:	899b      	ldrh	r3, [r3, #12]
 800a7f6:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800a7fa:	b29a      	uxth	r2, r3
 800a7fc:	897b      	ldrh	r3, [r7, #10]
 800a7fe:	4313      	orrs	r3, r2
 800a800:	817b      	strh	r3, [r7, #10]
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
 800a802:	683b      	ldr	r3, [r7, #0]
 800a804:	885b      	ldrh	r3, [r3, #2]
 800a806:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800a80a:	b29a      	uxth	r2, r3
 800a80c:	897b      	ldrh	r3, [r7, #10]
 800a80e:	4313      	orrs	r3, r2
 800a810:	817b      	strh	r3, [r7, #10]
  
  if((TIMx == TIM1) || (TIMx == TIM8))
 800a812:	687a      	ldr	r2, [r7, #4]
 800a814:	4b12      	ldr	r3, [pc, #72]	; (800a860 <TIM_OC4Init+0xd4>)
 800a816:	429a      	cmp	r2, r3
 800a818:	d003      	beq.n	800a822 <TIM_OC4Init+0x96>
 800a81a:	687a      	ldr	r2, [r7, #4]
 800a81c:	4b11      	ldr	r3, [pc, #68]	; (800a864 <TIM_OC4Init+0xd8>)
 800a81e:	429a      	cmp	r2, r3
 800a820:	d10b      	bne.n	800a83a <TIM_OC4Init+0xae>
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &=(uint16_t) ~TIM_CR2_OIS4;
 800a822:	89fb      	ldrh	r3, [r7, #14]
 800a824:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800a828:	81fb      	strh	r3, [r7, #14]
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
 800a82a:	683b      	ldr	r3, [r7, #0]
 800a82c:	8a1b      	ldrh	r3, [r3, #16]
 800a82e:	ea4f 1383 	mov.w	r3, r3, lsl #6
 800a832:	b29a      	uxth	r2, r3
 800a834:	89fb      	ldrh	r3, [r7, #14]
 800a836:	4313      	orrs	r3, r2
 800a838:	81fb      	strh	r3, [r7, #14]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800a83a:	687b      	ldr	r3, [r7, #4]
 800a83c:	89fa      	ldrh	r2, [r7, #14]
 800a83e:	809a      	strh	r2, [r3, #4]
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR2 = tmpccmrx;
 800a840:	687b      	ldr	r3, [r7, #4]
 800a842:	89ba      	ldrh	r2, [r7, #12]
 800a844:	839a      	strh	r2, [r3, #28]
    
  /* Set the Capture Compare Register value */
  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
 800a846:	683b      	ldr	r3, [r7, #0]
 800a848:	689a      	ldr	r2, [r3, #8]
 800a84a:	687b      	ldr	r3, [r7, #4]
 800a84c:	641a      	str	r2, [r3, #64]	; 0x40
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800a84e:	687b      	ldr	r3, [r7, #4]
 800a850:	897a      	ldrh	r2, [r7, #10]
 800a852:	841a      	strh	r2, [r3, #32]
}
 800a854:	f107 0714 	add.w	r7, r7, #20
 800a858:	46bd      	mov	sp, r7
 800a85a:	bc80      	pop	{r7}
 800a85c:	4770      	bx	lr
 800a85e:	bf00      	nop
 800a860:	40010000 	.word	0x40010000
 800a864:	40010400 	.word	0x40010400

0800a868 <TIM_OCStructInit>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure which will
  *         be initialized.
  * @retval None
  */
void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 800a868:	b480      	push	{r7}
 800a86a:	b083      	sub	sp, #12
 800a86c:	af00      	add	r7, sp, #0
 800a86e:	6078      	str	r0, [r7, #4]
  /* Set the default configuration */
  TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
 800a870:	687b      	ldr	r3, [r7, #4]
 800a872:	f04f 0200 	mov.w	r2, #0
 800a876:	801a      	strh	r2, [r3, #0]
  TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
 800a878:	687b      	ldr	r3, [r7, #4]
 800a87a:	f04f 0200 	mov.w	r2, #0
 800a87e:	805a      	strh	r2, [r3, #2]
  TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
 800a880:	687b      	ldr	r3, [r7, #4]
 800a882:	f04f 0200 	mov.w	r2, #0
 800a886:	809a      	strh	r2, [r3, #4]
  TIM_OCInitStruct->TIM_Pulse = 0x00000000;
 800a888:	687b      	ldr	r3, [r7, #4]
 800a88a:	f04f 0200 	mov.w	r2, #0
 800a88e:	609a      	str	r2, [r3, #8]
  TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
 800a890:	687b      	ldr	r3, [r7, #4]
 800a892:	f04f 0200 	mov.w	r2, #0
 800a896:	819a      	strh	r2, [r3, #12]
  TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
 800a898:	687b      	ldr	r3, [r7, #4]
 800a89a:	f04f 0200 	mov.w	r2, #0
 800a89e:	81da      	strh	r2, [r3, #14]
  TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
 800a8a0:	687b      	ldr	r3, [r7, #4]
 800a8a2:	f04f 0200 	mov.w	r2, #0
 800a8a6:	821a      	strh	r2, [r3, #16]
  TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
 800a8a8:	687b      	ldr	r3, [r7, #4]
 800a8aa:	f04f 0200 	mov.w	r2, #0
 800a8ae:	825a      	strh	r2, [r3, #18]
}
 800a8b0:	f107 070c 	add.w	r7, r7, #12
 800a8b4:	46bd      	mov	sp, r7
 800a8b6:	bc80      	pop	{r7}
 800a8b8:	4770      	bx	lr
 800a8ba:	bf00      	nop

0800a8bc <TIM_SelectOCxM>:
  *            @arg TIM_ForcedAction_Active
  *            @arg TIM_ForcedAction_InActive
  * @retval None
  */
void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
{
 800a8bc:	b480      	push	{r7}
 800a8be:	b085      	sub	sp, #20
 800a8c0:	af00      	add	r7, sp, #0
 800a8c2:	6078      	str	r0, [r7, #4]
 800a8c4:	4613      	mov	r3, r2
 800a8c6:	460a      	mov	r2, r1
 800a8c8:	807a      	strh	r2, [r7, #2]
 800a8ca:	803b      	strh	r3, [r7, #0]
  uint32_t tmp = 0;
 800a8cc:	f04f 0300 	mov.w	r3, #0
 800a8d0:	60fb      	str	r3, [r7, #12]
  uint16_t tmp1 = 0;
 800a8d2:	f04f 0300 	mov.w	r3, #0
 800a8d6:	817b      	strh	r3, [r7, #10]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_OCM(TIM_OCMode));

  tmp = (uint32_t) TIMx;
 800a8d8:	687b      	ldr	r3, [r7, #4]
 800a8da:	60fb      	str	r3, [r7, #12]
  tmp += CCMR_OFFSET;
 800a8dc:	68fb      	ldr	r3, [r7, #12]
 800a8de:	f103 0318 	add.w	r3, r3, #24
 800a8e2:	60fb      	str	r3, [r7, #12]

  tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
 800a8e4:	887b      	ldrh	r3, [r7, #2]
 800a8e6:	f04f 0201 	mov.w	r2, #1
 800a8ea:	fa02 f303 	lsl.w	r3, r2, r3
 800a8ee:	817b      	strh	r3, [r7, #10]

  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;
 800a8f0:	687b      	ldr	r3, [r7, #4]
 800a8f2:	8c1b      	ldrh	r3, [r3, #32]
 800a8f4:	b29a      	uxth	r2, r3
 800a8f6:	897b      	ldrh	r3, [r7, #10]
 800a8f8:	ea6f 0303 	mvn.w	r3, r3
 800a8fc:	b29b      	uxth	r3, r3
 800a8fe:	4013      	ands	r3, r2
 800a900:	b29a      	uxth	r2, r3
 800a902:	687b      	ldr	r3, [r7, #4]
 800a904:	841a      	strh	r2, [r3, #32]

  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
 800a906:	887b      	ldrh	r3, [r7, #2]
 800a908:	2b00      	cmp	r3, #0
 800a90a:	d002      	beq.n	800a912 <TIM_SelectOCxM+0x56>
 800a90c:	887b      	ldrh	r3, [r7, #2]
 800a90e:	2b08      	cmp	r3, #8
 800a910:	d114      	bne.n	800a93c <TIM_SelectOCxM+0x80>
  {
    tmp += (TIM_Channel>>1);
 800a912:	887b      	ldrh	r3, [r7, #2]
 800a914:	ea4f 0353 	mov.w	r3, r3, lsr #1
 800a918:	b29b      	uxth	r3, r3
 800a91a:	68fa      	ldr	r2, [r7, #12]
 800a91c:	18d3      	adds	r3, r2, r3
 800a91e:	60fb      	str	r3, [r7, #12]

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= CCMR_OC13M_MASK;
 800a920:	68fa      	ldr	r2, [r7, #12]
 800a922:	68fb      	ldr	r3, [r7, #12]
 800a924:	6819      	ldr	r1, [r3, #0]
 800a926:	f64f 738f 	movw	r3, #65423	; 0xff8f
 800a92a:	400b      	ands	r3, r1
 800a92c:	6013      	str	r3, [r2, #0]
   
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= TIM_OCMode;
 800a92e:	68fb      	ldr	r3, [r7, #12]
 800a930:	68fa      	ldr	r2, [r7, #12]
 800a932:	6811      	ldr	r1, [r2, #0]
 800a934:	883a      	ldrh	r2, [r7, #0]
 800a936:	430a      	orrs	r2, r1
 800a938:	601a      	str	r2, [r3, #0]
 800a93a:	e019      	b.n	800a970 <TIM_SelectOCxM+0xb4>
  }
  else
  {
    tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
 800a93c:	887b      	ldrh	r3, [r7, #2]
 800a93e:	f1a3 0304 	sub.w	r3, r3, #4
 800a942:	b29b      	uxth	r3, r3
 800a944:	ea4f 0353 	mov.w	r3, r3, lsr #1
 800a948:	b29b      	uxth	r3, r3
 800a94a:	68fa      	ldr	r2, [r7, #12]
 800a94c:	18d3      	adds	r3, r2, r3
 800a94e:	60fb      	str	r3, [r7, #12]

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
 800a950:	68fa      	ldr	r2, [r7, #12]
 800a952:	68fb      	ldr	r3, [r7, #12]
 800a954:	6819      	ldr	r1, [r3, #0]
 800a956:	f648 73ff 	movw	r3, #36863	; 0x8fff
 800a95a:	400b      	ands	r3, r1
 800a95c:	6013      	str	r3, [r2, #0]
    
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
 800a95e:	68fb      	ldr	r3, [r7, #12]
 800a960:	68fa      	ldr	r2, [r7, #12]
 800a962:	6811      	ldr	r1, [r2, #0]
 800a964:	883a      	ldrh	r2, [r7, #0]
 800a966:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800a96a:	b292      	uxth	r2, r2
 800a96c:	430a      	orrs	r2, r1
 800a96e:	601a      	str	r2, [r3, #0]
  }
}
 800a970:	f107 0714 	add.w	r7, r7, #20
 800a974:	46bd      	mov	sp, r7
 800a976:	bc80      	pop	{r7}
 800a978:	4770      	bx	lr
 800a97a:	bf00      	nop

0800a97c <TIM_SetCompare1>:
  * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
  * @param  Compare1: specifies the Capture Compare1 register new value.
  * @retval None
  */
void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
{
 800a97c:	b480      	push	{r7}
 800a97e:	b083      	sub	sp, #12
 800a980:	af00      	add	r7, sp, #0
 800a982:	6078      	str	r0, [r7, #4]
 800a984:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));

  /* Set the Capture Compare1 Register value */
  TIMx->CCR1 = Compare1;
 800a986:	687b      	ldr	r3, [r7, #4]
 800a988:	683a      	ldr	r2, [r7, #0]
 800a98a:	635a      	str	r2, [r3, #52]	; 0x34
}
 800a98c:	f107 070c 	add.w	r7, r7, #12
 800a990:	46bd      	mov	sp, r7
 800a992:	bc80      	pop	{r7}
 800a994:	4770      	bx	lr
 800a996:	bf00      	nop

0800a998 <TIM_SetCompare2>:
  *         peripheral.
  * @param  Compare2: specifies the Capture Compare2 register new value.
  * @retval None
  */
void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
{
 800a998:	b480      	push	{r7}
 800a99a:	b083      	sub	sp, #12
 800a99c:	af00      	add	r7, sp, #0
 800a99e:	6078      	str	r0, [r7, #4]
 800a9a0:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Set the Capture Compare2 Register value */
  TIMx->CCR2 = Compare2;
 800a9a2:	687b      	ldr	r3, [r7, #4]
 800a9a4:	683a      	ldr	r2, [r7, #0]
 800a9a6:	639a      	str	r2, [r3, #56]	; 0x38
}
 800a9a8:	f107 070c 	add.w	r7, r7, #12
 800a9ac:	46bd      	mov	sp, r7
 800a9ae:	bc80      	pop	{r7}
 800a9b0:	4770      	bx	lr
 800a9b2:	bf00      	nop

0800a9b4 <TIM_SetCompare3>:
  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
  * @param  Compare3: specifies the Capture Compare3 register new value.
  * @retval None
  */
void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
{
 800a9b4:	b480      	push	{r7}
 800a9b6:	b083      	sub	sp, #12
 800a9b8:	af00      	add	r7, sp, #0
 800a9ba:	6078      	str	r0, [r7, #4]
 800a9bc:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Set the Capture Compare3 Register value */
  TIMx->CCR3 = Compare3;
 800a9be:	687b      	ldr	r3, [r7, #4]
 800a9c0:	683a      	ldr	r2, [r7, #0]
 800a9c2:	63da      	str	r2, [r3, #60]	; 0x3c
}
 800a9c4:	f107 070c 	add.w	r7, r7, #12
 800a9c8:	46bd      	mov	sp, r7
 800a9ca:	bc80      	pop	{r7}
 800a9cc:	4770      	bx	lr
 800a9ce:	bf00      	nop

0800a9d0 <TIM_SetCompare4>:
  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
  * @param  Compare4: specifies the Capture Compare4 register new value.
  * @retval None
  */
void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
{
 800a9d0:	b480      	push	{r7}
 800a9d2:	b083      	sub	sp, #12
 800a9d4:	af00      	add	r7, sp, #0
 800a9d6:	6078      	str	r0, [r7, #4]
 800a9d8:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Set the Capture Compare4 Register value */
  TIMx->CCR4 = Compare4;
 800a9da:	687b      	ldr	r3, [r7, #4]
 800a9dc:	683a      	ldr	r2, [r7, #0]
 800a9de:	641a      	str	r2, [r3, #64]	; 0x40
}
 800a9e0:	f107 070c 	add.w	r7, r7, #12
 800a9e4:	46bd      	mov	sp, r7
 800a9e6:	bc80      	pop	{r7}
 800a9e8:	4770      	bx	lr
 800a9ea:	bf00      	nop

0800a9ec <TIM_ForcedOC1Config>:
  *            @arg TIM_ForcedAction_Active: Force active level on OC1REF
  *            @arg TIM_ForcedAction_InActive: Force inactive level on OC1REF.
  * @retval None
  */
void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
{
 800a9ec:	b480      	push	{r7}
 800a9ee:	b085      	sub	sp, #20
 800a9f0:	af00      	add	r7, sp, #0
 800a9f2:	6078      	str	r0, [r7, #4]
 800a9f4:	460b      	mov	r3, r1
 800a9f6:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 800a9f8:	f04f 0300 	mov.w	r3, #0
 800a9fc:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr1 = TIMx->CCMR1;
 800a9fe:	687b      	ldr	r3, [r7, #4]
 800aa00:	8b1b      	ldrh	r3, [r3, #24]
 800aa02:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC1M Bits */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1M;
 800aa04:	89fb      	ldrh	r3, [r7, #14]
 800aa06:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800aa0a:	81fb      	strh	r3, [r7, #14]

  /* Configure The Forced output Mode */
  tmpccmr1 |= TIM_ForcedAction;
 800aa0c:	89fa      	ldrh	r2, [r7, #14]
 800aa0e:	887b      	ldrh	r3, [r7, #2]
 800aa10:	4313      	orrs	r3, r2
 800aa12:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 800aa14:	687b      	ldr	r3, [r7, #4]
 800aa16:	89fa      	ldrh	r2, [r7, #14]
 800aa18:	831a      	strh	r2, [r3, #24]
}
 800aa1a:	f107 0714 	add.w	r7, r7, #20
 800aa1e:	46bd      	mov	sp, r7
 800aa20:	bc80      	pop	{r7}
 800aa22:	4770      	bx	lr

0800aa24 <TIM_ForcedOC2Config>:
  *            @arg TIM_ForcedAction_Active: Force active level on OC2REF
  *            @arg TIM_ForcedAction_InActive: Force inactive level on OC2REF.
  * @retval None
  */
void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
{
 800aa24:	b480      	push	{r7}
 800aa26:	b085      	sub	sp, #20
 800aa28:	af00      	add	r7, sp, #0
 800aa2a:	6078      	str	r0, [r7, #4]
 800aa2c:	460b      	mov	r3, r1
 800aa2e:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 800aa30:	f04f 0300 	mov.w	r3, #0
 800aa34:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr1 = TIMx->CCMR1;
 800aa36:	687b      	ldr	r3, [r7, #4]
 800aa38:	8b1b      	ldrh	r3, [r3, #24]
 800aa3a:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC2M Bits */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2M;
 800aa3c:	89fb      	ldrh	r3, [r7, #14]
 800aa3e:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800aa42:	81fb      	strh	r3, [r7, #14]

  /* Configure The Forced output Mode */
  tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
 800aa44:	887b      	ldrh	r3, [r7, #2]
 800aa46:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800aa4a:	b29a      	uxth	r2, r3
 800aa4c:	89fb      	ldrh	r3, [r7, #14]
 800aa4e:	4313      	orrs	r3, r2
 800aa50:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 800aa52:	687b      	ldr	r3, [r7, #4]
 800aa54:	89fa      	ldrh	r2, [r7, #14]
 800aa56:	831a      	strh	r2, [r3, #24]
}
 800aa58:	f107 0714 	add.w	r7, r7, #20
 800aa5c:	46bd      	mov	sp, r7
 800aa5e:	bc80      	pop	{r7}
 800aa60:	4770      	bx	lr
 800aa62:	bf00      	nop

0800aa64 <TIM_ForcedOC3Config>:
  *            @arg TIM_ForcedAction_Active: Force active level on OC3REF
  *            @arg TIM_ForcedAction_InActive: Force inactive level on OC3REF.
  * @retval None
  */
void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
{
 800aa64:	b480      	push	{r7}
 800aa66:	b085      	sub	sp, #20
 800aa68:	af00      	add	r7, sp, #0
 800aa6a:	6078      	str	r0, [r7, #4]
 800aa6c:	460b      	mov	r3, r1
 800aa6e:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
 800aa70:	f04f 0300 	mov.w	r3, #0
 800aa74:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));

  tmpccmr2 = TIMx->CCMR2;
 800aa76:	687b      	ldr	r3, [r7, #4]
 800aa78:	8b9b      	ldrh	r3, [r3, #28]
 800aa7a:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC1M Bits */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3M;
 800aa7c:	89fb      	ldrh	r3, [r7, #14]
 800aa7e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800aa82:	81fb      	strh	r3, [r7, #14]

  /* Configure The Forced output Mode */
  tmpccmr2 |= TIM_ForcedAction;
 800aa84:	89fa      	ldrh	r2, [r7, #14]
 800aa86:	887b      	ldrh	r3, [r7, #2]
 800aa88:	4313      	orrs	r3, r2
 800aa8a:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 800aa8c:	687b      	ldr	r3, [r7, #4]
 800aa8e:	89fa      	ldrh	r2, [r7, #14]
 800aa90:	839a      	strh	r2, [r3, #28]
}
 800aa92:	f107 0714 	add.w	r7, r7, #20
 800aa96:	46bd      	mov	sp, r7
 800aa98:	bc80      	pop	{r7}
 800aa9a:	4770      	bx	lr

0800aa9c <TIM_ForcedOC4Config>:
  *            @arg TIM_ForcedAction_Active: Force active level on OC4REF
  *            @arg TIM_ForcedAction_InActive: Force inactive level on OC4REF.
  * @retval None
  */
void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
{
 800aa9c:	b480      	push	{r7}
 800aa9e:	b085      	sub	sp, #20
 800aaa0:	af00      	add	r7, sp, #0
 800aaa2:	6078      	str	r0, [r7, #4]
 800aaa4:	460b      	mov	r3, r1
 800aaa6:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
 800aaa8:	f04f 0300 	mov.w	r3, #0
 800aaac:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr2 = TIMx->CCMR2;
 800aaae:	687b      	ldr	r3, [r7, #4]
 800aab0:	8b9b      	ldrh	r3, [r3, #28]
 800aab2:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC2M Bits */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4M;
 800aab4:	89fb      	ldrh	r3, [r7, #14]
 800aab6:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800aaba:	81fb      	strh	r3, [r7, #14]

  /* Configure The Forced output Mode */
  tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
 800aabc:	887b      	ldrh	r3, [r7, #2]
 800aabe:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800aac2:	b29a      	uxth	r2, r3
 800aac4:	89fb      	ldrh	r3, [r7, #14]
 800aac6:	4313      	orrs	r3, r2
 800aac8:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 800aaca:	687b      	ldr	r3, [r7, #4]
 800aacc:	89fa      	ldrh	r2, [r7, #14]
 800aace:	839a      	strh	r2, [r3, #28]
}
 800aad0:	f107 0714 	add.w	r7, r7, #20
 800aad4:	46bd      	mov	sp, r7
 800aad6:	bc80      	pop	{r7}
 800aad8:	4770      	bx	lr
 800aada:	bf00      	nop

0800aadc <TIM_OC1PreloadConfig>:
  *            @arg TIM_OCPreload_Enable
  *            @arg TIM_OCPreload_Disable
  * @retval None
  */
void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
{
 800aadc:	b480      	push	{r7}
 800aade:	b085      	sub	sp, #20
 800aae0:	af00      	add	r7, sp, #0
 800aae2:	6078      	str	r0, [r7, #4]
 800aae4:	460b      	mov	r3, r1
 800aae6:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 800aae8:	f04f 0300 	mov.w	r3, #0
 800aaec:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr1 = TIMx->CCMR1;
 800aaee:	687b      	ldr	r3, [r7, #4]
 800aaf0:	8b1b      	ldrh	r3, [r3, #24]
 800aaf2:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC1PE Bit */
  tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC1PE);
 800aaf4:	89fb      	ldrh	r3, [r7, #14]
 800aaf6:	f023 0308 	bic.w	r3, r3, #8
 800aafa:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= TIM_OCPreload;
 800aafc:	89fa      	ldrh	r2, [r7, #14]
 800aafe:	887b      	ldrh	r3, [r7, #2]
 800ab00:	4313      	orrs	r3, r2
 800ab02:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 800ab04:	687b      	ldr	r3, [r7, #4]
 800ab06:	89fa      	ldrh	r2, [r7, #14]
 800ab08:	831a      	strh	r2, [r3, #24]
}
 800ab0a:	f107 0714 	add.w	r7, r7, #20
 800ab0e:	46bd      	mov	sp, r7
 800ab10:	bc80      	pop	{r7}
 800ab12:	4770      	bx	lr

0800ab14 <TIM_OC2PreloadConfig>:
  *            @arg TIM_OCPreload_Enable
  *            @arg TIM_OCPreload_Disable
  * @retval None
  */
void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
{
 800ab14:	b480      	push	{r7}
 800ab16:	b085      	sub	sp, #20
 800ab18:	af00      	add	r7, sp, #0
 800ab1a:	6078      	str	r0, [r7, #4]
 800ab1c:	460b      	mov	r3, r1
 800ab1e:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 800ab20:	f04f 0300 	mov.w	r3, #0
 800ab24:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr1 = TIMx->CCMR1;
 800ab26:	687b      	ldr	r3, [r7, #4]
 800ab28:	8b1b      	ldrh	r3, [r3, #24]
 800ab2a:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC2PE Bit */
  tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2PE);
 800ab2c:	89fb      	ldrh	r3, [r7, #14]
 800ab2e:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800ab32:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
 800ab34:	887b      	ldrh	r3, [r7, #2]
 800ab36:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800ab3a:	b29a      	uxth	r2, r3
 800ab3c:	89fb      	ldrh	r3, [r7, #14]
 800ab3e:	4313      	orrs	r3, r2
 800ab40:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 800ab42:	687b      	ldr	r3, [r7, #4]
 800ab44:	89fa      	ldrh	r2, [r7, #14]
 800ab46:	831a      	strh	r2, [r3, #24]
}
 800ab48:	f107 0714 	add.w	r7, r7, #20
 800ab4c:	46bd      	mov	sp, r7
 800ab4e:	bc80      	pop	{r7}
 800ab50:	4770      	bx	lr
 800ab52:	bf00      	nop

0800ab54 <TIM_OC3PreloadConfig>:
  *            @arg TIM_OCPreload_Enable
  *            @arg TIM_OCPreload_Disable
  * @retval None
  */
void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
{
 800ab54:	b480      	push	{r7}
 800ab56:	b085      	sub	sp, #20
 800ab58:	af00      	add	r7, sp, #0
 800ab5a:	6078      	str	r0, [r7, #4]
 800ab5c:	460b      	mov	r3, r1
 800ab5e:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
 800ab60:	f04f 0300 	mov.w	r3, #0
 800ab64:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr2 = TIMx->CCMR2;
 800ab66:	687b      	ldr	r3, [r7, #4]
 800ab68:	8b9b      	ldrh	r3, [r3, #28]
 800ab6a:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC3PE Bit */
  tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC3PE);
 800ab6c:	89fb      	ldrh	r3, [r7, #14]
 800ab6e:	f023 0308 	bic.w	r3, r3, #8
 800ab72:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr2 |= TIM_OCPreload;
 800ab74:	89fa      	ldrh	r2, [r7, #14]
 800ab76:	887b      	ldrh	r3, [r7, #2]
 800ab78:	4313      	orrs	r3, r2
 800ab7a:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 800ab7c:	687b      	ldr	r3, [r7, #4]
 800ab7e:	89fa      	ldrh	r2, [r7, #14]
 800ab80:	839a      	strh	r2, [r3, #28]
}
 800ab82:	f107 0714 	add.w	r7, r7, #20
 800ab86:	46bd      	mov	sp, r7
 800ab88:	bc80      	pop	{r7}
 800ab8a:	4770      	bx	lr

0800ab8c <TIM_OC4PreloadConfig>:
  *            @arg TIM_OCPreload_Enable
  *            @arg TIM_OCPreload_Disable
  * @retval None
  */
void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
{
 800ab8c:	b480      	push	{r7}
 800ab8e:	b085      	sub	sp, #20
 800ab90:	af00      	add	r7, sp, #0
 800ab92:	6078      	str	r0, [r7, #4]
 800ab94:	460b      	mov	r3, r1
 800ab96:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
 800ab98:	f04f 0300 	mov.w	r3, #0
 800ab9c:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr2 = TIMx->CCMR2;
 800ab9e:	687b      	ldr	r3, [r7, #4]
 800aba0:	8b9b      	ldrh	r3, [r3, #28]
 800aba2:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC4PE Bit */
  tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4PE);
 800aba4:	89fb      	ldrh	r3, [r7, #14]
 800aba6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800abaa:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
 800abac:	887b      	ldrh	r3, [r7, #2]
 800abae:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800abb2:	b29a      	uxth	r2, r3
 800abb4:	89fb      	ldrh	r3, [r7, #14]
 800abb6:	4313      	orrs	r3, r2
 800abb8:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 800abba:	687b      	ldr	r3, [r7, #4]
 800abbc:	89fa      	ldrh	r2, [r7, #14]
 800abbe:	839a      	strh	r2, [r3, #28]
}
 800abc0:	f107 0714 	add.w	r7, r7, #20
 800abc4:	46bd      	mov	sp, r7
 800abc6:	bc80      	pop	{r7}
 800abc8:	4770      	bx	lr
 800abca:	bf00      	nop

0800abcc <TIM_OC1FastConfig>:
  *            @arg TIM_OCFast_Enable: TIM output compare fast enable
  *            @arg TIM_OCFast_Disable: TIM output compare fast disable
  * @retval None
  */
void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
{
 800abcc:	b480      	push	{r7}
 800abce:	b085      	sub	sp, #20
 800abd0:	af00      	add	r7, sp, #0
 800abd2:	6078      	str	r0, [r7, #4]
 800abd4:	460b      	mov	r3, r1
 800abd6:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 800abd8:	f04f 0300 	mov.w	r3, #0
 800abdc:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 800abde:	687b      	ldr	r3, [r7, #4]
 800abe0:	8b1b      	ldrh	r3, [r3, #24]
 800abe2:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC1FE Bit */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1FE;
 800abe4:	89fb      	ldrh	r3, [r7, #14]
 800abe6:	f023 0304 	bic.w	r3, r3, #4
 800abea:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr1 |= TIM_OCFast;
 800abec:	89fa      	ldrh	r2, [r7, #14]
 800abee:	887b      	ldrh	r3, [r7, #2]
 800abf0:	4313      	orrs	r3, r2
 800abf2:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 800abf4:	687b      	ldr	r3, [r7, #4]
 800abf6:	89fa      	ldrh	r2, [r7, #14]
 800abf8:	831a      	strh	r2, [r3, #24]
}
 800abfa:	f107 0714 	add.w	r7, r7, #20
 800abfe:	46bd      	mov	sp, r7
 800ac00:	bc80      	pop	{r7}
 800ac02:	4770      	bx	lr

0800ac04 <TIM_OC2FastConfig>:
  *            @arg TIM_OCFast_Enable: TIM output compare fast enable
  *            @arg TIM_OCFast_Disable: TIM output compare fast disable
  * @retval None
  */
void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
{
 800ac04:	b480      	push	{r7}
 800ac06:	b085      	sub	sp, #20
 800ac08:	af00      	add	r7, sp, #0
 800ac0a:	6078      	str	r0, [r7, #4]
 800ac0c:	460b      	mov	r3, r1
 800ac0e:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 800ac10:	f04f 0300 	mov.w	r3, #0
 800ac14:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 800ac16:	687b      	ldr	r3, [r7, #4]
 800ac18:	8b1b      	ldrh	r3, [r3, #24]
 800ac1a:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC2FE Bit */
  tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2FE);
 800ac1c:	89fb      	ldrh	r3, [r7, #14]
 800ac1e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800ac22:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
 800ac24:	887b      	ldrh	r3, [r7, #2]
 800ac26:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800ac2a:	b29a      	uxth	r2, r3
 800ac2c:	89fb      	ldrh	r3, [r7, #14]
 800ac2e:	4313      	orrs	r3, r2
 800ac30:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 800ac32:	687b      	ldr	r3, [r7, #4]
 800ac34:	89fa      	ldrh	r2, [r7, #14]
 800ac36:	831a      	strh	r2, [r3, #24]
}
 800ac38:	f107 0714 	add.w	r7, r7, #20
 800ac3c:	46bd      	mov	sp, r7
 800ac3e:	bc80      	pop	{r7}
 800ac40:	4770      	bx	lr
 800ac42:	bf00      	nop

0800ac44 <TIM_OC3FastConfig>:
  *            @arg TIM_OCFast_Enable: TIM output compare fast enable
  *            @arg TIM_OCFast_Disable: TIM output compare fast disable
  * @retval None
  */
void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
{
 800ac44:	b480      	push	{r7}
 800ac46:	b085      	sub	sp, #20
 800ac48:	af00      	add	r7, sp, #0
 800ac4a:	6078      	str	r0, [r7, #4]
 800ac4c:	460b      	mov	r3, r1
 800ac4e:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
 800ac50:	f04f 0300 	mov.w	r3, #0
 800ac54:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = TIMx->CCMR2;
 800ac56:	687b      	ldr	r3, [r7, #4]
 800ac58:	8b9b      	ldrh	r3, [r3, #28]
 800ac5a:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC3FE Bit */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3FE;
 800ac5c:	89fb      	ldrh	r3, [r7, #14]
 800ac5e:	f023 0304 	bic.w	r3, r3, #4
 800ac62:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr2 |= TIM_OCFast;
 800ac64:	89fa      	ldrh	r2, [r7, #14]
 800ac66:	887b      	ldrh	r3, [r7, #2]
 800ac68:	4313      	orrs	r3, r2
 800ac6a:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmr2;
 800ac6c:	687b      	ldr	r3, [r7, #4]
 800ac6e:	89fa      	ldrh	r2, [r7, #14]
 800ac70:	839a      	strh	r2, [r3, #28]
}
 800ac72:	f107 0714 	add.w	r7, r7, #20
 800ac76:	46bd      	mov	sp, r7
 800ac78:	bc80      	pop	{r7}
 800ac7a:	4770      	bx	lr

0800ac7c <TIM_OC4FastConfig>:
  *            @arg TIM_OCFast_Enable: TIM output compare fast enable
  *            @arg TIM_OCFast_Disable: TIM output compare fast disable
  * @retval None
  */
void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
{
 800ac7c:	b480      	push	{r7}
 800ac7e:	b085      	sub	sp, #20
 800ac80:	af00      	add	r7, sp, #0
 800ac82:	6078      	str	r0, [r7, #4]
 800ac84:	460b      	mov	r3, r1
 800ac86:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
 800ac88:	f04f 0300 	mov.w	r3, #0
 800ac8c:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = TIMx->CCMR2;
 800ac8e:	687b      	ldr	r3, [r7, #4]
 800ac90:	8b9b      	ldrh	r3, [r3, #28]
 800ac92:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC4FE Bit */
  tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4FE);
 800ac94:	89fb      	ldrh	r3, [r7, #14]
 800ac96:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800ac9a:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
 800ac9c:	887b      	ldrh	r3, [r7, #2]
 800ac9e:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800aca2:	b29a      	uxth	r2, r3
 800aca4:	89fb      	ldrh	r3, [r7, #14]
 800aca6:	4313      	orrs	r3, r2
 800aca8:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmr2;
 800acaa:	687b      	ldr	r3, [r7, #4]
 800acac:	89fa      	ldrh	r2, [r7, #14]
 800acae:	839a      	strh	r2, [r3, #28]
}
 800acb0:	f107 0714 	add.w	r7, r7, #20
 800acb4:	46bd      	mov	sp, r7
 800acb6:	bc80      	pop	{r7}
 800acb8:	4770      	bx	lr
 800acba:	bf00      	nop

0800acbc <TIM_ClearOC1Ref>:
  *            @arg TIM_OCClear_Enable: TIM Output clear enable
  *            @arg TIM_OCClear_Disable: TIM Output clear disable
  * @retval None
  */
void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
{
 800acbc:	b480      	push	{r7}
 800acbe:	b085      	sub	sp, #20
 800acc0:	af00      	add	r7, sp, #0
 800acc2:	6078      	str	r0, [r7, #4]
 800acc4:	460b      	mov	r3, r1
 800acc6:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 800acc8:	f04f 0300 	mov.w	r3, #0
 800accc:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr1 = TIMx->CCMR1;
 800acce:	687b      	ldr	r3, [r7, #4]
 800acd0:	8b1b      	ldrh	r3, [r3, #24]
 800acd2:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC1CE Bit */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1CE;
 800acd4:	89fb      	ldrh	r3, [r7, #14]
 800acd6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800acda:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= TIM_OCClear;
 800acdc:	89fa      	ldrh	r2, [r7, #14]
 800acde:	887b      	ldrh	r3, [r7, #2]
 800ace0:	4313      	orrs	r3, r2
 800ace2:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 800ace4:	687b      	ldr	r3, [r7, #4]
 800ace6:	89fa      	ldrh	r2, [r7, #14]
 800ace8:	831a      	strh	r2, [r3, #24]
}
 800acea:	f107 0714 	add.w	r7, r7, #20
 800acee:	46bd      	mov	sp, r7
 800acf0:	bc80      	pop	{r7}
 800acf2:	4770      	bx	lr

0800acf4 <TIM_ClearOC2Ref>:
  *            @arg TIM_OCClear_Enable: TIM Output clear enable
  *            @arg TIM_OCClear_Disable: TIM Output clear disable
  * @retval None
  */
void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
{
 800acf4:	b480      	push	{r7}
 800acf6:	b085      	sub	sp, #20
 800acf8:	af00      	add	r7, sp, #0
 800acfa:	6078      	str	r0, [r7, #4]
 800acfc:	460b      	mov	r3, r1
 800acfe:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 800ad00:	f04f 0300 	mov.w	r3, #0
 800ad04:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr1 = TIMx->CCMR1;
 800ad06:	687b      	ldr	r3, [r7, #4]
 800ad08:	8b1b      	ldrh	r3, [r3, #24]
 800ad0a:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC2CE Bit */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2CE;
 800ad0c:	89fb      	ldrh	r3, [r7, #14]
 800ad0e:	ea4f 4343 	mov.w	r3, r3, lsl #17
 800ad12:	ea4f 4353 	mov.w	r3, r3, lsr #17
 800ad16:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
 800ad18:	887b      	ldrh	r3, [r7, #2]
 800ad1a:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800ad1e:	b29a      	uxth	r2, r3
 800ad20:	89fb      	ldrh	r3, [r7, #14]
 800ad22:	4313      	orrs	r3, r2
 800ad24:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 800ad26:	687b      	ldr	r3, [r7, #4]
 800ad28:	89fa      	ldrh	r2, [r7, #14]
 800ad2a:	831a      	strh	r2, [r3, #24]
}
 800ad2c:	f107 0714 	add.w	r7, r7, #20
 800ad30:	46bd      	mov	sp, r7
 800ad32:	bc80      	pop	{r7}
 800ad34:	4770      	bx	lr
 800ad36:	bf00      	nop

0800ad38 <TIM_ClearOC3Ref>:
  *            @arg TIM_OCClear_Enable: TIM Output clear enable
  *            @arg TIM_OCClear_Disable: TIM Output clear disable
  * @retval None
  */
void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
{
 800ad38:	b480      	push	{r7}
 800ad3a:	b085      	sub	sp, #20
 800ad3c:	af00      	add	r7, sp, #0
 800ad3e:	6078      	str	r0, [r7, #4]
 800ad40:	460b      	mov	r3, r1
 800ad42:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
 800ad44:	f04f 0300 	mov.w	r3, #0
 800ad48:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr2 = TIMx->CCMR2;
 800ad4a:	687b      	ldr	r3, [r7, #4]
 800ad4c:	8b9b      	ldrh	r3, [r3, #28]
 800ad4e:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC3CE Bit */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3CE;
 800ad50:	89fb      	ldrh	r3, [r7, #14]
 800ad52:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800ad56:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= TIM_OCClear;
 800ad58:	89fa      	ldrh	r2, [r7, #14]
 800ad5a:	887b      	ldrh	r3, [r7, #2]
 800ad5c:	4313      	orrs	r3, r2
 800ad5e:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 800ad60:	687b      	ldr	r3, [r7, #4]
 800ad62:	89fa      	ldrh	r2, [r7, #14]
 800ad64:	839a      	strh	r2, [r3, #28]
}
 800ad66:	f107 0714 	add.w	r7, r7, #20
 800ad6a:	46bd      	mov	sp, r7
 800ad6c:	bc80      	pop	{r7}
 800ad6e:	4770      	bx	lr

0800ad70 <TIM_ClearOC4Ref>:
  *            @arg TIM_OCClear_Enable: TIM Output clear enable
  *            @arg TIM_OCClear_Disable: TIM Output clear disable
  * @retval None
  */
void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
{
 800ad70:	b480      	push	{r7}
 800ad72:	b085      	sub	sp, #20
 800ad74:	af00      	add	r7, sp, #0
 800ad76:	6078      	str	r0, [r7, #4]
 800ad78:	460b      	mov	r3, r1
 800ad7a:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
 800ad7c:	f04f 0300 	mov.w	r3, #0
 800ad80:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr2 = TIMx->CCMR2;
 800ad82:	687b      	ldr	r3, [r7, #4]
 800ad84:	8b9b      	ldrh	r3, [r3, #28]
 800ad86:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC4CE Bit */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4CE;
 800ad88:	89fb      	ldrh	r3, [r7, #14]
 800ad8a:	ea4f 4343 	mov.w	r3, r3, lsl #17
 800ad8e:	ea4f 4353 	mov.w	r3, r3, lsr #17
 800ad92:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
 800ad94:	887b      	ldrh	r3, [r7, #2]
 800ad96:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800ad9a:	b29a      	uxth	r2, r3
 800ad9c:	89fb      	ldrh	r3, [r7, #14]
 800ad9e:	4313      	orrs	r3, r2
 800ada0:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 800ada2:	687b      	ldr	r3, [r7, #4]
 800ada4:	89fa      	ldrh	r2, [r7, #14]
 800ada6:	839a      	strh	r2, [r3, #28]
}
 800ada8:	f107 0714 	add.w	r7, r7, #20
 800adac:	46bd      	mov	sp, r7
 800adae:	bc80      	pop	{r7}
 800adb0:	4770      	bx	lr
 800adb2:	bf00      	nop

0800adb4 <TIM_OC1PolarityConfig>:
  *            @arg TIM_OCPolarity_High: Output Compare active high
  *            @arg TIM_OCPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
{
 800adb4:	b480      	push	{r7}
 800adb6:	b085      	sub	sp, #20
 800adb8:	af00      	add	r7, sp, #0
 800adba:	6078      	str	r0, [r7, #4]
 800adbc:	460b      	mov	r3, r1
 800adbe:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
 800adc0:	f04f 0300 	mov.w	r3, #0
 800adc4:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 800adc6:	687b      	ldr	r3, [r7, #4]
 800adc8:	8c1b      	ldrh	r3, [r3, #32]
 800adca:	81fb      	strh	r3, [r7, #14]

  /* Set or Reset the CC1P Bit */
  tmpccer &= (uint16_t)(~TIM_CCER_CC1P);
 800adcc:	89fb      	ldrh	r3, [r7, #14]
 800adce:	f023 0302 	bic.w	r3, r3, #2
 800add2:	81fb      	strh	r3, [r7, #14]
  tmpccer |= TIM_OCPolarity;
 800add4:	89fa      	ldrh	r2, [r7, #14]
 800add6:	887b      	ldrh	r3, [r7, #2]
 800add8:	4313      	orrs	r3, r2
 800adda:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 800addc:	687b      	ldr	r3, [r7, #4]
 800adde:	89fa      	ldrh	r2, [r7, #14]
 800ade0:	841a      	strh	r2, [r3, #32]
}
 800ade2:	f107 0714 	add.w	r7, r7, #20
 800ade6:	46bd      	mov	sp, r7
 800ade8:	bc80      	pop	{r7}
 800adea:	4770      	bx	lr

0800adec <TIM_OC1NPolarityConfig>:
  *            @arg TIM_OCNPolarity_High: Output Compare active high
  *            @arg TIM_OCNPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
{
 800adec:	b480      	push	{r7}
 800adee:	b085      	sub	sp, #20
 800adf0:	af00      	add	r7, sp, #0
 800adf2:	6078      	str	r0, [r7, #4]
 800adf4:	460b      	mov	r3, r1
 800adf6:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
 800adf8:	f04f 0300 	mov.w	r3, #0
 800adfc:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   
  tmpccer = TIMx->CCER;
 800adfe:	687b      	ldr	r3, [r7, #4]
 800ae00:	8c1b      	ldrh	r3, [r3, #32]
 800ae02:	81fb      	strh	r3, [r7, #14]

  /* Set or Reset the CC1NP Bit */
  tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
 800ae04:	89fb      	ldrh	r3, [r7, #14]
 800ae06:	f023 0308 	bic.w	r3, r3, #8
 800ae0a:	81fb      	strh	r3, [r7, #14]
  tmpccer |= TIM_OCNPolarity;
 800ae0c:	89fa      	ldrh	r2, [r7, #14]
 800ae0e:	887b      	ldrh	r3, [r7, #2]
 800ae10:	4313      	orrs	r3, r2
 800ae12:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 800ae14:	687b      	ldr	r3, [r7, #4]
 800ae16:	89fa      	ldrh	r2, [r7, #14]
 800ae18:	841a      	strh	r2, [r3, #32]
}
 800ae1a:	f107 0714 	add.w	r7, r7, #20
 800ae1e:	46bd      	mov	sp, r7
 800ae20:	bc80      	pop	{r7}
 800ae22:	4770      	bx	lr

0800ae24 <TIM_OC2PolarityConfig>:
  *            @arg TIM_OCPolarity_High: Output Compare active high
  *            @arg TIM_OCPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
{
 800ae24:	b480      	push	{r7}
 800ae26:	b085      	sub	sp, #20
 800ae28:	af00      	add	r7, sp, #0
 800ae2a:	6078      	str	r0, [r7, #4]
 800ae2c:	460b      	mov	r3, r1
 800ae2e:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
 800ae30:	f04f 0300 	mov.w	r3, #0
 800ae34:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 800ae36:	687b      	ldr	r3, [r7, #4]
 800ae38:	8c1b      	ldrh	r3, [r3, #32]
 800ae3a:	81fb      	strh	r3, [r7, #14]

  /* Set or Reset the CC2P Bit */
  tmpccer &= (uint16_t)(~TIM_CCER_CC2P);
 800ae3c:	89fb      	ldrh	r3, [r7, #14]
 800ae3e:	f023 0320 	bic.w	r3, r3, #32
 800ae42:	81fb      	strh	r3, [r7, #14]
  tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
 800ae44:	887b      	ldrh	r3, [r7, #2]
 800ae46:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800ae4a:	b29a      	uxth	r2, r3
 800ae4c:	89fb      	ldrh	r3, [r7, #14]
 800ae4e:	4313      	orrs	r3, r2
 800ae50:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 800ae52:	687b      	ldr	r3, [r7, #4]
 800ae54:	89fa      	ldrh	r2, [r7, #14]
 800ae56:	841a      	strh	r2, [r3, #32]
}
 800ae58:	f107 0714 	add.w	r7, r7, #20
 800ae5c:	46bd      	mov	sp, r7
 800ae5e:	bc80      	pop	{r7}
 800ae60:	4770      	bx	lr
 800ae62:	bf00      	nop

0800ae64 <TIM_OC2NPolarityConfig>:
  *            @arg TIM_OCNPolarity_High: Output Compare active high
  *            @arg TIM_OCNPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
{
 800ae64:	b480      	push	{r7}
 800ae66:	b085      	sub	sp, #20
 800ae68:	af00      	add	r7, sp, #0
 800ae6a:	6078      	str	r0, [r7, #4]
 800ae6c:	460b      	mov	r3, r1
 800ae6e:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
 800ae70:	f04f 0300 	mov.w	r3, #0
 800ae74:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
  
  tmpccer = TIMx->CCER;
 800ae76:	687b      	ldr	r3, [r7, #4]
 800ae78:	8c1b      	ldrh	r3, [r3, #32]
 800ae7a:	81fb      	strh	r3, [r7, #14]

  /* Set or Reset the CC2NP Bit */
  tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
 800ae7c:	89fb      	ldrh	r3, [r7, #14]
 800ae7e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800ae82:	81fb      	strh	r3, [r7, #14]
  tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
 800ae84:	887b      	ldrh	r3, [r7, #2]
 800ae86:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800ae8a:	b29a      	uxth	r2, r3
 800ae8c:	89fb      	ldrh	r3, [r7, #14]
 800ae8e:	4313      	orrs	r3, r2
 800ae90:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 800ae92:	687b      	ldr	r3, [r7, #4]
 800ae94:	89fa      	ldrh	r2, [r7, #14]
 800ae96:	841a      	strh	r2, [r3, #32]
}
 800ae98:	f107 0714 	add.w	r7, r7, #20
 800ae9c:	46bd      	mov	sp, r7
 800ae9e:	bc80      	pop	{r7}
 800aea0:	4770      	bx	lr
 800aea2:	bf00      	nop

0800aea4 <TIM_OC3PolarityConfig>:
  *            @arg TIM_OCPolarity_High: Output Compare active high
  *            @arg TIM_OCPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
{
 800aea4:	b480      	push	{r7}
 800aea6:	b085      	sub	sp, #20
 800aea8:	af00      	add	r7, sp, #0
 800aeaa:	6078      	str	r0, [r7, #4]
 800aeac:	460b      	mov	r3, r1
 800aeae:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
 800aeb0:	f04f 0300 	mov.w	r3, #0
 800aeb4:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 800aeb6:	687b      	ldr	r3, [r7, #4]
 800aeb8:	8c1b      	ldrh	r3, [r3, #32]
 800aeba:	81fb      	strh	r3, [r7, #14]

  /* Set or Reset the CC3P Bit */
  tmpccer &= (uint16_t)~TIM_CCER_CC3P;
 800aebc:	89fb      	ldrh	r3, [r7, #14]
 800aebe:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800aec2:	81fb      	strh	r3, [r7, #14]
  tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
 800aec4:	887b      	ldrh	r3, [r7, #2]
 800aec6:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800aeca:	b29a      	uxth	r2, r3
 800aecc:	89fb      	ldrh	r3, [r7, #14]
 800aece:	4313      	orrs	r3, r2
 800aed0:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 800aed2:	687b      	ldr	r3, [r7, #4]
 800aed4:	89fa      	ldrh	r2, [r7, #14]
 800aed6:	841a      	strh	r2, [r3, #32]
}
 800aed8:	f107 0714 	add.w	r7, r7, #20
 800aedc:	46bd      	mov	sp, r7
 800aede:	bc80      	pop	{r7}
 800aee0:	4770      	bx	lr
 800aee2:	bf00      	nop

0800aee4 <TIM_OC3NPolarityConfig>:
  *            @arg TIM_OCNPolarity_High: Output Compare active high
  *            @arg TIM_OCNPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
{
 800aee4:	b480      	push	{r7}
 800aee6:	b085      	sub	sp, #20
 800aee8:	af00      	add	r7, sp, #0
 800aeea:	6078      	str	r0, [r7, #4]
 800aeec:	460b      	mov	r3, r1
 800aeee:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
 800aef0:	f04f 0300 	mov.w	r3, #0
 800aef4:	81fb      	strh	r3, [r7, #14]
 
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
    
  tmpccer = TIMx->CCER;
 800aef6:	687b      	ldr	r3, [r7, #4]
 800aef8:	8c1b      	ldrh	r3, [r3, #32]
 800aefa:	81fb      	strh	r3, [r7, #14]

  /* Set or Reset the CC3NP Bit */
  tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
 800aefc:	89fb      	ldrh	r3, [r7, #14]
 800aefe:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800af02:	81fb      	strh	r3, [r7, #14]
  tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
 800af04:	887b      	ldrh	r3, [r7, #2]
 800af06:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800af0a:	b29a      	uxth	r2, r3
 800af0c:	89fb      	ldrh	r3, [r7, #14]
 800af0e:	4313      	orrs	r3, r2
 800af10:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 800af12:	687b      	ldr	r3, [r7, #4]
 800af14:	89fa      	ldrh	r2, [r7, #14]
 800af16:	841a      	strh	r2, [r3, #32]
}
 800af18:	f107 0714 	add.w	r7, r7, #20
 800af1c:	46bd      	mov	sp, r7
 800af1e:	bc80      	pop	{r7}
 800af20:	4770      	bx	lr
 800af22:	bf00      	nop

0800af24 <TIM_OC4PolarityConfig>:
  *            @arg TIM_OCPolarity_High: Output Compare active high
  *            @arg TIM_OCPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
{
 800af24:	b480      	push	{r7}
 800af26:	b085      	sub	sp, #20
 800af28:	af00      	add	r7, sp, #0
 800af2a:	6078      	str	r0, [r7, #4]
 800af2c:	460b      	mov	r3, r1
 800af2e:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
 800af30:	f04f 0300 	mov.w	r3, #0
 800af34:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 800af36:	687b      	ldr	r3, [r7, #4]
 800af38:	8c1b      	ldrh	r3, [r3, #32]
 800af3a:	81fb      	strh	r3, [r7, #14]

  /* Set or Reset the CC4P Bit */
  tmpccer &= (uint16_t)~TIM_CCER_CC4P;
 800af3c:	89fb      	ldrh	r3, [r7, #14]
 800af3e:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800af42:	81fb      	strh	r3, [r7, #14]
  tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
 800af44:	887b      	ldrh	r3, [r7, #2]
 800af46:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800af4a:	b29a      	uxth	r2, r3
 800af4c:	89fb      	ldrh	r3, [r7, #14]
 800af4e:	4313      	orrs	r3, r2
 800af50:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 800af52:	687b      	ldr	r3, [r7, #4]
 800af54:	89fa      	ldrh	r2, [r7, #14]
 800af56:	841a      	strh	r2, [r3, #32]
}
 800af58:	f107 0714 	add.w	r7, r7, #20
 800af5c:	46bd      	mov	sp, r7
 800af5e:	bc80      	pop	{r7}
 800af60:	4770      	bx	lr
 800af62:	bf00      	nop

0800af64 <TIM_CCxCmd>:
  * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
  * @retval None
  */
void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
{
 800af64:	b480      	push	{r7}
 800af66:	b085      	sub	sp, #20
 800af68:	af00      	add	r7, sp, #0
 800af6a:	6078      	str	r0, [r7, #4]
 800af6c:	4613      	mov	r3, r2
 800af6e:	460a      	mov	r2, r1
 800af70:	807a      	strh	r2, [r7, #2]
 800af72:	803b      	strh	r3, [r7, #0]
  uint16_t tmp = 0;
 800af74:	f04f 0300 	mov.w	r3, #0
 800af78:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
  assert_param(IS_TIM_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_CCX(TIM_CCx));

  tmp = CCER_CCE_SET << TIM_Channel;
 800af7a:	887b      	ldrh	r3, [r7, #2]
 800af7c:	f04f 0201 	mov.w	r2, #1
 800af80:	fa02 f303 	lsl.w	r3, r2, r3
 800af84:	81fb      	strh	r3, [r7, #14]

  /* Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t)~ tmp;
 800af86:	687b      	ldr	r3, [r7, #4]
 800af88:	8c1b      	ldrh	r3, [r3, #32]
 800af8a:	b29a      	uxth	r2, r3
 800af8c:	89fb      	ldrh	r3, [r7, #14]
 800af8e:	ea6f 0303 	mvn.w	r3, r3
 800af92:	b29b      	uxth	r3, r3
 800af94:	4013      	ands	r3, r2
 800af96:	b29a      	uxth	r2, r3
 800af98:	687b      	ldr	r3, [r7, #4]
 800af9a:	841a      	strh	r2, [r3, #32]

  /* Set or reset the CCxE Bit */ 
  TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
 800af9c:	687b      	ldr	r3, [r7, #4]
 800af9e:	8c1b      	ldrh	r3, [r3, #32]
 800afa0:	b29a      	uxth	r2, r3
 800afa2:	8839      	ldrh	r1, [r7, #0]
 800afa4:	887b      	ldrh	r3, [r7, #2]
 800afa6:	fa01 f303 	lsl.w	r3, r1, r3
 800afaa:	b29b      	uxth	r3, r3
 800afac:	4313      	orrs	r3, r2
 800afae:	b29a      	uxth	r2, r3
 800afb0:	687b      	ldr	r3, [r7, #4]
 800afb2:	841a      	strh	r2, [r3, #32]
}
 800afb4:	f107 0714 	add.w	r7, r7, #20
 800afb8:	46bd      	mov	sp, r7
 800afba:	bc80      	pop	{r7}
 800afbc:	4770      	bx	lr
 800afbe:	bf00      	nop

0800afc0 <TIM_CCxNCmd>:
  * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.
  *          This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
  * @retval None
  */
void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
{
 800afc0:	b480      	push	{r7}
 800afc2:	b085      	sub	sp, #20
 800afc4:	af00      	add	r7, sp, #0
 800afc6:	6078      	str	r0, [r7, #4]
 800afc8:	4613      	mov	r3, r2
 800afca:	460a      	mov	r2, r1
 800afcc:	807a      	strh	r2, [r7, #2]
 800afce:	803b      	strh	r3, [r7, #0]
  uint16_t tmp = 0;
 800afd0:	f04f 0300 	mov.w	r3, #0
 800afd4:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_CCXN(TIM_CCxN));

  tmp = CCER_CCNE_SET << TIM_Channel;
 800afd6:	887b      	ldrh	r3, [r7, #2]
 800afd8:	f04f 0204 	mov.w	r2, #4
 800afdc:	fa02 f303 	lsl.w	r3, r2, r3
 800afe0:	81fb      	strh	r3, [r7, #14]

  /* Reset the CCxNE Bit */
  TIMx->CCER &= (uint16_t) ~tmp;
 800afe2:	687b      	ldr	r3, [r7, #4]
 800afe4:	8c1b      	ldrh	r3, [r3, #32]
 800afe6:	b29a      	uxth	r2, r3
 800afe8:	89fb      	ldrh	r3, [r7, #14]
 800afea:	ea6f 0303 	mvn.w	r3, r3
 800afee:	b29b      	uxth	r3, r3
 800aff0:	4013      	ands	r3, r2
 800aff2:	b29a      	uxth	r2, r3
 800aff4:	687b      	ldr	r3, [r7, #4]
 800aff6:	841a      	strh	r2, [r3, #32]

  /* Set or reset the CCxNE Bit */ 
  TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
 800aff8:	687b      	ldr	r3, [r7, #4]
 800affa:	8c1b      	ldrh	r3, [r3, #32]
 800affc:	b29a      	uxth	r2, r3
 800affe:	8839      	ldrh	r1, [r7, #0]
 800b000:	887b      	ldrh	r3, [r7, #2]
 800b002:	fa01 f303 	lsl.w	r3, r1, r3
 800b006:	b29b      	uxth	r3, r3
 800b008:	4313      	orrs	r3, r2
 800b00a:	b29a      	uxth	r2, r3
 800b00c:	687b      	ldr	r3, [r7, #4]
 800b00e:	841a      	strh	r2, [r3, #32]
}
 800b010:	f107 0714 	add.w	r7, r7, #20
 800b014:	46bd      	mov	sp, r7
 800b016:	bc80      	pop	{r7}
 800b018:	4770      	bx	lr
 800b01a:	bf00      	nop

0800b01c <TIM_ICInit>:
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 800b01c:	b580      	push	{r7, lr}
 800b01e:	b082      	sub	sp, #8
 800b020:	af00      	add	r7, sp, #0
 800b022:	6078      	str	r0, [r7, #4]
 800b024:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
  
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 800b026:	683b      	ldr	r3, [r7, #0]
 800b028:	881b      	ldrh	r3, [r3, #0]
 800b02a:	2b00      	cmp	r3, #0
 800b02c:	d10f      	bne.n	800b04e <TIM_ICInit+0x32>
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 800b02e:	683b      	ldr	r3, [r7, #0]
 800b030:	8859      	ldrh	r1, [r3, #2]
               TIM_ICInitStruct->TIM_ICSelection,
 800b032:	683b      	ldr	r3, [r7, #0]
  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
  
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 800b034:	889a      	ldrh	r2, [r3, #4]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
 800b036:	683b      	ldr	r3, [r7, #0]
  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
  
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 800b038:	891b      	ldrh	r3, [r3, #8]
 800b03a:	6878      	ldr	r0, [r7, #4]
 800b03c:	f000 fcc4 	bl	800b9c8 <TI1_Config>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800b040:	683b      	ldr	r3, [r7, #0]
 800b042:	88db      	ldrh	r3, [r3, #6]
 800b044:	6878      	ldr	r0, [r7, #4]
 800b046:	4619      	mov	r1, r3
 800b048:	f000 f8ec 	bl	800b224 <TIM_SetIC1Prescaler>
 800b04c:	e036      	b.n	800b0bc <TIM_ICInit+0xa0>
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
 800b04e:	683b      	ldr	r3, [r7, #0]
 800b050:	881b      	ldrh	r3, [r3, #0]
 800b052:	2b04      	cmp	r3, #4
 800b054:	d10f      	bne.n	800b076 <TIM_ICInit+0x5a>
  {
    /* TI2 Configuration */
    assert_param(IS_TIM_LIST2_PERIPH(TIMx));
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 800b056:	683b      	ldr	r3, [r7, #0]
 800b058:	8859      	ldrh	r1, [r3, #2]
               TIM_ICInitStruct->TIM_ICSelection,
 800b05a:	683b      	ldr	r3, [r7, #0]
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
  {
    /* TI2 Configuration */
    assert_param(IS_TIM_LIST2_PERIPH(TIMx));
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 800b05c:	889a      	ldrh	r2, [r3, #4]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
 800b05e:	683b      	ldr	r3, [r7, #0]
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
  {
    /* TI2 Configuration */
    assert_param(IS_TIM_LIST2_PERIPH(TIMx));
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 800b060:	891b      	ldrh	r3, [r3, #8]
 800b062:	6878      	ldr	r0, [r7, #4]
 800b064:	f000 fcf0 	bl	800ba48 <TI2_Config>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800b068:	683b      	ldr	r3, [r7, #0]
 800b06a:	88db      	ldrh	r3, [r3, #6]
 800b06c:	6878      	ldr	r0, [r7, #4]
 800b06e:	4619      	mov	r1, r3
 800b070:	f000 f8f4 	bl	800b25c <TIM_SetIC2Prescaler>
 800b074:	e022      	b.n	800b0bc <TIM_ICInit+0xa0>
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
 800b076:	683b      	ldr	r3, [r7, #0]
 800b078:	881b      	ldrh	r3, [r3, #0]
 800b07a:	2b08      	cmp	r3, #8
 800b07c:	d10f      	bne.n	800b09e <TIM_ICInit+0x82>
  {
    /* TI3 Configuration */
    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
 800b07e:	683b      	ldr	r3, [r7, #0]
 800b080:	8859      	ldrh	r1, [r3, #2]
               TIM_ICInitStruct->TIM_ICSelection,
 800b082:	683b      	ldr	r3, [r7, #0]
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
  {
    /* TI3 Configuration */
    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
 800b084:	889a      	ldrh	r2, [r3, #4]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
 800b086:	683b      	ldr	r3, [r7, #0]
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
  {
    /* TI3 Configuration */
    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
 800b088:	891b      	ldrh	r3, [r3, #8]
 800b08a:	6878      	ldr	r0, [r7, #4]
 800b08c:	f000 fd2a 	bl	800bae4 <TI3_Config>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800b090:	683b      	ldr	r3, [r7, #0]
 800b092:	88db      	ldrh	r3, [r3, #6]
 800b094:	6878      	ldr	r0, [r7, #4]
 800b096:	4619      	mov	r1, r3
 800b098:	f000 f8fe 	bl	800b298 <TIM_SetIC3Prescaler>
 800b09c:	e00e      	b.n	800b0bc <TIM_ICInit+0xa0>
  }
  else
  {
    /* TI4 Configuration */
    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 800b09e:	683b      	ldr	r3, [r7, #0]
 800b0a0:	8859      	ldrh	r1, [r3, #2]
               TIM_ICInitStruct->TIM_ICSelection,
 800b0a2:	683b      	ldr	r3, [r7, #0]
  }
  else
  {
    /* TI4 Configuration */
    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 800b0a4:	889a      	ldrh	r2, [r3, #4]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
 800b0a6:	683b      	ldr	r3, [r7, #0]
  }
  else
  {
    /* TI4 Configuration */
    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 800b0a8:	891b      	ldrh	r3, [r3, #8]
 800b0aa:	6878      	ldr	r0, [r7, #4]
 800b0ac:	f000 fd60 	bl	800bb70 <TI4_Config>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800b0b0:	683b      	ldr	r3, [r7, #0]
 800b0b2:	88db      	ldrh	r3, [r3, #6]
 800b0b4:	6878      	ldr	r0, [r7, #4]
 800b0b6:	4619      	mov	r1, r3
 800b0b8:	f000 f90a 	bl	800b2d0 <TIM_SetIC4Prescaler>
  }
}
 800b0bc:	f107 0708 	add.w	r7, r7, #8
 800b0c0:	46bd      	mov	sp, r7
 800b0c2:	bd80      	pop	{r7, pc}

0800b0c4 <TIM_ICStructInit>:
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure which will
  *         be initialized.
  * @retval None
  */
void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 800b0c4:	b480      	push	{r7}
 800b0c6:	b083      	sub	sp, #12
 800b0c8:	af00      	add	r7, sp, #0
 800b0ca:	6078      	str	r0, [r7, #4]
  /* Set the default configuration */
  TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
 800b0cc:	687b      	ldr	r3, [r7, #4]
 800b0ce:	f04f 0200 	mov.w	r2, #0
 800b0d2:	801a      	strh	r2, [r3, #0]
  TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
 800b0d4:	687b      	ldr	r3, [r7, #4]
 800b0d6:	f04f 0200 	mov.w	r2, #0
 800b0da:	805a      	strh	r2, [r3, #2]
  TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
 800b0dc:	687b      	ldr	r3, [r7, #4]
 800b0de:	f04f 0201 	mov.w	r2, #1
 800b0e2:	809a      	strh	r2, [r3, #4]
  TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
 800b0e4:	687b      	ldr	r3, [r7, #4]
 800b0e6:	f04f 0200 	mov.w	r2, #0
 800b0ea:	80da      	strh	r2, [r3, #6]
  TIM_ICInitStruct->TIM_ICFilter = 0x00;
 800b0ec:	687b      	ldr	r3, [r7, #4]
 800b0ee:	f04f 0200 	mov.w	r2, #0
 800b0f2:	811a      	strh	r2, [r3, #8]
}
 800b0f4:	f107 070c 	add.w	r7, r7, #12
 800b0f8:	46bd      	mov	sp, r7
 800b0fa:	bc80      	pop	{r7}
 800b0fc:	4770      	bx	lr
 800b0fe:	bf00      	nop

0800b100 <TIM_PWMIConfig>:
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 800b100:	b580      	push	{r7, lr}
 800b102:	b084      	sub	sp, #16
 800b104:	af00      	add	r7, sp, #0
 800b106:	6078      	str	r0, [r7, #4]
 800b108:	6039      	str	r1, [r7, #0]
  uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
 800b10a:	f04f 0300 	mov.w	r3, #0
 800b10e:	81fb      	strh	r3, [r7, #14]
  uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
 800b110:	f04f 0301 	mov.w	r3, #1
 800b114:	81bb      	strh	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Select the Opposite Input Polarity */
  if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
 800b116:	683b      	ldr	r3, [r7, #0]
 800b118:	885b      	ldrh	r3, [r3, #2]
 800b11a:	2b00      	cmp	r3, #0
 800b11c:	d103      	bne.n	800b126 <TIM_PWMIConfig+0x26>
  {
    icoppositepolarity = TIM_ICPolarity_Falling;
 800b11e:	f04f 0302 	mov.w	r3, #2
 800b122:	81fb      	strh	r3, [r7, #14]
 800b124:	e002      	b.n	800b12c <TIM_PWMIConfig+0x2c>
  }
  else
  {
    icoppositepolarity = TIM_ICPolarity_Rising;
 800b126:	f04f 0300 	mov.w	r3, #0
 800b12a:	81fb      	strh	r3, [r7, #14]
  }
  /* Select the Opposite Input */
  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
 800b12c:	683b      	ldr	r3, [r7, #0]
 800b12e:	889b      	ldrh	r3, [r3, #4]
 800b130:	2b01      	cmp	r3, #1
 800b132:	d103      	bne.n	800b13c <TIM_PWMIConfig+0x3c>
  {
    icoppositeselection = TIM_ICSelection_IndirectTI;
 800b134:	f04f 0302 	mov.w	r3, #2
 800b138:	81bb      	strh	r3, [r7, #12]
 800b13a:	e002      	b.n	800b142 <TIM_PWMIConfig+0x42>
  }
  else
  {
    icoppositeselection = TIM_ICSelection_DirectTI;
 800b13c:	f04f 0301 	mov.w	r3, #1
 800b140:	81bb      	strh	r3, [r7, #12]
  }
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 800b142:	683b      	ldr	r3, [r7, #0]
 800b144:	881b      	ldrh	r3, [r3, #0]
 800b146:	2b00      	cmp	r3, #0
 800b148:	d11c      	bne.n	800b184 <TIM_PWMIConfig+0x84>
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
 800b14a:	683b      	ldr	r3, [r7, #0]
 800b14c:	8859      	ldrh	r1, [r3, #2]
 800b14e:	683b      	ldr	r3, [r7, #0]
 800b150:	889a      	ldrh	r2, [r3, #4]
               TIM_ICInitStruct->TIM_ICFilter);
 800b152:	683b      	ldr	r3, [r7, #0]
    icoppositeselection = TIM_ICSelection_DirectTI;
  }
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
 800b154:	891b      	ldrh	r3, [r3, #8]
 800b156:	6878      	ldr	r0, [r7, #4]
 800b158:	f000 fc36 	bl	800b9c8 <TI1_Config>
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800b15c:	683b      	ldr	r3, [r7, #0]
 800b15e:	88db      	ldrh	r3, [r3, #6]
 800b160:	6878      	ldr	r0, [r7, #4]
 800b162:	4619      	mov	r1, r3
 800b164:	f000 f85e 	bl	800b224 <TIM_SetIC1Prescaler>
    /* TI2 Configuration */
    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
 800b168:	683b      	ldr	r3, [r7, #0]
 800b16a:	891b      	ldrh	r3, [r3, #8]
 800b16c:	89f9      	ldrh	r1, [r7, #14]
 800b16e:	89ba      	ldrh	r2, [r7, #12]
 800b170:	6878      	ldr	r0, [r7, #4]
 800b172:	f000 fc69 	bl	800ba48 <TI2_Config>
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800b176:	683b      	ldr	r3, [r7, #0]
 800b178:	88db      	ldrh	r3, [r3, #6]
 800b17a:	6878      	ldr	r0, [r7, #4]
 800b17c:	4619      	mov	r1, r3
 800b17e:	f000 f86d 	bl	800b25c <TIM_SetIC2Prescaler>
 800b182:	e01b      	b.n	800b1bc <TIM_PWMIConfig+0xbc>
  }
  else
  { 
    /* TI2 Configuration */
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
 800b184:	683b      	ldr	r3, [r7, #0]
 800b186:	8859      	ldrh	r1, [r3, #2]
 800b188:	683b      	ldr	r3, [r7, #0]
 800b18a:	889a      	ldrh	r2, [r3, #4]
               TIM_ICInitStruct->TIM_ICFilter);
 800b18c:	683b      	ldr	r3, [r7, #0]
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
  else
  { 
    /* TI2 Configuration */
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
 800b18e:	891b      	ldrh	r3, [r3, #8]
 800b190:	6878      	ldr	r0, [r7, #4]
 800b192:	f000 fc59 	bl	800ba48 <TI2_Config>
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800b196:	683b      	ldr	r3, [r7, #0]
 800b198:	88db      	ldrh	r3, [r3, #6]
 800b19a:	6878      	ldr	r0, [r7, #4]
 800b19c:	4619      	mov	r1, r3
 800b19e:	f000 f85d 	bl	800b25c <TIM_SetIC2Prescaler>
    /* TI1 Configuration */
    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
 800b1a2:	683b      	ldr	r3, [r7, #0]
 800b1a4:	891b      	ldrh	r3, [r3, #8]
 800b1a6:	89f9      	ldrh	r1, [r7, #14]
 800b1a8:	89ba      	ldrh	r2, [r7, #12]
 800b1aa:	6878      	ldr	r0, [r7, #4]
 800b1ac:	f000 fc0c 	bl	800b9c8 <TI1_Config>
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800b1b0:	683b      	ldr	r3, [r7, #0]
 800b1b2:	88db      	ldrh	r3, [r3, #6]
 800b1b4:	6878      	ldr	r0, [r7, #4]
 800b1b6:	4619      	mov	r1, r3
 800b1b8:	f000 f834 	bl	800b224 <TIM_SetIC1Prescaler>
  }
}
 800b1bc:	f107 0710 	add.w	r7, r7, #16
 800b1c0:	46bd      	mov	sp, r7
 800b1c2:	bd80      	pop	{r7, pc}

0800b1c4 <TIM_GetCapture1>:
  * @brief  Gets the TIMx Input Capture 1 value.
  * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
  * @retval Capture Compare 1 Register value.
  */
uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
{
 800b1c4:	b480      	push	{r7}
 800b1c6:	b083      	sub	sp, #12
 800b1c8:	af00      	add	r7, sp, #0
 800b1ca:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));

  /* Get the Capture 1 Register value */
  return TIMx->CCR1;
 800b1cc:	687b      	ldr	r3, [r7, #4]
 800b1ce:	6b5b      	ldr	r3, [r3, #52]	; 0x34
}
 800b1d0:	4618      	mov	r0, r3
 800b1d2:	f107 070c 	add.w	r7, r7, #12
 800b1d6:	46bd      	mov	sp, r7
 800b1d8:	bc80      	pop	{r7}
 800b1da:	4770      	bx	lr

0800b1dc <TIM_GetCapture2>:
  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
  *         peripheral.
  * @retval Capture Compare 2 Register value.
  */
uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
{
 800b1dc:	b480      	push	{r7}
 800b1de:	b083      	sub	sp, #12
 800b1e0:	af00      	add	r7, sp, #0
 800b1e2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Get the Capture 2 Register value */
  return TIMx->CCR2;
 800b1e4:	687b      	ldr	r3, [r7, #4]
 800b1e6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
}
 800b1e8:	4618      	mov	r0, r3
 800b1ea:	f107 070c 	add.w	r7, r7, #12
 800b1ee:	46bd      	mov	sp, r7
 800b1f0:	bc80      	pop	{r7}
 800b1f2:	4770      	bx	lr

0800b1f4 <TIM_GetCapture3>:
  * @brief  Gets the TIMx Input Capture 3 value.
  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
  * @retval Capture Compare 3 Register value.
  */
uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
{
 800b1f4:	b480      	push	{r7}
 800b1f6:	b083      	sub	sp, #12
 800b1f8:	af00      	add	r7, sp, #0
 800b1fa:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 

  /* Get the Capture 3 Register value */
  return TIMx->CCR3;
 800b1fc:	687b      	ldr	r3, [r7, #4]
 800b1fe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
}
 800b200:	4618      	mov	r0, r3
 800b202:	f107 070c 	add.w	r7, r7, #12
 800b206:	46bd      	mov	sp, r7
 800b208:	bc80      	pop	{r7}
 800b20a:	4770      	bx	lr

0800b20c <TIM_GetCapture4>:
  * @brief  Gets the TIMx Input Capture 4 value.
  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
  * @retval Capture Compare 4 Register value.
  */
uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
{
 800b20c:	b480      	push	{r7}
 800b20e:	b083      	sub	sp, #12
 800b210:	af00      	add	r7, sp, #0
 800b212:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Get the Capture 4 Register value */
  return TIMx->CCR4;
 800b214:	687b      	ldr	r3, [r7, #4]
 800b216:	6c1b      	ldr	r3, [r3, #64]	; 0x40
}
 800b218:	4618      	mov	r0, r3
 800b21a:	f107 070c 	add.w	r7, r7, #12
 800b21e:	46bd      	mov	sp, r7
 800b220:	bc80      	pop	{r7}
 800b222:	4770      	bx	lr

0800b224 <TIM_SetIC1Prescaler>:
  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
  * @retval None
  */
void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
{
 800b224:	b480      	push	{r7}
 800b226:	b083      	sub	sp, #12
 800b228:	af00      	add	r7, sp, #0
 800b22a:	6078      	str	r0, [r7, #4]
 800b22c:	460b      	mov	r3, r1
 800b22e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC1PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC;
 800b230:	687b      	ldr	r3, [r7, #4]
 800b232:	8b1b      	ldrh	r3, [r3, #24]
 800b234:	b29b      	uxth	r3, r3
 800b236:	f023 030c 	bic.w	r3, r3, #12
 800b23a:	b29a      	uxth	r2, r3
 800b23c:	687b      	ldr	r3, [r7, #4]
 800b23e:	831a      	strh	r2, [r3, #24]

  /* Set the IC1PSC value */
  TIMx->CCMR1 |= TIM_ICPSC;
 800b240:	687b      	ldr	r3, [r7, #4]
 800b242:	8b1b      	ldrh	r3, [r3, #24]
 800b244:	b29a      	uxth	r2, r3
 800b246:	887b      	ldrh	r3, [r7, #2]
 800b248:	4313      	orrs	r3, r2
 800b24a:	b29a      	uxth	r2, r3
 800b24c:	687b      	ldr	r3, [r7, #4]
 800b24e:	831a      	strh	r2, [r3, #24]
}
 800b250:	f107 070c 	add.w	r7, r7, #12
 800b254:	46bd      	mov	sp, r7
 800b256:	bc80      	pop	{r7}
 800b258:	4770      	bx	lr
 800b25a:	bf00      	nop

0800b25c <TIM_SetIC2Prescaler>:
  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
  * @retval None
  */
void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
{
 800b25c:	b480      	push	{r7}
 800b25e:	b083      	sub	sp, #12
 800b260:	af00      	add	r7, sp, #0
 800b262:	6078      	str	r0, [r7, #4]
 800b264:	460b      	mov	r3, r1
 800b266:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC2PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC;
 800b268:	687b      	ldr	r3, [r7, #4]
 800b26a:	8b1b      	ldrh	r3, [r3, #24]
 800b26c:	b29b      	uxth	r3, r3
 800b26e:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 800b272:	b29a      	uxth	r2, r3
 800b274:	687b      	ldr	r3, [r7, #4]
 800b276:	831a      	strh	r2, [r3, #24]

  /* Set the IC2PSC value */
  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
 800b278:	687b      	ldr	r3, [r7, #4]
 800b27a:	8b1b      	ldrh	r3, [r3, #24]
 800b27c:	b29a      	uxth	r2, r3
 800b27e:	887b      	ldrh	r3, [r7, #2]
 800b280:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800b284:	b29b      	uxth	r3, r3
 800b286:	4313      	orrs	r3, r2
 800b288:	b29a      	uxth	r2, r3
 800b28a:	687b      	ldr	r3, [r7, #4]
 800b28c:	831a      	strh	r2, [r3, #24]
}
 800b28e:	f107 070c 	add.w	r7, r7, #12
 800b292:	46bd      	mov	sp, r7
 800b294:	bc80      	pop	{r7}
 800b296:	4770      	bx	lr

0800b298 <TIM_SetIC3Prescaler>:
  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
  * @retval None
  */
void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
{
 800b298:	b480      	push	{r7}
 800b29a:	b083      	sub	sp, #12
 800b29c:	af00      	add	r7, sp, #0
 800b29e:	6078      	str	r0, [r7, #4]
 800b2a0:	460b      	mov	r3, r1
 800b2a2:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC3PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC;
 800b2a4:	687b      	ldr	r3, [r7, #4]
 800b2a6:	8b9b      	ldrh	r3, [r3, #28]
 800b2a8:	b29b      	uxth	r3, r3
 800b2aa:	f023 030c 	bic.w	r3, r3, #12
 800b2ae:	b29a      	uxth	r2, r3
 800b2b0:	687b      	ldr	r3, [r7, #4]
 800b2b2:	839a      	strh	r2, [r3, #28]

  /* Set the IC3PSC value */
  TIMx->CCMR2 |= TIM_ICPSC;
 800b2b4:	687b      	ldr	r3, [r7, #4]
 800b2b6:	8b9b      	ldrh	r3, [r3, #28]
 800b2b8:	b29a      	uxth	r2, r3
 800b2ba:	887b      	ldrh	r3, [r7, #2]
 800b2bc:	4313      	orrs	r3, r2
 800b2be:	b29a      	uxth	r2, r3
 800b2c0:	687b      	ldr	r3, [r7, #4]
 800b2c2:	839a      	strh	r2, [r3, #28]
}
 800b2c4:	f107 070c 	add.w	r7, r7, #12
 800b2c8:	46bd      	mov	sp, r7
 800b2ca:	bc80      	pop	{r7}
 800b2cc:	4770      	bx	lr
 800b2ce:	bf00      	nop

0800b2d0 <TIM_SetIC4Prescaler>:
  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
  * @retval None
  */
void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
{  
 800b2d0:	b480      	push	{r7}
 800b2d2:	b083      	sub	sp, #12
 800b2d4:	af00      	add	r7, sp, #0
 800b2d6:	6078      	str	r0, [r7, #4]
 800b2d8:	460b      	mov	r3, r1
 800b2da:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC4PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC;
 800b2dc:	687b      	ldr	r3, [r7, #4]
 800b2de:	8b9b      	ldrh	r3, [r3, #28]
 800b2e0:	b29b      	uxth	r3, r3
 800b2e2:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 800b2e6:	b29a      	uxth	r2, r3
 800b2e8:	687b      	ldr	r3, [r7, #4]
 800b2ea:	839a      	strh	r2, [r3, #28]

  /* Set the IC4PSC value */
  TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
 800b2ec:	687b      	ldr	r3, [r7, #4]
 800b2ee:	8b9b      	ldrh	r3, [r3, #28]
 800b2f0:	b29a      	uxth	r2, r3
 800b2f2:	887b      	ldrh	r3, [r7, #2]
 800b2f4:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800b2f8:	b29b      	uxth	r3, r3
 800b2fa:	4313      	orrs	r3, r2
 800b2fc:	b29a      	uxth	r2, r3
 800b2fe:	687b      	ldr	r3, [r7, #4]
 800b300:	839a      	strh	r2, [r3, #28]
}
 800b302:	f107 070c 	add.w	r7, r7, #12
 800b306:	46bd      	mov	sp, r7
 800b308:	bc80      	pop	{r7}
 800b30a:	4770      	bx	lr

0800b30c <TIM_BDTRConfig>:
  * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure that
  *         contains the BDTR Register configuration  information for the TIM peripheral.
  * @retval None
  */
void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
{
 800b30c:	b480      	push	{r7}
 800b30e:	b083      	sub	sp, #12
 800b310:	af00      	add	r7, sp, #0
 800b312:	6078      	str	r0, [r7, #4]
 800b314:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 800b316:	683b      	ldr	r3, [r7, #0]
 800b318:	881a      	ldrh	r2, [r3, #0]
 800b31a:	683b      	ldr	r3, [r7, #0]
 800b31c:	885b      	ldrh	r3, [r3, #2]
 800b31e:	4313      	orrs	r3, r2
 800b320:	b29a      	uxth	r2, r3
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
 800b322:	683b      	ldr	r3, [r7, #0]
 800b324:	889b      	ldrh	r3, [r3, #4]
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 800b326:	4313      	orrs	r3, r2
 800b328:	b29a      	uxth	r2, r3
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
 800b32a:	683b      	ldr	r3, [r7, #0]
 800b32c:	88db      	ldrh	r3, [r3, #6]
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 800b32e:	4313      	orrs	r3, r2
 800b330:	b29a      	uxth	r2, r3
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
 800b332:	683b      	ldr	r3, [r7, #0]
 800b334:	891b      	ldrh	r3, [r3, #8]
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 800b336:	4313      	orrs	r3, r2
 800b338:	b29a      	uxth	r2, r3
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
 800b33a:	683b      	ldr	r3, [r7, #0]
 800b33c:	895b      	ldrh	r3, [r3, #10]
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 800b33e:	4313      	orrs	r3, r2
 800b340:	b29a      	uxth	r2, r3
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
             TIM_BDTRInitStruct->TIM_AutomaticOutput;
 800b342:	683b      	ldr	r3, [r7, #0]
 800b344:	899b      	ldrh	r3, [r3, #12]
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 800b346:	4313      	orrs	r3, r2
 800b348:	b29a      	uxth	r2, r3
 800b34a:	687b      	ldr	r3, [r7, #4]
 800b34c:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
             TIM_BDTRInitStruct->TIM_AutomaticOutput;
}
 800b350:	f107 070c 	add.w	r7, r7, #12
 800b354:	46bd      	mov	sp, r7
 800b356:	bc80      	pop	{r7}
 800b358:	4770      	bx	lr
 800b35a:	bf00      	nop

0800b35c <TIM_BDTRStructInit>:
  * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure which
  *         will be initialized.
  * @retval None
  */
void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
{
 800b35c:	b480      	push	{r7}
 800b35e:	b083      	sub	sp, #12
 800b360:	af00      	add	r7, sp, #0
 800b362:	6078      	str	r0, [r7, #4]
  /* Set the default configuration */
  TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
 800b364:	687b      	ldr	r3, [r7, #4]
 800b366:	f04f 0200 	mov.w	r2, #0
 800b36a:	801a      	strh	r2, [r3, #0]
  TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
 800b36c:	687b      	ldr	r3, [r7, #4]
 800b36e:	f04f 0200 	mov.w	r2, #0
 800b372:	805a      	strh	r2, [r3, #2]
  TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
 800b374:	687b      	ldr	r3, [r7, #4]
 800b376:	f04f 0200 	mov.w	r2, #0
 800b37a:	809a      	strh	r2, [r3, #4]
  TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
 800b37c:	687b      	ldr	r3, [r7, #4]
 800b37e:	f04f 0200 	mov.w	r2, #0
 800b382:	80da      	strh	r2, [r3, #6]
  TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
 800b384:	687b      	ldr	r3, [r7, #4]
 800b386:	f04f 0200 	mov.w	r2, #0
 800b38a:	811a      	strh	r2, [r3, #8]
  TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
 800b38c:	687b      	ldr	r3, [r7, #4]
 800b38e:	f04f 0200 	mov.w	r2, #0
 800b392:	815a      	strh	r2, [r3, #10]
  TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
 800b394:	687b      	ldr	r3, [r7, #4]
 800b396:	f04f 0200 	mov.w	r2, #0
 800b39a:	819a      	strh	r2, [r3, #12]
}
 800b39c:	f107 070c 	add.w	r7, r7, #12
 800b3a0:	46bd      	mov	sp, r7
 800b3a2:	bc80      	pop	{r7}
 800b3a4:	4770      	bx	lr
 800b3a6:	bf00      	nop

0800b3a8 <TIM_CtrlPWMOutputs>:
  * @param  NewState: new state of the TIM peripheral Main Outputs.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 800b3a8:	b480      	push	{r7}
 800b3aa:	b083      	sub	sp, #12
 800b3ac:	af00      	add	r7, sp, #0
 800b3ae:	6078      	str	r0, [r7, #4]
 800b3b0:	460b      	mov	r3, r1
 800b3b2:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800b3b4:	78fb      	ldrb	r3, [r7, #3]
 800b3b6:	2b00      	cmp	r3, #0
 800b3b8:	d00c      	beq.n	800b3d4 <TIM_CtrlPWMOutputs+0x2c>
  {
    /* Enable the TIM Main Output */
    TIMx->BDTR |= TIM_BDTR_MOE;
 800b3ba:	687b      	ldr	r3, [r7, #4]
 800b3bc:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800b3c0:	b29b      	uxth	r3, r3
 800b3c2:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800b3c6:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800b3ca:	b29a      	uxth	r2, r3
 800b3cc:	687b      	ldr	r3, [r7, #4]
 800b3ce:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
 800b3d2:	e00b      	b.n	800b3ec <TIM_CtrlPWMOutputs+0x44>
  }
  else
  {
    /* Disable the TIM Main Output */
    TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
 800b3d4:	687b      	ldr	r3, [r7, #4]
 800b3d6:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800b3da:	b29b      	uxth	r3, r3
 800b3dc:	ea4f 4343 	mov.w	r3, r3, lsl #17
 800b3e0:	ea4f 4353 	mov.w	r3, r3, lsr #17
 800b3e4:	b29a      	uxth	r2, r3
 800b3e6:	687b      	ldr	r3, [r7, #4]
 800b3e8:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
  }  
}
 800b3ec:	f107 070c 	add.w	r7, r7, #12
 800b3f0:	46bd      	mov	sp, r7
 800b3f2:	bc80      	pop	{r7}
 800b3f4:	4770      	bx	lr
 800b3f6:	bf00      	nop

0800b3f8 <TIM_SelectCOM>:
  * @param  NewState: new state of the Commutation event.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 800b3f8:	b480      	push	{r7}
 800b3fa:	b083      	sub	sp, #12
 800b3fc:	af00      	add	r7, sp, #0
 800b3fe:	6078      	str	r0, [r7, #4]
 800b400:	460b      	mov	r3, r1
 800b402:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800b404:	78fb      	ldrb	r3, [r7, #3]
 800b406:	2b00      	cmp	r3, #0
 800b408:	d008      	beq.n	800b41c <TIM_SelectCOM+0x24>
  {
    /* Set the COM Bit */
    TIMx->CR2 |= TIM_CR2_CCUS;
 800b40a:	687b      	ldr	r3, [r7, #4]
 800b40c:	889b      	ldrh	r3, [r3, #4]
 800b40e:	b29b      	uxth	r3, r3
 800b410:	f043 0304 	orr.w	r3, r3, #4
 800b414:	b29a      	uxth	r2, r3
 800b416:	687b      	ldr	r3, [r7, #4]
 800b418:	809a      	strh	r2, [r3, #4]
 800b41a:	e007      	b.n	800b42c <TIM_SelectCOM+0x34>
  }
  else
  {
    /* Reset the COM Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCUS;
 800b41c:	687b      	ldr	r3, [r7, #4]
 800b41e:	889b      	ldrh	r3, [r3, #4]
 800b420:	b29b      	uxth	r3, r3
 800b422:	f023 0304 	bic.w	r3, r3, #4
 800b426:	b29a      	uxth	r2, r3
 800b428:	687b      	ldr	r3, [r7, #4]
 800b42a:	809a      	strh	r2, [r3, #4]
  }
}
 800b42c:	f107 070c 	add.w	r7, r7, #12
 800b430:	46bd      	mov	sp, r7
 800b432:	bc80      	pop	{r7}
 800b434:	4770      	bx	lr
 800b436:	bf00      	nop

0800b438 <TIM_CCPreloadControl>:
  * @param  NewState: new state of the Capture Compare Preload Control bit
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
{ 
 800b438:	b480      	push	{r7}
 800b43a:	b083      	sub	sp, #12
 800b43c:	af00      	add	r7, sp, #0
 800b43e:	6078      	str	r0, [r7, #4]
 800b440:	460b      	mov	r3, r1
 800b442:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800b444:	78fb      	ldrb	r3, [r7, #3]
 800b446:	2b00      	cmp	r3, #0
 800b448:	d008      	beq.n	800b45c <TIM_CCPreloadControl+0x24>
  {
    /* Set the CCPC Bit */
    TIMx->CR2 |= TIM_CR2_CCPC;
 800b44a:	687b      	ldr	r3, [r7, #4]
 800b44c:	889b      	ldrh	r3, [r3, #4]
 800b44e:	b29b      	uxth	r3, r3
 800b450:	f043 0301 	orr.w	r3, r3, #1
 800b454:	b29a      	uxth	r2, r3
 800b456:	687b      	ldr	r3, [r7, #4]
 800b458:	809a      	strh	r2, [r3, #4]
 800b45a:	e007      	b.n	800b46c <TIM_CCPreloadControl+0x34>
  }
  else
  {
    /* Reset the CCPC Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCPC;
 800b45c:	687b      	ldr	r3, [r7, #4]
 800b45e:	889b      	ldrh	r3, [r3, #4]
 800b460:	b29b      	uxth	r3, r3
 800b462:	f023 0301 	bic.w	r3, r3, #1
 800b466:	b29a      	uxth	r2, r3
 800b468:	687b      	ldr	r3, [r7, #4]
 800b46a:	809a      	strh	r2, [r3, #4]
  }
}
 800b46c:	f107 070c 	add.w	r7, r7, #12
 800b470:	46bd      	mov	sp, r7
 800b472:	bc80      	pop	{r7}
 800b474:	4770      	bx	lr
 800b476:	bf00      	nop

0800b478 <TIM_ITConfig>:
  * @param  NewState: new state of the TIM interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
{  
 800b478:	b480      	push	{r7}
 800b47a:	b083      	sub	sp, #12
 800b47c:	af00      	add	r7, sp, #0
 800b47e:	6078      	str	r0, [r7, #4]
 800b480:	4613      	mov	r3, r2
 800b482:	460a      	mov	r2, r1
 800b484:	807a      	strh	r2, [r7, #2]
 800b486:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800b488:	787b      	ldrb	r3, [r7, #1]
 800b48a:	2b00      	cmp	r3, #0
 800b48c:	d008      	beq.n	800b4a0 <TIM_ITConfig+0x28>
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
 800b48e:	687b      	ldr	r3, [r7, #4]
 800b490:	899b      	ldrh	r3, [r3, #12]
 800b492:	b29a      	uxth	r2, r3
 800b494:	887b      	ldrh	r3, [r7, #2]
 800b496:	4313      	orrs	r3, r2
 800b498:	b29a      	uxth	r2, r3
 800b49a:	687b      	ldr	r3, [r7, #4]
 800b49c:	819a      	strh	r2, [r3, #12]
 800b49e:	e00a      	b.n	800b4b6 <TIM_ITConfig+0x3e>
  }
  else
  {
    /* Disable the Interrupt sources */
    TIMx->DIER &= (uint16_t)~TIM_IT;
 800b4a0:	687b      	ldr	r3, [r7, #4]
 800b4a2:	899b      	ldrh	r3, [r3, #12]
 800b4a4:	b29a      	uxth	r2, r3
 800b4a6:	887b      	ldrh	r3, [r7, #2]
 800b4a8:	ea6f 0303 	mvn.w	r3, r3
 800b4ac:	b29b      	uxth	r3, r3
 800b4ae:	4013      	ands	r3, r2
 800b4b0:	b29a      	uxth	r2, r3
 800b4b2:	687b      	ldr	r3, [r7, #4]
 800b4b4:	819a      	strh	r2, [r3, #12]
  }
}
 800b4b6:	f107 070c 	add.w	r7, r7, #12
 800b4ba:	46bd      	mov	sp, r7
 800b4bc:	bc80      	pop	{r7}
 800b4be:	4770      	bx	lr

0800b4c0 <TIM_GenerateEvent>:
  * @note   TIM_EventSource_COM and TIM_EventSource_Break are used only with TIM1 and TIM8.
  *        
  * @retval None
  */
void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
{ 
 800b4c0:	b480      	push	{r7}
 800b4c2:	b083      	sub	sp, #12
 800b4c4:	af00      	add	r7, sp, #0
 800b4c6:	6078      	str	r0, [r7, #4]
 800b4c8:	460b      	mov	r3, r1
 800b4ca:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
 
  /* Set the event sources */
  TIMx->EGR = TIM_EventSource;
 800b4cc:	687b      	ldr	r3, [r7, #4]
 800b4ce:	887a      	ldrh	r2, [r7, #2]
 800b4d0:	829a      	strh	r2, [r3, #20]
}
 800b4d2:	f107 070c 	add.w	r7, r7, #12
 800b4d6:	46bd      	mov	sp, r7
 800b4d8:	bc80      	pop	{r7}
 800b4da:	4770      	bx	lr

0800b4dc <TIM_GetFlagStatus>:
  * @note   TIM_FLAG_COM and TIM_FLAG_Break are used only with TIM1 and TIM8.    
  *
  * @retval The new state of TIM_FLAG (SET or RESET).
  */
FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
{ 
 800b4dc:	b480      	push	{r7}
 800b4de:	b085      	sub	sp, #20
 800b4e0:	af00      	add	r7, sp, #0
 800b4e2:	6078      	str	r0, [r7, #4]
 800b4e4:	460b      	mov	r3, r1
 800b4e6:	807b      	strh	r3, [r7, #2]
  ITStatus bitstatus = RESET;  
 800b4e8:	f04f 0300 	mov.w	r3, #0
 800b4ec:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_FLAG(TIM_FLAG));

  
  if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
 800b4ee:	687b      	ldr	r3, [r7, #4]
 800b4f0:	8a1b      	ldrh	r3, [r3, #16]
 800b4f2:	b29a      	uxth	r2, r3
 800b4f4:	887b      	ldrh	r3, [r7, #2]
 800b4f6:	4013      	ands	r3, r2
 800b4f8:	b29b      	uxth	r3, r3
 800b4fa:	2b00      	cmp	r3, #0
 800b4fc:	d003      	beq.n	800b506 <TIM_GetFlagStatus+0x2a>
  {
    bitstatus = SET;
 800b4fe:	f04f 0301 	mov.w	r3, #1
 800b502:	73fb      	strb	r3, [r7, #15]
 800b504:	e002      	b.n	800b50c <TIM_GetFlagStatus+0x30>
  }
  else
  {
    bitstatus = RESET;
 800b506:	f04f 0300 	mov.w	r3, #0
 800b50a:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 800b50c:	7bfb      	ldrb	r3, [r7, #15]
}
 800b50e:	4618      	mov	r0, r3
 800b510:	f107 0714 	add.w	r7, r7, #20
 800b514:	46bd      	mov	sp, r7
 800b516:	bc80      	pop	{r7}
 800b518:	4770      	bx	lr
 800b51a:	bf00      	nop

0800b51c <TIM_ClearFlag>:
  * @note   TIM_FLAG_COM and TIM_FLAG_Break are used only with TIM1 and TIM8.
  *    
  * @retval None
  */
void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
{  
 800b51c:	b480      	push	{r7}
 800b51e:	b083      	sub	sp, #12
 800b520:	af00      	add	r7, sp, #0
 800b522:	6078      	str	r0, [r7, #4]
 800b524:	460b      	mov	r3, r1
 800b526:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
   
  /* Clear the flags */
  TIMx->SR = (uint16_t)~TIM_FLAG;
 800b528:	887b      	ldrh	r3, [r7, #2]
 800b52a:	ea6f 0303 	mvn.w	r3, r3
 800b52e:	b29a      	uxth	r2, r3
 800b530:	687b      	ldr	r3, [r7, #4]
 800b532:	821a      	strh	r2, [r3, #16]
}
 800b534:	f107 070c 	add.w	r7, r7, #12
 800b538:	46bd      	mov	sp, r7
 800b53a:	bc80      	pop	{r7}
 800b53c:	4770      	bx	lr
 800b53e:	bf00      	nop

0800b540 <TIM_GetITStatus>:
  * @note   TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.
  *     
  * @retval The new state of the TIM_IT(SET or RESET).
  */
ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
{
 800b540:	b480      	push	{r7}
 800b542:	b085      	sub	sp, #20
 800b544:	af00      	add	r7, sp, #0
 800b546:	6078      	str	r0, [r7, #4]
 800b548:	460b      	mov	r3, r1
 800b54a:	807b      	strh	r3, [r7, #2]
  ITStatus bitstatus = RESET;  
 800b54c:	f04f 0300 	mov.w	r3, #0
 800b550:	73fb      	strb	r3, [r7, #15]
  uint16_t itstatus = 0x0, itenable = 0x0;
 800b552:	f04f 0300 	mov.w	r3, #0
 800b556:	81bb      	strh	r3, [r7, #12]
 800b558:	f04f 0300 	mov.w	r3, #0
 800b55c:	817b      	strh	r3, [r7, #10]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
 800b55e:	687b      	ldr	r3, [r7, #4]
 800b560:	8a1b      	ldrh	r3, [r3, #16]
 800b562:	b29a      	uxth	r2, r3
 800b564:	887b      	ldrh	r3, [r7, #2]
 800b566:	4013      	ands	r3, r2
 800b568:	81bb      	strh	r3, [r7, #12]
  
  itenable = TIMx->DIER & TIM_IT;
 800b56a:	687b      	ldr	r3, [r7, #4]
 800b56c:	899b      	ldrh	r3, [r3, #12]
 800b56e:	b29a      	uxth	r2, r3
 800b570:	887b      	ldrh	r3, [r7, #2]
 800b572:	4013      	ands	r3, r2
 800b574:	817b      	strh	r3, [r7, #10]
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 800b576:	89bb      	ldrh	r3, [r7, #12]
 800b578:	2b00      	cmp	r3, #0
 800b57a:	d006      	beq.n	800b58a <TIM_GetITStatus+0x4a>
 800b57c:	897b      	ldrh	r3, [r7, #10]
 800b57e:	2b00      	cmp	r3, #0
 800b580:	d003      	beq.n	800b58a <TIM_GetITStatus+0x4a>
  {
    bitstatus = SET;
 800b582:	f04f 0301 	mov.w	r3, #1
 800b586:	73fb      	strb	r3, [r7, #15]
 800b588:	e002      	b.n	800b590 <TIM_GetITStatus+0x50>
  }
  else
  {
    bitstatus = RESET;
 800b58a:	f04f 0300 	mov.w	r3, #0
 800b58e:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 800b590:	7bfb      	ldrb	r3, [r7, #15]
}
 800b592:	4618      	mov	r0, r3
 800b594:	f107 0714 	add.w	r7, r7, #20
 800b598:	46bd      	mov	sp, r7
 800b59a:	bc80      	pop	{r7}
 800b59c:	4770      	bx	lr
 800b59e:	bf00      	nop

0800b5a0 <TIM_ClearITPendingBit>:
  * @note   TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.
  *      
  * @retval None
  */
void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
{
 800b5a0:	b480      	push	{r7}
 800b5a2:	b083      	sub	sp, #12
 800b5a4:	af00      	add	r7, sp, #0
 800b5a6:	6078      	str	r0, [r7, #4]
 800b5a8:	460b      	mov	r3, r1
 800b5aa:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Clear the IT pending Bit */
  TIMx->SR = (uint16_t)~TIM_IT;
 800b5ac:	887b      	ldrh	r3, [r7, #2]
 800b5ae:	ea6f 0303 	mvn.w	r3, r3
 800b5b2:	b29a      	uxth	r2, r3
 800b5b4:	687b      	ldr	r3, [r7, #4]
 800b5b6:	821a      	strh	r2, [r3, #16]
}
 800b5b8:	f107 070c 	add.w	r7, r7, #12
 800b5bc:	46bd      	mov	sp, r7
 800b5be:	bc80      	pop	{r7}
 800b5c0:	4770      	bx	lr
 800b5c2:	bf00      	nop

0800b5c4 <TIM_DMAConfig>:
  * @param  TIM_DMABurstLength: DMA Burst length. This parameter can be one value
  *         between: TIM_DMABurstLength_1Transfer and TIM_DMABurstLength_18Transfers.
  * @retval None
  */
void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
{
 800b5c4:	b480      	push	{r7}
 800b5c6:	b083      	sub	sp, #12
 800b5c8:	af00      	add	r7, sp, #0
 800b5ca:	6078      	str	r0, [r7, #4]
 800b5cc:	4613      	mov	r3, r2
 800b5ce:	460a      	mov	r2, r1
 800b5d0:	807a      	strh	r2, [r7, #2]
 800b5d2:	803b      	strh	r3, [r7, #0]
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
  assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));

  /* Set the DMA Base and the DMA Burst Length */
  TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
 800b5d4:	887a      	ldrh	r2, [r7, #2]
 800b5d6:	883b      	ldrh	r3, [r7, #0]
 800b5d8:	4313      	orrs	r3, r2
 800b5da:	b29a      	uxth	r2, r3
 800b5dc:	687b      	ldr	r3, [r7, #4]
 800b5de:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
}
 800b5e2:	f107 070c 	add.w	r7, r7, #12
 800b5e6:	46bd      	mov	sp, r7
 800b5e8:	bc80      	pop	{r7}
 800b5ea:	4770      	bx	lr

0800b5ec <TIM_DMACmd>:
  * @param  NewState: new state of the DMA Request sources.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
{ 
 800b5ec:	b480      	push	{r7}
 800b5ee:	b083      	sub	sp, #12
 800b5f0:	af00      	add	r7, sp, #0
 800b5f2:	6078      	str	r0, [r7, #4]
 800b5f4:	4613      	mov	r3, r2
 800b5f6:	460a      	mov	r2, r1
 800b5f8:	807a      	strh	r2, [r7, #2]
 800b5fa:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_TIM_LIST5_PERIPH(TIMx)); 
  assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800b5fc:	787b      	ldrb	r3, [r7, #1]
 800b5fe:	2b00      	cmp	r3, #0
 800b600:	d008      	beq.n	800b614 <TIM_DMACmd+0x28>
  {
    /* Enable the DMA sources */
    TIMx->DIER |= TIM_DMASource; 
 800b602:	687b      	ldr	r3, [r7, #4]
 800b604:	899b      	ldrh	r3, [r3, #12]
 800b606:	b29a      	uxth	r2, r3
 800b608:	887b      	ldrh	r3, [r7, #2]
 800b60a:	4313      	orrs	r3, r2
 800b60c:	b29a      	uxth	r2, r3
 800b60e:	687b      	ldr	r3, [r7, #4]
 800b610:	819a      	strh	r2, [r3, #12]
 800b612:	e00a      	b.n	800b62a <TIM_DMACmd+0x3e>
  }
  else
  {
    /* Disable the DMA sources */
    TIMx->DIER &= (uint16_t)~TIM_DMASource;
 800b614:	687b      	ldr	r3, [r7, #4]
 800b616:	899b      	ldrh	r3, [r3, #12]
 800b618:	b29a      	uxth	r2, r3
 800b61a:	887b      	ldrh	r3, [r7, #2]
 800b61c:	ea6f 0303 	mvn.w	r3, r3
 800b620:	b29b      	uxth	r3, r3
 800b622:	4013      	ands	r3, r2
 800b624:	b29a      	uxth	r2, r3
 800b626:	687b      	ldr	r3, [r7, #4]
 800b628:	819a      	strh	r2, [r3, #12]
  }
}
 800b62a:	f107 070c 	add.w	r7, r7, #12
 800b62e:	46bd      	mov	sp, r7
 800b630:	bc80      	pop	{r7}
 800b632:	4770      	bx	lr

0800b634 <TIM_SelectCCDMA>:
  * @param  NewState: new state of the Capture Compare DMA source
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 800b634:	b480      	push	{r7}
 800b636:	b083      	sub	sp, #12
 800b638:	af00      	add	r7, sp, #0
 800b63a:	6078      	str	r0, [r7, #4]
 800b63c:	460b      	mov	r3, r1
 800b63e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800b640:	78fb      	ldrb	r3, [r7, #3]
 800b642:	2b00      	cmp	r3, #0
 800b644:	d008      	beq.n	800b658 <TIM_SelectCCDMA+0x24>
  {
    /* Set the CCDS Bit */
    TIMx->CR2 |= TIM_CR2_CCDS;
 800b646:	687b      	ldr	r3, [r7, #4]
 800b648:	889b      	ldrh	r3, [r3, #4]
 800b64a:	b29b      	uxth	r3, r3
 800b64c:	f043 0308 	orr.w	r3, r3, #8
 800b650:	b29a      	uxth	r2, r3
 800b652:	687b      	ldr	r3, [r7, #4]
 800b654:	809a      	strh	r2, [r3, #4]
 800b656:	e007      	b.n	800b668 <TIM_SelectCCDMA+0x34>
  }
  else
  {
    /* Reset the CCDS Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCDS;
 800b658:	687b      	ldr	r3, [r7, #4]
 800b65a:	889b      	ldrh	r3, [r3, #4]
 800b65c:	b29b      	uxth	r3, r3
 800b65e:	f023 0308 	bic.w	r3, r3, #8
 800b662:	b29a      	uxth	r2, r3
 800b664:	687b      	ldr	r3, [r7, #4]
 800b666:	809a      	strh	r2, [r3, #4]
  }
}
 800b668:	f107 070c 	add.w	r7, r7, #12
 800b66c:	46bd      	mov	sp, r7
 800b66e:	bc80      	pop	{r7}
 800b670:	4770      	bx	lr
 800b672:	bf00      	nop

0800b674 <TIM_InternalClockConfig>:
  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
  *         peripheral.
  * @retval None
  */
void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
{
 800b674:	b480      	push	{r7}
 800b676:	b083      	sub	sp, #12
 800b678:	af00      	add	r7, sp, #0
 800b67a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Disable slave mode to clock the prescaler directly with the internal clock */
  TIMx->SMCR &=  (uint16_t)~TIM_SMCR_SMS;
 800b67c:	687b      	ldr	r3, [r7, #4]
 800b67e:	891b      	ldrh	r3, [r3, #8]
 800b680:	b29b      	uxth	r3, r3
 800b682:	f023 0307 	bic.w	r3, r3, #7
 800b686:	b29a      	uxth	r2, r3
 800b688:	687b      	ldr	r3, [r7, #4]
 800b68a:	811a      	strh	r2, [r3, #8]
}
 800b68c:	f107 070c 	add.w	r7, r7, #12
 800b690:	46bd      	mov	sp, r7
 800b692:	bc80      	pop	{r7}
 800b694:	4770      	bx	lr
 800b696:	bf00      	nop

0800b698 <TIM_ITRxExternalClockConfig>:
  *            @arg TIM_TS_ITR2: Internal Trigger 2
  *            @arg TIM_TS_ITR3: Internal Trigger 3
  * @retval None
  */
void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
{
 800b698:	b580      	push	{r7, lr}
 800b69a:	b082      	sub	sp, #8
 800b69c:	af00      	add	r7, sp, #0
 800b69e:	6078      	str	r0, [r7, #4]
 800b6a0:	460b      	mov	r3, r1
 800b6a2:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Select the Internal Trigger */
  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
 800b6a4:	887b      	ldrh	r3, [r7, #2]
 800b6a6:	6878      	ldr	r0, [r7, #4]
 800b6a8:	4619      	mov	r1, r3
 800b6aa:	f000 f87d 	bl	800b7a8 <TIM_SelectInputTrigger>

  /* Select the External clock mode1 */
  TIMx->SMCR |= TIM_SlaveMode_External1;
 800b6ae:	687b      	ldr	r3, [r7, #4]
 800b6b0:	891b      	ldrh	r3, [r3, #8]
 800b6b2:	b29b      	uxth	r3, r3
 800b6b4:	f043 0307 	orr.w	r3, r3, #7
 800b6b8:	b29a      	uxth	r2, r3
 800b6ba:	687b      	ldr	r3, [r7, #4]
 800b6bc:	811a      	strh	r2, [r3, #8]
}
 800b6be:	f107 0708 	add.w	r7, r7, #8
 800b6c2:	46bd      	mov	sp, r7
 800b6c4:	bd80      	pop	{r7, pc}
 800b6c6:	bf00      	nop

0800b6c8 <TIM_TIxExternalClockConfig>:
  *          This parameter must be a value between 0x0 and 0xF.
  * @retval None
  */
void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
                                uint16_t TIM_ICPolarity, uint16_t ICFilter)
{
 800b6c8:	b580      	push	{r7, lr}
 800b6ca:	b084      	sub	sp, #16
 800b6cc:	af00      	add	r7, sp, #0
 800b6ce:	60f8      	str	r0, [r7, #12]
 800b6d0:	8179      	strh	r1, [r7, #10]
 800b6d2:	813a      	strh	r2, [r7, #8]
 800b6d4:	80fb      	strh	r3, [r7, #6]
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
  assert_param(IS_TIM_IC_FILTER(ICFilter));

  /* Configure the Timer Input Clock Source */
  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
 800b6d6:	897b      	ldrh	r3, [r7, #10]
 800b6d8:	2b60      	cmp	r3, #96	; 0x60
 800b6da:	d108      	bne.n	800b6ee <TIM_TIxExternalClockConfig+0x26>
  {
    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
 800b6dc:	893a      	ldrh	r2, [r7, #8]
 800b6de:	88fb      	ldrh	r3, [r7, #6]
 800b6e0:	68f8      	ldr	r0, [r7, #12]
 800b6e2:	4611      	mov	r1, r2
 800b6e4:	f04f 0201 	mov.w	r2, #1
 800b6e8:	f000 f9ae 	bl	800ba48 <TI2_Config>
 800b6ec:	e007      	b.n	800b6fe <TIM_TIxExternalClockConfig+0x36>
  }
  else
  {
    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
 800b6ee:	893a      	ldrh	r2, [r7, #8]
 800b6f0:	88fb      	ldrh	r3, [r7, #6]
 800b6f2:	68f8      	ldr	r0, [r7, #12]
 800b6f4:	4611      	mov	r1, r2
 800b6f6:	f04f 0201 	mov.w	r2, #1
 800b6fa:	f000 f965 	bl	800b9c8 <TI1_Config>
  }
  /* Select the Trigger source */
  TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
 800b6fe:	897b      	ldrh	r3, [r7, #10]
 800b700:	68f8      	ldr	r0, [r7, #12]
 800b702:	4619      	mov	r1, r3
 800b704:	f000 f850 	bl	800b7a8 <TIM_SelectInputTrigger>
  /* Select the External clock mode1 */
  TIMx->SMCR |= TIM_SlaveMode_External1;
 800b708:	68fb      	ldr	r3, [r7, #12]
 800b70a:	891b      	ldrh	r3, [r3, #8]
 800b70c:	b29b      	uxth	r3, r3
 800b70e:	f043 0307 	orr.w	r3, r3, #7
 800b712:	b29a      	uxth	r2, r3
 800b714:	68fb      	ldr	r3, [r7, #12]
 800b716:	811a      	strh	r2, [r3, #8]
}
 800b718:	f107 0710 	add.w	r7, r7, #16
 800b71c:	46bd      	mov	sp, r7
 800b71e:	bd80      	pop	{r7, pc}

0800b720 <TIM_ETRClockMode1Config>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
                            uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 800b720:	b580      	push	{r7, lr}
 800b722:	b086      	sub	sp, #24
 800b724:	af00      	add	r7, sp, #0
 800b726:	60f8      	str	r0, [r7, #12]
 800b728:	8179      	strh	r1, [r7, #10]
 800b72a:	813a      	strh	r2, [r7, #8]
 800b72c:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpsmcr = 0;
 800b72e:	f04f 0300 	mov.w	r3, #0
 800b732:	82fb      	strh	r3, [r7, #22]
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
  /* Configure the ETR Clock source */
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
 800b734:	8979      	ldrh	r1, [r7, #10]
 800b736:	893a      	ldrh	r2, [r7, #8]
 800b738:	88fb      	ldrh	r3, [r7, #6]
 800b73a:	68f8      	ldr	r0, [r7, #12]
 800b73c:	f000 f8a4 	bl	800b888 <TIM_ETRConfig>
  
  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 800b740:	68fb      	ldr	r3, [r7, #12]
 800b742:	891b      	ldrh	r3, [r3, #8]
 800b744:	82fb      	strh	r3, [r7, #22]

  /* Reset the SMS Bits */
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
 800b746:	8afb      	ldrh	r3, [r7, #22]
 800b748:	f023 0307 	bic.w	r3, r3, #7
 800b74c:	82fb      	strh	r3, [r7, #22]

  /* Select the External clock mode1 */
  tmpsmcr |= TIM_SlaveMode_External1;
 800b74e:	8afb      	ldrh	r3, [r7, #22]
 800b750:	f043 0307 	orr.w	r3, r3, #7
 800b754:	82fb      	strh	r3, [r7, #22]

  /* Select the Trigger selection : ETRF */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 800b756:	8afb      	ldrh	r3, [r7, #22]
 800b758:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800b75c:	82fb      	strh	r3, [r7, #22]
  tmpsmcr |= TIM_TS_ETRF;
 800b75e:	8afb      	ldrh	r3, [r7, #22]
 800b760:	f043 0370 	orr.w	r3, r3, #112	; 0x70
 800b764:	82fb      	strh	r3, [r7, #22]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800b766:	68fb      	ldr	r3, [r7, #12]
 800b768:	8afa      	ldrh	r2, [r7, #22]
 800b76a:	811a      	strh	r2, [r3, #8]
}
 800b76c:	f107 0718 	add.w	r7, r7, #24
 800b770:	46bd      	mov	sp, r7
 800b772:	bd80      	pop	{r7, pc}

0800b774 <TIM_ETRClockMode2Config>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 800b774:	b580      	push	{r7, lr}
 800b776:	b084      	sub	sp, #16
 800b778:	af00      	add	r7, sp, #0
 800b77a:	60f8      	str	r0, [r7, #12]
 800b77c:	8179      	strh	r1, [r7, #10]
 800b77e:	813a      	strh	r2, [r7, #8]
 800b780:	80fb      	strh	r3, [r7, #6]
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));

  /* Configure the ETR Clock source */
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
 800b782:	8979      	ldrh	r1, [r7, #10]
 800b784:	893a      	ldrh	r2, [r7, #8]
 800b786:	88fb      	ldrh	r3, [r7, #6]
 800b788:	68f8      	ldr	r0, [r7, #12]
 800b78a:	f000 f87d 	bl	800b888 <TIM_ETRConfig>

  /* Enable the External clock mode2 */
  TIMx->SMCR |= TIM_SMCR_ECE;
 800b78e:	68fb      	ldr	r3, [r7, #12]
 800b790:	891b      	ldrh	r3, [r3, #8]
 800b792:	b29b      	uxth	r3, r3
 800b794:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800b798:	b29a      	uxth	r2, r3
 800b79a:	68fb      	ldr	r3, [r7, #12]
 800b79c:	811a      	strh	r2, [r3, #8]
}
 800b79e:	f107 0710 	add.w	r7, r7, #16
 800b7a2:	46bd      	mov	sp, r7
 800b7a4:	bd80      	pop	{r7, pc}
 800b7a6:	bf00      	nop

0800b7a8 <TIM_SelectInputTrigger>:
  *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
  *            @arg TIM_TS_ETRF: External Trigger input
  * @retval None
  */
void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
{
 800b7a8:	b480      	push	{r7}
 800b7aa:	b085      	sub	sp, #20
 800b7ac:	af00      	add	r7, sp, #0
 800b7ae:	6078      	str	r0, [r7, #4]
 800b7b0:	460b      	mov	r3, r1
 800b7b2:	807b      	strh	r3, [r7, #2]
  uint16_t tmpsmcr = 0;
 800b7b4:	f04f 0300 	mov.w	r3, #0
 800b7b8:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 800b7ba:	687b      	ldr	r3, [r7, #4]
 800b7bc:	891b      	ldrh	r3, [r3, #8]
 800b7be:	81fb      	strh	r3, [r7, #14]

  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 800b7c0:	89fb      	ldrh	r3, [r7, #14]
 800b7c2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800b7c6:	81fb      	strh	r3, [r7, #14]

  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;
 800b7c8:	89fa      	ldrh	r2, [r7, #14]
 800b7ca:	887b      	ldrh	r3, [r7, #2]
 800b7cc:	4313      	orrs	r3, r2
 800b7ce:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800b7d0:	687b      	ldr	r3, [r7, #4]
 800b7d2:	89fa      	ldrh	r2, [r7, #14]
 800b7d4:	811a      	strh	r2, [r3, #8]
}
 800b7d6:	f107 0714 	add.w	r7, r7, #20
 800b7da:	46bd      	mov	sp, r7
 800b7dc:	bc80      	pop	{r7}
 800b7de:	4770      	bx	lr

0800b7e0 <TIM_SelectOutputTrigger>:
  *            @arg TIM_TRGOSource_OC4Ref: OC4REF signal is used as the trigger output(TRGO)
  *
  * @retval None
  */
void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
{
 800b7e0:	b480      	push	{r7}
 800b7e2:	b083      	sub	sp, #12
 800b7e4:	af00      	add	r7, sp, #0
 800b7e6:	6078      	str	r0, [r7, #4]
 800b7e8:	460b      	mov	r3, r1
 800b7ea:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST5_PERIPH(TIMx));
  assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));

  /* Reset the MMS Bits */
  TIMx->CR2 &= (uint16_t)~TIM_CR2_MMS;
 800b7ec:	687b      	ldr	r3, [r7, #4]
 800b7ee:	889b      	ldrh	r3, [r3, #4]
 800b7f0:	b29b      	uxth	r3, r3
 800b7f2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800b7f6:	b29a      	uxth	r2, r3
 800b7f8:	687b      	ldr	r3, [r7, #4]
 800b7fa:	809a      	strh	r2, [r3, #4]
  /* Select the TRGO source */
  TIMx->CR2 |=  TIM_TRGOSource;
 800b7fc:	687b      	ldr	r3, [r7, #4]
 800b7fe:	889b      	ldrh	r3, [r3, #4]
 800b800:	b29a      	uxth	r2, r3
 800b802:	887b      	ldrh	r3, [r7, #2]
 800b804:	4313      	orrs	r3, r2
 800b806:	b29a      	uxth	r2, r3
 800b808:	687b      	ldr	r3, [r7, #4]
 800b80a:	809a      	strh	r2, [r3, #4]
}
 800b80c:	f107 070c 	add.w	r7, r7, #12
 800b810:	46bd      	mov	sp, r7
 800b812:	bc80      	pop	{r7}
 800b814:	4770      	bx	lr
 800b816:	bf00      	nop

0800b818 <TIM_SelectSlaveMode>:
  *            @arg TIM_SlaveMode_Trigger:   The counter starts at a rising edge of the trigger TRGI
  *            @arg TIM_SlaveMode_External1: Rising edges of the selected trigger (TRGI) clock the counter
  * @retval None
  */
void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
{
 800b818:	b480      	push	{r7}
 800b81a:	b083      	sub	sp, #12
 800b81c:	af00      	add	r7, sp, #0
 800b81e:	6078      	str	r0, [r7, #4]
 800b820:	460b      	mov	r3, r1
 800b822:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));

  /* Reset the SMS Bits */
  TIMx->SMCR &= (uint16_t)~TIM_SMCR_SMS;
 800b824:	687b      	ldr	r3, [r7, #4]
 800b826:	891b      	ldrh	r3, [r3, #8]
 800b828:	b29b      	uxth	r3, r3
 800b82a:	f023 0307 	bic.w	r3, r3, #7
 800b82e:	b29a      	uxth	r2, r3
 800b830:	687b      	ldr	r3, [r7, #4]
 800b832:	811a      	strh	r2, [r3, #8]

  /* Select the Slave Mode */
  TIMx->SMCR |= TIM_SlaveMode;
 800b834:	687b      	ldr	r3, [r7, #4]
 800b836:	891b      	ldrh	r3, [r3, #8]
 800b838:	b29a      	uxth	r2, r3
 800b83a:	887b      	ldrh	r3, [r7, #2]
 800b83c:	4313      	orrs	r3, r2
 800b83e:	b29a      	uxth	r2, r3
 800b840:	687b      	ldr	r3, [r7, #4]
 800b842:	811a      	strh	r2, [r3, #8]
}
 800b844:	f107 070c 	add.w	r7, r7, #12
 800b848:	46bd      	mov	sp, r7
 800b84a:	bc80      	pop	{r7}
 800b84c:	4770      	bx	lr
 800b84e:	bf00      	nop

0800b850 <TIM_SelectMasterSlaveMode>:
  *                                             and its slaves (through TRGO)
  *            @arg TIM_MasterSlaveMode_Disable: No action
  * @retval None
  */
void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
{
 800b850:	b480      	push	{r7}
 800b852:	b083      	sub	sp, #12
 800b854:	af00      	add	r7, sp, #0
 800b856:	6078      	str	r0, [r7, #4]
 800b858:	460b      	mov	r3, r1
 800b85a:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));

  /* Reset the MSM Bit */
  TIMx->SMCR &= (uint16_t)~TIM_SMCR_MSM;
 800b85c:	687b      	ldr	r3, [r7, #4]
 800b85e:	891b      	ldrh	r3, [r3, #8]
 800b860:	b29b      	uxth	r3, r3
 800b862:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800b866:	b29a      	uxth	r2, r3
 800b868:	687b      	ldr	r3, [r7, #4]
 800b86a:	811a      	strh	r2, [r3, #8]
  
  /* Set or Reset the MSM Bit */
  TIMx->SMCR |= TIM_MasterSlaveMode;
 800b86c:	687b      	ldr	r3, [r7, #4]
 800b86e:	891b      	ldrh	r3, [r3, #8]
 800b870:	b29a      	uxth	r2, r3
 800b872:	887b      	ldrh	r3, [r7, #2]
 800b874:	4313      	orrs	r3, r2
 800b876:	b29a      	uxth	r2, r3
 800b878:	687b      	ldr	r3, [r7, #4]
 800b87a:	811a      	strh	r2, [r3, #8]
}
 800b87c:	f107 070c 	add.w	r7, r7, #12
 800b880:	46bd      	mov	sp, r7
 800b882:	bc80      	pop	{r7}
 800b884:	4770      	bx	lr
 800b886:	bf00      	nop

0800b888 <TIM_ETRConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
                   uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 800b888:	b480      	push	{r7}
 800b88a:	b087      	sub	sp, #28
 800b88c:	af00      	add	r7, sp, #0
 800b88e:	60f8      	str	r0, [r7, #12]
 800b890:	8179      	strh	r1, [r7, #10]
 800b892:	813a      	strh	r2, [r7, #8]
 800b894:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpsmcr = 0;
 800b896:	f04f 0300 	mov.w	r3, #0
 800b89a:	82fb      	strh	r3, [r7, #22]
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));

  tmpsmcr = TIMx->SMCR;
 800b89c:	68fb      	ldr	r3, [r7, #12]
 800b89e:	891b      	ldrh	r3, [r3, #8]
 800b8a0:	82fb      	strh	r3, [r7, #22]

  /* Reset the ETR Bits */
  tmpsmcr &= SMCR_ETR_MASK;
 800b8a2:	8afb      	ldrh	r3, [r7, #22]
 800b8a4:	b2db      	uxtb	r3, r3
 800b8a6:	82fb      	strh	r3, [r7, #22]

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
 800b8a8:	88fb      	ldrh	r3, [r7, #6]
 800b8aa:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800b8ae:	b29a      	uxth	r2, r3
 800b8b0:	893b      	ldrh	r3, [r7, #8]
 800b8b2:	4313      	orrs	r3, r2
 800b8b4:	b29a      	uxth	r2, r3
 800b8b6:	897b      	ldrh	r3, [r7, #10]
 800b8b8:	4313      	orrs	r3, r2
 800b8ba:	b29a      	uxth	r2, r3
 800b8bc:	8afb      	ldrh	r3, [r7, #22]
 800b8be:	4313      	orrs	r3, r2
 800b8c0:	82fb      	strh	r3, [r7, #22]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800b8c2:	68fb      	ldr	r3, [r7, #12]
 800b8c4:	8afa      	ldrh	r2, [r7, #22]
 800b8c6:	811a      	strh	r2, [r3, #8]
}
 800b8c8:	f107 071c 	add.w	r7, r7, #28
 800b8cc:	46bd      	mov	sp, r7
 800b8ce:	bc80      	pop	{r7}
 800b8d0:	4770      	bx	lr
 800b8d2:	bf00      	nop

0800b8d4 <TIM_EncoderInterfaceConfig>:
  *            @arg TIM_ICPolarity_Rising: IC Rising edge.
  * @retval None
  */
void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
{
 800b8d4:	b480      	push	{r7}
 800b8d6:	b087      	sub	sp, #28
 800b8d8:	af00      	add	r7, sp, #0
 800b8da:	60f8      	str	r0, [r7, #12]
 800b8dc:	8179      	strh	r1, [r7, #10]
 800b8de:	813a      	strh	r2, [r7, #8]
 800b8e0:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpsmcr = 0;
 800b8e2:	f04f 0300 	mov.w	r3, #0
 800b8e6:	82fb      	strh	r3, [r7, #22]
  uint16_t tmpccmr1 = 0;
 800b8e8:	f04f 0300 	mov.w	r3, #0
 800b8ec:	82bb      	strh	r3, [r7, #20]
  uint16_t tmpccer = 0;
 800b8ee:	f04f 0300 	mov.w	r3, #0
 800b8f2:	827b      	strh	r3, [r7, #18]
  assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
  assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
  assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 800b8f4:	68fb      	ldr	r3, [r7, #12]
 800b8f6:	891b      	ldrh	r3, [r3, #8]
 800b8f8:	82fb      	strh	r3, [r7, #22]

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 800b8fa:	68fb      	ldr	r3, [r7, #12]
 800b8fc:	8b1b      	ldrh	r3, [r3, #24]
 800b8fe:	82bb      	strh	r3, [r7, #20]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800b900:	68fb      	ldr	r3, [r7, #12]
 800b902:	8c1b      	ldrh	r3, [r3, #32]
 800b904:	827b      	strh	r3, [r7, #18]

  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
 800b906:	8afb      	ldrh	r3, [r7, #22]
 800b908:	f023 0307 	bic.w	r3, r3, #7
 800b90c:	82fb      	strh	r3, [r7, #22]
  tmpsmcr |= TIM_EncoderMode;
 800b90e:	8afa      	ldrh	r2, [r7, #22]
 800b910:	897b      	ldrh	r3, [r7, #10]
 800b912:	4313      	orrs	r3, r2
 800b914:	82fb      	strh	r3, [r7, #22]

  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
 800b916:	8abb      	ldrh	r3, [r7, #20]
 800b918:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800b91c:	f023 0303 	bic.w	r3, r3, #3
 800b920:	82bb      	strh	r3, [r7, #20]
  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
 800b922:	8abb      	ldrh	r3, [r7, #20]
 800b924:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800b928:	f043 0301 	orr.w	r3, r3, #1
 800b92c:	82bb      	strh	r3, [r7, #20]

  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
 800b92e:	8a7b      	ldrh	r3, [r7, #18]
 800b930:	f023 0322 	bic.w	r3, r3, #34	; 0x22
 800b934:	827b      	strh	r3, [r7, #18]
  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
 800b936:	88fb      	ldrh	r3, [r7, #6]
 800b938:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800b93c:	b29a      	uxth	r2, r3
 800b93e:	893b      	ldrh	r3, [r7, #8]
 800b940:	4313      	orrs	r3, r2
 800b942:	b29a      	uxth	r2, r3
 800b944:	8a7b      	ldrh	r3, [r7, #18]
 800b946:	4313      	orrs	r3, r2
 800b948:	827b      	strh	r3, [r7, #18]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800b94a:	68fb      	ldr	r3, [r7, #12]
 800b94c:	8afa      	ldrh	r2, [r7, #22]
 800b94e:	811a      	strh	r2, [r3, #8]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 800b950:	68fb      	ldr	r3, [r7, #12]
 800b952:	8aba      	ldrh	r2, [r7, #20]
 800b954:	831a      	strh	r2, [r3, #24]

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800b956:	68fb      	ldr	r3, [r7, #12]
 800b958:	8a7a      	ldrh	r2, [r7, #18]
 800b95a:	841a      	strh	r2, [r3, #32]
}
 800b95c:	f107 071c 	add.w	r7, r7, #28
 800b960:	46bd      	mov	sp, r7
 800b962:	bc80      	pop	{r7}
 800b964:	4770      	bx	lr
 800b966:	bf00      	nop

0800b968 <TIM_SelectHallSensor>:
  * @param  NewState: new state of the TIMx Hall sensor interface.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 800b968:	b480      	push	{r7}
 800b96a:	b083      	sub	sp, #12
 800b96c:	af00      	add	r7, sp, #0
 800b96e:	6078      	str	r0, [r7, #4]
 800b970:	460b      	mov	r3, r1
 800b972:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800b974:	78fb      	ldrb	r3, [r7, #3]
 800b976:	2b00      	cmp	r3, #0
 800b978:	d008      	beq.n	800b98c <TIM_SelectHallSensor+0x24>
  {
    /* Set the TI1S Bit */
    TIMx->CR2 |= TIM_CR2_TI1S;
 800b97a:	687b      	ldr	r3, [r7, #4]
 800b97c:	889b      	ldrh	r3, [r3, #4]
 800b97e:	b29b      	uxth	r3, r3
 800b980:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b984:	b29a      	uxth	r2, r3
 800b986:	687b      	ldr	r3, [r7, #4]
 800b988:	809a      	strh	r2, [r3, #4]
 800b98a:	e007      	b.n	800b99c <TIM_SelectHallSensor+0x34>
  }
  else
  {
    /* Reset the TI1S Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_TI1S;
 800b98c:	687b      	ldr	r3, [r7, #4]
 800b98e:	889b      	ldrh	r3, [r3, #4]
 800b990:	b29b      	uxth	r3, r3
 800b992:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800b996:	b29a      	uxth	r2, r3
 800b998:	687b      	ldr	r3, [r7, #4]
 800b99a:	809a      	strh	r2, [r3, #4]
  }
}
 800b99c:	f107 070c 	add.w	r7, r7, #12
 800b9a0:	46bd      	mov	sp, r7
 800b9a2:	bc80      	pop	{r7}
 800b9a4:	4770      	bx	lr
 800b9a6:	bf00      	nop

0800b9a8 <TIM_RemapConfig>:
  *            @arg TIM11_HSE:      TIM11 CH4 input is connected to HSE_RTC clock
  *                                 (HSE divided by a programmable prescaler)  
  * @retval None
  */
void TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap)
{
 800b9a8:	b480      	push	{r7}
 800b9aa:	b083      	sub	sp, #12
 800b9ac:	af00      	add	r7, sp, #0
 800b9ae:	6078      	str	r0, [r7, #4]
 800b9b0:	460b      	mov	r3, r1
 800b9b2:	807b      	strh	r3, [r7, #2]
 /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_REMAP(TIM_Remap));

  /* Set the Timer remapping configuration */
  TIMx->OR =  TIM_Remap;
 800b9b4:	687b      	ldr	r3, [r7, #4]
 800b9b6:	887a      	ldrh	r2, [r7, #2]
 800b9b8:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
}
 800b9bc:	f107 070c 	add.w	r7, r7, #12
 800b9c0:	46bd      	mov	sp, r7
 800b9c2:	bc80      	pop	{r7}
 800b9c4:	4770      	bx	lr
 800b9c6:	bf00      	nop

0800b9c8 <TI1_Config>:
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 800b9c8:	b480      	push	{r7}
 800b9ca:	b087      	sub	sp, #28
 800b9cc:	af00      	add	r7, sp, #0
 800b9ce:	60f8      	str	r0, [r7, #12]
 800b9d0:	8179      	strh	r1, [r7, #10]
 800b9d2:	813a      	strh	r2, [r7, #8]
 800b9d4:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpccmr1 = 0, tmpccer = 0;
 800b9d6:	f04f 0300 	mov.w	r3, #0
 800b9da:	82fb      	strh	r3, [r7, #22]
 800b9dc:	f04f 0300 	mov.w	r3, #0
 800b9e0:	82bb      	strh	r3, [r7, #20]

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
 800b9e2:	68fb      	ldr	r3, [r7, #12]
 800b9e4:	8c1b      	ldrh	r3, [r3, #32]
 800b9e6:	b29b      	uxth	r3, r3
 800b9e8:	f023 0301 	bic.w	r3, r3, #1
 800b9ec:	b29a      	uxth	r2, r3
 800b9ee:	68fb      	ldr	r3, [r7, #12]
 800b9f0:	841a      	strh	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 800b9f2:	68fb      	ldr	r3, [r7, #12]
 800b9f4:	8b1b      	ldrh	r3, [r3, #24]
 800b9f6:	82fb      	strh	r3, [r7, #22]
  tmpccer = TIMx->CCER;
 800b9f8:	68fb      	ldr	r3, [r7, #12]
 800b9fa:	8c1b      	ldrh	r3, [r3, #32]
 800b9fc:	82bb      	strh	r3, [r7, #20]

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
 800b9fe:	8afb      	ldrh	r3, [r7, #22]
 800ba00:	f023 03f3 	bic.w	r3, r3, #243	; 0xf3
 800ba04:	82fb      	strh	r3, [r7, #22]
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 800ba06:	88fb      	ldrh	r3, [r7, #6]
 800ba08:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800ba0c:	b29a      	uxth	r2, r3
 800ba0e:	893b      	ldrh	r3, [r7, #8]
 800ba10:	4313      	orrs	r3, r2
 800ba12:	b29a      	uxth	r2, r3
 800ba14:	8afb      	ldrh	r3, [r7, #22]
 800ba16:	4313      	orrs	r3, r2
 800ba18:	82fb      	strh	r3, [r7, #22]

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 800ba1a:	8abb      	ldrh	r3, [r7, #20]
 800ba1c:	f023 030a 	bic.w	r3, r3, #10
 800ba20:	82bb      	strh	r3, [r7, #20]
  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
 800ba22:	897a      	ldrh	r2, [r7, #10]
 800ba24:	8abb      	ldrh	r3, [r7, #20]
 800ba26:	4313      	orrs	r3, r2
 800ba28:	b29b      	uxth	r3, r3
 800ba2a:	f043 0301 	orr.w	r3, r3, #1
 800ba2e:	82bb      	strh	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 800ba30:	68fb      	ldr	r3, [r7, #12]
 800ba32:	8afa      	ldrh	r2, [r7, #22]
 800ba34:	831a      	strh	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 800ba36:	68fb      	ldr	r3, [r7, #12]
 800ba38:	8aba      	ldrh	r2, [r7, #20]
 800ba3a:	841a      	strh	r2, [r3, #32]
}
 800ba3c:	f107 071c 	add.w	r7, r7, #28
 800ba40:	46bd      	mov	sp, r7
 800ba42:	bc80      	pop	{r7}
 800ba44:	4770      	bx	lr
 800ba46:	bf00      	nop

0800ba48 <TI2_Config>:
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 800ba48:	b480      	push	{r7}
 800ba4a:	b087      	sub	sp, #28
 800ba4c:	af00      	add	r7, sp, #0
 800ba4e:	60f8      	str	r0, [r7, #12]
 800ba50:	8179      	strh	r1, [r7, #10]
 800ba52:	813a      	strh	r2, [r7, #8]
 800ba54:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
 800ba56:	f04f 0300 	mov.w	r3, #0
 800ba5a:	82fb      	strh	r3, [r7, #22]
 800ba5c:	f04f 0300 	mov.w	r3, #0
 800ba60:	82bb      	strh	r3, [r7, #20]
 800ba62:	f04f 0300 	mov.w	r3, #0
 800ba66:	827b      	strh	r3, [r7, #18]

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
 800ba68:	68fb      	ldr	r3, [r7, #12]
 800ba6a:	8c1b      	ldrh	r3, [r3, #32]
 800ba6c:	b29b      	uxth	r3, r3
 800ba6e:	f023 0310 	bic.w	r3, r3, #16
 800ba72:	b29a      	uxth	r2, r3
 800ba74:	68fb      	ldr	r3, [r7, #12]
 800ba76:	841a      	strh	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 800ba78:	68fb      	ldr	r3, [r7, #12]
 800ba7a:	8b1b      	ldrh	r3, [r3, #24]
 800ba7c:	82fb      	strh	r3, [r7, #22]
  tmpccer = TIMx->CCER;
 800ba7e:	68fb      	ldr	r3, [r7, #12]
 800ba80:	8c1b      	ldrh	r3, [r3, #32]
 800ba82:	82bb      	strh	r3, [r7, #20]
  tmp = (uint16_t)(TIM_ICPolarity << 4);
 800ba84:	897b      	ldrh	r3, [r7, #10]
 800ba86:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800ba8a:	827b      	strh	r3, [r7, #18]

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
 800ba8c:	8afb      	ldrh	r3, [r7, #22]
 800ba8e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800ba92:	ea4f 5303 	mov.w	r3, r3, lsl #20
 800ba96:	ea4f 5313 	mov.w	r3, r3, lsr #20
 800ba9a:	82fb      	strh	r3, [r7, #22]
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
 800ba9c:	88fb      	ldrh	r3, [r7, #6]
 800ba9e:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800baa2:	b29a      	uxth	r2, r3
 800baa4:	8afb      	ldrh	r3, [r7, #22]
 800baa6:	4313      	orrs	r3, r2
 800baa8:	82fb      	strh	r3, [r7, #22]
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
 800baaa:	893b      	ldrh	r3, [r7, #8]
 800baac:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800bab0:	b29a      	uxth	r2, r3
 800bab2:	8afb      	ldrh	r3, [r7, #22]
 800bab4:	4313      	orrs	r3, r2
 800bab6:	82fb      	strh	r3, [r7, #22]

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 800bab8:	8abb      	ldrh	r3, [r7, #20]
 800baba:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 800babe:	82bb      	strh	r3, [r7, #20]
  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
 800bac0:	8a7a      	ldrh	r2, [r7, #18]
 800bac2:	8abb      	ldrh	r3, [r7, #20]
 800bac4:	4313      	orrs	r3, r2
 800bac6:	b29b      	uxth	r3, r3
 800bac8:	f043 0310 	orr.w	r3, r3, #16
 800bacc:	82bb      	strh	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 800bace:	68fb      	ldr	r3, [r7, #12]
 800bad0:	8afa      	ldrh	r2, [r7, #22]
 800bad2:	831a      	strh	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 800bad4:	68fb      	ldr	r3, [r7, #12]
 800bad6:	8aba      	ldrh	r2, [r7, #20]
 800bad8:	841a      	strh	r2, [r3, #32]
}
 800bada:	f107 071c 	add.w	r7, r7, #28
 800bade:	46bd      	mov	sp, r7
 800bae0:	bc80      	pop	{r7}
 800bae2:	4770      	bx	lr

0800bae4 <TI3_Config>:
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 800bae4:	b480      	push	{r7}
 800bae6:	b087      	sub	sp, #28
 800bae8:	af00      	add	r7, sp, #0
 800baea:	60f8      	str	r0, [r7, #12]
 800baec:	8179      	strh	r1, [r7, #10]
 800baee:	813a      	strh	r2, [r7, #8]
 800baf0:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
 800baf2:	f04f 0300 	mov.w	r3, #0
 800baf6:	82fb      	strh	r3, [r7, #22]
 800baf8:	f04f 0300 	mov.w	r3, #0
 800bafc:	82bb      	strh	r3, [r7, #20]
 800bafe:	f04f 0300 	mov.w	r3, #0
 800bb02:	827b      	strh	r3, [r7, #18]

  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
 800bb04:	68fb      	ldr	r3, [r7, #12]
 800bb06:	8c1b      	ldrh	r3, [r3, #32]
 800bb08:	b29b      	uxth	r3, r3
 800bb0a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800bb0e:	b29a      	uxth	r2, r3
 800bb10:	68fb      	ldr	r3, [r7, #12]
 800bb12:	841a      	strh	r2, [r3, #32]
  tmpccmr2 = TIMx->CCMR2;
 800bb14:	68fb      	ldr	r3, [r7, #12]
 800bb16:	8b9b      	ldrh	r3, [r3, #28]
 800bb18:	82fb      	strh	r3, [r7, #22]
  tmpccer = TIMx->CCER;
 800bb1a:	68fb      	ldr	r3, [r7, #12]
 800bb1c:	8c1b      	ldrh	r3, [r3, #32]
 800bb1e:	82bb      	strh	r3, [r7, #20]
  tmp = (uint16_t)(TIM_ICPolarity << 8);
 800bb20:	897b      	ldrh	r3, [r7, #10]
 800bb22:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800bb26:	827b      	strh	r3, [r7, #18]

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
 800bb28:	8afb      	ldrh	r3, [r7, #22]
 800bb2a:	f023 03f3 	bic.w	r3, r3, #243	; 0xf3
 800bb2e:	82fb      	strh	r3, [r7, #22]
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 800bb30:	88fb      	ldrh	r3, [r7, #6]
 800bb32:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800bb36:	b29a      	uxth	r2, r3
 800bb38:	893b      	ldrh	r3, [r7, #8]
 800bb3a:	4313      	orrs	r3, r2
 800bb3c:	b29a      	uxth	r2, r3
 800bb3e:	8afb      	ldrh	r3, [r7, #22]
 800bb40:	4313      	orrs	r3, r2
 800bb42:	82fb      	strh	r3, [r7, #22]

  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
 800bb44:	8abb      	ldrh	r3, [r7, #20]
 800bb46:	f423 6320 	bic.w	r3, r3, #2560	; 0xa00
 800bb4a:	82bb      	strh	r3, [r7, #20]
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
 800bb4c:	8a7a      	ldrh	r2, [r7, #18]
 800bb4e:	8abb      	ldrh	r3, [r7, #20]
 800bb50:	4313      	orrs	r3, r2
 800bb52:	b29b      	uxth	r3, r3
 800bb54:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800bb58:	82bb      	strh	r3, [r7, #20]

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 800bb5a:	68fb      	ldr	r3, [r7, #12]
 800bb5c:	8afa      	ldrh	r2, [r7, #22]
 800bb5e:	839a      	strh	r2, [r3, #28]
  TIMx->CCER = tmpccer;
 800bb60:	68fb      	ldr	r3, [r7, #12]
 800bb62:	8aba      	ldrh	r2, [r7, #20]
 800bb64:	841a      	strh	r2, [r3, #32]
}
 800bb66:	f107 071c 	add.w	r7, r7, #28
 800bb6a:	46bd      	mov	sp, r7
 800bb6c:	bc80      	pop	{r7}
 800bb6e:	4770      	bx	lr

0800bb70 <TI4_Config>:
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 800bb70:	b480      	push	{r7}
 800bb72:	b087      	sub	sp, #28
 800bb74:	af00      	add	r7, sp, #0
 800bb76:	60f8      	str	r0, [r7, #12]
 800bb78:	8179      	strh	r1, [r7, #10]
 800bb7a:	813a      	strh	r2, [r7, #8]
 800bb7c:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
 800bb7e:	f04f 0300 	mov.w	r3, #0
 800bb82:	82fb      	strh	r3, [r7, #22]
 800bb84:	f04f 0300 	mov.w	r3, #0
 800bb88:	82bb      	strh	r3, [r7, #20]
 800bb8a:	f04f 0300 	mov.w	r3, #0
 800bb8e:	827b      	strh	r3, [r7, #18]

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
 800bb90:	68fb      	ldr	r3, [r7, #12]
 800bb92:	8c1b      	ldrh	r3, [r3, #32]
 800bb94:	b29b      	uxth	r3, r3
 800bb96:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800bb9a:	b29a      	uxth	r2, r3
 800bb9c:	68fb      	ldr	r3, [r7, #12]
 800bb9e:	841a      	strh	r2, [r3, #32]
  tmpccmr2 = TIMx->CCMR2;
 800bba0:	68fb      	ldr	r3, [r7, #12]
 800bba2:	8b9b      	ldrh	r3, [r3, #28]
 800bba4:	82fb      	strh	r3, [r7, #22]
  tmpccer = TIMx->CCER;
 800bba6:	68fb      	ldr	r3, [r7, #12]
 800bba8:	8c1b      	ldrh	r3, [r3, #32]
 800bbaa:	82bb      	strh	r3, [r7, #20]
  tmp = (uint16_t)(TIM_ICPolarity << 12);
 800bbac:	897b      	ldrh	r3, [r7, #10]
 800bbae:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800bbb2:	827b      	strh	r3, [r7, #18]

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
 800bbb4:	8afb      	ldrh	r3, [r7, #22]
 800bbb6:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800bbba:	ea4f 5303 	mov.w	r3, r3, lsl #20
 800bbbe:	ea4f 5313 	mov.w	r3, r3, lsr #20
 800bbc2:	82fb      	strh	r3, [r7, #22]
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
 800bbc4:	893b      	ldrh	r3, [r7, #8]
 800bbc6:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800bbca:	b29a      	uxth	r2, r3
 800bbcc:	8afb      	ldrh	r3, [r7, #22]
 800bbce:	4313      	orrs	r3, r2
 800bbd0:	82fb      	strh	r3, [r7, #22]
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
 800bbd2:	88fb      	ldrh	r3, [r7, #6]
 800bbd4:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800bbd8:	b29a      	uxth	r2, r3
 800bbda:	8afb      	ldrh	r3, [r7, #22]
 800bbdc:	4313      	orrs	r3, r2
 800bbde:	82fb      	strh	r3, [r7, #22]

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
 800bbe0:	8abb      	ldrh	r3, [r7, #20]
 800bbe2:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800bbe6:	ea4f 4343 	mov.w	r3, r3, lsl #17
 800bbea:	ea4f 4353 	mov.w	r3, r3, lsr #17
 800bbee:	82bb      	strh	r3, [r7, #20]
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
 800bbf0:	8a7a      	ldrh	r2, [r7, #18]
 800bbf2:	8abb      	ldrh	r3, [r7, #20]
 800bbf4:	4313      	orrs	r3, r2
 800bbf6:	b29b      	uxth	r3, r3
 800bbf8:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800bbfc:	82bb      	strh	r3, [r7, #20]

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 800bbfe:	68fb      	ldr	r3, [r7, #12]
 800bc00:	8afa      	ldrh	r2, [r7, #22]
 800bc02:	839a      	strh	r2, [r3, #28]
  TIMx->CCER = tmpccer ;
 800bc04:	68fb      	ldr	r3, [r7, #12]
 800bc06:	8aba      	ldrh	r2, [r7, #20]
 800bc08:	841a      	strh	r2, [r3, #32]
}
 800bc0a:	f107 071c 	add.w	r7, r7, #28
 800bc0e:	46bd      	mov	sp, r7
 800bc10:	bc80      	pop	{r7}
 800bc12:	4770      	bx	lr

0800bc14 <TimerConfig>:

extern uint16_t aADCDualConvertedValue[10];
volatile uint16_t ADCConvertedValues[ADC_PACKAGE_MAX_NUMBER][12];

void TimerConfig()
{
 800bc14:	b580      	push	{r7, lr}
 800bc16:	b084      	sub	sp, #16
 800bc18:	af00      	add	r7, sp, #0
	TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
	NVIC_InitTypeDef NVIC_InitStructure;

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);  	// APB1 -> 42 MHz, Timer -> 84 MHz
 800bc1a:	f04f 0002 	mov.w	r0, #2
 800bc1e:	f04f 0101 	mov.w	r1, #1
 800bc22:	f7fc fb25 	bl	8008270 <RCC_APB1PeriphClockCmd>

	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
 800bc26:	f107 0304 	add.w	r3, r7, #4
 800bc2a:	4618      	mov	r0, r3
 800bc2c:	f7fe fad6 	bl	800a1dc <TIM_TimeBaseStructInit>
	TIM_TimeBaseStructure.TIM_Period = 41999;
 800bc30:	f24a 430f 	movw	r3, #41999	; 0xa40f
 800bc34:	60bb      	str	r3, [r7, #8]
	TIM_TimeBaseStructure.TIM_Prescaler = 999;
 800bc36:	f240 33e7 	movw	r3, #999	; 0x3e7
 800bc3a:	80bb      	strh	r3, [r7, #4]
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 800bc3c:	f04f 0300 	mov.w	r3, #0
 800bc40:	81bb      	strh	r3, [r7, #12]
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 800bc42:	f04f 0300 	mov.w	r3, #0
 800bc46:	80fb      	strh	r3, [r7, #6]

	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
 800bc48:	f107 0304 	add.w	r3, r7, #4
 800bc4c:	4811      	ldr	r0, [pc, #68]	; (800bc94 <TimerConfig+0x80>)
 800bc4e:	4619      	mov	r1, r3
 800bc50:	f7fe fa58 	bl	800a104 <TIM_TimeBaseInit>
	TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);
 800bc54:	480f      	ldr	r0, [pc, #60]	; (800bc94 <TimerConfig+0x80>)
 800bc56:	f04f 0101 	mov.w	r1, #1
 800bc5a:	f04f 0201 	mov.w	r2, #1
 800bc5e:	f7ff fc0b 	bl	800b478 <TIM_ITConfig>

	NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
 800bc62:	f04f 031d 	mov.w	r3, #29
 800bc66:	703b      	strb	r3, [r7, #0]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 800bc68:	f04f 0301 	mov.w	r3, #1
 800bc6c:	70fb      	strb	r3, [r7, #3]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 5;
 800bc6e:	f04f 0305 	mov.w	r3, #5
 800bc72:	707b      	strb	r3, [r7, #1]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 800bc74:	f04f 0300 	mov.w	r3, #0
 800bc78:	70bb      	strb	r3, [r7, #2]
	NVIC_Init(&NVIC_InitStructure);
 800bc7a:	463b      	mov	r3, r7
 800bc7c:	4618      	mov	r0, r3
 800bc7e:	f7f9 fcb1 	bl	80055e4 <NVIC_Init>

	TIM_Cmd(TIM3, ENABLE);
 800bc82:	4804      	ldr	r0, [pc, #16]	; (800bc94 <TimerConfig+0x80>)
 800bc84:	f04f 0101 	mov.w	r1, #1
 800bc88:	f7fe fbc4 	bl	800a414 <TIM_Cmd>
}
 800bc8c:	f107 0710 	add.w	r7, r7, #16
 800bc90:	46bd      	mov	sp, r7
 800bc92:	bd80      	pop	{r7, pc}
 800bc94:	40000400 	.word	0x40000400

0800bc98 <TIM3_IRQHandler>:

void TIM3_IRQHandler(void)
{
 800bc98:	b590      	push	{r4, r7, lr}
 800bc9a:	b085      	sub	sp, #20
 800bc9c:	af00      	add	r7, sp, #0
	static int i = 0;
	static uint8_t interruptStatus = 0;
	int j = 0;
 800bc9e:	f04f 0300 	mov.w	r3, #0
 800bca2:	60fb      	str	r3, [r7, #12]

	RTC_TimeTypeDef RTC_TimeStruct;
	RTC_DateTypeDef RTC_DateStruct;


	if (TIM_GetITStatus(TIM3, TIM_IT_Update) == SET)
 800bca4:	4853      	ldr	r0, [pc, #332]	; (800bdf4 <TIM3_IRQHandler+0x15c>)
 800bca6:	f04f 0101 	mov.w	r1, #1
 800bcaa:	f7ff fc49 	bl	800b540 <TIM_GetITStatus>
 800bcae:	4603      	mov	r3, r0
 800bcb0:	2b01      	cmp	r3, #1
 800bcb2:	f040 809a 	bne.w	800bdea <TIM3_IRQHandler+0x152>
	{

		STM_EVAL_LEDToggle(LED4);
 800bcb6:	f04f 0000 	mov.w	r0, #0
 800bcba:	f7f8 fc01 	bl	80044c0 <STM_EVAL_LEDToggle>
		STM_EVAL_LEDToggle(LED5);
 800bcbe:	f04f 0002 	mov.w	r0, #2
 800bcc2:	f7f8 fbfd 	bl	80044c0 <STM_EVAL_LEDToggle>
		STM_EVAL_LEDToggle(LED6);
 800bcc6:	f04f 0003 	mov.w	r0, #3
 800bcca:	f7f8 fbf9 	bl	80044c0 <STM_EVAL_LEDToggle>

		if(interruptStatus == 0)
 800bcce:	4b4a      	ldr	r3, [pc, #296]	; (800bdf8 <TIM3_IRQHandler+0x160>)
 800bcd0:	781b      	ldrb	r3, [r3, #0]
 800bcd2:	2b00      	cmp	r3, #0
 800bcd4:	d10a      	bne.n	800bcec <TIM3_IRQHandler+0x54>
		{
			ADC_SoftwareStartConv(ADC1);
 800bcd6:	4849      	ldr	r0, [pc, #292]	; (800bdfc <TIM3_IRQHandler+0x164>)
 800bcd8:	f7f9 ff92 	bl	8005c00 <ADC_SoftwareStartConv>
			interruptStatus++;
 800bcdc:	4b46      	ldr	r3, [pc, #280]	; (800bdf8 <TIM3_IRQHandler+0x160>)
 800bcde:	781b      	ldrb	r3, [r3, #0]
 800bce0:	f103 0301 	add.w	r3, r3, #1
 800bce4:	b2da      	uxtb	r2, r3
 800bce6:	4b44      	ldr	r3, [pc, #272]	; (800bdf8 <TIM3_IRQHandler+0x160>)
 800bce8:	701a      	strb	r2, [r3, #0]
 800bcea:	e079      	b.n	800bde0 <TIM3_IRQHandler+0x148>
		}
		else
		{
			RTC_GetTime(RTC_Format_BCD, &RTC_TimeStruct);
 800bcec:	f107 0308 	add.w	r3, r7, #8
 800bcf0:	f04f 0001 	mov.w	r0, #1
 800bcf4:	4619      	mov	r1, r3
 800bcf6:	f7fc ff73 	bl	8008be0 <RTC_GetTime>
			RTC_GetDate(RTC_Format_BCD, &RTC_DateStruct);
 800bcfa:	f107 0304 	add.w	r3, r7, #4
 800bcfe:	f04f 0001 	mov.w	r0, #1
 800bd02:	4619      	mov	r1, r3
 800bd04:	f7fd f882 	bl	8008e0c <RTC_GetDate>


			if(i < ADC_PACKAGE_MAX_NUMBER)
 800bd08:	4b3d      	ldr	r3, [pc, #244]	; (800be00 <TIM3_IRQHandler+0x168>)
 800bd0a:	681b      	ldr	r3, [r3, #0]
 800bd0c:	2b02      	cmp	r3, #2
 800bd0e:	dc06      	bgt.n	800bd1e <TIM3_IRQHandler+0x86>
				i++;
 800bd10:	4b3b      	ldr	r3, [pc, #236]	; (800be00 <TIM3_IRQHandler+0x168>)
 800bd12:	681b      	ldr	r3, [r3, #0]
 800bd14:	f103 0201 	add.w	r2, r3, #1
 800bd18:	4b39      	ldr	r3, [pc, #228]	; (800be00 <TIM3_IRQHandler+0x168>)
 800bd1a:	601a      	str	r2, [r3, #0]
 800bd1c:	e008      	b.n	800bd30 <TIM3_IRQHandler+0x98>
			else
			{
				i = 0;
 800bd1e:	4b38      	ldr	r3, [pc, #224]	; (800be00 <TIM3_IRQHandler+0x168>)
 800bd20:	f04f 0200 	mov.w	r2, #0
 800bd24:	601a      	str	r2, [r3, #0]
				//CopyToFlash((uint16_t*)ADCConvertedValues, (ADC_PACKAGE_MAX_NUMBER * SIZE_OF_PACK));
				CopyToFlashTest((uint16_t*)ADCConvertedValues, (ADC_PACKAGE_MAX_NUMBER * SIZE_OF_PACK));
 800bd26:	4837      	ldr	r0, [pc, #220]	; (800be04 <TIM3_IRQHandler+0x16c>)
 800bd28:	f04f 0124 	mov.w	r1, #36	; 0x24
 800bd2c:	f000 ff7c 	bl	800cc28 <CopyToFlashTest>
			}

			for(j = 0; j < NUMBER_OF_CONVERSIONS; j++)
 800bd30:	f04f 0300 	mov.w	r3, #0
 800bd34:	60fb      	str	r3, [r7, #12]
 800bd36:	e017      	b.n	800bd68 <TIM3_IRQHandler+0xd0>
				ADCConvertedValues[i][j + 2] = aADCDualConvertedValue[j];
 800bd38:	4b31      	ldr	r3, [pc, #196]	; (800be00 <TIM3_IRQHandler+0x168>)
 800bd3a:	681a      	ldr	r2, [r3, #0]
 800bd3c:	68fb      	ldr	r3, [r7, #12]
 800bd3e:	f103 0402 	add.w	r4, r3, #2
 800bd42:	4b31      	ldr	r3, [pc, #196]	; (800be08 <TIM3_IRQHandler+0x170>)
 800bd44:	68f9      	ldr	r1, [r7, #12]
 800bd46:	f833 0011 	ldrh.w	r0, [r3, r1, lsl #1]
 800bd4a:	492e      	ldr	r1, [pc, #184]	; (800be04 <TIM3_IRQHandler+0x16c>)
 800bd4c:	4613      	mov	r3, r2
 800bd4e:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800bd52:	189b      	adds	r3, r3, r2
 800bd54:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800bd58:	191b      	adds	r3, r3, r4
 800bd5a:	4602      	mov	r2, r0
 800bd5c:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
				i = 0;
				//CopyToFlash((uint16_t*)ADCConvertedValues, (ADC_PACKAGE_MAX_NUMBER * SIZE_OF_PACK));
				CopyToFlashTest((uint16_t*)ADCConvertedValues, (ADC_PACKAGE_MAX_NUMBER * SIZE_OF_PACK));
			}

			for(j = 0; j < NUMBER_OF_CONVERSIONS; j++)
 800bd60:	68fb      	ldr	r3, [r7, #12]
 800bd62:	f103 0301 	add.w	r3, r3, #1
 800bd66:	60fb      	str	r3, [r7, #12]
 800bd68:	68fb      	ldr	r3, [r7, #12]
 800bd6a:	2b09      	cmp	r3, #9
 800bd6c:	dde4      	ble.n	800bd38 <TIM3_IRQHandler+0xa0>
				ADCConvertedValues[i][j + 2] = aADCDualConvertedValue[j];

			ADCConvertedValues[i][0] = (((RTC_DateStruct.RTC_Year) << 8) | (RTC_DateStruct.RTC_Month));
 800bd6e:	4b24      	ldr	r3, [pc, #144]	; (800be00 <TIM3_IRQHandler+0x168>)
 800bd70:	681a      	ldr	r2, [r3, #0]
 800bd72:	79fb      	ldrb	r3, [r7, #7]
 800bd74:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800bd78:	b299      	uxth	r1, r3
 800bd7a:	797b      	ldrb	r3, [r7, #5]
 800bd7c:	430b      	orrs	r3, r1
 800bd7e:	b29b      	uxth	r3, r3
 800bd80:	b299      	uxth	r1, r3
 800bd82:	4820      	ldr	r0, [pc, #128]	; (800be04 <TIM3_IRQHandler+0x16c>)
 800bd84:	4613      	mov	r3, r2
 800bd86:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800bd8a:	189b      	adds	r3, r3, r2
 800bd8c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800bd90:	18c3      	adds	r3, r0, r3
 800bd92:	460a      	mov	r2, r1
 800bd94:	801a      	strh	r2, [r3, #0]
			ADCConvertedValues[i][1] = (((RTC_DateStruct.RTC_Date & 0x1F) << 11) | ((RTC_TimeStruct.RTC_Hours & 0x1F) << 6) | (RTC_TimeStruct.RTC_Minutes & 0x3F));
 800bd96:	4b1a      	ldr	r3, [pc, #104]	; (800be00 <TIM3_IRQHandler+0x168>)
 800bd98:	681a      	ldr	r2, [r3, #0]
 800bd9a:	79bb      	ldrb	r3, [r7, #6]
 800bd9c:	ea4f 23c3 	mov.w	r3, r3, lsl #11
 800bda0:	b299      	uxth	r1, r3
 800bda2:	7a3b      	ldrb	r3, [r7, #8]
 800bda4:	f003 031f 	and.w	r3, r3, #31
 800bda8:	ea4f 1383 	mov.w	r3, r3, lsl #6
 800bdac:	b29b      	uxth	r3, r3
 800bdae:	430b      	orrs	r3, r1
 800bdb0:	b299      	uxth	r1, r3
 800bdb2:	7a7b      	ldrb	r3, [r7, #9]
 800bdb4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800bdb8:	b29b      	uxth	r3, r3
 800bdba:	430b      	orrs	r3, r1
 800bdbc:	b29b      	uxth	r3, r3
 800bdbe:	b299      	uxth	r1, r3
 800bdc0:	4810      	ldr	r0, [pc, #64]	; (800be04 <TIM3_IRQHandler+0x16c>)
 800bdc2:	4613      	mov	r3, r2
 800bdc4:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800bdc8:	189b      	adds	r3, r3, r2
 800bdca:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800bdce:	18c3      	adds	r3, r0, r3
 800bdd0:	f103 0302 	add.w	r3, r3, #2
 800bdd4:	460a      	mov	r2, r1
 800bdd6:	801a      	strh	r2, [r3, #0]

			interruptStatus = 0;
 800bdd8:	4b07      	ldr	r3, [pc, #28]	; (800bdf8 <TIM3_IRQHandler+0x160>)
 800bdda:	f04f 0200 	mov.w	r2, #0
 800bdde:	701a      	strb	r2, [r3, #0]
		}

		TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
 800bde0:	4804      	ldr	r0, [pc, #16]	; (800bdf4 <TIM3_IRQHandler+0x15c>)
 800bde2:	f04f 0101 	mov.w	r1, #1
 800bde6:	f7ff fbdb 	bl	800b5a0 <TIM_ClearITPendingBit>
   }
}
 800bdea:	f107 0714 	add.w	r7, r7, #20
 800bdee:	46bd      	mov	sp, r7
 800bdf0:	bd90      	pop	{r4, r7, pc}
 800bdf2:	bf00      	nop
 800bdf4:	40000400 	.word	0x40000400
 800bdf8:	20000054 	.word	0x20000054
 800bdfc:	40012000 	.word	0x40012000
 800be00:	20000058 	.word	0x20000058
 800be04:	20001444 	.word	0x20001444
 800be08:	2000148c 	.word	0x2000148c

0800be0c <ADC_Driver_Init>:

__IO uint16_t aADCDualConvertedValue[NUMBER_OF_CONVERSIONS];
#define ADC_CCR_ADDRESS    ((uint32_t)0x40012308)

void ADC_Driver_Init()
{
 800be0c:	b580      	push	{r7, lr}
 800be0e:	b08a      	sub	sp, #40	; 0x28
 800be10:	af00      	add	r7, sp, #0
	ADC_CommonInitTypeDef ADC_CommonInitStructure;
	ADC_InitTypeDef ADC_InitStructure;

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
 800be12:	f44f 7080 	mov.w	r0, #256	; 0x100
 800be16:	f04f 0101 	mov.w	r1, #1
 800be1a:	f7fc fa49 	bl	80082b0 <RCC_APB2PeriphClockCmd>
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC2, ENABLE);
 800be1e:	f44f 7000 	mov.w	r0, #512	; 0x200
 800be22:	f04f 0101 	mov.w	r1, #1
 800be26:	f7fc fa43 	bl	80082b0 <RCC_APB2PeriphClockCmd>

	/* DMA2 Stream0 channel0 configuration **************************************/
	DMA_Config();
 800be2a:	f000 f8bb 	bl	800bfa4 <DMA_Config>

	ADC_GPIO_Config();
 800be2e:	f000 f903 	bl	800c038 <ADC_GPIO_Config>

	ADC_CommonInitStructure.ADC_Mode = ADC_DualMode_RegSimult;
 800be32:	f04f 0306 	mov.w	r3, #6
 800be36:	61bb      	str	r3, [r7, #24]
	ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div2;
 800be38:	f04f 0300 	mov.w	r3, #0
 800be3c:	61fb      	str	r3, [r7, #28]
	ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_1;
 800be3e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800be42:	623b      	str	r3, [r7, #32]
	ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_20Cycles;
 800be44:	f44f 6370 	mov.w	r3, #3840	; 0xf00
 800be48:	627b      	str	r3, [r7, #36]	; 0x24
	ADC_CommonInit(&ADC_CommonInitStructure);
 800be4a:	f107 0318 	add.w	r3, r7, #24
 800be4e:	4618      	mov	r0, r3
 800be50:	f7f9 fd14 	bl	800587c <ADC_CommonInit>

	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
 800be54:	f04f 0300 	mov.w	r3, #0
 800be58:	603b      	str	r3, [r7, #0]
	ADC_InitStructure.ADC_ScanConvMode = ENABLE;
 800be5a:	f04f 0301 	mov.w	r3, #1
 800be5e:	713b      	strb	r3, [r7, #4]
	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
 800be60:	f04f 0300 	mov.w	r3, #0
 800be64:	717b      	strb	r3, [r7, #5]
	ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
 800be66:	f04f 0300 	mov.w	r3, #0
 800be6a:	60bb      	str	r3, [r7, #8]
	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
 800be6c:	f04f 0300 	mov.w	r3, #0
 800be70:	60fb      	str	r3, [r7, #12]
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
 800be72:	f04f 0300 	mov.w	r3, #0
 800be76:	613b      	str	r3, [r7, #16]
	ADC_InitStructure.ADC_NbrOfConversion = 5;
 800be78:	f04f 0305 	mov.w	r3, #5
 800be7c:	753b      	strb	r3, [r7, #20]
	ADC_Init(ADC1, &ADC_InitStructure);
 800be7e:	463b      	mov	r3, r7
 800be80:	4846      	ldr	r0, [pc, #280]	; (800bf9c <ADC_Driver_Init+0x190>)
 800be82:	4619      	mov	r1, r3
 800be84:	f7f9 fc7a 	bl	800577c <ADC_Init>

	ADC_RegularChannelConfig( ADC1, 	ADC_Channel_9, 		1,		ADC_SampleTime_480Cycles );
 800be88:	4844      	ldr	r0, [pc, #272]	; (800bf9c <ADC_Driver_Init+0x190>)
 800be8a:	f04f 0109 	mov.w	r1, #9
 800be8e:	f04f 0201 	mov.w	r2, #1
 800be92:	f04f 0307 	mov.w	r3, #7
 800be96:	f7f9 fdd5 	bl	8005a44 <ADC_RegularChannelConfig>
	ADC_RegularChannelConfig( ADC1, 	ADC_Channel_15, 	2,		ADC_SampleTime_480Cycles );
 800be9a:	4840      	ldr	r0, [pc, #256]	; (800bf9c <ADC_Driver_Init+0x190>)
 800be9c:	f04f 010f 	mov.w	r1, #15
 800bea0:	f04f 0202 	mov.w	r2, #2
 800bea4:	f04f 0307 	mov.w	r3, #7
 800bea8:	f7f9 fdcc 	bl	8005a44 <ADC_RegularChannelConfig>
	ADC_RegularChannelConfig( ADC1, 	ADC_Channel_5,	 	3,		ADC_SampleTime_480Cycles );
 800beac:	483b      	ldr	r0, [pc, #236]	; (800bf9c <ADC_Driver_Init+0x190>)
 800beae:	f04f 0105 	mov.w	r1, #5
 800beb2:	f04f 0203 	mov.w	r2, #3
 800beb6:	f04f 0307 	mov.w	r3, #7
 800beba:	f7f9 fdc3 	bl	8005a44 <ADC_RegularChannelConfig>
	ADC_RegularChannelConfig( ADC1, 	ADC_Channel_3,	 	4,		ADC_SampleTime_480Cycles );
 800bebe:	4837      	ldr	r0, [pc, #220]	; (800bf9c <ADC_Driver_Init+0x190>)
 800bec0:	f04f 0103 	mov.w	r1, #3
 800bec4:	f04f 0204 	mov.w	r2, #4
 800bec8:	f04f 0307 	mov.w	r3, #7
 800becc:	f7f9 fdba 	bl	8005a44 <ADC_RegularChannelConfig>
	ADC_RegularChannelConfig( ADC1, 	ADC_Channel_1,	 	5,		ADC_SampleTime_480Cycles );
 800bed0:	4832      	ldr	r0, [pc, #200]	; (800bf9c <ADC_Driver_Init+0x190>)
 800bed2:	f04f 0101 	mov.w	r1, #1
 800bed6:	f04f 0205 	mov.w	r2, #5
 800beda:	f04f 0307 	mov.w	r3, #7
 800bede:	f7f9 fdb1 	bl	8005a44 <ADC_RegularChannelConfig>

	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
 800bee2:	f04f 0300 	mov.w	r3, #0
 800bee6:	603b      	str	r3, [r7, #0]
	ADC_InitStructure.ADC_ScanConvMode = ENABLE;
 800bee8:	f04f 0301 	mov.w	r3, #1
 800beec:	713b      	strb	r3, [r7, #4]
	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
 800beee:	f04f 0300 	mov.w	r3, #0
 800bef2:	717b      	strb	r3, [r7, #5]
	ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
 800bef4:	f04f 0300 	mov.w	r3, #0
 800bef8:	60bb      	str	r3, [r7, #8]
	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
 800befa:	f04f 0300 	mov.w	r3, #0
 800befe:	60fb      	str	r3, [r7, #12]
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
 800bf00:	f04f 0300 	mov.w	r3, #0
 800bf04:	613b      	str	r3, [r7, #16]
	ADC_InitStructure.ADC_NbrOfConversion = 5;
 800bf06:	f04f 0305 	mov.w	r3, #5
 800bf0a:	753b      	strb	r3, [r7, #20]
	ADC_Init(ADC2, &ADC_InitStructure);
 800bf0c:	463b      	mov	r3, r7
 800bf0e:	4824      	ldr	r0, [pc, #144]	; (800bfa0 <ADC_Driver_Init+0x194>)
 800bf10:	4619      	mov	r1, r3
 800bf12:	f7f9 fc33 	bl	800577c <ADC_Init>

	ADC_RegularChannelConfig( ADC2, 	ADC_Channel_11,		1,		ADC_SampleTime_480Cycles );
 800bf16:	4822      	ldr	r0, [pc, #136]	; (800bfa0 <ADC_Driver_Init+0x194>)
 800bf18:	f04f 010b 	mov.w	r1, #11
 800bf1c:	f04f 0201 	mov.w	r2, #1
 800bf20:	f04f 0307 	mov.w	r3, #7
 800bf24:	f7f9 fd8e 	bl	8005a44 <ADC_RegularChannelConfig>
	ADC_RegularChannelConfig( ADC2, 	ADC_Channel_12,	 	2,		ADC_SampleTime_480Cycles );
 800bf28:	481d      	ldr	r0, [pc, #116]	; (800bfa0 <ADC_Driver_Init+0x194>)
 800bf2a:	f04f 010c 	mov.w	r1, #12
 800bf2e:	f04f 0202 	mov.w	r2, #2
 800bf32:	f04f 0307 	mov.w	r3, #7
 800bf36:	f7f9 fd85 	bl	8005a44 <ADC_RegularChannelConfig>
	ADC_RegularChannelConfig( ADC2, 	ADC_Channel_2,		3,		ADC_SampleTime_480Cycles );
 800bf3a:	4819      	ldr	r0, [pc, #100]	; (800bfa0 <ADC_Driver_Init+0x194>)
 800bf3c:	f04f 0102 	mov.w	r1, #2
 800bf40:	f04f 0203 	mov.w	r2, #3
 800bf44:	f04f 0307 	mov.w	r3, #7
 800bf48:	f7f9 fd7c 	bl	8005a44 <ADC_RegularChannelConfig>
	ADC_RegularChannelConfig( ADC2, 	ADC_Channel_14, 	4,		ADC_SampleTime_480Cycles );
 800bf4c:	4814      	ldr	r0, [pc, #80]	; (800bfa0 <ADC_Driver_Init+0x194>)
 800bf4e:	f04f 010e 	mov.w	r1, #14
 800bf52:	f04f 0204 	mov.w	r2, #4
 800bf56:	f04f 0307 	mov.w	r3, #7
 800bf5a:	f7f9 fd73 	bl	8005a44 <ADC_RegularChannelConfig>
	ADC_RegularChannelConfig( ADC2, 	ADC_Channel_8,	 	5,		ADC_SampleTime_480Cycles );
 800bf5e:	4810      	ldr	r0, [pc, #64]	; (800bfa0 <ADC_Driver_Init+0x194>)
 800bf60:	f04f 0108 	mov.w	r1, #8
 800bf64:	f04f 0205 	mov.w	r2, #5
 800bf68:	f04f 0307 	mov.w	r3, #7
 800bf6c:	f7f9 fd6a 	bl	8005a44 <ADC_RegularChannelConfig>

	ADC_MultiModeDMARequestAfterLastTransferCmd(ENABLE);
 800bf70:	f04f 0001 	mov.w	r0, #1
 800bf74:	f7f9 ff3a 	bl	8005dec <ADC_MultiModeDMARequestAfterLastTransferCmd>

	/* Enable ADC1 */
	ADC_Cmd(ADC1, ENABLE);
 800bf78:	4808      	ldr	r0, [pc, #32]	; (800bf9c <ADC_Driver_Init+0x190>)
 800bf7a:	f04f 0101 	mov.w	r1, #1
 800bf7e:	f7f9 fcbf 	bl	8005900 <ADC_Cmd>

	/* Enable ADC2 */
	ADC_Cmd(ADC2, ENABLE);
 800bf82:	4807      	ldr	r0, [pc, #28]	; (800bfa0 <ADC_Driver_Init+0x194>)
 800bf84:	f04f 0101 	mov.w	r1, #1
 800bf88:	f7f9 fcba 	bl	8005900 <ADC_Cmd>

	/* Start ADC1 Software Conversion */
	ADC_SoftwareStartConv(ADC1);
 800bf8c:	4803      	ldr	r0, [pc, #12]	; (800bf9c <ADC_Driver_Init+0x190>)
 800bf8e:	f7f9 fe37 	bl	8005c00 <ADC_SoftwareStartConv>
}
 800bf92:	f107 0728 	add.w	r7, r7, #40	; 0x28
 800bf96:	46bd      	mov	sp, r7
 800bf98:	bd80      	pop	{r7, pc}
 800bf9a:	bf00      	nop
 800bf9c:	40012000 	.word	0x40012000
 800bfa0:	40012100 	.word	0x40012100

0800bfa4 <DMA_Config>:

void DMA_Config(void)
{
 800bfa4:	b580      	push	{r7, lr}
 800bfa6:	b090      	sub	sp, #64	; 0x40
 800bfa8:	af00      	add	r7, sp, #0
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2, ENABLE);
 800bfaa:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 800bfae:	f04f 0101 	mov.w	r1, #1
 800bfb2:	f7fc f8fd 	bl	80081b0 <RCC_AHB1PeriphClockCmd>

	DMA_InitTypeDef DMA_InitStructure;

	DMA_InitStructure.DMA_Channel = DMA_Channel_0;
 800bfb6:	f04f 0300 	mov.w	r3, #0
 800bfba:	607b      	str	r3, [r7, #4]
	DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)&aADCDualConvertedValue;
 800bfbc:	4b1b      	ldr	r3, [pc, #108]	; (800c02c <DMA_Config+0x88>)
 800bfbe:	60fb      	str	r3, [r7, #12]
	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)ADC_CCR_ADDRESS;
 800bfc0:	4b1b      	ldr	r3, [pc, #108]	; (800c030 <DMA_Config+0x8c>)
 800bfc2:	60bb      	str	r3, [r7, #8]
	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
 800bfc4:	f04f 0300 	mov.w	r3, #0
 800bfc8:	613b      	str	r3, [r7, #16]
	DMA_InitStructure.DMA_BufferSize = NUMBER_OF_CONVERSIONS;
 800bfca:	f04f 030a 	mov.w	r3, #10
 800bfce:	617b      	str	r3, [r7, #20]
	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 800bfd0:	f04f 0300 	mov.w	r3, #0
 800bfd4:	61bb      	str	r3, [r7, #24]
	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 800bfd6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bfda:	61fb      	str	r3, [r7, #28]
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
 800bfdc:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800bfe0:	623b      	str	r3, [r7, #32]
	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
 800bfe2:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800bfe6:	627b      	str	r3, [r7, #36]	; 0x24
	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
 800bfe8:	f44f 7380 	mov.w	r3, #256	; 0x100
 800bfec:	62bb      	str	r3, [r7, #40]	; 0x28
	DMA_InitStructure.DMA_Priority = DMA_Priority_High;
 800bfee:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 800bff2:	62fb      	str	r3, [r7, #44]	; 0x2c
	DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Enable;
 800bff4:	f04f 0304 	mov.w	r3, #4
 800bff8:	633b      	str	r3, [r7, #48]	; 0x30
	DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
 800bffa:	f04f 0301 	mov.w	r3, #1
 800bffe:	637b      	str	r3, [r7, #52]	; 0x34
	DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
 800c000:	f04f 0300 	mov.w	r3, #0
 800c004:	63bb      	str	r3, [r7, #56]	; 0x38
	DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
 800c006:	f04f 0300 	mov.w	r3, #0
 800c00a:	63fb      	str	r3, [r7, #60]	; 0x3c
	DMA_Init(DMA2_Stream0, &DMA_InitStructure);
 800c00c:	f107 0304 	add.w	r3, r7, #4
 800c010:	4808      	ldr	r0, [pc, #32]	; (800c034 <DMA_Config+0x90>)
 800c012:	4619      	mov	r1, r3
 800c014:	f7fa fa20 	bl	8006458 <DMA_Init>

	/* DMA2_Stream0 enable */
	DMA_Cmd(DMA2_Stream0, ENABLE);
 800c018:	4806      	ldr	r0, [pc, #24]	; (800c034 <DMA_Config+0x90>)
 800c01a:	f04f 0101 	mov.w	r1, #1
 800c01e:	f7fa fab9 	bl	8006594 <DMA_Cmd>
}
 800c022:	f107 0740 	add.w	r7, r7, #64	; 0x40
 800c026:	46bd      	mov	sp, r7
 800c028:	bd80      	pop	{r7, pc}
 800c02a:	bf00      	nop
 800c02c:	2000148c 	.word	0x2000148c
 800c030:	40012308 	.word	0x40012308
 800c034:	40026410 	.word	0x40026410

0800c038 <ADC_GPIO_Config>:


void ADC_GPIO_Config(void)
{
 800c038:	b580      	push	{r7, lr}
 800c03a:	b082      	sub	sp, #8
 800c03c:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 800c03e:	f04f 0001 	mov.w	r0, #1
 800c042:	f04f 0101 	mov.w	r1, #1
 800c046:	f7fc f8b3 	bl	80081b0 <RCC_AHB1PeriphClockCmd>
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
 800c04a:	f04f 0002 	mov.w	r0, #2
 800c04e:	f04f 0101 	mov.w	r1, #1
 800c052:	f7fc f8ad 	bl	80081b0 <RCC_AHB1PeriphClockCmd>
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
 800c056:	f04f 0004 	mov.w	r0, #4
 800c05a:	f04f 0101 	mov.w	r1, #1
 800c05e:	f7fc f8a7 	bl	80081b0 <RCC_AHB1PeriphClockCmd>


	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_5;
 800c062:	f04f 032e 	mov.w	r3, #46	; 0x2e
 800c066:	603b      	str	r3, [r7, #0]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
 800c068:	f04f 0303 	mov.w	r3, #3
 800c06c:	713b      	strb	r3, [r7, #4]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
 800c06e:	f04f 0300 	mov.w	r3, #0
 800c072:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 800c074:	463b      	mov	r3, r7
 800c076:	480c      	ldr	r0, [pc, #48]	; (800c0a8 <ADC_GPIO_Config+0x70>)
 800c078:	4619      	mov	r1, r3
 800c07a:	f7fb fa87 	bl	800758c <GPIO_Init>

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;
 800c07e:	f04f 0303 	mov.w	r3, #3
 800c082:	603b      	str	r3, [r7, #0]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 800c084:	463b      	mov	r3, r7
 800c086:	4809      	ldr	r0, [pc, #36]	; (800c0ac <ADC_GPIO_Config+0x74>)
 800c088:	4619      	mov	r1, r3
 800c08a:	f7fb fa7f 	bl	800758c <GPIO_Init>

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_4 | GPIO_Pin_5;
 800c08e:	f04f 0336 	mov.w	r3, #54	; 0x36
 800c092:	603b      	str	r3, [r7, #0]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 800c094:	463b      	mov	r3, r7
 800c096:	4806      	ldr	r0, [pc, #24]	; (800c0b0 <ADC_GPIO_Config+0x78>)
 800c098:	4619      	mov	r1, r3
 800c09a:	f7fb fa77 	bl	800758c <GPIO_Init>
}
 800c09e:	f107 0708 	add.w	r7, r7, #8
 800c0a2:	46bd      	mov	sp, r7
 800c0a4:	bd80      	pop	{r7, pc}
 800c0a6:	bf00      	nop
 800c0a8:	40020000 	.word	0x40020000
 800c0ac:	40020400 	.word	0x40020400
 800c0b0:	40020800 	.word	0x40020800

0800c0b4 <FlashReset>:


uint32_t GetSector(uint32_t Address);

void FlashReset()
{
 800c0b4:	b580      	push	{r7, lr}
 800c0b6:	b086      	sub	sp, #24
 800c0b8:	af00      	add	r7, sp, #0
	uint32_t uwStartSector = 0;
 800c0ba:	f04f 0300 	mov.w	r3, #0
 800c0be:	613b      	str	r3, [r7, #16]
	uint32_t uwEndSector = 0;
 800c0c0:	f04f 0300 	mov.w	r3, #0
 800c0c4:	60fb      	str	r3, [r7, #12]
	uint32_t uwAddress = 0;
 800c0c6:	f04f 0300 	mov.w	r3, #0
 800c0ca:	60bb      	str	r3, [r7, #8]
	uint32_t uwSectorCounter = 0;
 800c0cc:	f04f 0300 	mov.w	r3, #0
 800c0d0:	617b      	str	r3, [r7, #20]
	__IO uint32_t uwData32 = 0;
 800c0d2:	f04f 0300 	mov.w	r3, #0
 800c0d6:	607b      	str	r3, [r7, #4]
	__IO uint32_t uwMemoryProgramStatus = 0;
 800c0d8:	f04f 0300 	mov.w	r3, #0
 800c0dc:	603b      	str	r3, [r7, #0]

	FLASH_Unlock();
 800c0de:	f7fa fe33 	bl	8006d48 <FLASH_Unlock>

	/* Erase the user Flash area ************************************************/
	/* area defined by FLASH_USER_START_ADDR and FLASH_USER_END_ADDR */

	/* Clear pending flags (if any) */
	FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |
 800c0e2:	f04f 00f3 	mov.w	r0, #243	; 0xf3
 800c0e6:	f7fb f93d 	bl	8007364 <FLASH_ClearFlag>
				   FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR|FLASH_FLAG_PGSERR);

	/* Get the number of the start and end sectors */
	uwStartSector = GetSector(FLASH_USER_START_ADDR);
 800c0ea:	4815      	ldr	r0, [pc, #84]	; (800c140 <FlashReset+0x8c>)
 800c0ec:	f000 f8b8 	bl	800c260 <GetSector>
 800c0f0:	6138      	str	r0, [r7, #16]
	uwEndSector = GetSector(FLASH_USER_END_ADDR);
 800c0f2:	4814      	ldr	r0, [pc, #80]	; (800c144 <FlashReset+0x90>)
 800c0f4:	f000 f8b4 	bl	800c260 <GetSector>
 800c0f8:	60f8      	str	r0, [r7, #12]

	/* Strat the erase operation */
	uwSectorCounter = uwStartSector;
 800c0fa:	693b      	ldr	r3, [r7, #16]
 800c0fc:	617b      	str	r3, [r7, #20]

	while (uwSectorCounter <= uwEndSector)
 800c0fe:	e014      	b.n	800c12a <FlashReset+0x76>
	{
		/* Device voltage range supposed to be [2.7V to 3.6V], the operation will
		be done by word */
		if (FLASH_EraseSector(uwSectorCounter, VoltageRange_3) != FLASH_COMPLETE)
 800c100:	6978      	ldr	r0, [r7, #20]
 800c102:	f04f 0102 	mov.w	r1, #2
 800c106:	f7fa fe43 	bl	8006d90 <FLASH_EraseSector>
 800c10a:	4603      	mov	r3, r0
 800c10c:	2b08      	cmp	r3, #8
 800c10e:	d000      	beq.n	800c112 <FlashReset+0x5e>
		{
		/* Error occurred while sector erase.
		  User can add here some code to deal with this error  */
			while (1)
			{
			}
 800c110:	e7fe      	b.n	800c110 <FlashReset+0x5c>
		}
		/* jump to the next sector */
		if (uwSectorCounter == FLASH_Sector_11)
 800c112:	697b      	ldr	r3, [r7, #20]
 800c114:	2b58      	cmp	r3, #88	; 0x58
 800c116:	d104      	bne.n	800c122 <FlashReset+0x6e>
		{
			uwSectorCounter += 40;
 800c118:	697b      	ldr	r3, [r7, #20]
 800c11a:	f103 0328 	add.w	r3, r3, #40	; 0x28
 800c11e:	617b      	str	r3, [r7, #20]
 800c120:	e003      	b.n	800c12a <FlashReset+0x76>
		}
		else
		{
			uwSectorCounter += 8;
 800c122:	697b      	ldr	r3, [r7, #20]
 800c124:	f103 0308 	add.w	r3, r3, #8
 800c128:	617b      	str	r3, [r7, #20]
	uwEndSector = GetSector(FLASH_USER_END_ADDR);

	/* Strat the erase operation */
	uwSectorCounter = uwStartSector;

	while (uwSectorCounter <= uwEndSector)
 800c12a:	697a      	ldr	r2, [r7, #20]
 800c12c:	68fb      	ldr	r3, [r7, #12]
 800c12e:	429a      	cmp	r2, r3
 800c130:	d9e6      	bls.n	800c100 <FlashReset+0x4c>
		{
			uwSectorCounter += 8;
		}
	}

	FLASH_Lock();
 800c132:	f7fa fe1f 	bl	8006d74 <FLASH_Lock>
}
 800c136:	f107 0718 	add.w	r7, r7, #24
 800c13a:	46bd      	mov	sp, r7
 800c13c:	bd80      	pop	{r7, pc}
 800c13e:	bf00      	nop
 800c140:	08010000 	.word	0x08010000
 800c144:	080e0000 	.word	0x080e0000

0800c148 <FlashSample>:

void FlashSample()
{
 800c148:	b580      	push	{r7, lr}
 800c14a:	b086      	sub	sp, #24
 800c14c:	af00      	add	r7, sp, #0
	uint32_t uwStartSector = 0;
 800c14e:	f04f 0300 	mov.w	r3, #0
 800c152:	60fb      	str	r3, [r7, #12]
	uint32_t uwEndSector = 0;
 800c154:	f04f 0300 	mov.w	r3, #0
 800c158:	60bb      	str	r3, [r7, #8]
	uint32_t uwAddress = 0;
 800c15a:	f04f 0300 	mov.w	r3, #0
 800c15e:	617b      	str	r3, [r7, #20]
	uint32_t uwSectorCounter = 0;
 800c160:	f04f 0300 	mov.w	r3, #0
 800c164:	613b      	str	r3, [r7, #16]
	__IO uint32_t uwData32 = 0;
 800c166:	f04f 0300 	mov.w	r3, #0
 800c16a:	607b      	str	r3, [r7, #4]
	__IO uint32_t uwMemoryProgramStatus = 0;
 800c16c:	f04f 0300 	mov.w	r3, #0
 800c170:	603b      	str	r3, [r7, #0]

	STM_EVAL_LEDInit(LED4);
 800c172:	f04f 0000 	mov.w	r0, #0
 800c176:	f7f8 f93f 	bl	80043f8 <STM_EVAL_LEDInit>
	STM_EVAL_LEDInit(LED5);
 800c17a:	f04f 0002 	mov.w	r0, #2
 800c17e:	f7f8 f93b 	bl	80043f8 <STM_EVAL_LEDInit>

	FLASH_Unlock();
 800c182:	f7fa fde1 	bl	8006d48 <FLASH_Unlock>

	/* Erase the user Flash area ************************************************/
	/* area defined by FLASH_USER_START_ADDR and FLASH_USER_END_ADDR */

	/* Clear pending flags (if any) */
	FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |
 800c186:	f04f 00f3 	mov.w	r0, #243	; 0xf3
 800c18a:	f7fb f8eb 	bl	8007364 <FLASH_ClearFlag>
				   FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR|FLASH_FLAG_PGSERR);

	/* Get the number of the start and end sectors */
	uwStartSector = GetSector(FLASH_USER_START_ADDR);
 800c18e:	4830      	ldr	r0, [pc, #192]	; (800c250 <FlashSample+0x108>)
 800c190:	f000 f866 	bl	800c260 <GetSector>
 800c194:	60f8      	str	r0, [r7, #12]
	uwEndSector = GetSector(FLASH_USER_END_ADDR);
 800c196:	482f      	ldr	r0, [pc, #188]	; (800c254 <FlashSample+0x10c>)
 800c198:	f000 f862 	bl	800c260 <GetSector>
 800c19c:	60b8      	str	r0, [r7, #8]

	/* Strat the erase operation */
	uwSectorCounter = uwStartSector;
 800c19e:	68fb      	ldr	r3, [r7, #12]
 800c1a0:	613b      	str	r3, [r7, #16]

	while (uwSectorCounter <= uwEndSector)
 800c1a2:	e014      	b.n	800c1ce <FlashSample+0x86>
	{
		/* Device voltage range supposed to be [2.7V to 3.6V], the operation will
		be done by word */
		if (FLASH_EraseSector(uwSectorCounter, VoltageRange_3) != FLASH_COMPLETE)
 800c1a4:	6938      	ldr	r0, [r7, #16]
 800c1a6:	f04f 0102 	mov.w	r1, #2
 800c1aa:	f7fa fdf1 	bl	8006d90 <FLASH_EraseSector>
 800c1ae:	4603      	mov	r3, r0
 800c1b0:	2b08      	cmp	r3, #8
 800c1b2:	d000      	beq.n	800c1b6 <FlashSample+0x6e>
		{
		/* Error occurred while sector erase.
		  User can add here some code to deal with this error  */
			while (1)
			{
			}
 800c1b4:	e7fe      	b.n	800c1b4 <FlashSample+0x6c>
		}
		/* jump to the next sector */
		if (uwSectorCounter == FLASH_Sector_11)
 800c1b6:	693b      	ldr	r3, [r7, #16]
 800c1b8:	2b58      	cmp	r3, #88	; 0x58
 800c1ba:	d104      	bne.n	800c1c6 <FlashSample+0x7e>
		{
			uwSectorCounter += 40;
 800c1bc:	693b      	ldr	r3, [r7, #16]
 800c1be:	f103 0328 	add.w	r3, r3, #40	; 0x28
 800c1c2:	613b      	str	r3, [r7, #16]
 800c1c4:	e003      	b.n	800c1ce <FlashSample+0x86>
		}
		else
		{
			uwSectorCounter += 8;
 800c1c6:	693b      	ldr	r3, [r7, #16]
 800c1c8:	f103 0308 	add.w	r3, r3, #8
 800c1cc:	613b      	str	r3, [r7, #16]
	uwEndSector = GetSector(FLASH_USER_END_ADDR);

	/* Strat the erase operation */
	uwSectorCounter = uwStartSector;

	while (uwSectorCounter <= uwEndSector)
 800c1ce:	693a      	ldr	r2, [r7, #16]
 800c1d0:	68bb      	ldr	r3, [r7, #8]
 800c1d2:	429a      	cmp	r2, r3
 800c1d4:	d9e6      	bls.n	800c1a4 <FlashSample+0x5c>
	}

	/* Program the user Flash area word by word ********************************/
	/* area defined by FLASH_USER_START_ADDR and FLASH_USER_END_ADDR */

	uwAddress = FLASH_USER_START_ADDR;
 800c1d6:	4b1e      	ldr	r3, [pc, #120]	; (800c250 <FlashSample+0x108>)
 800c1d8:	617b      	str	r3, [r7, #20]

	while (uwAddress < FLASH_USER_END_ADDR)
 800c1da:	e00c      	b.n	800c1f6 <FlashSample+0xae>
	{
		if (FLASH_ProgramWord(uwAddress, DATA_32) == FLASH_COMPLETE)
 800c1dc:	6978      	ldr	r0, [r7, #20]
 800c1de:	491e      	ldr	r1, [pc, #120]	; (800c258 <FlashSample+0x110>)
 800c1e0:	f7fa fec8 	bl	8006f74 <FLASH_ProgramWord>
 800c1e4:	4603      	mov	r3, r0
 800c1e6:	2b08      	cmp	r3, #8
 800c1e8:	d104      	bne.n	800c1f4 <FlashSample+0xac>
		{
			uwAddress = uwAddress + 4;
 800c1ea:	697b      	ldr	r3, [r7, #20]
 800c1ec:	f103 0304 	add.w	r3, r3, #4
 800c1f0:	617b      	str	r3, [r7, #20]
 800c1f2:	e000      	b.n	800c1f6 <FlashSample+0xae>
		{
		/* Error occurred while writing data in Flash memory.
		  User can add here some code to deal with this error */
			while (1)
			{
			}
 800c1f4:	e7fe      	b.n	800c1f4 <FlashSample+0xac>
	/* Program the user Flash area word by word ********************************/
	/* area defined by FLASH_USER_START_ADDR and FLASH_USER_END_ADDR */

	uwAddress = FLASH_USER_START_ADDR;

	while (uwAddress < FLASH_USER_END_ADDR)
 800c1f6:	697a      	ldr	r2, [r7, #20]
 800c1f8:	4b18      	ldr	r3, [pc, #96]	; (800c25c <FlashSample+0x114>)
 800c1fa:	429a      	cmp	r2, r3
 800c1fc:	d9ee      	bls.n	800c1dc <FlashSample+0x94>
		}
	}

	/* Lock the Flash to disable the flash control register access (recommended
	  to protect the FLASH memory against possible unwanted operation) */
	FLASH_Lock();
 800c1fe:	f7fa fdb9 	bl	8006d74 <FLASH_Lock>

	/* Check if the programmed data is OK ***************************************/
	/*  MemoryProgramStatus = 0: data programmed correctly
	   MemoryProgramStatus != 0: number of words not programmed correctly */
	uwAddress = FLASH_USER_START_ADDR;
 800c202:	4b13      	ldr	r3, [pc, #76]	; (800c250 <FlashSample+0x108>)
 800c204:	617b      	str	r3, [r7, #20]
	uwMemoryProgramStatus = 0;
 800c206:	f04f 0300 	mov.w	r3, #0
 800c20a:	603b      	str	r3, [r7, #0]

	while (uwAddress < FLASH_USER_END_ADDR)
 800c20c:	e00e      	b.n	800c22c <FlashSample+0xe4>
	{
		uwData32 = *(__IO uint32_t*)uwAddress;
 800c20e:	697b      	ldr	r3, [r7, #20]
 800c210:	681b      	ldr	r3, [r3, #0]
 800c212:	607b      	str	r3, [r7, #4]

		if (uwData32 != DATA_32)
 800c214:	687a      	ldr	r2, [r7, #4]
 800c216:	4b10      	ldr	r3, [pc, #64]	; (800c258 <FlashSample+0x110>)
 800c218:	429a      	cmp	r2, r3
 800c21a:	d003      	beq.n	800c224 <FlashSample+0xdc>
		{
			uwMemoryProgramStatus++;
 800c21c:	683b      	ldr	r3, [r7, #0]
 800c21e:	f103 0301 	add.w	r3, r3, #1
 800c222:	603b      	str	r3, [r7, #0]
		}

		uwAddress = uwAddress + 4;
 800c224:	697b      	ldr	r3, [r7, #20]
 800c226:	f103 0304 	add.w	r3, r3, #4
 800c22a:	617b      	str	r3, [r7, #20]
	/*  MemoryProgramStatus = 0: data programmed correctly
	   MemoryProgramStatus != 0: number of words not programmed correctly */
	uwAddress = FLASH_USER_START_ADDR;
	uwMemoryProgramStatus = 0;

	while (uwAddress < FLASH_USER_END_ADDR)
 800c22c:	697a      	ldr	r2, [r7, #20]
 800c22e:	4b0b      	ldr	r3, [pc, #44]	; (800c25c <FlashSample+0x114>)
 800c230:	429a      	cmp	r2, r3
 800c232:	d9ec      	bls.n	800c20e <FlashSample+0xc6>

		uwAddress = uwAddress + 4;
	}

	/* Check Data correctness */
	if(uwMemoryProgramStatus)
 800c234:	683b      	ldr	r3, [r7, #0]
 800c236:	2b00      	cmp	r3, #0
 800c238:	d004      	beq.n	800c244 <FlashSample+0xfc>
	{
		/* KO */
		/* Turn on LD2 */
		STM_EVAL_LEDOn(LED4);
 800c23a:	f04f 0000 	mov.w	r0, #0
 800c23e:	f7f8 f90f 	bl	8004460 <STM_EVAL_LEDOn>
 800c242:	e003      	b.n	800c24c <FlashSample+0x104>
	}
	else
	{
		/* OK */
		/* Turn on LD1 */
		STM_EVAL_LEDOn(LED5);
 800c244:	f04f 0002 	mov.w	r0, #2
 800c248:	f7f8 f90a 	bl	8004460 <STM_EVAL_LEDOn>
	}

	while (1)
	{
	}
 800c24c:	e7fe      	b.n	800c24c <FlashSample+0x104>
 800c24e:	bf00      	nop
 800c250:	08010000 	.word	0x08010000
 800c254:	080e0000 	.word	0x080e0000
 800c258:	12345678 	.word	0x12345678
 800c25c:	080dffff 	.word	0x080dffff

0800c260 <GetSector>:
   * @brief  Gets the sector of a given address
   * @param  None
   * @retval The sector of a given address
   */
uint32_t GetSector(uint32_t Address)
{
 800c260:	b480      	push	{r7}
 800c262:	b085      	sub	sp, #20
 800c264:	af00      	add	r7, sp, #0
 800c266:	6078      	str	r0, [r7, #4]
	uint32_t sector = 0;
 800c268:	f04f 0300 	mov.w	r3, #0
 800c26c:	60fb      	str	r3, [r7, #12]

	if((Address < ADDR_FLASH_SECTOR_1) && (Address >= ADDR_FLASH_SECTOR_0))
 800c26e:	687a      	ldr	r2, [r7, #4]
 800c270:	4b46      	ldr	r3, [pc, #280]	; (800c38c <GetSector+0x12c>)
 800c272:	429a      	cmp	r2, r3
 800c274:	d808      	bhi.n	800c288 <GetSector+0x28>
 800c276:	687a      	ldr	r2, [r7, #4]
 800c278:	f06f 4378 	mvn.w	r3, #4160749568	; 0xf8000000
 800c27c:	429a      	cmp	r2, r3
 800c27e:	d903      	bls.n	800c288 <GetSector+0x28>
	{
	 sector = FLASH_Sector_0;
 800c280:	f04f 0300 	mov.w	r3, #0
 800c284:	60fb      	str	r3, [r7, #12]
 800c286:	e07a      	b.n	800c37e <GetSector+0x11e>
	}
	else if((Address < ADDR_FLASH_SECTOR_2) && (Address >= ADDR_FLASH_SECTOR_1))
 800c288:	687a      	ldr	r2, [r7, #4]
 800c28a:	4b41      	ldr	r3, [pc, #260]	; (800c390 <GetSector+0x130>)
 800c28c:	429a      	cmp	r2, r3
 800c28e:	d807      	bhi.n	800c2a0 <GetSector+0x40>
 800c290:	687a      	ldr	r2, [r7, #4]
 800c292:	4b3e      	ldr	r3, [pc, #248]	; (800c38c <GetSector+0x12c>)
 800c294:	429a      	cmp	r2, r3
 800c296:	d903      	bls.n	800c2a0 <GetSector+0x40>
	{
	 sector = FLASH_Sector_1;
 800c298:	f04f 0308 	mov.w	r3, #8
 800c29c:	60fb      	str	r3, [r7, #12]
 800c29e:	e06e      	b.n	800c37e <GetSector+0x11e>
	}
	else if((Address < ADDR_FLASH_SECTOR_3) && (Address >= ADDR_FLASH_SECTOR_2))
 800c2a0:	687a      	ldr	r2, [r7, #4]
 800c2a2:	4b3c      	ldr	r3, [pc, #240]	; (800c394 <GetSector+0x134>)
 800c2a4:	429a      	cmp	r2, r3
 800c2a6:	d807      	bhi.n	800c2b8 <GetSector+0x58>
 800c2a8:	687a      	ldr	r2, [r7, #4]
 800c2aa:	4b39      	ldr	r3, [pc, #228]	; (800c390 <GetSector+0x130>)
 800c2ac:	429a      	cmp	r2, r3
 800c2ae:	d903      	bls.n	800c2b8 <GetSector+0x58>
	{
	 sector = FLASH_Sector_2;
 800c2b0:	f04f 0310 	mov.w	r3, #16
 800c2b4:	60fb      	str	r3, [r7, #12]
 800c2b6:	e062      	b.n	800c37e <GetSector+0x11e>
	}
	else if((Address < ADDR_FLASH_SECTOR_4) && (Address >= ADDR_FLASH_SECTOR_3))
 800c2b8:	687a      	ldr	r2, [r7, #4]
 800c2ba:	4b37      	ldr	r3, [pc, #220]	; (800c398 <GetSector+0x138>)
 800c2bc:	429a      	cmp	r2, r3
 800c2be:	d807      	bhi.n	800c2d0 <GetSector+0x70>
 800c2c0:	687a      	ldr	r2, [r7, #4]
 800c2c2:	4b34      	ldr	r3, [pc, #208]	; (800c394 <GetSector+0x134>)
 800c2c4:	429a      	cmp	r2, r3
 800c2c6:	d903      	bls.n	800c2d0 <GetSector+0x70>
	{
	 sector = FLASH_Sector_3;
 800c2c8:	f04f 0318 	mov.w	r3, #24
 800c2cc:	60fb      	str	r3, [r7, #12]
 800c2ce:	e056      	b.n	800c37e <GetSector+0x11e>
	}
	else if((Address < ADDR_FLASH_SECTOR_5) && (Address >= ADDR_FLASH_SECTOR_4))
 800c2d0:	687a      	ldr	r2, [r7, #4]
 800c2d2:	4b32      	ldr	r3, [pc, #200]	; (800c39c <GetSector+0x13c>)
 800c2d4:	429a      	cmp	r2, r3
 800c2d6:	d807      	bhi.n	800c2e8 <GetSector+0x88>
 800c2d8:	687a      	ldr	r2, [r7, #4]
 800c2da:	4b2f      	ldr	r3, [pc, #188]	; (800c398 <GetSector+0x138>)
 800c2dc:	429a      	cmp	r2, r3
 800c2de:	d903      	bls.n	800c2e8 <GetSector+0x88>
	{
	 sector = FLASH_Sector_4;
 800c2e0:	f04f 0320 	mov.w	r3, #32
 800c2e4:	60fb      	str	r3, [r7, #12]
 800c2e6:	e04a      	b.n	800c37e <GetSector+0x11e>
	}
	else if((Address < ADDR_FLASH_SECTOR_6) && (Address >= ADDR_FLASH_SECTOR_5))
 800c2e8:	687a      	ldr	r2, [r7, #4]
 800c2ea:	4b2d      	ldr	r3, [pc, #180]	; (800c3a0 <GetSector+0x140>)
 800c2ec:	429a      	cmp	r2, r3
 800c2ee:	d807      	bhi.n	800c300 <GetSector+0xa0>
 800c2f0:	687a      	ldr	r2, [r7, #4]
 800c2f2:	4b2a      	ldr	r3, [pc, #168]	; (800c39c <GetSector+0x13c>)
 800c2f4:	429a      	cmp	r2, r3
 800c2f6:	d903      	bls.n	800c300 <GetSector+0xa0>
	{
	 sector = FLASH_Sector_5;
 800c2f8:	f04f 0328 	mov.w	r3, #40	; 0x28
 800c2fc:	60fb      	str	r3, [r7, #12]
 800c2fe:	e03e      	b.n	800c37e <GetSector+0x11e>
	}
	else if((Address < ADDR_FLASH_SECTOR_7) && (Address >= ADDR_FLASH_SECTOR_6))
 800c300:	687a      	ldr	r2, [r7, #4]
 800c302:	4b28      	ldr	r3, [pc, #160]	; (800c3a4 <GetSector+0x144>)
 800c304:	429a      	cmp	r2, r3
 800c306:	d807      	bhi.n	800c318 <GetSector+0xb8>
 800c308:	687a      	ldr	r2, [r7, #4]
 800c30a:	4b25      	ldr	r3, [pc, #148]	; (800c3a0 <GetSector+0x140>)
 800c30c:	429a      	cmp	r2, r3
 800c30e:	d903      	bls.n	800c318 <GetSector+0xb8>
	{
	 sector = FLASH_Sector_6;
 800c310:	f04f 0330 	mov.w	r3, #48	; 0x30
 800c314:	60fb      	str	r3, [r7, #12]
 800c316:	e032      	b.n	800c37e <GetSector+0x11e>
	}
	else if((Address < ADDR_FLASH_SECTOR_8) && (Address >= ADDR_FLASH_SECTOR_7))
 800c318:	687a      	ldr	r2, [r7, #4]
 800c31a:	4b23      	ldr	r3, [pc, #140]	; (800c3a8 <GetSector+0x148>)
 800c31c:	429a      	cmp	r2, r3
 800c31e:	d807      	bhi.n	800c330 <GetSector+0xd0>
 800c320:	687a      	ldr	r2, [r7, #4]
 800c322:	4b20      	ldr	r3, [pc, #128]	; (800c3a4 <GetSector+0x144>)
 800c324:	429a      	cmp	r2, r3
 800c326:	d903      	bls.n	800c330 <GetSector+0xd0>
	{
	 sector = FLASH_Sector_7;
 800c328:	f04f 0338 	mov.w	r3, #56	; 0x38
 800c32c:	60fb      	str	r3, [r7, #12]
 800c32e:	e026      	b.n	800c37e <GetSector+0x11e>
	}
	else if((Address < ADDR_FLASH_SECTOR_9) && (Address >= ADDR_FLASH_SECTOR_8))
 800c330:	687a      	ldr	r2, [r7, #4]
 800c332:	4b1e      	ldr	r3, [pc, #120]	; (800c3ac <GetSector+0x14c>)
 800c334:	429a      	cmp	r2, r3
 800c336:	d807      	bhi.n	800c348 <GetSector+0xe8>
 800c338:	687a      	ldr	r2, [r7, #4]
 800c33a:	4b1b      	ldr	r3, [pc, #108]	; (800c3a8 <GetSector+0x148>)
 800c33c:	429a      	cmp	r2, r3
 800c33e:	d903      	bls.n	800c348 <GetSector+0xe8>
	{
	 sector = FLASH_Sector_8;
 800c340:	f04f 0340 	mov.w	r3, #64	; 0x40
 800c344:	60fb      	str	r3, [r7, #12]
 800c346:	e01a      	b.n	800c37e <GetSector+0x11e>
	}
	else if((Address < ADDR_FLASH_SECTOR_10) && (Address >= ADDR_FLASH_SECTOR_9))
 800c348:	687a      	ldr	r2, [r7, #4]
 800c34a:	4b19      	ldr	r3, [pc, #100]	; (800c3b0 <GetSector+0x150>)
 800c34c:	429a      	cmp	r2, r3
 800c34e:	d807      	bhi.n	800c360 <GetSector+0x100>
 800c350:	687a      	ldr	r2, [r7, #4]
 800c352:	4b16      	ldr	r3, [pc, #88]	; (800c3ac <GetSector+0x14c>)
 800c354:	429a      	cmp	r2, r3
 800c356:	d903      	bls.n	800c360 <GetSector+0x100>
	{
	 sector = FLASH_Sector_9;
 800c358:	f04f 0348 	mov.w	r3, #72	; 0x48
 800c35c:	60fb      	str	r3, [r7, #12]
 800c35e:	e00e      	b.n	800c37e <GetSector+0x11e>
	}
	else if((Address < ADDR_FLASH_SECTOR_11) && (Address >= ADDR_FLASH_SECTOR_10))
 800c360:	687a      	ldr	r2, [r7, #4]
 800c362:	4b14      	ldr	r3, [pc, #80]	; (800c3b4 <GetSector+0x154>)
 800c364:	429a      	cmp	r2, r3
 800c366:	d807      	bhi.n	800c378 <GetSector+0x118>
 800c368:	687a      	ldr	r2, [r7, #4]
 800c36a:	4b11      	ldr	r3, [pc, #68]	; (800c3b0 <GetSector+0x150>)
 800c36c:	429a      	cmp	r2, r3
 800c36e:	d903      	bls.n	800c378 <GetSector+0x118>
	{
	 sector = FLASH_Sector_10;
 800c370:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c374:	60fb      	str	r3, [r7, #12]
 800c376:	e002      	b.n	800c37e <GetSector+0x11e>
	}
	else
	{
	 sector = FLASH_Sector_11;
 800c378:	f04f 0358 	mov.w	r3, #88	; 0x58
 800c37c:	60fb      	str	r3, [r7, #12]
	}
	return sector;
 800c37e:	68fb      	ldr	r3, [r7, #12]
}
 800c380:	4618      	mov	r0, r3
 800c382:	f107 0714 	add.w	r7, r7, #20
 800c386:	46bd      	mov	sp, r7
 800c388:	bc80      	pop	{r7}
 800c38a:	4770      	bx	lr
 800c38c:	08003fff 	.word	0x08003fff
 800c390:	08007fff 	.word	0x08007fff
 800c394:	0800bfff 	.word	0x0800bfff
 800c398:	0800ffff 	.word	0x0800ffff
 800c39c:	0801ffff 	.word	0x0801ffff
 800c3a0:	0803ffff 	.word	0x0803ffff
 800c3a4:	0805ffff 	.word	0x0805ffff
 800c3a8:	0807ffff 	.word	0x0807ffff
 800c3ac:	0809ffff 	.word	0x0809ffff
 800c3b0:	080bffff 	.word	0x080bffff
 800c3b4:	080dffff 	.word	0x080dffff

0800c3b8 <GetSectorStamp2>:

void GetSectorStamp2(FlashStampStruct* returnStruct)
{
 800c3b8:	b480      	push	{r7}
 800c3ba:	b085      	sub	sp, #20
 800c3bc:	af00      	add	r7, sp, #0
 800c3be:	6078      	str	r0, [r7, #4]
	uint8_t i = 0;
 800c3c0:	f04f 0300 	mov.w	r3, #0
 800c3c4:	73fb      	strb	r3, [r7, #15]
	uint32_t uwAddress = ADDR_FLASH_SELECTOR;
 800c3c6:	4b36      	ldr	r3, [pc, #216]	; (800c4a0 <GetSectorStamp2+0xe8>)
 800c3c8:	60bb      	str	r3, [r7, #8]

	uwAddress = ((*(__IO uint16_t*)uwAddress) == FlashSectorSelector_End) ? ( ADDR_FLASH_SECTOR_4 + ( sizeof(FlashStampStruct) * 15 )) :  ADDR_FLASH_SECTOR_4;
 800c3ca:	68bb      	ldr	r3, [r7, #8]
 800c3cc:	881b      	ldrh	r3, [r3, #0]
 800c3ce:	b29b      	uxth	r3, r3
 800c3d0:	2b01      	cmp	r3, #1
 800c3d2:	d101      	bne.n	800c3d8 <GetSectorStamp2+0x20>
 800c3d4:	4b33      	ldr	r3, [pc, #204]	; (800c4a4 <GetSectorStamp2+0xec>)
 800c3d6:	e000      	b.n	800c3da <GetSectorStamp2+0x22>
 800c3d8:	4b33      	ldr	r3, [pc, #204]	; (800c4a8 <GetSectorStamp2+0xf0>)
 800c3da:	60bb      	str	r3, [r7, #8]

	for(i = 0; i < 15; i++)
 800c3dc:	f04f 0300 	mov.w	r3, #0
 800c3e0:	73fb      	strb	r3, [r7, #15]
 800c3e2:	e055      	b.n	800c490 <GetSectorStamp2+0xd8>
	{
		returnStruct[i].FlashStampStruct_uwAddress = *(__IO uint32_t*)uwAddress;
 800c3e4:	7bfa      	ldrb	r2, [r7, #15]
 800c3e6:	4613      	mov	r3, r2
 800c3e8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c3ec:	189b      	adds	r3, r3, r2
 800c3ee:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c3f2:	687a      	ldr	r2, [r7, #4]
 800c3f4:	18d3      	adds	r3, r2, r3
 800c3f6:	68ba      	ldr	r2, [r7, #8]
 800c3f8:	6812      	ldr	r2, [r2, #0]
 800c3fa:	601a      	str	r2, [r3, #0]
		uwAddress += 4;
 800c3fc:	68bb      	ldr	r3, [r7, #8]
 800c3fe:	f103 0304 	add.w	r3, r3, #4
 800c402:	60bb      	str	r3, [r7, #8]

		returnStruct[i].FlashStampStruct_uwSectorCounter = *(__IO uint32_t*)uwAddress;
 800c404:	7bfa      	ldrb	r2, [r7, #15]
 800c406:	4613      	mov	r3, r2
 800c408:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c40c:	189b      	adds	r3, r3, r2
 800c40e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c412:	687a      	ldr	r2, [r7, #4]
 800c414:	18d3      	adds	r3, r2, r3
 800c416:	68ba      	ldr	r2, [r7, #8]
 800c418:	6812      	ldr	r2, [r2, #0]
 800c41a:	605a      	str	r2, [r3, #4]
		uwAddress += 4;
 800c41c:	68bb      	ldr	r3, [r7, #8]
 800c41e:	f103 0304 	add.w	r3, r3, #4
 800c422:	60bb      	str	r3, [r7, #8]

		returnStruct[i].FlashStampStruct_uwSelector = *(__IO uint8_t*)uwAddress;
 800c424:	7bfa      	ldrb	r2, [r7, #15]
 800c426:	4613      	mov	r3, r2
 800c428:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c42c:	189b      	adds	r3, r3, r2
 800c42e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c432:	687a      	ldr	r2, [r7, #4]
 800c434:	18d3      	adds	r3, r2, r3
 800c436:	68ba      	ldr	r2, [r7, #8]
 800c438:	7812      	ldrb	r2, [r2, #0]
 800c43a:	b2d2      	uxtb	r2, r2
 800c43c:	721a      	strb	r2, [r3, #8]
		uwAddress++;
 800c43e:	68bb      	ldr	r3, [r7, #8]
 800c440:	f103 0301 	add.w	r3, r3, #1
 800c444:	60bb      	str	r3, [r7, #8]

		returnStruct[i].FlashStampStruct_Length = *(__IO uint32_t*)uwAddress;
 800c446:	7bfa      	ldrb	r2, [r7, #15]
 800c448:	4613      	mov	r3, r2
 800c44a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c44e:	189b      	adds	r3, r3, r2
 800c450:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c454:	687a      	ldr	r2, [r7, #4]
 800c456:	18d3      	adds	r3, r2, r3
 800c458:	68ba      	ldr	r2, [r7, #8]
 800c45a:	6812      	ldr	r2, [r2, #0]
 800c45c:	60da      	str	r2, [r3, #12]
		uwAddress += 4;
 800c45e:	68bb      	ldr	r3, [r7, #8]
 800c460:	f103 0304 	add.w	r3, r3, #4
 800c464:	60bb      	str	r3, [r7, #8]

		returnStruct[i].FlashStampStruct_StateMState = *(__IO uint8_t*)uwAddress;
 800c466:	7bfa      	ldrb	r2, [r7, #15]
 800c468:	4613      	mov	r3, r2
 800c46a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c46e:	189b      	adds	r3, r3, r2
 800c470:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c474:	687a      	ldr	r2, [r7, #4]
 800c476:	18d3      	adds	r3, r2, r3
 800c478:	68ba      	ldr	r2, [r7, #8]
 800c47a:	7812      	ldrb	r2, [r2, #0]
 800c47c:	b2d2      	uxtb	r2, r2
 800c47e:	741a      	strb	r2, [r3, #16]
		uwAddress++;
 800c480:	68bb      	ldr	r3, [r7, #8]
 800c482:	f103 0301 	add.w	r3, r3, #1
 800c486:	60bb      	str	r3, [r7, #8]
	uint8_t i = 0;
	uint32_t uwAddress = ADDR_FLASH_SELECTOR;

	uwAddress = ((*(__IO uint16_t*)uwAddress) == FlashSectorSelector_End) ? ( ADDR_FLASH_SECTOR_4 + ( sizeof(FlashStampStruct) * 15 )) :  ADDR_FLASH_SECTOR_4;

	for(i = 0; i < 15; i++)
 800c488:	7bfb      	ldrb	r3, [r7, #15]
 800c48a:	f103 0301 	add.w	r3, r3, #1
 800c48e:	73fb      	strb	r3, [r7, #15]
 800c490:	7bfb      	ldrb	r3, [r7, #15]
 800c492:	2b0e      	cmp	r3, #14
 800c494:	d9a6      	bls.n	800c3e4 <GetSectorStamp2+0x2c>
		uwAddress += 4;

		returnStruct[i].FlashStampStruct_StateMState = *(__IO uint8_t*)uwAddress;
		uwAddress++;
	}
}
 800c496:	f107 0714 	add.w	r7, r7, #20
 800c49a:	46bd      	mov	sp, r7
 800c49c:	bc80      	pop	{r7}
 800c49e:	4770      	bx	lr
 800c4a0:	0801ffff 	.word	0x0801ffff
 800c4a4:	0801012c 	.word	0x0801012c
 800c4a8:	08010000 	.word	0x08010000

0800c4ac <GetSectorStamp>:


void GetSectorStamp(FlashStampStruct* returnStruct)
{
 800c4ac:	b580      	push	{r7, lr}
 800c4ae:	b0ce      	sub	sp, #312	; 0x138
 800c4b0:	af00      	add	r7, sp, #0
 800c4b2:	f107 0304 	add.w	r3, r7, #4
 800c4b6:	6018      	str	r0, [r3, #0]
	FlashStampStruct getStruct[15];
	uint8_t i = 0;
 800c4b8:	f04f 0300 	mov.w	r3, #0
 800c4bc:	f887 3137 	strb.w	r3, [r7, #311]	; 0x137

	GetSectorStamp2(&getStruct[0]);
 800c4c0:	f107 0308 	add.w	r3, r7, #8
 800c4c4:	4618      	mov	r0, r3
 800c4c6:	f7ff ff77 	bl	800c3b8 <GetSectorStamp2>

	for(i = 0; i < 15; i++)
 800c4ca:	f04f 0300 	mov.w	r3, #0
 800c4ce:	f887 3137 	strb.w	r3, [r7, #311]	; 0x137
 800c4d2:	e0d3      	b.n	800c67c <GetSectorStamp+0x1d0>
	{
		if(getStruct[i].FlashStampStruct_StateMState == 0xFF )
 800c4d4:	f897 2137 	ldrb.w	r2, [r7, #311]	; 0x137
 800c4d8:	f107 0108 	add.w	r1, r7, #8
 800c4dc:	4613      	mov	r3, r2
 800c4de:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c4e2:	189b      	adds	r3, r3, r2
 800c4e4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c4e8:	18cb      	adds	r3, r1, r3
 800c4ea:	f103 0310 	add.w	r3, r3, #16
 800c4ee:	781b      	ldrb	r3, [r3, #0]
 800c4f0:	2bff      	cmp	r3, #255	; 0xff
 800c4f2:	f040 80bd 	bne.w	800c670 <GetSectorStamp+0x1c4>
		{
			returnStruct[SectorStampSelector_Current].FlashStampStruct_Length = getStruct[i].FlashStampStruct_Length;
 800c4f6:	f107 0304 	add.w	r3, r7, #4
 800c4fa:	681b      	ldr	r3, [r3, #0]
 800c4fc:	f103 0114 	add.w	r1, r3, #20
 800c500:	f897 2137 	ldrb.w	r2, [r7, #311]	; 0x137
 800c504:	f107 0008 	add.w	r0, r7, #8
 800c508:	4613      	mov	r3, r2
 800c50a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c50e:	189b      	adds	r3, r3, r2
 800c510:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c514:	18c3      	adds	r3, r0, r3
 800c516:	f103 0308 	add.w	r3, r3, #8
 800c51a:	685b      	ldr	r3, [r3, #4]
 800c51c:	60cb      	str	r3, [r1, #12]
			returnStruct[SectorStampSelector_Current].FlashStampStruct_uwAddress = getStruct[i].FlashStampStruct_uwAddress;
 800c51e:	f107 0304 	add.w	r3, r7, #4
 800c522:	681b      	ldr	r3, [r3, #0]
 800c524:	f103 0114 	add.w	r1, r3, #20
 800c528:	f897 2137 	ldrb.w	r2, [r7, #311]	; 0x137
 800c52c:	f107 0008 	add.w	r0, r7, #8
 800c530:	4613      	mov	r3, r2
 800c532:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c536:	189b      	adds	r3, r3, r2
 800c538:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c53c:	18c3      	adds	r3, r0, r3
 800c53e:	681b      	ldr	r3, [r3, #0]
 800c540:	600b      	str	r3, [r1, #0]
			returnStruct[SectorStampSelector_Current].FlashStampStruct_uwSectorCounter = getStruct[i].FlashStampStruct_uwSectorCounter;
 800c542:	f107 0304 	add.w	r3, r7, #4
 800c546:	681b      	ldr	r3, [r3, #0]
 800c548:	f103 0114 	add.w	r1, r3, #20
 800c54c:	f897 2137 	ldrb.w	r2, [r7, #311]	; 0x137
 800c550:	f107 0008 	add.w	r0, r7, #8
 800c554:	4613      	mov	r3, r2
 800c556:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c55a:	189b      	adds	r3, r3, r2
 800c55c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c560:	18c3      	adds	r3, r0, r3
 800c562:	685b      	ldr	r3, [r3, #4]
 800c564:	604b      	str	r3, [r1, #4]
			returnStruct[SectorStampSelector_Current].FlashStampStruct_uwSelector = getStruct[i].FlashStampStruct_uwSelector;
 800c566:	f107 0304 	add.w	r3, r7, #4
 800c56a:	681b      	ldr	r3, [r3, #0]
 800c56c:	f103 0114 	add.w	r1, r3, #20
 800c570:	f897 2137 	ldrb.w	r2, [r7, #311]	; 0x137
 800c574:	f107 0008 	add.w	r0, r7, #8
 800c578:	4613      	mov	r3, r2
 800c57a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c57e:	189b      	adds	r3, r3, r2
 800c580:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c584:	18c3      	adds	r3, r0, r3
 800c586:	f103 0308 	add.w	r3, r3, #8
 800c58a:	781b      	ldrb	r3, [r3, #0]
 800c58c:	720b      	strb	r3, [r1, #8]
			returnStruct[SectorStampSelector_Current].FlashStampStruct_StateMState = getStruct[i].FlashStampStruct_StateMState;
 800c58e:	f107 0304 	add.w	r3, r7, #4
 800c592:	681b      	ldr	r3, [r3, #0]
 800c594:	f103 0114 	add.w	r1, r3, #20
 800c598:	f897 2137 	ldrb.w	r2, [r7, #311]	; 0x137
 800c59c:	f107 0008 	add.w	r0, r7, #8
 800c5a0:	4613      	mov	r3, r2
 800c5a2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c5a6:	189b      	adds	r3, r3, r2
 800c5a8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c5ac:	18c3      	adds	r3, r0, r3
 800c5ae:	f103 0310 	add.w	r3, r3, #16
 800c5b2:	781b      	ldrb	r3, [r3, #0]
 800c5b4:	740b      	strb	r3, [r1, #16]

			--i;
 800c5b6:	f897 3137 	ldrb.w	r3, [r7, #311]	; 0x137
 800c5ba:	f103 33ff 	add.w	r3, r3, #4294967295
 800c5be:	f887 3137 	strb.w	r3, [r7, #311]	; 0x137

			returnStruct[SectorStampSelector_Prev].FlashStampStruct_Length = getStruct[i].FlashStampStruct_Length;
 800c5c2:	f897 2137 	ldrb.w	r2, [r7, #311]	; 0x137
 800c5c6:	f107 0108 	add.w	r1, r7, #8
 800c5ca:	4613      	mov	r3, r2
 800c5cc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c5d0:	189b      	adds	r3, r3, r2
 800c5d2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c5d6:	18cb      	adds	r3, r1, r3
 800c5d8:	f103 0308 	add.w	r3, r3, #8
 800c5dc:	685a      	ldr	r2, [r3, #4]
 800c5de:	f107 0304 	add.w	r3, r7, #4
 800c5e2:	681b      	ldr	r3, [r3, #0]
 800c5e4:	60da      	str	r2, [r3, #12]
			returnStruct[SectorStampSelector_Prev].FlashStampStruct_uwAddress = getStruct[i].FlashStampStruct_uwAddress;
 800c5e6:	f897 2137 	ldrb.w	r2, [r7, #311]	; 0x137
 800c5ea:	f107 0108 	add.w	r1, r7, #8
 800c5ee:	4613      	mov	r3, r2
 800c5f0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c5f4:	189b      	adds	r3, r3, r2
 800c5f6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c5fa:	18cb      	adds	r3, r1, r3
 800c5fc:	681a      	ldr	r2, [r3, #0]
 800c5fe:	f107 0304 	add.w	r3, r7, #4
 800c602:	681b      	ldr	r3, [r3, #0]
 800c604:	601a      	str	r2, [r3, #0]
			returnStruct[SectorStampSelector_Prev].FlashStampStruct_uwSectorCounter = getStruct[i].FlashStampStruct_uwSectorCounter;
 800c606:	f897 2137 	ldrb.w	r2, [r7, #311]	; 0x137
 800c60a:	f107 0108 	add.w	r1, r7, #8
 800c60e:	4613      	mov	r3, r2
 800c610:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c614:	189b      	adds	r3, r3, r2
 800c616:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c61a:	18cb      	adds	r3, r1, r3
 800c61c:	685a      	ldr	r2, [r3, #4]
 800c61e:	f107 0304 	add.w	r3, r7, #4
 800c622:	681b      	ldr	r3, [r3, #0]
 800c624:	605a      	str	r2, [r3, #4]
			returnStruct[SectorStampSelector_Prev].FlashStampStruct_uwSelector = getStruct[i].FlashStampStruct_uwSelector;
 800c626:	f897 2137 	ldrb.w	r2, [r7, #311]	; 0x137
 800c62a:	f107 0108 	add.w	r1, r7, #8
 800c62e:	4613      	mov	r3, r2
 800c630:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c634:	189b      	adds	r3, r3, r2
 800c636:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c63a:	18cb      	adds	r3, r1, r3
 800c63c:	f103 0308 	add.w	r3, r3, #8
 800c640:	781a      	ldrb	r2, [r3, #0]
 800c642:	f107 0304 	add.w	r3, r7, #4
 800c646:	681b      	ldr	r3, [r3, #0]
 800c648:	721a      	strb	r2, [r3, #8]
			returnStruct[SectorStampSelector_Prev].FlashStampStruct_StateMState = getStruct[i].FlashStampStruct_StateMState;
 800c64a:	f897 2137 	ldrb.w	r2, [r7, #311]	; 0x137
 800c64e:	f107 0108 	add.w	r1, r7, #8
 800c652:	4613      	mov	r3, r2
 800c654:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c658:	189b      	adds	r3, r3, r2
 800c65a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c65e:	18cb      	adds	r3, r1, r3
 800c660:	f103 0310 	add.w	r3, r3, #16
 800c664:	781a      	ldrb	r2, [r3, #0]
 800c666:	f107 0304 	add.w	r3, r7, #4
 800c66a:	681b      	ldr	r3, [r3, #0]
 800c66c:	741a      	strb	r2, [r3, #16]

			break;
 800c66e:	e00a      	b.n	800c686 <GetSectorStamp+0x1da>
	FlashStampStruct getStruct[15];
	uint8_t i = 0;

	GetSectorStamp2(&getStruct[0]);

	for(i = 0; i < 15; i++)
 800c670:	f897 3137 	ldrb.w	r3, [r7, #311]	; 0x137
 800c674:	f103 0301 	add.w	r3, r3, #1
 800c678:	f887 3137 	strb.w	r3, [r7, #311]	; 0x137
 800c67c:	f897 3137 	ldrb.w	r3, [r7, #311]	; 0x137
 800c680:	2b0e      	cmp	r3, #14
 800c682:	f67f af27 	bls.w	800c4d4 <GetSectorStamp+0x28>
			returnStruct[SectorStampSelector_Prev].FlashStampStruct_StateMState = getStruct[i].FlashStampStruct_StateMState;

			break;
		}
	}
}
 800c686:	f507 779c 	add.w	r7, r7, #312	; 0x138
 800c68a:	46bd      	mov	sp, r7
 800c68c:	bd80      	pop	{r7, pc}
 800c68e:	bf00      	nop

0800c690 <SetSectorStamp>:
/*
 * Csak elõzõleg törölt szektoron alkalmazható
 * Szükséges a Flash memória Unlock-olása
 * */
FlashBool_Type SetSectorStamp(FlashStampStruct* dataStruct)
{
 800c690:	b580      	push	{r7, lr}
 800c692:	b0da      	sub	sp, #360	; 0x168
 800c694:	af00      	add	r7, sp, #0
 800c696:	f107 0304 	add.w	r3, r7, #4
 800c69a:	6018      	str	r0, [r3, #0]
	//uint32_t uwAddress = ADDR_FLASH_SECTOR_4;
	FlashStampStruct returnStruct[2];
	FlashStampStruct returnStruct2[15];
	uint8_t i = 0;
 800c69c:	f04f 0300 	mov.w	r3, #0
 800c6a0:	f887 3167 	strb.w	r3, [r7, #359]	; 0x167
	uint32_t uwAddress = ADDR_FLASH_SELECTOR;
 800c6a4:	4b5c      	ldr	r3, [pc, #368]	; (800c818 <SetSectorStamp+0x188>)
 800c6a6:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160

	uwAddress = ((*(__IO uint16_t*)uwAddress) == FlashSectorSelector_End) ? ( ADDR_FLASH_SECTOR_4 + ( sizeof(FlashStampStruct) * 15 )) :  ADDR_FLASH_SECTOR_4;
 800c6aa:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 800c6ae:	881b      	ldrh	r3, [r3, #0]
 800c6b0:	b29b      	uxth	r3, r3
 800c6b2:	2b01      	cmp	r3, #1
 800c6b4:	d101      	bne.n	800c6ba <SetSectorStamp+0x2a>
 800c6b6:	4b59      	ldr	r3, [pc, #356]	; (800c81c <SetSectorStamp+0x18c>)
 800c6b8:	e000      	b.n	800c6bc <SetSectorStamp+0x2c>
 800c6ba:	4b59      	ldr	r3, [pc, #356]	; (800c820 <SetSectorStamp+0x190>)
 800c6bc:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160


	GetSectorStamp2(&returnStruct2[0]);
 800c6c0:	f107 030c 	add.w	r3, r7, #12
 800c6c4:	4618      	mov	r0, r3
 800c6c6:	f7ff fe77 	bl	800c3b8 <GetSectorStamp2>

	for(i = 0; i < 15; ++i)
 800c6ca:	f04f 0300 	mov.w	r3, #0
 800c6ce:	f887 3167 	strb.w	r3, [r7, #359]	; 0x167
 800c6d2:	e08f      	b.n	800c7f4 <SetSectorStamp+0x164>
	{
		if(returnStruct2[i].FlashStampStruct_StateMState == 0xFF)
 800c6d4:	f897 2167 	ldrb.w	r2, [r7, #359]	; 0x167
 800c6d8:	f107 010c 	add.w	r1, r7, #12
 800c6dc:	4613      	mov	r3, r2
 800c6de:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c6e2:	189b      	adds	r3, r3, r2
 800c6e4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c6e8:	18cb      	adds	r3, r1, r3
 800c6ea:	f103 0310 	add.w	r3, r3, #16
 800c6ee:	781b      	ldrb	r3, [r3, #0]
 800c6f0:	2bff      	cmp	r3, #255	; 0xff
 800c6f2:	d173      	bne.n	800c7dc <SetSectorStamp+0x14c>
		{
			uwAddress += 9;
 800c6f4:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 800c6f8:	f103 0309 	add.w	r3, r3, #9
 800c6fc:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160

			if (FLASH_ProgramByte(uwAddress, (((dataStruct->FlashStampStruct_Length) & 0xFF))) != FLASH_COMPLETE)
 800c700:	f107 0304 	add.w	r3, r7, #4
 800c704:	681b      	ldr	r3, [r3, #0]
 800c706:	68db      	ldr	r3, [r3, #12]
 800c708:	b2db      	uxtb	r3, r3
 800c70a:	f8d7 0160 	ldr.w	r0, [r7, #352]	; 0x160
 800c70e:	4619      	mov	r1, r3
 800c710:	f7fa fc9e 	bl	8007050 <FLASH_ProgramByte>
 800c714:	4603      	mov	r3, r0
 800c716:	2b08      	cmp	r3, #8
 800c718:	d000      	beq.n	800c71c <SetSectorStamp+0x8c>
			{
				while (1)
				{
				}
 800c71a:	e7fe      	b.n	800c71a <SetSectorStamp+0x8a>
			}
			uwAddress++;
 800c71c:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 800c720:	f103 0301 	add.w	r3, r3, #1
 800c724:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160

			if (FLASH_ProgramByte(uwAddress, (((dataStruct->FlashStampStruct_Length) & 0xFF00) >> 8)) != FLASH_COMPLETE)
 800c728:	f107 0304 	add.w	r3, r7, #4
 800c72c:	681b      	ldr	r3, [r3, #0]
 800c72e:	68db      	ldr	r3, [r3, #12]
 800c730:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800c734:	ea4f 2313 	mov.w	r3, r3, lsr #8
 800c738:	b2db      	uxtb	r3, r3
 800c73a:	f8d7 0160 	ldr.w	r0, [r7, #352]	; 0x160
 800c73e:	4619      	mov	r1, r3
 800c740:	f7fa fc86 	bl	8007050 <FLASH_ProgramByte>
 800c744:	4603      	mov	r3, r0
 800c746:	2b08      	cmp	r3, #8
 800c748:	d000      	beq.n	800c74c <SetSectorStamp+0xbc>
			{
				while (1)
				{
				}
 800c74a:	e7fe      	b.n	800c74a <SetSectorStamp+0xba>
			}
			uwAddress++;
 800c74c:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 800c750:	f103 0301 	add.w	r3, r3, #1
 800c754:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160

			if (FLASH_ProgramByte(uwAddress, (((dataStruct->FlashStampStruct_Length) & 0xFF0000) >> 16)) != FLASH_COMPLETE)
 800c758:	f107 0304 	add.w	r3, r7, #4
 800c75c:	681b      	ldr	r3, [r3, #0]
 800c75e:	68db      	ldr	r3, [r3, #12]
 800c760:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800c764:	ea4f 4313 	mov.w	r3, r3, lsr #16
 800c768:	b2db      	uxtb	r3, r3
 800c76a:	f8d7 0160 	ldr.w	r0, [r7, #352]	; 0x160
 800c76e:	4619      	mov	r1, r3
 800c770:	f7fa fc6e 	bl	8007050 <FLASH_ProgramByte>
 800c774:	4603      	mov	r3, r0
 800c776:	2b08      	cmp	r3, #8
 800c778:	d000      	beq.n	800c77c <SetSectorStamp+0xec>
			{
				while (1)
				{
				}
 800c77a:	e7fe      	b.n	800c77a <SetSectorStamp+0xea>
			}
			uwAddress++;
 800c77c:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 800c780:	f103 0301 	add.w	r3, r3, #1
 800c784:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160

			if (FLASH_ProgramByte(uwAddress, (((dataStruct->FlashStampStruct_Length) & 0xFF000000) >> 24)) != FLASH_COMPLETE)
 800c788:	f107 0304 	add.w	r3, r7, #4
 800c78c:	681b      	ldr	r3, [r3, #0]
 800c78e:	68db      	ldr	r3, [r3, #12]
 800c790:	ea4f 6313 	mov.w	r3, r3, lsr #24
 800c794:	b2db      	uxtb	r3, r3
 800c796:	f8d7 0160 	ldr.w	r0, [r7, #352]	; 0x160
 800c79a:	4619      	mov	r1, r3
 800c79c:	f7fa fc58 	bl	8007050 <FLASH_ProgramByte>
 800c7a0:	4603      	mov	r3, r0
 800c7a2:	2b08      	cmp	r3, #8
 800c7a4:	d000      	beq.n	800c7a8 <SetSectorStamp+0x118>
			{
				while (1)
				{
				}
 800c7a6:	e7fe      	b.n	800c7a6 <SetSectorStamp+0x116>
			}
			uwAddress++;
 800c7a8:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 800c7ac:	f103 0301 	add.w	r3, r3, #1
 800c7b0:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160

			if (FLASH_ProgramByte(uwAddress, ((dataStruct->FlashStampStruct_StateMState))) != FLASH_COMPLETE)
 800c7b4:	f107 0304 	add.w	r3, r7, #4
 800c7b8:	681b      	ldr	r3, [r3, #0]
 800c7ba:	7c1b      	ldrb	r3, [r3, #16]
 800c7bc:	f8d7 0160 	ldr.w	r0, [r7, #352]	; 0x160
 800c7c0:	4619      	mov	r1, r3
 800c7c2:	f7fa fc45 	bl	8007050 <FLASH_ProgramByte>
 800c7c6:	4603      	mov	r3, r0
 800c7c8:	2b08      	cmp	r3, #8
 800c7ca:	d000      	beq.n	800c7ce <SetSectorStamp+0x13e>
			{
				while (1)
				{
				}
 800c7cc:	e7fe      	b.n	800c7cc <SetSectorStamp+0x13c>
			}
			uwAddress++;
 800c7ce:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 800c7d2:	f103 0301 	add.w	r3, r3, #1
 800c7d6:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160

			break;
 800c7da:	e010      	b.n	800c7fe <SetSectorStamp+0x16e>
		}

		else
		{
			uwAddress += 14;
 800c7dc:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 800c7e0:	f103 030e 	add.w	r3, r3, #14
 800c7e4:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
	uwAddress = ((*(__IO uint16_t*)uwAddress) == FlashSectorSelector_End) ? ( ADDR_FLASH_SECTOR_4 + ( sizeof(FlashStampStruct) * 15 )) :  ADDR_FLASH_SECTOR_4;


	GetSectorStamp2(&returnStruct2[0]);

	for(i = 0; i < 15; ++i)
 800c7e8:	f897 3167 	ldrb.w	r3, [r7, #359]	; 0x167
 800c7ec:	f103 0301 	add.w	r3, r3, #1
 800c7f0:	f887 3167 	strb.w	r3, [r7, #359]	; 0x167
 800c7f4:	f897 3167 	ldrb.w	r3, [r7, #359]	; 0x167
 800c7f8:	2b0e      	cmp	r3, #14
 800c7fa:	f67f af6b 	bls.w	800c6d4 <SetSectorStamp+0x44>
		{
			uwAddress += 14;
		}
	}

	GetSectorStamp2(&returnStruct2[0]);
 800c7fe:	f107 030c 	add.w	r3, r7, #12
 800c802:	4618      	mov	r0, r3
 800c804:	f7ff fdd8 	bl	800c3b8 <GetSectorStamp2>
/*
	if((returnStruct.FlashStampStruct_Length == dataStruct->FlashStampStruct_Length) && (returnStruct.FlashStampStruct_StateMState == dataStruct->FlashStampStruct_StateMState))
		return FlashBool_True;
	else
		return FlashBool_False;*/
	return FlashBool_True;
 800c808:	f04f 0301 	mov.w	r3, #1
}
 800c80c:	4618      	mov	r0, r3
 800c80e:	f507 77b4 	add.w	r7, r7, #360	; 0x168
 800c812:	46bd      	mov	sp, r7
 800c814:	bd80      	pop	{r7, pc}
 800c816:	bf00      	nop
 800c818:	0801ffff 	.word	0x0801ffff
 800c81c:	0801012c 	.word	0x0801012c
 800c820:	08010000 	.word	0x08010000

0800c824 <FlashSectorStampToDefault>:

void FlashSectorStampToDefault(SectorStampToDefaultMode mode)
{
 800c824:	b580      	push	{r7, lr}
 800c826:	b08a      	sub	sp, #40	; 0x28
 800c828:	af00      	add	r7, sp, #0
 800c82a:	4603      	mov	r3, r0
 800c82c:	71fb      	strb	r3, [r7, #7]
	uint32_t uwSectorCounter = 0;
 800c82e:	f04f 0300 	mov.w	r3, #0
 800c832:	613b      	str	r3, [r7, #16]
	uint32_t targetSectorCounter = 0;
 800c834:	f04f 0300 	mov.w	r3, #0
 800c838:	627b      	str	r3, [r7, #36]	; 0x24
	uint32_t targetAddress = 0;
 800c83a:	f04f 0300 	mov.w	r3, #0
 800c83e:	623b      	str	r3, [r7, #32]
	uint8_t  targetSelector = 0;
 800c840:	f04f 0300 	mov.w	r3, #0
 800c844:	77fb      	strb	r3, [r7, #31]
	uwSectorCounter = GetSector(ADDR_FLASH_SECTOR_4);
 800c846:	48a4      	ldr	r0, [pc, #656]	; (800cad8 <FlashSectorStampToDefault+0x2b4>)
 800c848:	f7ff fd0a 	bl	800c260 <GetSector>
 800c84c:	6138      	str	r0, [r7, #16]
	uint32_t uwAddress = ADDR_FLASH_SECTOR_4;
 800c84e:	4ba2      	ldr	r3, [pc, #648]	; (800cad8 <FlashSectorStampToDefault+0x2b4>)
 800c850:	61bb      	str	r3, [r7, #24]
	uint8_t i = 0;
 800c852:	f04f 0300 	mov.w	r3, #0
 800c856:	75fb      	strb	r3, [r7, #23]
	uint8_t j = 0;
 800c858:	f04f 0300 	mov.w	r3, #0
 800c85c:	75bb      	strb	r3, [r7, #22]
	uint8_t selector = 0;
 800c85e:	f04f 0300 	mov.w	r3, #0
 800c862:	73fb      	strb	r3, [r7, #15]
	uint8_t cycle = 0;
 800c864:	f04f 0300 	mov.w	r3, #0
 800c868:	757b      	strb	r3, [r7, #21]

	selector = *(__IO uint8_t*)ADDR_FLASH_SELECTOR;
 800c86a:	4b9c      	ldr	r3, [pc, #624]	; (800cadc <FlashSectorStampToDefault+0x2b8>)
 800c86c:	781b      	ldrb	r3, [r3, #0]
 800c86e:	73fb      	strb	r3, [r7, #15]

	FLASH_Unlock();
 800c870:	f7fa fa6a 	bl	8006d48 <FLASH_Unlock>

	FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |
 800c874:	f04f 00f3 	mov.w	r0, #243	; 0xf3
 800c878:	f7fa fd74 	bl	8007364 <FLASH_ClearFlag>
				FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR|FLASH_FLAG_PGSERR);

	/* Strat the erase operation */
	/* Device voltage range supposed to be [2.7V to 3.6V], the operation will
	be done by word */
	if (FLASH_EraseSector(uwSectorCounter, VoltageRange_3) != FLASH_COMPLETE)
 800c87c:	6938      	ldr	r0, [r7, #16]
 800c87e:	f04f 0102 	mov.w	r1, #2
 800c882:	f7fa fa85 	bl	8006d90 <FLASH_EraseSector>
 800c886:	4603      	mov	r3, r0
 800c888:	2b08      	cmp	r3, #8
 800c88a:	d000      	beq.n	800c88e <FlashSectorStampToDefault+0x6a>
	{
	/* Error occurred while sector erase.
	  User can add here some code to deal with this error  */
		while (1)
		{
		}
 800c88c:	e7fe      	b.n	800c88c <FlashSectorStampToDefault+0x68>
	}

	for(i = 0; i < 15; i++)
 800c88e:	f04f 0300 	mov.w	r3, #0
 800c892:	75fb      	strb	r3, [r7, #23]
 800c894:	e1bd      	b.n	800cc12 <FlashSectorStampToDefault+0x3ee>
	{
		switch(i)
 800c896:	7dfb      	ldrb	r3, [r7, #23]
 800c898:	2b0e      	cmp	r3, #14
 800c89a:	f200 80a8 	bhi.w	800c9ee <FlashSectorStampToDefault+0x1ca>
 800c89e:	a201      	add	r2, pc, #4	; (adr r2, 800c8a4 <FlashSectorStampToDefault+0x80>)
 800c8a0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800c8a4:	0800c8e1 	.word	0x0800c8e1
 800c8a8:	0800c8f3 	.word	0x0800c8f3
 800c8ac:	0800c905 	.word	0x0800c905
 800c8b0:	0800c917 	.word	0x0800c917
 800c8b4:	0800c929 	.word	0x0800c929
 800c8b8:	0800c93b 	.word	0x0800c93b
 800c8bc:	0800c94d 	.word	0x0800c94d
 800c8c0:	0800c95f 	.word	0x0800c95f
 800c8c4:	0800c971 	.word	0x0800c971
 800c8c8:	0800c983 	.word	0x0800c983
 800c8cc:	0800c995 	.word	0x0800c995
 800c8d0:	0800c9a7 	.word	0x0800c9a7
 800c8d4:	0800c9b9 	.word	0x0800c9b9
 800c8d8:	0800c9cb 	.word	0x0800c9cb
 800c8dc:	0800c9dd 	.word	0x0800c9dd
		{
		case 0 :
			targetSectorCounter = FLASH_Sector_5;
 800c8e0:	f04f 0328 	mov.w	r3, #40	; 0x28
 800c8e4:	627b      	str	r3, [r7, #36]	; 0x24
			targetAddress = ADDR_FLASH_SECTOR_5;
 800c8e6:	4b7e      	ldr	r3, [pc, #504]	; (800cae0 <FlashSectorStampToDefault+0x2bc>)
 800c8e8:	623b      	str	r3, [r7, #32]
			targetSelector = FlashSectorSelector_Beginning;
 800c8ea:	f04f 0300 	mov.w	r3, #0
 800c8ee:	77fb      	strb	r3, [r7, #31]
			break;
 800c8f0:	e07d      	b.n	800c9ee <FlashSectorStampToDefault+0x1ca>

		case 1 :
			targetSectorCounter = FLASH_Sector_5;
 800c8f2:	f04f 0328 	mov.w	r3, #40	; 0x28
 800c8f6:	627b      	str	r3, [r7, #36]	; 0x24
			targetAddress = ADDR_FLASH_SECTOR_5;
 800c8f8:	4b79      	ldr	r3, [pc, #484]	; (800cae0 <FlashSectorStampToDefault+0x2bc>)
 800c8fa:	623b      	str	r3, [r7, #32]
			targetSelector = FlashSectorSelector_Beginning;
 800c8fc:	f04f 0300 	mov.w	r3, #0
 800c900:	77fb      	strb	r3, [r7, #31]
			break;
 800c902:	e074      	b.n	800c9ee <FlashSectorStampToDefault+0x1ca>

		case 2 :
			targetSectorCounter = FLASH_Sector_5;
 800c904:	f04f 0328 	mov.w	r3, #40	; 0x28
 800c908:	627b      	str	r3, [r7, #36]	; 0x24
			targetAddress = ADDR_FLASH_SECTOR_5;
 800c90a:	4b75      	ldr	r3, [pc, #468]	; (800cae0 <FlashSectorStampToDefault+0x2bc>)
 800c90c:	623b      	str	r3, [r7, #32]
			targetSelector = FlashSectorSelector_End;
 800c90e:	f04f 0301 	mov.w	r3, #1
 800c912:	77fb      	strb	r3, [r7, #31]
			break;
 800c914:	e06b      	b.n	800c9ee <FlashSectorStampToDefault+0x1ca>

		case 3 :
			targetSectorCounter = FLASH_Sector_6;
 800c916:	f04f 0330 	mov.w	r3, #48	; 0x30
 800c91a:	627b      	str	r3, [r7, #36]	; 0x24
			targetAddress = ADDR_FLASH_SECTOR_6;
 800c91c:	4b71      	ldr	r3, [pc, #452]	; (800cae4 <FlashSectorStampToDefault+0x2c0>)
 800c91e:	623b      	str	r3, [r7, #32]
			targetSelector = FlashSectorSelector_Beginning;
 800c920:	f04f 0300 	mov.w	r3, #0
 800c924:	77fb      	strb	r3, [r7, #31]
			break;
 800c926:	e062      	b.n	800c9ee <FlashSectorStampToDefault+0x1ca>

		case 4 :
			targetSectorCounter = FLASH_Sector_6;
 800c928:	f04f 0330 	mov.w	r3, #48	; 0x30
 800c92c:	627b      	str	r3, [r7, #36]	; 0x24
			targetAddress = ADDR_FLASH_SECTOR_6;
 800c92e:	4b6d      	ldr	r3, [pc, #436]	; (800cae4 <FlashSectorStampToDefault+0x2c0>)
 800c930:	623b      	str	r3, [r7, #32]
			targetSelector = FlashSectorSelector_End;
 800c932:	f04f 0301 	mov.w	r3, #1
 800c936:	77fb      	strb	r3, [r7, #31]
			break;
 800c938:	e059      	b.n	800c9ee <FlashSectorStampToDefault+0x1ca>

		case 5 :
			targetSectorCounter = FLASH_Sector_7;
 800c93a:	f04f 0338 	mov.w	r3, #56	; 0x38
 800c93e:	627b      	str	r3, [r7, #36]	; 0x24
			targetAddress = ADDR_FLASH_SECTOR_7;
 800c940:	4b69      	ldr	r3, [pc, #420]	; (800cae8 <FlashSectorStampToDefault+0x2c4>)
 800c942:	623b      	str	r3, [r7, #32]
			targetSelector = FlashSectorSelector_Beginning;
 800c944:	f04f 0300 	mov.w	r3, #0
 800c948:	77fb      	strb	r3, [r7, #31]
			break;
 800c94a:	e050      	b.n	800c9ee <FlashSectorStampToDefault+0x1ca>

		case 6 :
			targetSectorCounter = FLASH_Sector_7;
 800c94c:	f04f 0338 	mov.w	r3, #56	; 0x38
 800c950:	627b      	str	r3, [r7, #36]	; 0x24
			targetAddress = ADDR_FLASH_SECTOR_7;
 800c952:	4b65      	ldr	r3, [pc, #404]	; (800cae8 <FlashSectorStampToDefault+0x2c4>)
 800c954:	623b      	str	r3, [r7, #32]
			targetSelector = FlashSectorSelector_End;
 800c956:	f04f 0301 	mov.w	r3, #1
 800c95a:	77fb      	strb	r3, [r7, #31]
			break;
 800c95c:	e047      	b.n	800c9ee <FlashSectorStampToDefault+0x1ca>

		case 7 :
			targetSectorCounter = FLASH_Sector_8;
 800c95e:	f04f 0340 	mov.w	r3, #64	; 0x40
 800c962:	627b      	str	r3, [r7, #36]	; 0x24
			targetAddress = ADDR_FLASH_SECTOR_8;
 800c964:	4b61      	ldr	r3, [pc, #388]	; (800caec <FlashSectorStampToDefault+0x2c8>)
 800c966:	623b      	str	r3, [r7, #32]
			targetSelector = FlashSectorSelector_Beginning;
 800c968:	f04f 0300 	mov.w	r3, #0
 800c96c:	77fb      	strb	r3, [r7, #31]
			break;
 800c96e:	e03e      	b.n	800c9ee <FlashSectorStampToDefault+0x1ca>

		case 8 :
			targetSectorCounter = FLASH_Sector_8;
 800c970:	f04f 0340 	mov.w	r3, #64	; 0x40
 800c974:	627b      	str	r3, [r7, #36]	; 0x24
			targetAddress = ADDR_FLASH_SECTOR_8;
 800c976:	4b5d      	ldr	r3, [pc, #372]	; (800caec <FlashSectorStampToDefault+0x2c8>)
 800c978:	623b      	str	r3, [r7, #32]
			targetSelector = FlashSectorSelector_End;
 800c97a:	f04f 0301 	mov.w	r3, #1
 800c97e:	77fb      	strb	r3, [r7, #31]
			break;
 800c980:	e035      	b.n	800c9ee <FlashSectorStampToDefault+0x1ca>

		case 9 :
			targetSectorCounter = FLASH_Sector_9;
 800c982:	f04f 0348 	mov.w	r3, #72	; 0x48
 800c986:	627b      	str	r3, [r7, #36]	; 0x24
			targetAddress = ADDR_FLASH_SECTOR_9;
 800c988:	4b59      	ldr	r3, [pc, #356]	; (800caf0 <FlashSectorStampToDefault+0x2cc>)
 800c98a:	623b      	str	r3, [r7, #32]
			targetSelector = FlashSectorSelector_Beginning;
 800c98c:	f04f 0300 	mov.w	r3, #0
 800c990:	77fb      	strb	r3, [r7, #31]
			break;
 800c992:	e02c      	b.n	800c9ee <FlashSectorStampToDefault+0x1ca>

		case 10 :
			targetSectorCounter = FLASH_Sector_9;
 800c994:	f04f 0348 	mov.w	r3, #72	; 0x48
 800c998:	627b      	str	r3, [r7, #36]	; 0x24
			targetAddress = ADDR_FLASH_SECTOR_9;
 800c99a:	4b55      	ldr	r3, [pc, #340]	; (800caf0 <FlashSectorStampToDefault+0x2cc>)
 800c99c:	623b      	str	r3, [r7, #32]
			targetSelector = FlashSectorSelector_End;
 800c99e:	f04f 0301 	mov.w	r3, #1
 800c9a2:	77fb      	strb	r3, [r7, #31]
			break;
 800c9a4:	e023      	b.n	800c9ee <FlashSectorStampToDefault+0x1ca>

		case 11 :
			targetSectorCounter = FLASH_Sector_10;
 800c9a6:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c9aa:	627b      	str	r3, [r7, #36]	; 0x24
			targetAddress = ADDR_FLASH_SECTOR_10;
 800c9ac:	4b51      	ldr	r3, [pc, #324]	; (800caf4 <FlashSectorStampToDefault+0x2d0>)
 800c9ae:	623b      	str	r3, [r7, #32]
			targetSelector = FlashSectorSelector_Beginning;
 800c9b0:	f04f 0300 	mov.w	r3, #0
 800c9b4:	77fb      	strb	r3, [r7, #31]
			break;
 800c9b6:	e01a      	b.n	800c9ee <FlashSectorStampToDefault+0x1ca>

		case 12 :
			targetSectorCounter = FLASH_Sector_10;
 800c9b8:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c9bc:	627b      	str	r3, [r7, #36]	; 0x24
			targetAddress = ADDR_FLASH_SECTOR_10;
 800c9be:	4b4d      	ldr	r3, [pc, #308]	; (800caf4 <FlashSectorStampToDefault+0x2d0>)
 800c9c0:	623b      	str	r3, [r7, #32]
			targetSelector = FlashSectorSelector_End;
 800c9c2:	f04f 0301 	mov.w	r3, #1
 800c9c6:	77fb      	strb	r3, [r7, #31]
			break;
 800c9c8:	e011      	b.n	800c9ee <FlashSectorStampToDefault+0x1ca>

		case 13 :
			targetSectorCounter = FLASH_Sector_11;
 800c9ca:	f04f 0358 	mov.w	r3, #88	; 0x58
 800c9ce:	627b      	str	r3, [r7, #36]	; 0x24
			targetAddress = ADDR_FLASH_SECTOR_11;
 800c9d0:	4b49      	ldr	r3, [pc, #292]	; (800caf8 <FlashSectorStampToDefault+0x2d4>)
 800c9d2:	623b      	str	r3, [r7, #32]
			targetSelector = FlashSectorSelector_Beginning;
 800c9d4:	f04f 0300 	mov.w	r3, #0
 800c9d8:	77fb      	strb	r3, [r7, #31]
			break;
 800c9da:	e008      	b.n	800c9ee <FlashSectorStampToDefault+0x1ca>

		case 14 :
			targetSectorCounter = FLASH_Sector_11;
 800c9dc:	f04f 0358 	mov.w	r3, #88	; 0x58
 800c9e0:	627b      	str	r3, [r7, #36]	; 0x24
			targetAddress = ADDR_FLASH_SECTOR_11;
 800c9e2:	4b45      	ldr	r3, [pc, #276]	; (800caf8 <FlashSectorStampToDefault+0x2d4>)
 800c9e4:	623b      	str	r3, [r7, #32]
			targetSelector = FlashSectorSelector_End;
 800c9e6:	f04f 0301 	mov.w	r3, #1
 800c9ea:	77fb      	strb	r3, [r7, #31]
			break;
 800c9ec:	bf00      	nop
		}

		if(mode == SectorStampToDefaultMode_Only_First)
 800c9ee:	79fb      	ldrb	r3, [r7, #7]
 800c9f0:	2b02      	cmp	r3, #2
 800c9f2:	d103      	bne.n	800c9fc <FlashSectorStampToDefault+0x1d8>
			cycle = 2;
 800c9f4:	f04f 0302 	mov.w	r3, #2
 800c9f8:	757b      	strb	r3, [r7, #21]
 800c9fa:	e002      	b.n	800ca02 <FlashSectorStampToDefault+0x1de>
		else
			cycle = 1;
 800c9fc:	f04f 0301 	mov.w	r3, #1
 800ca00:	757b      	strb	r3, [r7, #21]

		for(j = 0; j < cycle; j++)
 800ca02:	f04f 0300 	mov.w	r3, #0
 800ca06:	75bb      	strb	r3, [r7, #22]
 800ca08:	e0fa      	b.n	800cc00 <FlashSectorStampToDefault+0x3dc>
		{
			if((j == 1) || (selector == FlashStumpSelector_Beginning))
 800ca0a:	7dbb      	ldrb	r3, [r7, #22]
 800ca0c:	2b01      	cmp	r3, #1
 800ca0e:	d002      	beq.n	800ca16 <FlashSectorStampToDefault+0x1f2>
 800ca10:	7bfb      	ldrb	r3, [r7, #15]
 800ca12:	2b01      	cmp	r3, #1
 800ca14:	d101      	bne.n	800ca1a <FlashSectorStampToDefault+0x1f6>
				uwAddress = ADDR_FLASH_SECTOR_4 + ( sizeof(FlashStampStruct) * 15 );
 800ca16:	4b39      	ldr	r3, [pc, #228]	; (800cafc <FlashSectorStampToDefault+0x2d8>)
 800ca18:	61bb      	str	r3, [r7, #24]

			if (FLASH_ProgramByte(uwAddress, ((targetAddress) & 0xFF)) != FLASH_COMPLETE)
 800ca1a:	6a3b      	ldr	r3, [r7, #32]
 800ca1c:	b2db      	uxtb	r3, r3
 800ca1e:	69b8      	ldr	r0, [r7, #24]
 800ca20:	4619      	mov	r1, r3
 800ca22:	f7fa fb15 	bl	8007050 <FLASH_ProgramByte>
 800ca26:	4603      	mov	r3, r0
 800ca28:	2b08      	cmp	r3, #8
 800ca2a:	d000      	beq.n	800ca2e <FlashSectorStampToDefault+0x20a>
			{
				while (1)
				{
				}
 800ca2c:	e7fe      	b.n	800ca2c <FlashSectorStampToDefault+0x208>
			}
			uwAddress++;
 800ca2e:	69bb      	ldr	r3, [r7, #24]
 800ca30:	f103 0301 	add.w	r3, r3, #1
 800ca34:	61bb      	str	r3, [r7, #24]

			if (FLASH_ProgramByte(uwAddress, (((targetAddress) & 0xFF00) >> 8)) != FLASH_COMPLETE)
 800ca36:	6a3b      	ldr	r3, [r7, #32]
 800ca38:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800ca3c:	ea4f 2313 	mov.w	r3, r3, lsr #8
 800ca40:	b2db      	uxtb	r3, r3
 800ca42:	69b8      	ldr	r0, [r7, #24]
 800ca44:	4619      	mov	r1, r3
 800ca46:	f7fa fb03 	bl	8007050 <FLASH_ProgramByte>
 800ca4a:	4603      	mov	r3, r0
 800ca4c:	2b08      	cmp	r3, #8
 800ca4e:	d000      	beq.n	800ca52 <FlashSectorStampToDefault+0x22e>
			{
				while (1)
				{
				}
 800ca50:	e7fe      	b.n	800ca50 <FlashSectorStampToDefault+0x22c>
			}
			uwAddress++;
 800ca52:	69bb      	ldr	r3, [r7, #24]
 800ca54:	f103 0301 	add.w	r3, r3, #1
 800ca58:	61bb      	str	r3, [r7, #24]

			if (FLASH_ProgramByte(uwAddress, (((targetAddress) & 0xFF0000) >> 16)) != FLASH_COMPLETE)
 800ca5a:	6a3b      	ldr	r3, [r7, #32]
 800ca5c:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800ca60:	ea4f 4313 	mov.w	r3, r3, lsr #16
 800ca64:	b2db      	uxtb	r3, r3
 800ca66:	69b8      	ldr	r0, [r7, #24]
 800ca68:	4619      	mov	r1, r3
 800ca6a:	f7fa faf1 	bl	8007050 <FLASH_ProgramByte>
 800ca6e:	4603      	mov	r3, r0
 800ca70:	2b08      	cmp	r3, #8
 800ca72:	d000      	beq.n	800ca76 <FlashSectorStampToDefault+0x252>
			{
				while (1)
				{
				}
 800ca74:	e7fe      	b.n	800ca74 <FlashSectorStampToDefault+0x250>
			}
			uwAddress++;
 800ca76:	69bb      	ldr	r3, [r7, #24]
 800ca78:	f103 0301 	add.w	r3, r3, #1
 800ca7c:	61bb      	str	r3, [r7, #24]

			if (FLASH_ProgramByte(uwAddress, (((targetAddress) & 0xFF000000) >> 24)) != FLASH_COMPLETE)
 800ca7e:	6a3b      	ldr	r3, [r7, #32]
 800ca80:	ea4f 6313 	mov.w	r3, r3, lsr #24
 800ca84:	b2db      	uxtb	r3, r3
 800ca86:	69b8      	ldr	r0, [r7, #24]
 800ca88:	4619      	mov	r1, r3
 800ca8a:	f7fa fae1 	bl	8007050 <FLASH_ProgramByte>
 800ca8e:	4603      	mov	r3, r0
 800ca90:	2b08      	cmp	r3, #8
 800ca92:	d000      	beq.n	800ca96 <FlashSectorStampToDefault+0x272>
			{
				while (1)
				{
				}
 800ca94:	e7fe      	b.n	800ca94 <FlashSectorStampToDefault+0x270>
			}
			uwAddress++;
 800ca96:	69bb      	ldr	r3, [r7, #24]
 800ca98:	f103 0301 	add.w	r3, r3, #1
 800ca9c:	61bb      	str	r3, [r7, #24]



			if (FLASH_ProgramByte(uwAddress, ((targetSectorCounter) & 0xFF)) != FLASH_COMPLETE)
 800ca9e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800caa0:	b2db      	uxtb	r3, r3
 800caa2:	69b8      	ldr	r0, [r7, #24]
 800caa4:	4619      	mov	r1, r3
 800caa6:	f7fa fad3 	bl	8007050 <FLASH_ProgramByte>
 800caaa:	4603      	mov	r3, r0
 800caac:	2b08      	cmp	r3, #8
 800caae:	d000      	beq.n	800cab2 <FlashSectorStampToDefault+0x28e>
			{
				while (1)
				{
				}
 800cab0:	e7fe      	b.n	800cab0 <FlashSectorStampToDefault+0x28c>
			}
			uwAddress++;
 800cab2:	69bb      	ldr	r3, [r7, #24]
 800cab4:	f103 0301 	add.w	r3, r3, #1
 800cab8:	61bb      	str	r3, [r7, #24]

			if (FLASH_ProgramByte(uwAddress, (((targetSectorCounter) & 0xFF00) >> 8)) != FLASH_COMPLETE)
 800caba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cabc:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800cac0:	ea4f 2313 	mov.w	r3, r3, lsr #8
 800cac4:	b2db      	uxtb	r3, r3
 800cac6:	69b8      	ldr	r0, [r7, #24]
 800cac8:	4619      	mov	r1, r3
 800caca:	f7fa fac1 	bl	8007050 <FLASH_ProgramByte>
 800cace:	4603      	mov	r3, r0
 800cad0:	2b08      	cmp	r3, #8
 800cad2:	d015      	beq.n	800cb00 <FlashSectorStampToDefault+0x2dc>
			{
				while (1)
				{
				}
 800cad4:	e7fe      	b.n	800cad4 <FlashSectorStampToDefault+0x2b0>
 800cad6:	bf00      	nop
 800cad8:	08010000 	.word	0x08010000
 800cadc:	0801ffff 	.word	0x0801ffff
 800cae0:	08020000 	.word	0x08020000
 800cae4:	08040000 	.word	0x08040000
 800cae8:	08060000 	.word	0x08060000
 800caec:	08080000 	.word	0x08080000
 800caf0:	080a0000 	.word	0x080a0000
 800caf4:	080c0000 	.word	0x080c0000
 800caf8:	080e0000 	.word	0x080e0000
 800cafc:	0801012c 	.word	0x0801012c
			}
			uwAddress++;
 800cb00:	69bb      	ldr	r3, [r7, #24]
 800cb02:	f103 0301 	add.w	r3, r3, #1
 800cb06:	61bb      	str	r3, [r7, #24]

			if (FLASH_ProgramByte(uwAddress, (((targetSectorCounter) & 0xFF0000) >> 16)) != FLASH_COMPLETE)
 800cb08:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cb0a:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800cb0e:	ea4f 4313 	mov.w	r3, r3, lsr #16
 800cb12:	b2db      	uxtb	r3, r3
 800cb14:	69b8      	ldr	r0, [r7, #24]
 800cb16:	4619      	mov	r1, r3
 800cb18:	f7fa fa9a 	bl	8007050 <FLASH_ProgramByte>
 800cb1c:	4603      	mov	r3, r0
 800cb1e:	2b08      	cmp	r3, #8
 800cb20:	d000      	beq.n	800cb24 <FlashSectorStampToDefault+0x300>
			{
				while (1)
				{
				}
 800cb22:	e7fe      	b.n	800cb22 <FlashSectorStampToDefault+0x2fe>
			}
			uwAddress++;
 800cb24:	69bb      	ldr	r3, [r7, #24]
 800cb26:	f103 0301 	add.w	r3, r3, #1
 800cb2a:	61bb      	str	r3, [r7, #24]

			if (FLASH_ProgramByte(uwAddress, (((targetSectorCounter) & 0xFF000000) >> 24)) != FLASH_COMPLETE)
 800cb2c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cb2e:	ea4f 6313 	mov.w	r3, r3, lsr #24
 800cb32:	b2db      	uxtb	r3, r3
 800cb34:	69b8      	ldr	r0, [r7, #24]
 800cb36:	4619      	mov	r1, r3
 800cb38:	f7fa fa8a 	bl	8007050 <FLASH_ProgramByte>
 800cb3c:	4603      	mov	r3, r0
 800cb3e:	2b08      	cmp	r3, #8
 800cb40:	d000      	beq.n	800cb44 <FlashSectorStampToDefault+0x320>
			{
				while (1)
				{
				}
 800cb42:	e7fe      	b.n	800cb42 <FlashSectorStampToDefault+0x31e>
			}
			uwAddress++;
 800cb44:	69bb      	ldr	r3, [r7, #24]
 800cb46:	f103 0301 	add.w	r3, r3, #1
 800cb4a:	61bb      	str	r3, [r7, #24]



			if (FLASH_ProgramByte(uwAddress, (targetSelector)) != FLASH_COMPLETE)
 800cb4c:	7ffb      	ldrb	r3, [r7, #31]
 800cb4e:	69b8      	ldr	r0, [r7, #24]
 800cb50:	4619      	mov	r1, r3
 800cb52:	f7fa fa7d 	bl	8007050 <FLASH_ProgramByte>
 800cb56:	4603      	mov	r3, r0
 800cb58:	2b08      	cmp	r3, #8
 800cb5a:	d000      	beq.n	800cb5e <FlashSectorStampToDefault+0x33a>
			{
				while (1)
				{
				}
 800cb5c:	e7fe      	b.n	800cb5c <FlashSectorStampToDefault+0x338>
			}
			uwAddress++;
 800cb5e:	69bb      	ldr	r3, [r7, #24]
 800cb60:	f103 0301 	add.w	r3, r3, #1
 800cb64:	61bb      	str	r3, [r7, #24]

			if(i == 0)
 800cb66:	7dfb      	ldrb	r3, [r7, #23]
 800cb68:	2b00      	cmp	r3, #0
 800cb6a:	d141      	bne.n	800cbf0 <FlashSectorStampToDefault+0x3cc>
			{
				if (FLASH_ProgramByte(uwAddress, 0) != FLASH_COMPLETE)
 800cb6c:	69b8      	ldr	r0, [r7, #24]
 800cb6e:	f04f 0100 	mov.w	r1, #0
 800cb72:	f7fa fa6d 	bl	8007050 <FLASH_ProgramByte>
 800cb76:	4603      	mov	r3, r0
 800cb78:	2b08      	cmp	r3, #8
 800cb7a:	d000      	beq.n	800cb7e <FlashSectorStampToDefault+0x35a>
				{
					while (1)
					{
					}
 800cb7c:	e7fe      	b.n	800cb7c <FlashSectorStampToDefault+0x358>
				}
				uwAddress++;
 800cb7e:	69bb      	ldr	r3, [r7, #24]
 800cb80:	f103 0301 	add.w	r3, r3, #1
 800cb84:	61bb      	str	r3, [r7, #24]

				if (FLASH_ProgramByte(uwAddress, 0) != FLASH_COMPLETE)
 800cb86:	69b8      	ldr	r0, [r7, #24]
 800cb88:	f04f 0100 	mov.w	r1, #0
 800cb8c:	f7fa fa60 	bl	8007050 <FLASH_ProgramByte>
 800cb90:	4603      	mov	r3, r0
 800cb92:	2b08      	cmp	r3, #8
 800cb94:	d000      	beq.n	800cb98 <FlashSectorStampToDefault+0x374>
				{
					while (1)
					{
					}
 800cb96:	e7fe      	b.n	800cb96 <FlashSectorStampToDefault+0x372>
				}
				uwAddress++;
 800cb98:	69bb      	ldr	r3, [r7, #24]
 800cb9a:	f103 0301 	add.w	r3, r3, #1
 800cb9e:	61bb      	str	r3, [r7, #24]

				if (FLASH_ProgramByte(uwAddress, 0) != FLASH_COMPLETE)
 800cba0:	69b8      	ldr	r0, [r7, #24]
 800cba2:	f04f 0100 	mov.w	r1, #0
 800cba6:	f7fa fa53 	bl	8007050 <FLASH_ProgramByte>
 800cbaa:	4603      	mov	r3, r0
 800cbac:	2b08      	cmp	r3, #8
 800cbae:	d000      	beq.n	800cbb2 <FlashSectorStampToDefault+0x38e>
				{
					while (1)
					{
					}
 800cbb0:	e7fe      	b.n	800cbb0 <FlashSectorStampToDefault+0x38c>
				}
				uwAddress++;
 800cbb2:	69bb      	ldr	r3, [r7, #24]
 800cbb4:	f103 0301 	add.w	r3, r3, #1
 800cbb8:	61bb      	str	r3, [r7, #24]

				if (FLASH_ProgramByte(uwAddress, 0) != FLASH_COMPLETE)
 800cbba:	69b8      	ldr	r0, [r7, #24]
 800cbbc:	f04f 0100 	mov.w	r1, #0
 800cbc0:	f7fa fa46 	bl	8007050 <FLASH_ProgramByte>
 800cbc4:	4603      	mov	r3, r0
 800cbc6:	2b08      	cmp	r3, #8
 800cbc8:	d000      	beq.n	800cbcc <FlashSectorStampToDefault+0x3a8>
				{
					while (1)
					{
					}
 800cbca:	e7fe      	b.n	800cbca <FlashSectorStampToDefault+0x3a6>
				}
				uwAddress++;
 800cbcc:	69bb      	ldr	r3, [r7, #24]
 800cbce:	f103 0301 	add.w	r3, r3, #1
 800cbd2:	61bb      	str	r3, [r7, #24]

				if (FLASH_ProgramByte(uwAddress, 0) != FLASH_COMPLETE)
 800cbd4:	69b8      	ldr	r0, [r7, #24]
 800cbd6:	f04f 0100 	mov.w	r1, #0
 800cbda:	f7fa fa39 	bl	8007050 <FLASH_ProgramByte>
 800cbde:	4603      	mov	r3, r0
 800cbe0:	2b08      	cmp	r3, #8
 800cbe2:	d000      	beq.n	800cbe6 <FlashSectorStampToDefault+0x3c2>
				{
					while (1)
					{
					}
 800cbe4:	e7fe      	b.n	800cbe4 <FlashSectorStampToDefault+0x3c0>
				}
				uwAddress++;
 800cbe6:	69bb      	ldr	r3, [r7, #24]
 800cbe8:	f103 0301 	add.w	r3, r3, #1
 800cbec:	61bb      	str	r3, [r7, #24]
 800cbee:	e003      	b.n	800cbf8 <FlashSectorStampToDefault+0x3d4>
			}

			else
				uwAddress += 5;
 800cbf0:	69bb      	ldr	r3, [r7, #24]
 800cbf2:	f103 0305 	add.w	r3, r3, #5
 800cbf6:	61bb      	str	r3, [r7, #24]
		if(mode == SectorStampToDefaultMode_Only_First)
			cycle = 2;
		else
			cycle = 1;

		for(j = 0; j < cycle; j++)
 800cbf8:	7dbb      	ldrb	r3, [r7, #22]
 800cbfa:	f103 0301 	add.w	r3, r3, #1
 800cbfe:	75bb      	strb	r3, [r7, #22]
 800cc00:	7dba      	ldrb	r2, [r7, #22]
 800cc02:	7d7b      	ldrb	r3, [r7, #21]
 800cc04:	429a      	cmp	r2, r3
 800cc06:	f4ff af00 	bcc.w	800ca0a <FlashSectorStampToDefault+0x1e6>
		while (1)
		{
		}
	}

	for(i = 0; i < 15; i++)
 800cc0a:	7dfb      	ldrb	r3, [r7, #23]
 800cc0c:	f103 0301 	add.w	r3, r3, #1
 800cc10:	75fb      	strb	r3, [r7, #23]
 800cc12:	7dfb      	ldrb	r3, [r7, #23]
 800cc14:	2b0e      	cmp	r3, #14
 800cc16:	f67f ae3e 	bls.w	800c896 <FlashSectorStampToDefault+0x72>
	if(mode == SectorStampToDefaultMode_In_Use)
	{

	}

	FLASH_Lock();
 800cc1a:	f7fa f8ab 	bl	8006d74 <FLASH_Lock>
}
 800cc1e:	f107 0728 	add.w	r7, r7, #40	; 0x28
 800cc22:	46bd      	mov	sp, r7
 800cc24:	bd80      	pop	{r7, pc}
 800cc26:	bf00      	nop

0800cc28 <CopyToFlashTest>:

void CopyToFlashTest(uint16_t* matrix, uint32_t numberOfHalfWorlds)
{
 800cc28:	b590      	push	{r4, r7, lr}
 800cc2a:	b0df      	sub	sp, #380	; 0x17c
 800cc2c:	af00      	add	r7, sp, #0
 800cc2e:	f107 0304 	add.w	r3, r7, #4
 800cc32:	6018      	str	r0, [r3, #0]
 800cc34:	463b      	mov	r3, r7
 800cc36:	6019      	str	r1, [r3, #0]
	static uint8_t ReceiveMatrix[8 * (sizeof(FlashStampStruct))];
	static uint16_t ADCConvertedValuesCheck[14][ADC_PACKAGE_MAX_NUMBER * 12 * 2];
	static uint16_t ADCConvertedValuesCheck2[14][ADC_PACKAGE_MAX_NUMBER * 12];
	uint32_t uwAddress = 0;
 800cc38:	f04f 0300 	mov.w	r3, #0
 800cc3c:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
	uint32_t uwAddressRef = 0;
 800cc40:	f04f 0300 	mov.w	r3, #0
 800cc44:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
	uint32_t uwAddressAccu = 0;
 800cc48:	f04f 0300 	mov.w	r3, #0
 800cc4c:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
	uint32_t uwSectorCounter = 0;
 800cc50:	f04f 0300 	mov.w	r3, #0
 800cc54:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
	uint8_t uwSelector = 0;
 800cc58:	f04f 0300 	mov.w	r3, #0
 800cc5c:	f887 315f 	strb.w	r3, [r7, #351]	; 0x15f
	uint16_t* matrixTemp = 0;
 800cc60:	f04f 0300 	mov.w	r3, #0
 800cc64:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
	FlashStampStruct flashStructGet[2];
	FlashStampStruct flashStructSet;
	FlashStampStruct flashStructBlock[14];
	uint8_t i = 0;
 800cc68:	f04f 0300 	mov.w	r3, #0
 800cc6c:	f887 316f 	strb.w	r3, [r7, #367]	; 0x16f
	uint8_t j = 0;
 800cc70:	f04f 0300 	mov.w	r3, #0
 800cc74:	f887 316e 	strb.w	r3, [r7, #366]	; 0x16e
	static uint8_t k = 0;


	matrixTemp = matrix;
 800cc78:	f107 0304 	add.w	r3, r7, #4
 800cc7c:	681b      	ldr	r3, [r3, #0]
 800cc7e:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170

	for(i = 0; i < numberOfHalfWorlds; ++i)
 800cc82:	f04f 0300 	mov.w	r3, #0
 800cc86:	f887 316f 	strb.w	r3, [r7, #367]	; 0x16f
 800cc8a:	e01e      	b.n	800ccca <CopyToFlashTest+0xa2>
	{
		ADCConvertedValuesCheck2[k][i] = *matrixTemp;
 800cc8c:	4ba5      	ldr	r3, [pc, #660]	; (800cf24 <CopyToFlashTest+0x2fc>)
 800cc8e:	781b      	ldrb	r3, [r3, #0]
 800cc90:	461a      	mov	r2, r3
 800cc92:	f897 416f 	ldrb.w	r4, [r7, #367]	; 0x16f
 800cc96:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 800cc9a:	8818      	ldrh	r0, [r3, #0]
 800cc9c:	49a2      	ldr	r1, [pc, #648]	; (800cf28 <CopyToFlashTest+0x300>)
 800cc9e:	4613      	mov	r3, r2
 800cca0:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800cca4:	189b      	adds	r3, r3, r2
 800cca6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800ccaa:	191b      	adds	r3, r3, r4
 800ccac:	4602      	mov	r2, r0
 800ccae:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
		matrixTemp++;
 800ccb2:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 800ccb6:	f103 0302 	add.w	r3, r3, #2
 800ccba:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
	static uint8_t k = 0;


	matrixTemp = matrix;

	for(i = 0; i < numberOfHalfWorlds; ++i)
 800ccbe:	f897 316f 	ldrb.w	r3, [r7, #367]	; 0x16f
 800ccc2:	f103 0301 	add.w	r3, r3, #1
 800ccc6:	f887 316f 	strb.w	r3, [r7, #367]	; 0x16f
 800ccca:	f897 216f 	ldrb.w	r2, [r7, #367]	; 0x16f
 800ccce:	463b      	mov	r3, r7
 800ccd0:	681b      	ldr	r3, [r3, #0]
 800ccd2:	429a      	cmp	r2, r3
 800ccd4:	d3da      	bcc.n	800cc8c <CopyToFlashTest+0x64>
	{
		ADCConvertedValuesCheck2[k][i] = *matrixTemp;
		matrixTemp++;
	}
	k = (k == 13) ? 0 : k + 1;
 800ccd6:	4b93      	ldr	r3, [pc, #588]	; (800cf24 <CopyToFlashTest+0x2fc>)
 800ccd8:	781b      	ldrb	r3, [r3, #0]
 800ccda:	2b0d      	cmp	r3, #13
 800ccdc:	d005      	beq.n	800ccea <CopyToFlashTest+0xc2>
 800ccde:	4b91      	ldr	r3, [pc, #580]	; (800cf24 <CopyToFlashTest+0x2fc>)
 800cce0:	781b      	ldrb	r3, [r3, #0]
 800cce2:	f103 0301 	add.w	r3, r3, #1
 800cce6:	b2db      	uxtb	r3, r3
 800cce8:	e001      	b.n	800ccee <CopyToFlashTest+0xc6>
 800ccea:	f04f 0300 	mov.w	r3, #0
 800ccee:	4a8d      	ldr	r2, [pc, #564]	; (800cf24 <CopyToFlashTest+0x2fc>)
 800ccf0:	7013      	strb	r3, [r2, #0]

	GetSectorStamp(&flashStructGet[0]);
 800ccf2:	f507 739a 	add.w	r3, r7, #308	; 0x134
 800ccf6:	4618      	mov	r0, r3
 800ccf8:	f7ff fbd8 	bl	800c4ac <GetSectorStamp>

	uwSectorCounter = flashStructGet[SectorStampSelector_Current].FlashStampStruct_uwSectorCounter;
 800ccfc:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 800cd00:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
	uwAddress = flashStructGet[SectorStampSelector_Current].FlashStampStruct_uwAddress;
 800cd04:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 800cd08:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
	uwSelector = flashStructGet[SectorStampSelector_Current].FlashStampStruct_uwSelector;
 800cd0c:	f897 3150 	ldrb.w	r3, [r7, #336]	; 0x150
 800cd10:	f887 315f 	strb.w	r3, [r7, #351]	; 0x15f

	if(uwSelector == FlashSectorSelector_Beginning)
 800cd14:	f897 315f 	ldrb.w	r3, [r7, #351]	; 0x15f
 800cd18:	2b00      	cmp	r3, #0
 800cd1a:	d104      	bne.n	800cd26 <CopyToFlashTest+0xfe>
	{
		flashStructSet.FlashStampStruct_Length = numberOfHalfWorlds;
 800cd1c:	463b      	mov	r3, r7
 800cd1e:	681b      	ldr	r3, [r3, #0]
 800cd20:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
 800cd24:	e013      	b.n	800cd4e <CopyToFlashTest+0x126>
	}
	else if(uwSelector == FlashSectorSelector_End)
 800cd26:	f897 315f 	ldrb.w	r3, [r7, #351]	; 0x15f
 800cd2a:	2b01      	cmp	r3, #1
 800cd2c:	d10f      	bne.n	800cd4e <CopyToFlashTest+0x126>
	{
		uwAddress += (flashStructGet[SectorStampSelector_Prev].FlashStampStruct_Length * 2);
 800cd2e:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 800cd32:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800cd36:	f8d7 2174 	ldr.w	r2, [r7, #372]	; 0x174
 800cd3a:	18d3      	adds	r3, r2, r3
 800cd3c:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
		flashStructSet.FlashStampStruct_Length = flashStructGet[SectorStampSelector_Prev].FlashStampStruct_Length + numberOfHalfWorlds;
 800cd40:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 800cd44:	463b      	mov	r3, r7
 800cd46:	681b      	ldr	r3, [r3, #0]
 800cd48:	18d3      	adds	r3, r2, r3
 800cd4a:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
	}

	FLASH_Unlock();
 800cd4e:	f7f9 fffb 	bl	8006d48 <FLASH_Unlock>

	if(uwSelector == FlashSectorSelector_Beginning)
 800cd52:	f897 315f 	ldrb.w	r3, [r7, #351]	; 0x15f
 800cd56:	2b00      	cmp	r3, #0
 800cd58:	d10d      	bne.n	800cd76 <CopyToFlashTest+0x14e>
	{
		FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |
 800cd5a:	f04f 00f3 	mov.w	r0, #243	; 0xf3
 800cd5e:	f7fa fb01 	bl	8007364 <FLASH_ClearFlag>
					FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR|FLASH_FLAG_PGSERR);

		/* Strat the erase operation */
		/* Device voltage range supposed to be [2.7V to 3.6V], the operation will
		be done by word */
		if (FLASH_EraseSector(uwSectorCounter, VoltageRange_3) != FLASH_COMPLETE)
 800cd62:	f8d7 0160 	ldr.w	r0, [r7, #352]	; 0x160
 800cd66:	f04f 0102 	mov.w	r1, #2
 800cd6a:	f7fa f811 	bl	8006d90 <FLASH_EraseSector>
 800cd6e:	4603      	mov	r3, r0
 800cd70:	2b08      	cmp	r3, #8
 800cd72:	d000      	beq.n	800cd76 <CopyToFlashTest+0x14e>
		{
		/* Error occurred while sector erase.
		  User can add here some code to deal with this error  */
			while (1)
			{
			}
 800cd74:	e7fe      	b.n	800cd74 <CopyToFlashTest+0x14c>
		}
	}

	uwAddressAccu = uwAddress;
 800cd76:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 800cd7a:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
	uwAddressRef = uwAddress;
 800cd7e:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 800cd82:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
	matrixTemp = matrix;
 800cd86:	f107 0304 	add.w	r3, r7, #4
 800cd8a:	681b      	ldr	r3, [r3, #0]
 800cd8c:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170

	while(uwAddress < (uwAddressRef + (2 * (flashStructSet.FlashStampStruct_Length))))
 800cd90:	e018      	b.n	800cdc4 <CopyToFlashTest+0x19c>
	{
		if (FLASH_ProgramHalfWord(uwAddress, *matrixTemp) == FLASH_COMPLETE)
 800cd92:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 800cd96:	881b      	ldrh	r3, [r3, #0]
 800cd98:	f8d7 0174 	ldr.w	r0, [r7, #372]	; 0x174
 800cd9c:	4619      	mov	r1, r3
 800cd9e:	f7fa f91f 	bl	8006fe0 <FLASH_ProgramHalfWord>
 800cda2:	4603      	mov	r3, r0
 800cda4:	2b08      	cmp	r3, #8
 800cda6:	d10c      	bne.n	800cdc2 <CopyToFlashTest+0x19a>
		{
			uwAddress = uwAddress + 2;
 800cda8:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 800cdac:	f103 0302 	add.w	r3, r3, #2
 800cdb0:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
			matrixTemp++;
 800cdb4:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 800cdb8:	f103 0302 	add.w	r3, r3, #2
 800cdbc:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
 800cdc0:	e000      	b.n	800cdc4 <CopyToFlashTest+0x19c>
		}
		else
		{
			while (1)
			{
			}
 800cdc2:	e7fe      	b.n	800cdc2 <CopyToFlashTest+0x19a>

	uwAddressAccu = uwAddress;
	uwAddressRef = uwAddress;
	matrixTemp = matrix;

	while(uwAddress < (uwAddressRef + (2 * (flashStructSet.FlashStampStruct_Length))))
 800cdc4:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 800cdc8:	ea4f 0243 	mov.w	r2, r3, lsl #1
 800cdcc:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800cdd0:	18d2      	adds	r2, r2, r3
 800cdd2:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 800cdd6:	429a      	cmp	r2, r3
 800cdd8:	d8db      	bhi.n	800cd92 <CopyToFlashTest+0x16a>
			{
			}
		}
	}

	if(flashStructGet[SectorStampSelector_Prev].FlashStampStruct_StateMState == 13)
 800cdda:	f897 3144 	ldrb.w	r3, [r7, #324]	; 0x144
 800cdde:	2b0d      	cmp	r3, #13
 800cde0:	d160      	bne.n	800cea4 <CopyToFlashTest+0x27c>
	{
		FlashSectorStampToDefault(SectorStampToDefaultMode_In_Use);
 800cde2:	f04f 0001 	mov.w	r0, #1
 800cde6:	f7ff fd1d 	bl	800c824 <FlashSectorStampToDefault>

		for(i = 0; i < 14; i++)
 800cdea:	f04f 0300 	mov.w	r3, #0
 800cdee:	f887 316f 	strb.w	r3, [r7, #367]	; 0x16f
 800cdf2:	e024      	b.n	800ce3e <CopyToFlashTest+0x216>
		{
			for(j = 0; j < (ADC_PACKAGE_MAX_NUMBER * 12 * 2); j++)
 800cdf4:	f04f 0300 	mov.w	r3, #0
 800cdf8:	f887 316e 	strb.w	r3, [r7, #366]	; 0x16e
 800cdfc:	e015      	b.n	800ce2a <CopyToFlashTest+0x202>
				ADCConvertedValuesCheck[i][j] = 0;
 800cdfe:	f897 216f 	ldrb.w	r2, [r7, #367]	; 0x16f
 800ce02:	f897 016e 	ldrb.w	r0, [r7, #366]	; 0x16e
 800ce06:	4949      	ldr	r1, [pc, #292]	; (800cf2c <CopyToFlashTest+0x304>)
 800ce08:	4613      	mov	r3, r2
 800ce0a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800ce0e:	189b      	adds	r3, r3, r2
 800ce10:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800ce14:	181b      	adds	r3, r3, r0
 800ce16:	f04f 0200 	mov.w	r2, #0
 800ce1a:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
	{
		FlashSectorStampToDefault(SectorStampToDefaultMode_In_Use);

		for(i = 0; i < 14; i++)
		{
			for(j = 0; j < (ADC_PACKAGE_MAX_NUMBER * 12 * 2); j++)
 800ce1e:	f897 316e 	ldrb.w	r3, [r7, #366]	; 0x16e
 800ce22:	f103 0301 	add.w	r3, r3, #1
 800ce26:	f887 316e 	strb.w	r3, [r7, #366]	; 0x16e
 800ce2a:	f897 316e 	ldrb.w	r3, [r7, #366]	; 0x16e
 800ce2e:	2b47      	cmp	r3, #71	; 0x47
 800ce30:	d9e5      	bls.n	800cdfe <CopyToFlashTest+0x1d6>

	if(flashStructGet[SectorStampSelector_Prev].FlashStampStruct_StateMState == 13)
	{
		FlashSectorStampToDefault(SectorStampToDefaultMode_In_Use);

		for(i = 0; i < 14; i++)
 800ce32:	f897 316f 	ldrb.w	r3, [r7, #367]	; 0x16f
 800ce36:	f103 0301 	add.w	r3, r3, #1
 800ce3a:	f887 316f 	strb.w	r3, [r7, #367]	; 0x16f
 800ce3e:	f897 316f 	ldrb.w	r3, [r7, #367]	; 0x16f
 800ce42:	2b0d      	cmp	r3, #13
 800ce44:	d9d6      	bls.n	800cdf4 <CopyToFlashTest+0x1cc>
		{
			for(j = 0; j < (ADC_PACKAGE_MAX_NUMBER * 12 * 2); j++)
				ADCConvertedValuesCheck[i][j] = 0;
		}

		for(i = 0; i < 14; i++)
 800ce46:	f04f 0300 	mov.w	r3, #0
 800ce4a:	f887 316f 	strb.w	r3, [r7, #367]	; 0x16f
 800ce4e:	e024      	b.n	800ce9a <CopyToFlashTest+0x272>
		{
			for(j = 0; j < (ADC_PACKAGE_MAX_NUMBER * 12); j++)
 800ce50:	f04f 0300 	mov.w	r3, #0
 800ce54:	f887 316e 	strb.w	r3, [r7, #366]	; 0x16e
 800ce58:	e015      	b.n	800ce86 <CopyToFlashTest+0x25e>
				ADCConvertedValuesCheck2[i][j] = 0;
 800ce5a:	f897 216f 	ldrb.w	r2, [r7, #367]	; 0x16f
 800ce5e:	f897 016e 	ldrb.w	r0, [r7, #366]	; 0x16e
 800ce62:	4931      	ldr	r1, [pc, #196]	; (800cf28 <CopyToFlashTest+0x300>)
 800ce64:	4613      	mov	r3, r2
 800ce66:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800ce6a:	189b      	adds	r3, r3, r2
 800ce6c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800ce70:	181b      	adds	r3, r3, r0
 800ce72:	f04f 0200 	mov.w	r2, #0
 800ce76:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
				ADCConvertedValuesCheck[i][j] = 0;
		}

		for(i = 0; i < 14; i++)
		{
			for(j = 0; j < (ADC_PACKAGE_MAX_NUMBER * 12); j++)
 800ce7a:	f897 316e 	ldrb.w	r3, [r7, #366]	; 0x16e
 800ce7e:	f103 0301 	add.w	r3, r3, #1
 800ce82:	f887 316e 	strb.w	r3, [r7, #366]	; 0x16e
 800ce86:	f897 316e 	ldrb.w	r3, [r7, #366]	; 0x16e
 800ce8a:	2b23      	cmp	r3, #35	; 0x23
 800ce8c:	d9e5      	bls.n	800ce5a <CopyToFlashTest+0x232>
		{
			for(j = 0; j < (ADC_PACKAGE_MAX_NUMBER * 12 * 2); j++)
				ADCConvertedValuesCheck[i][j] = 0;
		}

		for(i = 0; i < 14; i++)
 800ce8e:	f897 316f 	ldrb.w	r3, [r7, #367]	; 0x16f
 800ce92:	f103 0301 	add.w	r3, r3, #1
 800ce96:	f887 316f 	strb.w	r3, [r7, #367]	; 0x16f
 800ce9a:	f897 316f 	ldrb.w	r3, [r7, #367]	; 0x16f
 800ce9e:	2b0d      	cmp	r3, #13
 800cea0:	d9d6      	bls.n	800ce50 <CopyToFlashTest+0x228>
 800cea2:	e00b      	b.n	800cebc <CopyToFlashTest+0x294>
		}
	}

	else
	{
		flashStructSet.FlashStampStruct_StateMState = flashStructGet[SectorStampSelector_Prev].FlashStampStruct_StateMState + 1;
 800cea4:	f897 3144 	ldrb.w	r3, [r7, #324]	; 0x144
 800cea8:	f103 0301 	add.w	r3, r3, #1
 800ceac:	b2db      	uxtb	r3, r3
 800ceae:	f887 3130 	strb.w	r3, [r7, #304]	; 0x130
		SetSectorStamp(&flashStructSet);
 800ceb2:	f507 7390 	add.w	r3, r7, #288	; 0x120
 800ceb6:	4618      	mov	r0, r3
 800ceb8:	f7ff fbea 	bl	800c690 <SetSectorStamp>
	}

	FLASH_Lock();
 800cebc:	f7f9 ff5a 	bl	8006d74 <FLASH_Lock>

	GetSectorStamp2(&flashStructBlock[0]);
 800cec0:	f107 0308 	add.w	r3, r7, #8
 800cec4:	4618      	mov	r0, r3
 800cec6:	f7ff fa77 	bl	800c3b8 <GetSectorStamp2>

	for(i = 0; i < 14; i++)
 800ceca:	f04f 0300 	mov.w	r3, #0
 800cece:	f887 316f 	strb.w	r3, [r7, #367]	; 0x16f
 800ced2:	e069      	b.n	800cfa8 <CopyToFlashTest+0x380>
	{
		j = 0;
 800ced4:	f04f 0300 	mov.w	r3, #0
 800ced8:	f887 316e 	strb.w	r3, [r7, #366]	; 0x16e

		uwAddress = flashStructBlock[i].FlashStampStruct_uwAddress;
 800cedc:	f897 216f 	ldrb.w	r2, [r7, #367]	; 0x16f
 800cee0:	f107 0108 	add.w	r1, r7, #8
 800cee4:	4613      	mov	r3, r2
 800cee6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800ceea:	189b      	adds	r3, r3, r2
 800ceec:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800cef0:	18cb      	adds	r3, r1, r3
 800cef2:	681b      	ldr	r3, [r3, #0]
 800cef4:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
		uwAddressRef = uwAddress;
 800cef8:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 800cefc:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168

		if(flashStructBlock[i].FlashStampStruct_Length != 0xFFFFFFFF)
 800cf00:	f897 216f 	ldrb.w	r2, [r7, #367]	; 0x16f
 800cf04:	f107 0108 	add.w	r1, r7, #8
 800cf08:	4613      	mov	r3, r2
 800cf0a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800cf0e:	189b      	adds	r3, r3, r2
 800cf10:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800cf14:	18cb      	adds	r3, r1, r3
 800cf16:	f103 0308 	add.w	r3, r3, #8
 800cf1a:	685b      	ldr	r3, [r3, #4]
 800cf1c:	f1b3 3fff 	cmp.w	r3, #4294967295
 800cf20:	d03c      	beq.n	800cf9c <CopyToFlashTest+0x374>
		{
			while(uwAddress < (uwAddressRef + (2 * flashStructBlock[i].FlashStampStruct_Length)))
 800cf22:	e024      	b.n	800cf6e <CopyToFlashTest+0x346>
 800cf24:	2000005c 	.word	0x2000005c
 800cf28:	20000060 	.word	0x20000060
 800cf2c:	20000450 	.word	0x20000450
			{
				ADCConvertedValuesCheck[i][j] = *(__IO uint16_t*)uwAddress;
 800cf30:	f897 216f 	ldrb.w	r2, [r7, #367]	; 0x16f
 800cf34:	f897 416e 	ldrb.w	r4, [r7, #366]	; 0x16e
 800cf38:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 800cf3c:	881b      	ldrh	r3, [r3, #0]
 800cf3e:	b298      	uxth	r0, r3
 800cf40:	491d      	ldr	r1, [pc, #116]	; (800cfb8 <CopyToFlashTest+0x390>)
 800cf42:	4613      	mov	r3, r2
 800cf44:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800cf48:	189b      	adds	r3, r3, r2
 800cf4a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800cf4e:	191b      	adds	r3, r3, r4
 800cf50:	4602      	mov	r2, r0
 800cf52:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
				j++;
 800cf56:	f897 316e 	ldrb.w	r3, [r7, #366]	; 0x16e
 800cf5a:	f103 0301 	add.w	r3, r3, #1
 800cf5e:	f887 316e 	strb.w	r3, [r7, #366]	; 0x16e
				uwAddress = uwAddress + 2;
 800cf62:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 800cf66:	f103 0302 	add.w	r3, r3, #2
 800cf6a:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
		uwAddress = flashStructBlock[i].FlashStampStruct_uwAddress;
		uwAddressRef = uwAddress;

		if(flashStructBlock[i].FlashStampStruct_Length != 0xFFFFFFFF)
		{
			while(uwAddress < (uwAddressRef + (2 * flashStructBlock[i].FlashStampStruct_Length)))
 800cf6e:	f897 216f 	ldrb.w	r2, [r7, #367]	; 0x16f
 800cf72:	f107 0108 	add.w	r1, r7, #8
 800cf76:	4613      	mov	r3, r2
 800cf78:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800cf7c:	189b      	adds	r3, r3, r2
 800cf7e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800cf82:	18cb      	adds	r3, r1, r3
 800cf84:	f103 0308 	add.w	r3, r3, #8
 800cf88:	685b      	ldr	r3, [r3, #4]
 800cf8a:	ea4f 0243 	mov.w	r2, r3, lsl #1
 800cf8e:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800cf92:	18d2      	adds	r2, r2, r3
 800cf94:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 800cf98:	429a      	cmp	r2, r3
 800cf9a:	d8c9      	bhi.n	800cf30 <CopyToFlashTest+0x308>

	FLASH_Lock();

	GetSectorStamp2(&flashStructBlock[0]);

	for(i = 0; i < 14; i++)
 800cf9c:	f897 316f 	ldrb.w	r3, [r7, #367]	; 0x16f
 800cfa0:	f103 0301 	add.w	r3, r3, #1
 800cfa4:	f887 316f 	strb.w	r3, [r7, #367]	; 0x16f
 800cfa8:	f897 316f 	ldrb.w	r3, [r7, #367]	; 0x16f
 800cfac:	2b0d      	cmp	r3, #13
 800cfae:	d991      	bls.n	800ced4 <CopyToFlashTest+0x2ac>
				j++;
				uwAddress = uwAddress + 2;
			}
		}
	}
}
 800cfb0:	f507 77be 	add.w	r7, r7, #380	; 0x17c
 800cfb4:	46bd      	mov	sp, r7
 800cfb6:	bd90      	pop	{r4, r7, pc}
 800cfb8:	20000450 	.word	0x20000450

0800cfbc <__libc_init_array>:
 800cfbc:	b570      	push	{r4, r5, r6, lr}
 800cfbe:	f24d 1628 	movw	r6, #53544	; 0xd128
 800cfc2:	f24d 1528 	movw	r5, #53544	; 0xd128
 800cfc6:	f6c0 0600 	movt	r6, #2048	; 0x800
 800cfca:	f6c0 0500 	movt	r5, #2048	; 0x800
 800cfce:	1b76      	subs	r6, r6, r5
 800cfd0:	10b6      	asrs	r6, r6, #2
 800cfd2:	d007      	beq.n	800cfe4 <__libc_init_array+0x28>
 800cfd4:	3d04      	subs	r5, #4
 800cfd6:	2400      	movs	r4, #0
 800cfd8:	f855 3f04 	ldr.w	r3, [r5, #4]!
 800cfdc:	3401      	adds	r4, #1
 800cfde:	4798      	blx	r3
 800cfe0:	42a6      	cmp	r6, r4
 800cfe2:	d1f9      	bne.n	800cfd8 <__libc_init_array+0x1c>
 800cfe4:	f24d 162c 	movw	r6, #53548	; 0xd12c
 800cfe8:	f24d 1528 	movw	r5, #53544	; 0xd128
 800cfec:	f6c0 0600 	movt	r6, #2048	; 0x800
 800cff0:	f6c0 0500 	movt	r5, #2048	; 0x800
 800cff4:	1b76      	subs	r6, r6, r5
 800cff6:	f000 f88b 	bl	800d110 <_init>
 800cffa:	10b6      	asrs	r6, r6, #2
 800cffc:	d008      	beq.n	800d010 <__libc_init_array+0x54>
 800cffe:	3d04      	subs	r5, #4
 800d000:	2400      	movs	r4, #0
 800d002:	f855 3f04 	ldr.w	r3, [r5, #4]!
 800d006:	3401      	adds	r4, #1
 800d008:	4798      	blx	r3
 800d00a:	42a6      	cmp	r6, r4
 800d00c:	d1f9      	bne.n	800d002 <__libc_init_array+0x46>
 800d00e:	bd70      	pop	{r4, r5, r6, pc}
 800d010:	bd70      	pop	{r4, r5, r6, pc}
 800d012:	bf00      	nop

0800d014 <Reset_Handler>:
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 800d014:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800d016:	f000 b804 	b.w	800d022 <LoopCopyDataInit>

0800d01a <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 800d01a:	4b0e      	ldr	r3, [pc, #56]	; (800d054 <LoopForever+0x6>)
  ldr  r3, [r3, r1]
 800d01c:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 800d01e:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 800d020:	3104      	adds	r1, #4

0800d022 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 800d022:	480d      	ldr	r0, [pc, #52]	; (800d058 <LoopForever+0xa>)
  ldr  r3, =_edata
 800d024:	4b0d      	ldr	r3, [pc, #52]	; (800d05c <LoopForever+0xe>)
  adds  r2, r0, r1
 800d026:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800d028:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 800d02a:	f4ff aff6 	bcc.w	800d01a <CopyDataInit>
  ldr  r2, =_sbss
 800d02e:	4a0c      	ldr	r2, [pc, #48]	; (800d060 <LoopForever+0x12>)
  b  LoopFillZerobss
 800d030:	f000 b803 	b.w	800d03a <LoopFillZerobss>

0800d034 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 800d034:	2300      	movs	r3, #0
  str  r3, [r2], #4
 800d036:	f842 3b04 	str.w	r3, [r2], #4

0800d03a <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 800d03a:	4b0a      	ldr	r3, [pc, #40]	; (800d064 <LoopForever+0x16>)
  cmp  r2, r3
 800d03c:	429a      	cmp	r2, r3
  bcc  FillZerobss
 800d03e:	f4ff aff9 	bcc.w	800d034 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 800d042:	f7f8 f987 	bl	8005354 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800d046:	f7ff ffb9 	bl	800cfbc <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800d04a:	f7f6 fa17 	bl	800347c <main>

0800d04e <LoopForever>:
/* Atollic update, branch LoopForever */
LoopForever:
  b LoopForever
 800d04e:	f7ff bffe 	b.w	800d04e <LoopForever>
 800d052:	0000      	.short	0x0000
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
 800d054:	0800d130 	.word	0x0800d130
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 800d058:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 800d05c:	20000038 	.word	0x20000038
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
 800d060:	20000038 	.word	0x20000038
FillZerobss:
  movs  r3, #0
  str  r3, [r2], #4
    
LoopFillZerobss:
  ldr  r3, = _ebss
 800d064:	200014a0 	.word	0x200014a0

0800d068 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 800d068:	f7ff bffe 	b.w	800d068 <ADC_IRQHandler>
 800d06c:	554e454d 	.word	0x554e454d
 800d070:	00000000 	.word	0x00000000
 800d074:	7074754f 	.word	0x7074754f
 800d078:	20737475 	.word	0x20737475
 800d07c:	00006e4f 	.word	0x00006e4f
 800d080:	7074754f 	.word	0x7074754f
 800d084:	20737475 	.word	0x20737475
 800d088:	0066664f 	.word	0x0066664f
 800d08c:	656d6954 	.word	0x656d6954
 800d090:	00000000 	.word	0x00000000
 800d094:	6f746e4f 	.word	0x6f746e4f
 800d098:	0073657a 	.word	0x0073657a
 800d09c:	79676e49 	.word	0x79676e49
 800d0a0:	53206e65 	.word	0x53206e65
 800d0a4:	0000726f 	.word	0x0000726f
 800d0a8:	002e2e2e 	.word	0x002e2e2e
 800d0ac:	75746144 	.word	0x75746144
 800d0b0:	0000006d 	.word	0x0000006d
 800d0b4:	006f6449 	.word	0x006f6449
 800d0b8:	79676956 	.word	0x79676956
 800d0bc:	207a7a61 	.word	0x207a7a61
 800d0c0:	6f6b7455 	.word	0x6f6b7455
 800d0c4:	2173657a 	.word	0x2173657a
 800d0c8:	00000000 	.word	0x00000000
 800d0cc:	6c726f54 	.word	0x6c726f54
 800d0d0:	00007365 	.word	0x00007365
 800d0d4:	72657a53 	.word	0x72657a53
 800d0d8:	7a73656b 	.word	0x7a73656b
 800d0dc:	00736574 	.word	0x00736574

0800d0e0 <GPIO_PIN>:
 800d0e0:	20001000 80004000                       ... .@..

0800d0e8 <GPIO_CLK>:
 800d0e8:	00000008 00000008 00000008 00000008     ................

0800d0f8 <BUTTON_PIN>:
 800d0f8:	00000001                                ....

0800d0fc <BUTTON_CLK>:
 800d0fc:	00000001                                ....

0800d100 <BUTTON_EXTI_LINE>:
 800d100:	00000001                                ....

0800d104 <BUTTON_PORT_SOURCE>:
 800d104:	00000000                                ....

0800d108 <BUTTON_PIN_SOURCE>:
 800d108:	00000000                                ....

0800d10c <BUTTON_IRQn>:
 800d10c:	00000006                                ....

0800d110 <_init>:
 800d110:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d112:	bf00      	nop
 800d114:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800d116:	bc08      	pop	{r3}
 800d118:	469e      	mov	lr, r3
 800d11a:	4770      	bx	lr

0800d11c <_fini>:
 800d11c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d11e:	bf00      	nop
 800d120:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800d122:	bc08      	pop	{r3}
 800d124:	469e      	mov	lr, r3
 800d126:	4770      	bx	lr
